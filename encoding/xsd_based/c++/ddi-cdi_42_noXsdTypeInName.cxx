// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ddi-cdi_42_noXsdTypeInName.hxx"

namespace XMLSchema
{
  // DDICDIModels
  //

  const DDICDIModels::Activity_sequence& DDICDIModels::
  Activity () const
  {
    return this->Activity_;
  }

  DDICDIModels::Activity_sequence& DDICDIModels::
  Activity ()
  {
    return this->Activity_;
  }

  void DDICDIModels::
  Activity (const Activity_sequence& s)
  {
    this->Activity_ = s;
  }

  const DDICDIModels::Agent_sequence& DDICDIModels::
  Agent () const
  {
    return this->Agent_;
  }

  DDICDIModels::Agent_sequence& DDICDIModels::
  Agent ()
  {
    return this->Agent_;
  }

  void DDICDIModels::
  Agent (const Agent_sequence& s)
  {
    this->Agent_ = s;
  }

  const DDICDIModels::AgentListing_sequence& DDICDIModels::
  AgentListing () const
  {
    return this->AgentListing_;
  }

  DDICDIModels::AgentListing_sequence& DDICDIModels::
  AgentListing ()
  {
    return this->AgentListing_;
  }

  void DDICDIModels::
  AgentListing (const AgentListing_sequence& s)
  {
    this->AgentListing_ = s;
  }

  const DDICDIModels::AgentPosition_sequence& DDICDIModels::
  AgentPosition () const
  {
    return this->AgentPosition_;
  }

  DDICDIModels::AgentPosition_sequence& DDICDIModels::
  AgentPosition ()
  {
    return this->AgentPosition_;
  }

  void DDICDIModels::
  AgentPosition (const AgentPosition_sequence& s)
  {
    this->AgentPosition_ = s;
  }

  const DDICDIModels::AgentRelationship_sequence& DDICDIModels::
  AgentRelationship () const
  {
    return this->AgentRelationship_;
  }

  DDICDIModels::AgentRelationship_sequence& DDICDIModels::
  AgentRelationship ()
  {
    return this->AgentRelationship_;
  }

  void DDICDIModels::
  AgentRelationship (const AgentRelationship_sequence& s)
  {
    this->AgentRelationship_ = s;
  }

  const DDICDIModels::AgentStructure_sequence& DDICDIModels::
  AgentStructure () const
  {
    return this->AgentStructure_;
  }

  DDICDIModels::AgentStructure_sequence& DDICDIModels::
  AgentStructure ()
  {
    return this->AgentStructure_;
  }

  void DDICDIModels::
  AgentStructure (const AgentStructure_sequence& s)
  {
    this->AgentStructure_ = s;
  }

  const DDICDIModels::AllenIntervalAlgebra_sequence& DDICDIModels::
  AllenIntervalAlgebra () const
  {
    return this->AllenIntervalAlgebra_;
  }

  DDICDIModels::AllenIntervalAlgebra_sequence& DDICDIModels::
  AllenIntervalAlgebra ()
  {
    return this->AllenIntervalAlgebra_;
  }

  void DDICDIModels::
  AllenIntervalAlgebra (const AllenIntervalAlgebra_sequence& s)
  {
    this->AllenIntervalAlgebra_ = s;
  }

  const DDICDIModels::AttributeComponent_sequence& DDICDIModels::
  AttributeComponent () const
  {
    return this->AttributeComponent_;
  }

  DDICDIModels::AttributeComponent_sequence& DDICDIModels::
  AttributeComponent ()
  {
    return this->AttributeComponent_;
  }

  void DDICDIModels::
  AttributeComponent (const AttributeComponent_sequence& s)
  {
    this->AttributeComponent_ = s;
  }

  const DDICDIModels::AuthorizationSource_sequence& DDICDIModels::
  AuthorizationSource () const
  {
    return this->AuthorizationSource_;
  }

  DDICDIModels::AuthorizationSource_sequence& DDICDIModels::
  AuthorizationSource ()
  {
    return this->AuthorizationSource_;
  }

  void DDICDIModels::
  AuthorizationSource (const AuthorizationSource_sequence& s)
  {
    this->AuthorizationSource_ = s;
  }

  const DDICDIModels::Category_sequence& DDICDIModels::
  Category () const
  {
    return this->Category_;
  }

  DDICDIModels::Category_sequence& DDICDIModels::
  Category ()
  {
    return this->Category_;
  }

  void DDICDIModels::
  Category (const Category_sequence& s)
  {
    this->Category_ = s;
  }

  const DDICDIModels::CategoryPosition_sequence& DDICDIModels::
  CategoryPosition () const
  {
    return this->CategoryPosition_;
  }

  DDICDIModels::CategoryPosition_sequence& DDICDIModels::
  CategoryPosition ()
  {
    return this->CategoryPosition_;
  }

  void DDICDIModels::
  CategoryPosition (const CategoryPosition_sequence& s)
  {
    this->CategoryPosition_ = s;
  }

  const DDICDIModels::CategoryRelationStructure_sequence& DDICDIModels::
  CategoryRelationStructure () const
  {
    return this->CategoryRelationStructure_;
  }

  DDICDIModels::CategoryRelationStructure_sequence& DDICDIModels::
  CategoryRelationStructure ()
  {
    return this->CategoryRelationStructure_;
  }

  void DDICDIModels::
  CategoryRelationStructure (const CategoryRelationStructure_sequence& s)
  {
    this->CategoryRelationStructure_ = s;
  }

  const DDICDIModels::CategoryRelationship_sequence& DDICDIModels::
  CategoryRelationship () const
  {
    return this->CategoryRelationship_;
  }

  DDICDIModels::CategoryRelationship_sequence& DDICDIModels::
  CategoryRelationship ()
  {
    return this->CategoryRelationship_;
  }

  void DDICDIModels::
  CategoryRelationship (const CategoryRelationship_sequence& s)
  {
    this->CategoryRelationship_ = s;
  }

  const DDICDIModels::CategorySet_sequence& DDICDIModels::
  CategorySet () const
  {
    return this->CategorySet_;
  }

  DDICDIModels::CategorySet_sequence& DDICDIModels::
  CategorySet ()
  {
    return this->CategorySet_;
  }

  void DDICDIModels::
  CategorySet (const CategorySet_sequence& s)
  {
    this->CategorySet_ = s;
  }

  const DDICDIModels::CategoryStatistic_sequence& DDICDIModels::
  CategoryStatistic () const
  {
    return this->CategoryStatistic_;
  }

  DDICDIModels::CategoryStatistic_sequence& DDICDIModels::
  CategoryStatistic ()
  {
    return this->CategoryStatistic_;
  }

  void DDICDIModels::
  CategoryStatistic (const CategoryStatistic_sequence& s)
  {
    this->CategoryStatistic_ = s;
  }

  const DDICDIModels::ClassificationFamily_sequence& DDICDIModels::
  ClassificationFamily () const
  {
    return this->ClassificationFamily_;
  }

  DDICDIModels::ClassificationFamily_sequence& DDICDIModels::
  ClassificationFamily ()
  {
    return this->ClassificationFamily_;
  }

  void DDICDIModels::
  ClassificationFamily (const ClassificationFamily_sequence& s)
  {
    this->ClassificationFamily_ = s;
  }

  const DDICDIModels::ClassificationIndex_sequence& DDICDIModels::
  ClassificationIndex () const
  {
    return this->ClassificationIndex_;
  }

  DDICDIModels::ClassificationIndex_sequence& DDICDIModels::
  ClassificationIndex ()
  {
    return this->ClassificationIndex_;
  }

  void DDICDIModels::
  ClassificationIndex (const ClassificationIndex_sequence& s)
  {
    this->ClassificationIndex_ = s;
  }

  const DDICDIModels::ClassificationIndexEntry_sequence& DDICDIModels::
  ClassificationIndexEntry () const
  {
    return this->ClassificationIndexEntry_;
  }

  DDICDIModels::ClassificationIndexEntry_sequence& DDICDIModels::
  ClassificationIndexEntry ()
  {
    return this->ClassificationIndexEntry_;
  }

  void DDICDIModels::
  ClassificationIndexEntry (const ClassificationIndexEntry_sequence& s)
  {
    this->ClassificationIndexEntry_ = s;
  }

  const DDICDIModels::ClassificationIndexEntryPosition_sequence& DDICDIModels::
  ClassificationIndexEntryPosition () const
  {
    return this->ClassificationIndexEntryPosition_;
  }

  DDICDIModels::ClassificationIndexEntryPosition_sequence& DDICDIModels::
  ClassificationIndexEntryPosition ()
  {
    return this->ClassificationIndexEntryPosition_;
  }

  void DDICDIModels::
  ClassificationIndexEntryPosition (const ClassificationIndexEntryPosition_sequence& s)
  {
    this->ClassificationIndexEntryPosition_ = s;
  }

  const DDICDIModels::ClassificationItem_sequence& DDICDIModels::
  ClassificationItem () const
  {
    return this->ClassificationItem_;
  }

  DDICDIModels::ClassificationItem_sequence& DDICDIModels::
  ClassificationItem ()
  {
    return this->ClassificationItem_;
  }

  void DDICDIModels::
  ClassificationItem (const ClassificationItem_sequence& s)
  {
    this->ClassificationItem_ = s;
  }

  const DDICDIModels::ClassificationItemPosition_sequence& DDICDIModels::
  ClassificationItemPosition () const
  {
    return this->ClassificationItemPosition_;
  }

  DDICDIModels::ClassificationItemPosition_sequence& DDICDIModels::
  ClassificationItemPosition ()
  {
    return this->ClassificationItemPosition_;
  }

  void DDICDIModels::
  ClassificationItemPosition (const ClassificationItemPosition_sequence& s)
  {
    this->ClassificationItemPosition_ = s;
  }

  const DDICDIModels::ClassificationItemRelationship_sequence& DDICDIModels::
  ClassificationItemRelationship () const
  {
    return this->ClassificationItemRelationship_;
  }

  DDICDIModels::ClassificationItemRelationship_sequence& DDICDIModels::
  ClassificationItemRelationship ()
  {
    return this->ClassificationItemRelationship_;
  }

  void DDICDIModels::
  ClassificationItemRelationship (const ClassificationItemRelationship_sequence& s)
  {
    this->ClassificationItemRelationship_ = s;
  }

  const DDICDIModels::ClassificationItemStructure_sequence& DDICDIModels::
  ClassificationItemStructure () const
  {
    return this->ClassificationItemStructure_;
  }

  DDICDIModels::ClassificationItemStructure_sequence& DDICDIModels::
  ClassificationItemStructure ()
  {
    return this->ClassificationItemStructure_;
  }

  void DDICDIModels::
  ClassificationItemStructure (const ClassificationItemStructure_sequence& s)
  {
    this->ClassificationItemStructure_ = s;
  }

  const DDICDIModels::ClassificationPosition_sequence& DDICDIModels::
  ClassificationPosition () const
  {
    return this->ClassificationPosition_;
  }

  DDICDIModels::ClassificationPosition_sequence& DDICDIModels::
  ClassificationPosition ()
  {
    return this->ClassificationPosition_;
  }

  void DDICDIModels::
  ClassificationPosition (const ClassificationPosition_sequence& s)
  {
    this->ClassificationPosition_ = s;
  }

  const DDICDIModels::ClassificationSeries_sequence& DDICDIModels::
  ClassificationSeries () const
  {
    return this->ClassificationSeries_;
  }

  DDICDIModels::ClassificationSeries_sequence& DDICDIModels::
  ClassificationSeries ()
  {
    return this->ClassificationSeries_;
  }

  void DDICDIModels::
  ClassificationSeries (const ClassificationSeries_sequence& s)
  {
    this->ClassificationSeries_ = s;
  }

  const DDICDIModels::ClassificationSeriesStructure_sequence& DDICDIModels::
  ClassificationSeriesStructure () const
  {
    return this->ClassificationSeriesStructure_;
  }

  DDICDIModels::ClassificationSeriesStructure_sequence& DDICDIModels::
  ClassificationSeriesStructure ()
  {
    return this->ClassificationSeriesStructure_;
  }

  void DDICDIModels::
  ClassificationSeriesStructure (const ClassificationSeriesStructure_sequence& s)
  {
    this->ClassificationSeriesStructure_ = s;
  }

  const DDICDIModels::Code_sequence& DDICDIModels::
  Code () const
  {
    return this->Code_;
  }

  DDICDIModels::Code_sequence& DDICDIModels::
  Code ()
  {
    return this->Code_;
  }

  void DDICDIModels::
  Code (const Code_sequence& s)
  {
    this->Code_ = s;
  }

  const DDICDIModels::CodeList_sequence& DDICDIModels::
  CodeList () const
  {
    return this->CodeList_;
  }

  DDICDIModels::CodeList_sequence& DDICDIModels::
  CodeList ()
  {
    return this->CodeList_;
  }

  void DDICDIModels::
  CodeList (const CodeList_sequence& s)
  {
    this->CodeList_ = s;
  }

  const DDICDIModels::CodeListStructure_sequence& DDICDIModels::
  CodeListStructure () const
  {
    return this->CodeListStructure_;
  }

  DDICDIModels::CodeListStructure_sequence& DDICDIModels::
  CodeListStructure ()
  {
    return this->CodeListStructure_;
  }

  void DDICDIModels::
  CodeListStructure (const CodeListStructure_sequence& s)
  {
    this->CodeListStructure_ = s;
  }

  const DDICDIModels::CodePosition_sequence& DDICDIModels::
  CodePosition () const
  {
    return this->CodePosition_;
  }

  DDICDIModels::CodePosition_sequence& DDICDIModels::
  CodePosition ()
  {
    return this->CodePosition_;
  }

  void DDICDIModels::
  CodePosition (const CodePosition_sequence& s)
  {
    this->CodePosition_ = s;
  }

  const DDICDIModels::CodeRelationship_sequence& DDICDIModels::
  CodeRelationship () const
  {
    return this->CodeRelationship_;
  }

  DDICDIModels::CodeRelationship_sequence& DDICDIModels::
  CodeRelationship ()
  {
    return this->CodeRelationship_;
  }

  void DDICDIModels::
  CodeRelationship (const CodeRelationship_sequence& s)
  {
    this->CodeRelationship_ = s;
  }

  const DDICDIModels::ComponentPosition_sequence& DDICDIModels::
  ComponentPosition () const
  {
    return this->ComponentPosition_;
  }

  DDICDIModels::ComponentPosition_sequence& DDICDIModels::
  ComponentPosition ()
  {
    return this->ComponentPosition_;
  }

  void DDICDIModels::
  ComponentPosition (const ComponentPosition_sequence& s)
  {
    this->ComponentPosition_ = s;
  }

  const DDICDIModels::Concept_sequence& DDICDIModels::
  Concept () const
  {
    return this->Concept_;
  }

  DDICDIModels::Concept_sequence& DDICDIModels::
  Concept ()
  {
    return this->Concept_;
  }

  void DDICDIModels::
  Concept (const Concept_sequence& s)
  {
    this->Concept_ = s;
  }

  const DDICDIModels::ConceptMap_sequence& DDICDIModels::
  ConceptMap () const
  {
    return this->ConceptMap_;
  }

  DDICDIModels::ConceptMap_sequence& DDICDIModels::
  ConceptMap ()
  {
    return this->ConceptMap_;
  }

  void DDICDIModels::
  ConceptMap (const ConceptMap_sequence& s)
  {
    this->ConceptMap_ = s;
  }

  const DDICDIModels::ConceptRelationship_sequence& DDICDIModels::
  ConceptRelationship () const
  {
    return this->ConceptRelationship_;
  }

  DDICDIModels::ConceptRelationship_sequence& DDICDIModels::
  ConceptRelationship ()
  {
    return this->ConceptRelationship_;
  }

  void DDICDIModels::
  ConceptRelationship (const ConceptRelationship_sequence& s)
  {
    this->ConceptRelationship_ = s;
  }

  const DDICDIModels::ConceptStructure_sequence& DDICDIModels::
  ConceptStructure () const
  {
    return this->ConceptStructure_;
  }

  DDICDIModels::ConceptStructure_sequence& DDICDIModels::
  ConceptStructure ()
  {
    return this->ConceptStructure_;
  }

  void DDICDIModels::
  ConceptStructure (const ConceptStructure_sequence& s)
  {
    this->ConceptStructure_ = s;
  }

  const DDICDIModels::ConceptSystem_sequence& DDICDIModels::
  ConceptSystem () const
  {
    return this->ConceptSystem_;
  }

  DDICDIModels::ConceptSystem_sequence& DDICDIModels::
  ConceptSystem ()
  {
    return this->ConceptSystem_;
  }

  void DDICDIModels::
  ConceptSystem (const ConceptSystem_sequence& s)
  {
    this->ConceptSystem_ = s;
  }

  const DDICDIModels::ConceptSystemCorrespondence_sequence& DDICDIModels::
  ConceptSystemCorrespondence () const
  {
    return this->ConceptSystemCorrespondence_;
  }

  DDICDIModels::ConceptSystemCorrespondence_sequence& DDICDIModels::
  ConceptSystemCorrespondence ()
  {
    return this->ConceptSystemCorrespondence_;
  }

  void DDICDIModels::
  ConceptSystemCorrespondence (const ConceptSystemCorrespondence_sequence& s)
  {
    this->ConceptSystemCorrespondence_ = s;
  }

  const DDICDIModels::ConceptualDomain_sequence& DDICDIModels::
  ConceptualDomain () const
  {
    return this->ConceptualDomain_;
  }

  DDICDIModels::ConceptualDomain_sequence& DDICDIModels::
  ConceptualDomain ()
  {
    return this->ConceptualDomain_;
  }

  void DDICDIModels::
  ConceptualDomain (const ConceptualDomain_sequence& s)
  {
    this->ConceptualDomain_ = s;
  }

  const DDICDIModels::ConceptualValue_sequence& DDICDIModels::
  ConceptualValue () const
  {
    return this->ConceptualValue_;
  }

  DDICDIModels::ConceptualValue_sequence& DDICDIModels::
  ConceptualValue ()
  {
    return this->ConceptualValue_;
  }

  void DDICDIModels::
  ConceptualValue (const ConceptualValue_sequence& s)
  {
    this->ConceptualValue_ = s;
  }

  const DDICDIModels::ConceptualVariable_sequence& DDICDIModels::
  ConceptualVariable () const
  {
    return this->ConceptualVariable_;
  }

  DDICDIModels::ConceptualVariable_sequence& DDICDIModels::
  ConceptualVariable ()
  {
    return this->ConceptualVariable_;
  }

  void DDICDIModels::
  ConceptualVariable (const ConceptualVariable_sequence& s)
  {
    this->ConceptualVariable_ = s;
  }

  const DDICDIModels::ConditionalControlLogic_sequence& DDICDIModels::
  ConditionalControlLogic () const
  {
    return this->ConditionalControlLogic_;
  }

  DDICDIModels::ConditionalControlLogic_sequence& DDICDIModels::
  ConditionalControlLogic ()
  {
    return this->ConditionalControlLogic_;
  }

  void DDICDIModels::
  ConditionalControlLogic (const ConditionalControlLogic_sequence& s)
  {
    this->ConditionalControlLogic_ = s;
  }

  const DDICDIModels::ContextualComponent_sequence& DDICDIModels::
  ContextualComponent () const
  {
    return this->ContextualComponent_;
  }

  DDICDIModels::ContextualComponent_sequence& DDICDIModels::
  ContextualComponent ()
  {
    return this->ContextualComponent_;
  }

  void DDICDIModels::
  ContextualComponent (const ContextualComponent_sequence& s)
  {
    this->ContextualComponent_ = s;
  }

  const DDICDIModels::ControlLogic_sequence& DDICDIModels::
  ControlLogic () const
  {
    return this->ControlLogic_;
  }

  DDICDIModels::ControlLogic_sequence& DDICDIModels::
  ControlLogic ()
  {
    return this->ControlLogic_;
  }

  void DDICDIModels::
  ControlLogic (const ControlLogic_sequence& s)
  {
    this->ControlLogic_ = s;
  }

  const DDICDIModels::CorrespondenceTable_sequence& DDICDIModels::
  CorrespondenceTable () const
  {
    return this->CorrespondenceTable_;
  }

  DDICDIModels::CorrespondenceTable_sequence& DDICDIModels::
  CorrespondenceTable ()
  {
    return this->CorrespondenceTable_;
  }

  void DDICDIModels::
  CorrespondenceTable (const CorrespondenceTable_sequence& s)
  {
    this->CorrespondenceTable_ = s;
  }

  const DDICDIModels::Curator_sequence& DDICDIModels::
  Curator () const
  {
    return this->Curator_;
  }

  DDICDIModels::Curator_sequence& DDICDIModels::
  Curator ()
  {
    return this->Curator_;
  }

  void DDICDIModels::
  Curator (const Curator_sequence& s)
  {
    this->Curator_ = s;
  }

  const DDICDIModels::DataPoint_sequence& DDICDIModels::
  DataPoint () const
  {
    return this->DataPoint_;
  }

  DDICDIModels::DataPoint_sequence& DDICDIModels::
  DataPoint ()
  {
    return this->DataPoint_;
  }

  void DDICDIModels::
  DataPoint (const DataPoint_sequence& s)
  {
    this->DataPoint_ = s;
  }

  const DDICDIModels::DataPointPosition_sequence& DDICDIModels::
  DataPointPosition () const
  {
    return this->DataPointPosition_;
  }

  DDICDIModels::DataPointPosition_sequence& DDICDIModels::
  DataPointPosition ()
  {
    return this->DataPointPosition_;
  }

  void DDICDIModels::
  DataPointPosition (const DataPointPosition_sequence& s)
  {
    this->DataPointPosition_ = s;
  }

  const DDICDIModels::DataPointRelationship_sequence& DDICDIModels::
  DataPointRelationship () const
  {
    return this->DataPointRelationship_;
  }

  DDICDIModels::DataPointRelationship_sequence& DDICDIModels::
  DataPointRelationship ()
  {
    return this->DataPointRelationship_;
  }

  void DDICDIModels::
  DataPointRelationship (const DataPointRelationship_sequence& s)
  {
    this->DataPointRelationship_ = s;
  }

  const DDICDIModels::DataSet_sequence& DDICDIModels::
  DataSet () const
  {
    return this->DataSet_;
  }

  DDICDIModels::DataSet_sequence& DDICDIModels::
  DataSet ()
  {
    return this->DataSet_;
  }

  void DDICDIModels::
  DataSet (const DataSet_sequence& s)
  {
    this->DataSet_ = s;
  }

  const DDICDIModels::DataStore_sequence& DDICDIModels::
  DataStore () const
  {
    return this->DataStore_;
  }

  DDICDIModels::DataStore_sequence& DDICDIModels::
  DataStore ()
  {
    return this->DataStore_;
  }

  void DDICDIModels::
  DataStore (const DataStore_sequence& s)
  {
    this->DataStore_ = s;
  }

  const DDICDIModels::DataStructure_sequence& DDICDIModels::
  DataStructure () const
  {
    return this->DataStructure_;
  }

  DDICDIModels::DataStructure_sequence& DDICDIModels::
  DataStructure ()
  {
    return this->DataStructure_;
  }

  void DDICDIModels::
  DataStructure (const DataStructure_sequence& s)
  {
    this->DataStructure_ = s;
  }

  const DDICDIModels::DataStructureComponent_sequence& DDICDIModels::
  DataStructureComponent () const
  {
    return this->DataStructureComponent_;
  }

  DDICDIModels::DataStructureComponent_sequence& DDICDIModels::
  DataStructureComponent ()
  {
    return this->DataStructureComponent_;
  }

  void DDICDIModels::
  DataStructureComponent (const DataStructureComponent_sequence& s)
  {
    this->DataStructureComponent_ = s;
  }

  const DDICDIModels::Datum_sequence& DDICDIModels::
  Datum () const
  {
    return this->Datum_;
  }

  DDICDIModels::Datum_sequence& DDICDIModels::
  Datum ()
  {
    return this->Datum_;
  }

  void DDICDIModels::
  Datum (const Datum_sequence& s)
  {
    this->Datum_ = s;
  }

  const DDICDIModels::Descriptor_sequence& DDICDIModels::
  Descriptor () const
  {
    return this->Descriptor_;
  }

  DDICDIModels::Descriptor_sequence& DDICDIModels::
  Descriptor ()
  {
    return this->Descriptor_;
  }

  void DDICDIModels::
  Descriptor (const Descriptor_sequence& s)
  {
    this->Descriptor_ = s;
  }

  const DDICDIModels::DescriptorValueDomain_sequence& DDICDIModels::
  DescriptorValueDomain () const
  {
    return this->DescriptorValueDomain_;
  }

  DDICDIModels::DescriptorValueDomain_sequence& DDICDIModels::
  DescriptorValueDomain ()
  {
    return this->DescriptorValueDomain_;
  }

  void DDICDIModels::
  DescriptorValueDomain (const DescriptorValueDomain_sequence& s)
  {
    this->DescriptorValueDomain_ = s;
  }

  const DDICDIModels::DescriptorVariable_sequence& DDICDIModels::
  DescriptorVariable () const
  {
    return this->DescriptorVariable_;
  }

  DDICDIModels::DescriptorVariable_sequence& DDICDIModels::
  DescriptorVariable ()
  {
    return this->DescriptorVariable_;
  }

  void DDICDIModels::
  DescriptorVariable (const DescriptorVariable_sequence& s)
  {
    this->DescriptorVariable_ = s;
  }

  const DDICDIModels::DeterministicImperative_sequence& DDICDIModels::
  DeterministicImperative () const
  {
    return this->DeterministicImperative_;
  }

  DDICDIModels::DeterministicImperative_sequence& DDICDIModels::
  DeterministicImperative ()
  {
    return this->DeterministicImperative_;
  }

  void DDICDIModels::
  DeterministicImperative (const DeterministicImperative_sequence& s)
  {
    this->DeterministicImperative_ = s;
  }

  const DDICDIModels::DimensionComponent_sequence& DDICDIModels::
  DimensionComponent () const
  {
    return this->DimensionComponent_;
  }

  DDICDIModels::DimensionComponent_sequence& DDICDIModels::
  DimensionComponent ()
  {
    return this->DimensionComponent_;
  }

  void DDICDIModels::
  DimensionComponent (const DimensionComponent_sequence& s)
  {
    this->DimensionComponent_ = s;
  }

  const DDICDIModels::DimensionGroup_sequence& DDICDIModels::
  DimensionGroup () const
  {
    return this->DimensionGroup_;
  }

  DDICDIModels::DimensionGroup_sequence& DDICDIModels::
  DimensionGroup ()
  {
    return this->DimensionGroup_;
  }

  void DDICDIModels::
  DimensionGroup (const DimensionGroup_sequence& s)
  {
    this->DimensionGroup_ = s;
  }

  const DDICDIModels::DimensionalDataSet_sequence& DDICDIModels::
  DimensionalDataSet () const
  {
    return this->DimensionalDataSet_;
  }

  DDICDIModels::DimensionalDataSet_sequence& DDICDIModels::
  DimensionalDataSet ()
  {
    return this->DimensionalDataSet_;
  }

  void DDICDIModels::
  DimensionalDataSet (const DimensionalDataSet_sequence& s)
  {
    this->DimensionalDataSet_ = s;
  }

  const DDICDIModels::DimensionalDataStructure_sequence& DDICDIModels::
  DimensionalDataStructure () const
  {
    return this->DimensionalDataStructure_;
  }

  DDICDIModels::DimensionalDataStructure_sequence& DDICDIModels::
  DimensionalDataStructure ()
  {
    return this->DimensionalDataStructure_;
  }

  void DDICDIModels::
  DimensionalDataStructure (const DimensionalDataStructure_sequence& s)
  {
    this->DimensionalDataStructure_ = s;
  }

  const DDICDIModels::DimensionalKey_sequence& DDICDIModels::
  DimensionalKey () const
  {
    return this->DimensionalKey_;
  }

  DDICDIModels::DimensionalKey_sequence& DDICDIModels::
  DimensionalKey ()
  {
    return this->DimensionalKey_;
  }

  void DDICDIModels::
  DimensionalKey (const DimensionalKey_sequence& s)
  {
    this->DimensionalKey_ = s;
  }

  const DDICDIModels::DimensionalKeyDefinition_sequence& DDICDIModels::
  DimensionalKeyDefinition () const
  {
    return this->DimensionalKeyDefinition_;
  }

  DDICDIModels::DimensionalKeyDefinition_sequence& DDICDIModels::
  DimensionalKeyDefinition ()
  {
    return this->DimensionalKeyDefinition_;
  }

  void DDICDIModels::
  DimensionalKeyDefinition (const DimensionalKeyDefinition_sequence& s)
  {
    this->DimensionalKeyDefinition_ = s;
  }

  const DDICDIModels::DimensionalKeyDefinitionMember_sequence& DDICDIModels::
  DimensionalKeyDefinitionMember () const
  {
    return this->DimensionalKeyDefinitionMember_;
  }

  DDICDIModels::DimensionalKeyDefinitionMember_sequence& DDICDIModels::
  DimensionalKeyDefinitionMember ()
  {
    return this->DimensionalKeyDefinitionMember_;
  }

  void DDICDIModels::
  DimensionalKeyDefinitionMember (const DimensionalKeyDefinitionMember_sequence& s)
  {
    this->DimensionalKeyDefinitionMember_ = s;
  }

  const DDICDIModels::DimensionalKeyMember_sequence& DDICDIModels::
  DimensionalKeyMember () const
  {
    return this->DimensionalKeyMember_;
  }

  DDICDIModels::DimensionalKeyMember_sequence& DDICDIModels::
  DimensionalKeyMember ()
  {
    return this->DimensionalKeyMember_;
  }

  void DDICDIModels::
  DimensionalKeyMember (const DimensionalKeyMember_sequence& s)
  {
    this->DimensionalKeyMember_ = s;
  }

  const DDICDIModels::EnumerationDomain_sequence& DDICDIModels::
  EnumerationDomain () const
  {
    return this->EnumerationDomain_;
  }

  DDICDIModels::EnumerationDomain_sequence& DDICDIModels::
  EnumerationDomain ()
  {
    return this->EnumerationDomain_;
  }

  void DDICDIModels::
  EnumerationDomain (const EnumerationDomain_sequence& s)
  {
    this->EnumerationDomain_ = s;
  }

  const DDICDIModels::ForeignKey_sequence& DDICDIModels::
  ForeignKey () const
  {
    return this->ForeignKey_;
  }

  DDICDIModels::ForeignKey_sequence& DDICDIModels::
  ForeignKey ()
  {
    return this->ForeignKey_;
  }

  void DDICDIModels::
  ForeignKey (const ForeignKey_sequence& s)
  {
    this->ForeignKey_ = s;
  }

  const DDICDIModels::ForeignKeyComponent_sequence& DDICDIModels::
  ForeignKeyComponent () const
  {
    return this->ForeignKeyComponent_;
  }

  DDICDIModels::ForeignKeyComponent_sequence& DDICDIModels::
  ForeignKeyComponent ()
  {
    return this->ForeignKeyComponent_;
  }

  void DDICDIModels::
  ForeignKeyComponent (const ForeignKeyComponent_sequence& s)
  {
    this->ForeignKeyComponent_ = s;
  }

  const DDICDIModels::IdentifierComponent_sequence& DDICDIModels::
  IdentifierComponent () const
  {
    return this->IdentifierComponent_;
  }

  DDICDIModels::IdentifierComponent_sequence& DDICDIModels::
  IdentifierComponent ()
  {
    return this->IdentifierComponent_;
  }

  void DDICDIModels::
  IdentifierComponent (const IdentifierComponent_sequence& s)
  {
    this->IdentifierComponent_ = s;
  }

  const DDICDIModels::Individual_sequence& DDICDIModels::
  Individual () const
  {
    return this->Individual_;
  }

  DDICDIModels::Individual_sequence& DDICDIModels::
  Individual ()
  {
    return this->Individual_;
  }

  void DDICDIModels::
  Individual (const Individual_sequence& s)
  {
    this->Individual_ = s;
  }

  const DDICDIModels::InformationFlowDefinition_sequence& DDICDIModels::
  InformationFlowDefinition () const
  {
    return this->InformationFlowDefinition_;
  }

  DDICDIModels::InformationFlowDefinition_sequence& DDICDIModels::
  InformationFlowDefinition ()
  {
    return this->InformationFlowDefinition_;
  }

  void DDICDIModels::
  InformationFlowDefinition (const InformationFlowDefinition_sequence& s)
  {
    this->InformationFlowDefinition_ = s;
  }

  const DDICDIModels::InstanceKey_sequence& DDICDIModels::
  InstanceKey () const
  {
    return this->InstanceKey_;
  }

  DDICDIModels::InstanceKey_sequence& DDICDIModels::
  InstanceKey ()
  {
    return this->InstanceKey_;
  }

  void DDICDIModels::
  InstanceKey (const InstanceKey_sequence& s)
  {
    this->InstanceKey_ = s;
  }

  const DDICDIModels::InstanceValue_sequence& DDICDIModels::
  InstanceValue () const
  {
    return this->InstanceValue_;
  }

  DDICDIModels::InstanceValue_sequence& DDICDIModels::
  InstanceValue ()
  {
    return this->InstanceValue_;
  }

  void DDICDIModels::
  InstanceValue (const InstanceValue_sequence& s)
  {
    this->InstanceValue_ = s;
  }

  const DDICDIModels::InstanceVariable_sequence& DDICDIModels::
  InstanceVariable () const
  {
    return this->InstanceVariable_;
  }

  DDICDIModels::InstanceVariable_sequence& DDICDIModels::
  InstanceVariable ()
  {
    return this->InstanceVariable_;
  }

  void DDICDIModels::
  InstanceVariable (const InstanceVariable_sequence& s)
  {
    this->InstanceVariable_ = s;
  }

  const DDICDIModels::InstanceVariableMap_sequence& DDICDIModels::
  InstanceVariableMap () const
  {
    return this->InstanceVariableMap_;
  }

  DDICDIModels::InstanceVariableMap_sequence& DDICDIModels::
  InstanceVariableMap ()
  {
    return this->InstanceVariableMap_;
  }

  void DDICDIModels::
  InstanceVariableMap (const InstanceVariableMap_sequence& s)
  {
    this->InstanceVariableMap_ = s;
  }

  const DDICDIModels::Key_sequence& DDICDIModels::
  Key () const
  {
    return this->Key_;
  }

  DDICDIModels::Key_sequence& DDICDIModels::
  Key ()
  {
    return this->Key_;
  }

  void DDICDIModels::
  Key (const Key_sequence& s)
  {
    this->Key_ = s;
  }

  const DDICDIModels::KeyDefinition_sequence& DDICDIModels::
  KeyDefinition () const
  {
    return this->KeyDefinition_;
  }

  DDICDIModels::KeyDefinition_sequence& DDICDIModels::
  KeyDefinition ()
  {
    return this->KeyDefinition_;
  }

  void DDICDIModels::
  KeyDefinition (const KeyDefinition_sequence& s)
  {
    this->KeyDefinition_ = s;
  }

  const DDICDIModels::KeyDefinitionMember_sequence& DDICDIModels::
  KeyDefinitionMember () const
  {
    return this->KeyDefinitionMember_;
  }

  DDICDIModels::KeyDefinitionMember_sequence& DDICDIModels::
  KeyDefinitionMember ()
  {
    return this->KeyDefinitionMember_;
  }

  void DDICDIModels::
  KeyDefinitionMember (const KeyDefinitionMember_sequence& s)
  {
    this->KeyDefinitionMember_ = s;
  }

  const DDICDIModels::KeyMember_sequence& DDICDIModels::
  KeyMember () const
  {
    return this->KeyMember_;
  }

  DDICDIModels::KeyMember_sequence& DDICDIModels::
  KeyMember ()
  {
    return this->KeyMember_;
  }

  void DDICDIModels::
  KeyMember (const KeyMember_sequence& s)
  {
    this->KeyMember_ = s;
  }

  const DDICDIModels::KeyValueDataStore_sequence& DDICDIModels::
  KeyValueDataStore () const
  {
    return this->KeyValueDataStore_;
  }

  DDICDIModels::KeyValueDataStore_sequence& DDICDIModels::
  KeyValueDataStore ()
  {
    return this->KeyValueDataStore_;
  }

  void DDICDIModels::
  KeyValueDataStore (const KeyValueDataStore_sequence& s)
  {
    this->KeyValueDataStore_ = s;
  }

  const DDICDIModels::KeyValueStructure_sequence& DDICDIModels::
  KeyValueStructure () const
  {
    return this->KeyValueStructure_;
  }

  DDICDIModels::KeyValueStructure_sequence& DDICDIModels::
  KeyValueStructure ()
  {
    return this->KeyValueStructure_;
  }

  void DDICDIModels::
  KeyValueStructure (const KeyValueStructure_sequence& s)
  {
    this->KeyValueStructure_ = s;
  }

  const DDICDIModels::Level_sequence& DDICDIModels::
  Level () const
  {
    return this->Level_;
  }

  DDICDIModels::Level_sequence& DDICDIModels::
  Level ()
  {
    return this->Level_;
  }

  void DDICDIModels::
  Level (const Level_sequence& s)
  {
    this->Level_ = s;
  }

  const DDICDIModels::LevelStructure_sequence& DDICDIModels::
  LevelStructure () const
  {
    return this->LevelStructure_;
  }

  DDICDIModels::LevelStructure_sequence& DDICDIModels::
  LevelStructure ()
  {
    return this->LevelStructure_;
  }

  void DDICDIModels::
  LevelStructure (const LevelStructure_sequence& s)
  {
    this->LevelStructure_ = s;
  }

  const DDICDIModels::LogicalRecord_sequence& DDICDIModels::
  LogicalRecord () const
  {
    return this->LogicalRecord_;
  }

  DDICDIModels::LogicalRecord_sequence& DDICDIModels::
  LogicalRecord ()
  {
    return this->LogicalRecord_;
  }

  void DDICDIModels::
  LogicalRecord (const LogicalRecord_sequence& s)
  {
    this->LogicalRecord_ = s;
  }

  const DDICDIModels::LogicalRecordPosition_sequence& DDICDIModels::
  LogicalRecordPosition () const
  {
    return this->LogicalRecordPosition_;
  }

  DDICDIModels::LogicalRecordPosition_sequence& DDICDIModels::
  LogicalRecordPosition ()
  {
    return this->LogicalRecordPosition_;
  }

  void DDICDIModels::
  LogicalRecordPosition (const LogicalRecordPosition_sequence& s)
  {
    this->LogicalRecordPosition_ = s;
  }

  const DDICDIModels::LogicalRecordRelationStructure_sequence& DDICDIModels::
  LogicalRecordRelationStructure () const
  {
    return this->LogicalRecordRelationStructure_;
  }

  DDICDIModels::LogicalRecordRelationStructure_sequence& DDICDIModels::
  LogicalRecordRelationStructure ()
  {
    return this->LogicalRecordRelationStructure_;
  }

  void DDICDIModels::
  LogicalRecordRelationStructure (const LogicalRecordRelationStructure_sequence& s)
  {
    this->LogicalRecordRelationStructure_ = s;
  }

  const DDICDIModels::LogicalRecordRelationship_sequence& DDICDIModels::
  LogicalRecordRelationship () const
  {
    return this->LogicalRecordRelationship_;
  }

  DDICDIModels::LogicalRecordRelationship_sequence& DDICDIModels::
  LogicalRecordRelationship ()
  {
    return this->LogicalRecordRelationship_;
  }

  void DDICDIModels::
  LogicalRecordRelationship (const LogicalRecordRelationship_sequence& s)
  {
    this->LogicalRecordRelationship_ = s;
  }

  const DDICDIModels::LongDataSet_sequence& DDICDIModels::
  LongDataSet () const
  {
    return this->LongDataSet_;
  }

  DDICDIModels::LongDataSet_sequence& DDICDIModels::
  LongDataSet ()
  {
    return this->LongDataSet_;
  }

  void DDICDIModels::
  LongDataSet (const LongDataSet_sequence& s)
  {
    this->LongDataSet_ = s;
  }

  const DDICDIModels::LongDataStructure_sequence& DDICDIModels::
  LongDataStructure () const
  {
    return this->LongDataStructure_;
  }

  DDICDIModels::LongDataStructure_sequence& DDICDIModels::
  LongDataStructure ()
  {
    return this->LongDataStructure_;
  }

  void DDICDIModels::
  LongDataStructure (const LongDataStructure_sequence& s)
  {
    this->LongDataStructure_ = s;
  }

  const DDICDIModels::LongKey_sequence& DDICDIModels::
  LongKey () const
  {
    return this->LongKey_;
  }

  DDICDIModels::LongKey_sequence& DDICDIModels::
  LongKey ()
  {
    return this->LongKey_;
  }

  void DDICDIModels::
  LongKey (const LongKey_sequence& s)
  {
    this->LongKey_ = s;
  }

  const DDICDIModels::LongMainKeyMember_sequence& DDICDIModels::
  LongMainKeyMember () const
  {
    return this->LongMainKeyMember_;
  }

  DDICDIModels::LongMainKeyMember_sequence& DDICDIModels::
  LongMainKeyMember ()
  {
    return this->LongMainKeyMember_;
  }

  void DDICDIModels::
  LongMainKeyMember (const LongMainKeyMember_sequence& s)
  {
    this->LongMainKeyMember_ = s;
  }

  const DDICDIModels::Machine_sequence& DDICDIModels::
  Machine () const
  {
    return this->Machine_;
  }

  DDICDIModels::Machine_sequence& DDICDIModels::
  Machine ()
  {
    return this->Machine_;
  }

  void DDICDIModels::
  Machine (const Machine_sequence& s)
  {
    this->Machine_ = s;
  }

  const DDICDIModels::MainKeyMember_sequence& DDICDIModels::
  MainKeyMember () const
  {
    return this->MainKeyMember_;
  }

  DDICDIModels::MainKeyMember_sequence& DDICDIModels::
  MainKeyMember ()
  {
    return this->MainKeyMember_;
  }

  void DDICDIModels::
  MainKeyMember (const MainKeyMember_sequence& s)
  {
    this->MainKeyMember_ = s;
  }

  const DDICDIModels::MeasureComponent_sequence& DDICDIModels::
  MeasureComponent () const
  {
    return this->MeasureComponent_;
  }

  DDICDIModels::MeasureComponent_sequence& DDICDIModels::
  MeasureComponent ()
  {
    return this->MeasureComponent_;
  }

  void DDICDIModels::
  MeasureComponent (const MeasureComponent_sequence& s)
  {
    this->MeasureComponent_ = s;
  }

  const DDICDIModels::NonDeterministicDeclarative_sequence& DDICDIModels::
  NonDeterministicDeclarative () const
  {
    return this->NonDeterministicDeclarative_;
  }

  DDICDIModels::NonDeterministicDeclarative_sequence& DDICDIModels::
  NonDeterministicDeclarative ()
  {
    return this->NonDeterministicDeclarative_;
  }

  void DDICDIModels::
  NonDeterministicDeclarative (const NonDeterministicDeclarative_sequence& s)
  {
    this->NonDeterministicDeclarative_ = s;
  }

  const DDICDIModels::Notation_sequence& DDICDIModels::
  Notation () const
  {
    return this->Notation_;
  }

  DDICDIModels::Notation_sequence& DDICDIModels::
  Notation ()
  {
    return this->Notation_;
  }

  void DDICDIModels::
  Notation (const Notation_sequence& s)
  {
    this->Notation_ = s;
  }

  const DDICDIModels::Organization_sequence& DDICDIModels::
  Organization () const
  {
    return this->Organization_;
  }

  DDICDIModels::Organization_sequence& DDICDIModels::
  Organization ()
  {
    return this->Organization_;
  }

  void DDICDIModels::
  Organization (const Organization_sequence& s)
  {
    this->Organization_ = s;
  }

  const DDICDIModels::Parameter_sequence& DDICDIModels::
  Parameter () const
  {
    return this->Parameter_;
  }

  DDICDIModels::Parameter_sequence& DDICDIModels::
  Parameter ()
  {
    return this->Parameter_;
  }

  void DDICDIModels::
  Parameter (const Parameter_sequence& s)
  {
    this->Parameter_ = s;
  }

  const DDICDIModels::PhysicalDataSet_sequence& DDICDIModels::
  PhysicalDataSet () const
  {
    return this->PhysicalDataSet_;
  }

  DDICDIModels::PhysicalDataSet_sequence& DDICDIModels::
  PhysicalDataSet ()
  {
    return this->PhysicalDataSet_;
  }

  void DDICDIModels::
  PhysicalDataSet (const PhysicalDataSet_sequence& s)
  {
    this->PhysicalDataSet_ = s;
  }

  const DDICDIModels::PhysicalDataSetStructure_sequence& DDICDIModels::
  PhysicalDataSetStructure () const
  {
    return this->PhysicalDataSetStructure_;
  }

  DDICDIModels::PhysicalDataSetStructure_sequence& DDICDIModels::
  PhysicalDataSetStructure ()
  {
    return this->PhysicalDataSetStructure_;
  }

  void DDICDIModels::
  PhysicalDataSetStructure (const PhysicalDataSetStructure_sequence& s)
  {
    this->PhysicalDataSetStructure_ = s;
  }

  const DDICDIModels::PhysicalLayoutRelationStructure_sequence& DDICDIModels::
  PhysicalLayoutRelationStructure () const
  {
    return this->PhysicalLayoutRelationStructure_;
  }

  DDICDIModels::PhysicalLayoutRelationStructure_sequence& DDICDIModels::
  PhysicalLayoutRelationStructure ()
  {
    return this->PhysicalLayoutRelationStructure_;
  }

  void DDICDIModels::
  PhysicalLayoutRelationStructure (const PhysicalLayoutRelationStructure_sequence& s)
  {
    this->PhysicalLayoutRelationStructure_ = s;
  }

  const DDICDIModels::PhysicalRecordSegment_sequence& DDICDIModels::
  PhysicalRecordSegment () const
  {
    return this->PhysicalRecordSegment_;
  }

  DDICDIModels::PhysicalRecordSegment_sequence& DDICDIModels::
  PhysicalRecordSegment ()
  {
    return this->PhysicalRecordSegment_;
  }

  void DDICDIModels::
  PhysicalRecordSegment (const PhysicalRecordSegment_sequence& s)
  {
    this->PhysicalRecordSegment_ = s;
  }

  const DDICDIModels::PhysicalRecordSegmentPosition_sequence& DDICDIModels::
  PhysicalRecordSegmentPosition () const
  {
    return this->PhysicalRecordSegmentPosition_;
  }

  DDICDIModels::PhysicalRecordSegmentPosition_sequence& DDICDIModels::
  PhysicalRecordSegmentPosition ()
  {
    return this->PhysicalRecordSegmentPosition_;
  }

  void DDICDIModels::
  PhysicalRecordSegmentPosition (const PhysicalRecordSegmentPosition_sequence& s)
  {
    this->PhysicalRecordSegmentPosition_ = s;
  }

  const DDICDIModels::PhysicalRecordSegmentRelationship_sequence& DDICDIModels::
  PhysicalRecordSegmentRelationship () const
  {
    return this->PhysicalRecordSegmentRelationship_;
  }

  DDICDIModels::PhysicalRecordSegmentRelationship_sequence& DDICDIModels::
  PhysicalRecordSegmentRelationship ()
  {
    return this->PhysicalRecordSegmentRelationship_;
  }

  void DDICDIModels::
  PhysicalRecordSegmentRelationship (const PhysicalRecordSegmentRelationship_sequence& s)
  {
    this->PhysicalRecordSegmentRelationship_ = s;
  }

  const DDICDIModels::PhysicalRecordSegmentStructure_sequence& DDICDIModels::
  PhysicalRecordSegmentStructure () const
  {
    return this->PhysicalRecordSegmentStructure_;
  }

  DDICDIModels::PhysicalRecordSegmentStructure_sequence& DDICDIModels::
  PhysicalRecordSegmentStructure ()
  {
    return this->PhysicalRecordSegmentStructure_;
  }

  void DDICDIModels::
  PhysicalRecordSegmentStructure (const PhysicalRecordSegmentStructure_sequence& s)
  {
    this->PhysicalRecordSegmentStructure_ = s;
  }

  const DDICDIModels::PhysicalSegmentLayout_sequence& DDICDIModels::
  PhysicalSegmentLayout () const
  {
    return this->PhysicalSegmentLayout_;
  }

  DDICDIModels::PhysicalSegmentLayout_sequence& DDICDIModels::
  PhysicalSegmentLayout ()
  {
    return this->PhysicalSegmentLayout_;
  }

  void DDICDIModels::
  PhysicalSegmentLayout (const PhysicalSegmentLayout_sequence& s)
  {
    this->PhysicalSegmentLayout_ = s;
  }

  const DDICDIModels::PhysicalSegmentLocation_sequence& DDICDIModels::
  PhysicalSegmentLocation () const
  {
    return this->PhysicalSegmentLocation_;
  }

  DDICDIModels::PhysicalSegmentLocation_sequence& DDICDIModels::
  PhysicalSegmentLocation ()
  {
    return this->PhysicalSegmentLocation_;
  }

  void DDICDIModels::
  PhysicalSegmentLocation (const PhysicalSegmentLocation_sequence& s)
  {
    this->PhysicalSegmentLocation_ = s;
  }

  const DDICDIModels::Population_sequence& DDICDIModels::
  Population () const
  {
    return this->Population_;
  }

  DDICDIModels::Population_sequence& DDICDIModels::
  Population ()
  {
    return this->Population_;
  }

  void DDICDIModels::
  Population (const Population_sequence& s)
  {
    this->Population_ = s;
  }

  const DDICDIModels::PrimaryKey_sequence& DDICDIModels::
  PrimaryKey () const
  {
    return this->PrimaryKey_;
  }

  DDICDIModels::PrimaryKey_sequence& DDICDIModels::
  PrimaryKey ()
  {
    return this->PrimaryKey_;
  }

  void DDICDIModels::
  PrimaryKey (const PrimaryKey_sequence& s)
  {
    this->PrimaryKey_ = s;
  }

  const DDICDIModels::PrimaryKeyComponent_sequence& DDICDIModels::
  PrimaryKeyComponent () const
  {
    return this->PrimaryKeyComponent_;
  }

  DDICDIModels::PrimaryKeyComponent_sequence& DDICDIModels::
  PrimaryKeyComponent ()
  {
    return this->PrimaryKeyComponent_;
  }

  void DDICDIModels::
  PrimaryKeyComponent (const PrimaryKeyComponent_sequence& s)
  {
    this->PrimaryKeyComponent_ = s;
  }

  const DDICDIModels::ProcessingAgent_sequence& DDICDIModels::
  ProcessingAgent () const
  {
    return this->ProcessingAgent_;
  }

  DDICDIModels::ProcessingAgent_sequence& DDICDIModels::
  ProcessingAgent ()
  {
    return this->ProcessingAgent_;
  }

  void DDICDIModels::
  ProcessingAgent (const ProcessingAgent_sequence& s)
  {
    this->ProcessingAgent_ = s;
  }

  const DDICDIModels::ProductionEnvironment_sequence& DDICDIModels::
  ProductionEnvironment () const
  {
    return this->ProductionEnvironment_;
  }

  DDICDIModels::ProductionEnvironment_sequence& DDICDIModels::
  ProductionEnvironment ()
  {
    return this->ProductionEnvironment_;
  }

  void DDICDIModels::
  ProductionEnvironment (const ProductionEnvironment_sequence& s)
  {
    this->ProductionEnvironment_ = s;
  }

  const DDICDIModels::QualifiedMeasure_sequence& DDICDIModels::
  QualifiedMeasure () const
  {
    return this->QualifiedMeasure_;
  }

  DDICDIModels::QualifiedMeasure_sequence& DDICDIModels::
  QualifiedMeasure ()
  {
    return this->QualifiedMeasure_;
  }

  void DDICDIModels::
  QualifiedMeasure (const QualifiedMeasure_sequence& s)
  {
    this->QualifiedMeasure_ = s;
  }

  const DDICDIModels::RecordRelation_sequence& DDICDIModels::
  RecordRelation () const
  {
    return this->RecordRelation_;
  }

  DDICDIModels::RecordRelation_sequence& DDICDIModels::
  RecordRelation ()
  {
    return this->RecordRelation_;
  }

  void DDICDIModels::
  RecordRelation (const RecordRelation_sequence& s)
  {
    this->RecordRelation_ = s;
  }

  const DDICDIModels::ReferenceValue_sequence& DDICDIModels::
  ReferenceValue () const
  {
    return this->ReferenceValue_;
  }

  DDICDIModels::ReferenceValue_sequence& DDICDIModels::
  ReferenceValue ()
  {
    return this->ReferenceValue_;
  }

  void DDICDIModels::
  ReferenceValue (const ReferenceValue_sequence& s)
  {
    this->ReferenceValue_ = s;
  }

  const DDICDIModels::ReferenceValueDomain_sequence& DDICDIModels::
  ReferenceValueDomain () const
  {
    return this->ReferenceValueDomain_;
  }

  DDICDIModels::ReferenceValueDomain_sequence& DDICDIModels::
  ReferenceValueDomain ()
  {
    return this->ReferenceValueDomain_;
  }

  void DDICDIModels::
  ReferenceValueDomain (const ReferenceValueDomain_sequence& s)
  {
    this->ReferenceValueDomain_ = s;
  }

  const DDICDIModels::ReferenceVariable_sequence& DDICDIModels::
  ReferenceVariable () const
  {
    return this->ReferenceVariable_;
  }

  DDICDIModels::ReferenceVariable_sequence& DDICDIModels::
  ReferenceVariable ()
  {
    return this->ReferenceVariable_;
  }

  void DDICDIModels::
  ReferenceVariable (const ReferenceVariable_sequence& s)
  {
    this->ReferenceVariable_ = s;
  }

  const DDICDIModels::RepresentedVariable_sequence& DDICDIModels::
  RepresentedVariable () const
  {
    return this->RepresentedVariable_;
  }

  DDICDIModels::RepresentedVariable_sequence& DDICDIModels::
  RepresentedVariable ()
  {
    return this->RepresentedVariable_;
  }

  void DDICDIModels::
  RepresentedVariable (const RepresentedVariable_sequence& s)
  {
    this->RepresentedVariable_ = s;
  }

  const DDICDIModels::RevisableDatum_sequence& DDICDIModels::
  RevisableDatum () const
  {
    return this->RevisableDatum_;
  }

  DDICDIModels::RevisableDatum_sequence& DDICDIModels::
  RevisableDatum ()
  {
    return this->RevisableDatum_;
  }

  void DDICDIModels::
  RevisableDatum (const RevisableDatum_sequence& s)
  {
    this->RevisableDatum_ = s;
  }

  const DDICDIModels::Revision_sequence& DDICDIModels::
  Revision () const
  {
    return this->Revision_;
  }

  DDICDIModels::Revision_sequence& DDICDIModels::
  Revision ()
  {
    return this->Revision_;
  }

  void DDICDIModels::
  Revision (const Revision_sequence& s)
  {
    this->Revision_ = s;
  }

  const DDICDIModels::Rule_sequence& DDICDIModels::
  Rule () const
  {
    return this->Rule_;
  }

  DDICDIModels::Rule_sequence& DDICDIModels::
  Rule ()
  {
    return this->Rule_;
  }

  void DDICDIModels::
  Rule (const Rule_sequence& s)
  {
    this->Rule_ = s;
  }

  const DDICDIModels::RuleBasedScheduling_sequence& DDICDIModels::
  RuleBasedScheduling () const
  {
    return this->RuleBasedScheduling_;
  }

  DDICDIModels::RuleBasedScheduling_sequence& DDICDIModels::
  RuleBasedScheduling ()
  {
    return this->RuleBasedScheduling_;
  }

  void DDICDIModels::
  RuleBasedScheduling (const RuleBasedScheduling_sequence& s)
  {
    this->RuleBasedScheduling_ = s;
  }

  const DDICDIModels::RuleSet_sequence& DDICDIModels::
  RuleSet () const
  {
    return this->RuleSet_;
  }

  DDICDIModels::RuleSet_sequence& DDICDIModels::
  RuleSet ()
  {
    return this->RuleSet_;
  }

  void DDICDIModels::
  RuleSet (const RuleSet_sequence& s)
  {
    this->RuleSet_ = s;
  }

  const DDICDIModels::ScopedMeasure_sequence& DDICDIModels::
  ScopedMeasure () const
  {
    return this->ScopedMeasure_;
  }

  DDICDIModels::ScopedMeasure_sequence& DDICDIModels::
  ScopedMeasure ()
  {
    return this->ScopedMeasure_;
  }

  void DDICDIModels::
  ScopedMeasure (const ScopedMeasure_sequence& s)
  {
    this->ScopedMeasure_ = s;
  }

  const DDICDIModels::SegmentByText_sequence& DDICDIModels::
  SegmentByText () const
  {
    return this->SegmentByText_;
  }

  DDICDIModels::SegmentByText_sequence& DDICDIModels::
  SegmentByText ()
  {
    return this->SegmentByText_;
  }

  void DDICDIModels::
  SegmentByText (const SegmentByText_sequence& s)
  {
    this->SegmentByText_ = s;
  }

  const DDICDIModels::SentinelConceptualDomain_sequence& DDICDIModels::
  SentinelConceptualDomain () const
  {
    return this->SentinelConceptualDomain_;
  }

  DDICDIModels::SentinelConceptualDomain_sequence& DDICDIModels::
  SentinelConceptualDomain ()
  {
    return this->SentinelConceptualDomain_;
  }

  void DDICDIModels::
  SentinelConceptualDomain (const SentinelConceptualDomain_sequence& s)
  {
    this->SentinelConceptualDomain_ = s;
  }

  const DDICDIModels::SentinelValueDomain_sequence& DDICDIModels::
  SentinelValueDomain () const
  {
    return this->SentinelValueDomain_;
  }

  DDICDIModels::SentinelValueDomain_sequence& DDICDIModels::
  SentinelValueDomain ()
  {
    return this->SentinelValueDomain_;
  }

  void DDICDIModels::
  SentinelValueDomain (const SentinelValueDomain_sequence& s)
  {
    this->SentinelValueDomain_ = s;
  }

  const DDICDIModels::Sequence_sequence& DDICDIModels::
  Sequence () const
  {
    return this->Sequence_;
  }

  DDICDIModels::Sequence_sequence& DDICDIModels::
  Sequence ()
  {
    return this->Sequence_;
  }

  void DDICDIModels::
  Sequence (const Sequence_sequence& s)
  {
    this->Sequence_ = s;
  }

  const DDICDIModels::SequencePosition_sequence& DDICDIModels::
  SequencePosition () const
  {
    return this->SequencePosition_;
  }

  DDICDIModels::SequencePosition_sequence& DDICDIModels::
  SequencePosition ()
  {
    return this->SequencePosition_;
  }

  void DDICDIModels::
  SequencePosition (const SequencePosition_sequence& s)
  {
    this->SequencePosition_ = s;
  }

  const DDICDIModels::Service_sequence& DDICDIModels::
  Service () const
  {
    return this->Service_;
  }

  DDICDIModels::Service_sequence& DDICDIModels::
  Service ()
  {
    return this->Service_;
  }

  void DDICDIModels::
  Service (const Service_sequence& s)
  {
    this->Service_ = s;
  }

  const DDICDIModels::StatisticalClassification_sequence& DDICDIModels::
  StatisticalClassification () const
  {
    return this->StatisticalClassification_;
  }

  DDICDIModels::StatisticalClassification_sequence& DDICDIModels::
  StatisticalClassification ()
  {
    return this->StatisticalClassification_;
  }

  void DDICDIModels::
  StatisticalClassification (const StatisticalClassification_sequence& s)
  {
    this->StatisticalClassification_ = s;
  }

  const DDICDIModels::StatisticalClassificationRelationship_sequence& DDICDIModels::
  StatisticalClassificationRelationship () const
  {
    return this->StatisticalClassificationRelationship_;
  }

  DDICDIModels::StatisticalClassificationRelationship_sequence& DDICDIModels::
  StatisticalClassificationRelationship ()
  {
    return this->StatisticalClassificationRelationship_;
  }

  void DDICDIModels::
  StatisticalClassificationRelationship (const StatisticalClassificationRelationship_sequence& s)
  {
    this->StatisticalClassificationRelationship_ = s;
  }

  const DDICDIModels::Step_sequence& DDICDIModels::
  Step () const
  {
    return this->Step_;
  }

  DDICDIModels::Step_sequence& DDICDIModels::
  Step ()
  {
    return this->Step_;
  }

  void DDICDIModels::
  Step (const Step_sequence& s)
  {
    this->Step_ = s;
  }

  const DDICDIModels::SubstantiveConceptualDomain_sequence& DDICDIModels::
  SubstantiveConceptualDomain () const
  {
    return this->SubstantiveConceptualDomain_;
  }

  DDICDIModels::SubstantiveConceptualDomain_sequence& DDICDIModels::
  SubstantiveConceptualDomain ()
  {
    return this->SubstantiveConceptualDomain_;
  }

  void DDICDIModels::
  SubstantiveConceptualDomain (const SubstantiveConceptualDomain_sequence& s)
  {
    this->SubstantiveConceptualDomain_ = s;
  }

  const DDICDIModels::SubstantiveValueDomain_sequence& DDICDIModels::
  SubstantiveValueDomain () const
  {
    return this->SubstantiveValueDomain_;
  }

  DDICDIModels::SubstantiveValueDomain_sequence& DDICDIModels::
  SubstantiveValueDomain ()
  {
    return this->SubstantiveValueDomain_;
  }

  void DDICDIModels::
  SubstantiveValueDomain (const SubstantiveValueDomain_sequence& s)
  {
    this->SubstantiveValueDomain_ = s;
  }

  const DDICDIModels::SyntheticIdComponent_sequence& DDICDIModels::
  SyntheticIdComponent () const
  {
    return this->SyntheticIdComponent_;
  }

  DDICDIModels::SyntheticIdComponent_sequence& DDICDIModels::
  SyntheticIdComponent ()
  {
    return this->SyntheticIdComponent_;
  }

  void DDICDIModels::
  SyntheticIdComponent (const SyntheticIdComponent_sequence& s)
  {
    this->SyntheticIdComponent_ = s;
  }

  const DDICDIModels::TemporalConstraints_sequence& DDICDIModels::
  TemporalConstraints () const
  {
    return this->TemporalConstraints_;
  }

  DDICDIModels::TemporalConstraints_sequence& DDICDIModels::
  TemporalConstraints ()
  {
    return this->TemporalConstraints_;
  }

  void DDICDIModels::
  TemporalConstraints (const TemporalConstraints_sequence& s)
  {
    this->TemporalConstraints_ = s;
  }

  const DDICDIModels::TemporalControlConstruct_sequence& DDICDIModels::
  TemporalControlConstruct () const
  {
    return this->TemporalControlConstruct_;
  }

  DDICDIModels::TemporalControlConstruct_sequence& DDICDIModels::
  TemporalControlConstruct ()
  {
    return this->TemporalControlConstruct_;
  }

  void DDICDIModels::
  TemporalControlConstruct (const TemporalControlConstruct_sequence& s)
  {
    this->TemporalControlConstruct_ = s;
  }

  const DDICDIModels::Unit_sequence& DDICDIModels::
  Unit () const
  {
    return this->Unit_;
  }

  DDICDIModels::Unit_sequence& DDICDIModels::
  Unit ()
  {
    return this->Unit_;
  }

  void DDICDIModels::
  Unit (const Unit_sequence& s)
  {
    this->Unit_ = s;
  }

  const DDICDIModels::UnitSegmentLayout_sequence& DDICDIModels::
  UnitSegmentLayout () const
  {
    return this->UnitSegmentLayout_;
  }

  DDICDIModels::UnitSegmentLayout_sequence& DDICDIModels::
  UnitSegmentLayout ()
  {
    return this->UnitSegmentLayout_;
  }

  void DDICDIModels::
  UnitSegmentLayout (const UnitSegmentLayout_sequence& s)
  {
    this->UnitSegmentLayout_ = s;
  }

  const DDICDIModels::UnitType_sequence& DDICDIModels::
  UnitType () const
  {
    return this->UnitType_;
  }

  DDICDIModels::UnitType_sequence& DDICDIModels::
  UnitType ()
  {
    return this->UnitType_;
  }

  void DDICDIModels::
  UnitType (const UnitType_sequence& s)
  {
    this->UnitType_ = s;
  }

  const DDICDIModels::Universe_sequence& DDICDIModels::
  Universe () const
  {
    return this->Universe_;
  }

  DDICDIModels::Universe_sequence& DDICDIModels::
  Universe ()
  {
    return this->Universe_;
  }

  void DDICDIModels::
  Universe (const Universe_sequence& s)
  {
    this->Universe_ = s;
  }

  const DDICDIModels::ValueAndConceptDescription_sequence& DDICDIModels::
  ValueAndConceptDescription () const
  {
    return this->ValueAndConceptDescription_;
  }

  DDICDIModels::ValueAndConceptDescription_sequence& DDICDIModels::
  ValueAndConceptDescription ()
  {
    return this->ValueAndConceptDescription_;
  }

  void DDICDIModels::
  ValueAndConceptDescription (const ValueAndConceptDescription_sequence& s)
  {
    this->ValueAndConceptDescription_ = s;
  }

  const DDICDIModels::ValueDomain_sequence& DDICDIModels::
  ValueDomain () const
  {
    return this->ValueDomain_;
  }

  DDICDIModels::ValueDomain_sequence& DDICDIModels::
  ValueDomain ()
  {
    return this->ValueDomain_;
  }

  void DDICDIModels::
  ValueDomain (const ValueDomain_sequence& s)
  {
    this->ValueDomain_ = s;
  }

  const DDICDIModels::ValueMapping_sequence& DDICDIModels::
  ValueMapping () const
  {
    return this->ValueMapping_;
  }

  DDICDIModels::ValueMapping_sequence& DDICDIModels::
  ValueMapping ()
  {
    return this->ValueMapping_;
  }

  void DDICDIModels::
  ValueMapping (const ValueMapping_sequence& s)
  {
    this->ValueMapping_ = s;
  }

  const DDICDIModels::ValueMappingPosition_sequence& DDICDIModels::
  ValueMappingPosition () const
  {
    return this->ValueMappingPosition_;
  }

  DDICDIModels::ValueMappingPosition_sequence& DDICDIModels::
  ValueMappingPosition ()
  {
    return this->ValueMappingPosition_;
  }

  void DDICDIModels::
  ValueMappingPosition (const ValueMappingPosition_sequence& s)
  {
    this->ValueMappingPosition_ = s;
  }

  const DDICDIModels::ValueMappingRelationship_sequence& DDICDIModels::
  ValueMappingRelationship () const
  {
    return this->ValueMappingRelationship_;
  }

  DDICDIModels::ValueMappingRelationship_sequence& DDICDIModels::
  ValueMappingRelationship ()
  {
    return this->ValueMappingRelationship_;
  }

  void DDICDIModels::
  ValueMappingRelationship (const ValueMappingRelationship_sequence& s)
  {
    this->ValueMappingRelationship_ = s;
  }

  const DDICDIModels::VariableCollection_sequence& DDICDIModels::
  VariableCollection () const
  {
    return this->VariableCollection_;
  }

  DDICDIModels::VariableCollection_sequence& DDICDIModels::
  VariableCollection ()
  {
    return this->VariableCollection_;
  }

  void DDICDIModels::
  VariableCollection (const VariableCollection_sequence& s)
  {
    this->VariableCollection_ = s;
  }

  const DDICDIModels::VariableDescriptorComponent_sequence& DDICDIModels::
  VariableDescriptorComponent () const
  {
    return this->VariableDescriptorComponent_;
  }

  DDICDIModels::VariableDescriptorComponent_sequence& DDICDIModels::
  VariableDescriptorComponent ()
  {
    return this->VariableDescriptorComponent_;
  }

  void DDICDIModels::
  VariableDescriptorComponent (const VariableDescriptorComponent_sequence& s)
  {
    this->VariableDescriptorComponent_ = s;
  }

  const DDICDIModels::VariablePosition_sequence& DDICDIModels::
  VariablePosition () const
  {
    return this->VariablePosition_;
  }

  DDICDIModels::VariablePosition_sequence& DDICDIModels::
  VariablePosition ()
  {
    return this->VariablePosition_;
  }

  void DDICDIModels::
  VariablePosition (const VariablePosition_sequence& s)
  {
    this->VariablePosition_ = s;
  }

  const DDICDIModels::VariableRelationship_sequence& DDICDIModels::
  VariableRelationship () const
  {
    return this->VariableRelationship_;
  }

  DDICDIModels::VariableRelationship_sequence& DDICDIModels::
  VariableRelationship ()
  {
    return this->VariableRelationship_;
  }

  void DDICDIModels::
  VariableRelationship (const VariableRelationship_sequence& s)
  {
    this->VariableRelationship_ = s;
  }

  const DDICDIModels::VariableStructure_sequence& DDICDIModels::
  VariableStructure () const
  {
    return this->VariableStructure_;
  }

  DDICDIModels::VariableStructure_sequence& DDICDIModels::
  VariableStructure ()
  {
    return this->VariableStructure_;
  }

  void DDICDIModels::
  VariableStructure (const VariableStructure_sequence& s)
  {
    this->VariableStructure_ = s;
  }

  const DDICDIModels::VariableValueComponent_sequence& DDICDIModels::
  VariableValueComponent () const
  {
    return this->VariableValueComponent_;
  }

  DDICDIModels::VariableValueComponent_sequence& DDICDIModels::
  VariableValueComponent ()
  {
    return this->VariableValueComponent_;
  }

  void DDICDIModels::
  VariableValueComponent (const VariableValueComponent_sequence& s)
  {
    this->VariableValueComponent_ = s;
  }

  const DDICDIModels::WideDataSet_sequence& DDICDIModels::
  WideDataSet () const
  {
    return this->WideDataSet_;
  }

  DDICDIModels::WideDataSet_sequence& DDICDIModels::
  WideDataSet ()
  {
    return this->WideDataSet_;
  }

  void DDICDIModels::
  WideDataSet (const WideDataSet_sequence& s)
  {
    this->WideDataSet_ = s;
  }

  const DDICDIModels::WideDataStructure_sequence& DDICDIModels::
  WideDataStructure () const
  {
    return this->WideDataStructure_;
  }

  DDICDIModels::WideDataStructure_sequence& DDICDIModels::
  WideDataStructure ()
  {
    return this->WideDataStructure_;
  }

  void DDICDIModels::
  WideDataStructure (const WideDataStructure_sequence& s)
  {
    this->WideDataStructure_ = s;
  }

  const DDICDIModels::WideKey_sequence& DDICDIModels::
  WideKey () const
  {
    return this->WideKey_;
  }

  DDICDIModels::WideKey_sequence& DDICDIModels::
  WideKey ()
  {
    return this->WideKey_;
  }

  void DDICDIModels::
  WideKey (const WideKey_sequence& s)
  {
    this->WideKey_ = s;
  }

  const DDICDIModels::WideKeyMember_sequence& DDICDIModels::
  WideKeyMember () const
  {
    return this->WideKeyMember_;
  }

  DDICDIModels::WideKeyMember_sequence& DDICDIModels::
  WideKeyMember ()
  {
    return this->WideKeyMember_;
  }

  void DDICDIModels::
  WideKeyMember (const WideKeyMember_sequence& s)
  {
    this->WideKeyMember_ = s;
  }

  const DDICDIModels::Wrapper_sequence& DDICDIModels::
  Wrapper () const
  {
    return this->Wrapper_;
  }

  DDICDIModels::Wrapper_sequence& DDICDIModels::
  Wrapper ()
  {
    return this->Wrapper_;
  }

  void DDICDIModels::
  Wrapper (const Wrapper_sequence& s)
  {
    this->Wrapper_ = s;
  }


  // Wrapper
  //

  const Wrapper::identifier_optional& Wrapper::
  identifier () const
  {
    return this->identifier_;
  }

  Wrapper::identifier_optional& Wrapper::
  identifier ()
  {
    return this->identifier_;
  }

  void Wrapper::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void Wrapper::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void Wrapper::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const Wrapper::supportingInformation_sequence& Wrapper::
  supportingInformation () const
  {
    return this->supportingInformation_;
  }

  Wrapper::supportingInformation_sequence& Wrapper::
  supportingInformation ()
  {
    return this->supportingInformation_;
  }

  void Wrapper::
  supportingInformation (const supportingInformation_sequence& s)
  {
    this->supportingInformation_ = s;
  }

  const Wrapper::Activity_sequence& Wrapper::
  Activity () const
  {
    return this->Activity_;
  }

  Wrapper::Activity_sequence& Wrapper::
  Activity ()
  {
    return this->Activity_;
  }

  void Wrapper::
  Activity (const Activity_sequence& s)
  {
    this->Activity_ = s;
  }

  const Wrapper::Agent_sequence& Wrapper::
  Agent () const
  {
    return this->Agent_;
  }

  Wrapper::Agent_sequence& Wrapper::
  Agent ()
  {
    return this->Agent_;
  }

  void Wrapper::
  Agent (const Agent_sequence& s)
  {
    this->Agent_ = s;
  }

  const Wrapper::AgentListing_sequence& Wrapper::
  AgentListing () const
  {
    return this->AgentListing_;
  }

  Wrapper::AgentListing_sequence& Wrapper::
  AgentListing ()
  {
    return this->AgentListing_;
  }

  void Wrapper::
  AgentListing (const AgentListing_sequence& s)
  {
    this->AgentListing_ = s;
  }

  const Wrapper::AgentPosition_sequence& Wrapper::
  AgentPosition () const
  {
    return this->AgentPosition_;
  }

  Wrapper::AgentPosition_sequence& Wrapper::
  AgentPosition ()
  {
    return this->AgentPosition_;
  }

  void Wrapper::
  AgentPosition (const AgentPosition_sequence& s)
  {
    this->AgentPosition_ = s;
  }

  const Wrapper::AgentRelationship_sequence& Wrapper::
  AgentRelationship () const
  {
    return this->AgentRelationship_;
  }

  Wrapper::AgentRelationship_sequence& Wrapper::
  AgentRelationship ()
  {
    return this->AgentRelationship_;
  }

  void Wrapper::
  AgentRelationship (const AgentRelationship_sequence& s)
  {
    this->AgentRelationship_ = s;
  }

  const Wrapper::AgentStructure_sequence& Wrapper::
  AgentStructure () const
  {
    return this->AgentStructure_;
  }

  Wrapper::AgentStructure_sequence& Wrapper::
  AgentStructure ()
  {
    return this->AgentStructure_;
  }

  void Wrapper::
  AgentStructure (const AgentStructure_sequence& s)
  {
    this->AgentStructure_ = s;
  }

  const Wrapper::AllenIntervalAlgebra_sequence& Wrapper::
  AllenIntervalAlgebra () const
  {
    return this->AllenIntervalAlgebra_;
  }

  Wrapper::AllenIntervalAlgebra_sequence& Wrapper::
  AllenIntervalAlgebra ()
  {
    return this->AllenIntervalAlgebra_;
  }

  void Wrapper::
  AllenIntervalAlgebra (const AllenIntervalAlgebra_sequence& s)
  {
    this->AllenIntervalAlgebra_ = s;
  }

  const Wrapper::AttributeComponent_sequence& Wrapper::
  AttributeComponent () const
  {
    return this->AttributeComponent_;
  }

  Wrapper::AttributeComponent_sequence& Wrapper::
  AttributeComponent ()
  {
    return this->AttributeComponent_;
  }

  void Wrapper::
  AttributeComponent (const AttributeComponent_sequence& s)
  {
    this->AttributeComponent_ = s;
  }

  const Wrapper::AuthorizationSource_sequence& Wrapper::
  AuthorizationSource () const
  {
    return this->AuthorizationSource_;
  }

  Wrapper::AuthorizationSource_sequence& Wrapper::
  AuthorizationSource ()
  {
    return this->AuthorizationSource_;
  }

  void Wrapper::
  AuthorizationSource (const AuthorizationSource_sequence& s)
  {
    this->AuthorizationSource_ = s;
  }

  const Wrapper::Category_sequence& Wrapper::
  Category () const
  {
    return this->Category_;
  }

  Wrapper::Category_sequence& Wrapper::
  Category ()
  {
    return this->Category_;
  }

  void Wrapper::
  Category (const Category_sequence& s)
  {
    this->Category_ = s;
  }

  const Wrapper::CategoryPosition_sequence& Wrapper::
  CategoryPosition () const
  {
    return this->CategoryPosition_;
  }

  Wrapper::CategoryPosition_sequence& Wrapper::
  CategoryPosition ()
  {
    return this->CategoryPosition_;
  }

  void Wrapper::
  CategoryPosition (const CategoryPosition_sequence& s)
  {
    this->CategoryPosition_ = s;
  }

  const Wrapper::CategoryRelationStructure_sequence& Wrapper::
  CategoryRelationStructure () const
  {
    return this->CategoryRelationStructure_;
  }

  Wrapper::CategoryRelationStructure_sequence& Wrapper::
  CategoryRelationStructure ()
  {
    return this->CategoryRelationStructure_;
  }

  void Wrapper::
  CategoryRelationStructure (const CategoryRelationStructure_sequence& s)
  {
    this->CategoryRelationStructure_ = s;
  }

  const Wrapper::CategoryRelationship_sequence& Wrapper::
  CategoryRelationship () const
  {
    return this->CategoryRelationship_;
  }

  Wrapper::CategoryRelationship_sequence& Wrapper::
  CategoryRelationship ()
  {
    return this->CategoryRelationship_;
  }

  void Wrapper::
  CategoryRelationship (const CategoryRelationship_sequence& s)
  {
    this->CategoryRelationship_ = s;
  }

  const Wrapper::CategorySet_sequence& Wrapper::
  CategorySet () const
  {
    return this->CategorySet_;
  }

  Wrapper::CategorySet_sequence& Wrapper::
  CategorySet ()
  {
    return this->CategorySet_;
  }

  void Wrapper::
  CategorySet (const CategorySet_sequence& s)
  {
    this->CategorySet_ = s;
  }

  const Wrapper::CategoryStatistic_sequence& Wrapper::
  CategoryStatistic () const
  {
    return this->CategoryStatistic_;
  }

  Wrapper::CategoryStatistic_sequence& Wrapper::
  CategoryStatistic ()
  {
    return this->CategoryStatistic_;
  }

  void Wrapper::
  CategoryStatistic (const CategoryStatistic_sequence& s)
  {
    this->CategoryStatistic_ = s;
  }

  const Wrapper::ClassificationFamily_sequence& Wrapper::
  ClassificationFamily () const
  {
    return this->ClassificationFamily_;
  }

  Wrapper::ClassificationFamily_sequence& Wrapper::
  ClassificationFamily ()
  {
    return this->ClassificationFamily_;
  }

  void Wrapper::
  ClassificationFamily (const ClassificationFamily_sequence& s)
  {
    this->ClassificationFamily_ = s;
  }

  const Wrapper::ClassificationIndex_sequence& Wrapper::
  ClassificationIndex () const
  {
    return this->ClassificationIndex_;
  }

  Wrapper::ClassificationIndex_sequence& Wrapper::
  ClassificationIndex ()
  {
    return this->ClassificationIndex_;
  }

  void Wrapper::
  ClassificationIndex (const ClassificationIndex_sequence& s)
  {
    this->ClassificationIndex_ = s;
  }

  const Wrapper::ClassificationIndexEntry_sequence& Wrapper::
  ClassificationIndexEntry () const
  {
    return this->ClassificationIndexEntry_;
  }

  Wrapper::ClassificationIndexEntry_sequence& Wrapper::
  ClassificationIndexEntry ()
  {
    return this->ClassificationIndexEntry_;
  }

  void Wrapper::
  ClassificationIndexEntry (const ClassificationIndexEntry_sequence& s)
  {
    this->ClassificationIndexEntry_ = s;
  }

  const Wrapper::ClassificationIndexEntryPosition_sequence& Wrapper::
  ClassificationIndexEntryPosition () const
  {
    return this->ClassificationIndexEntryPosition_;
  }

  Wrapper::ClassificationIndexEntryPosition_sequence& Wrapper::
  ClassificationIndexEntryPosition ()
  {
    return this->ClassificationIndexEntryPosition_;
  }

  void Wrapper::
  ClassificationIndexEntryPosition (const ClassificationIndexEntryPosition_sequence& s)
  {
    this->ClassificationIndexEntryPosition_ = s;
  }

  const Wrapper::ClassificationItem_sequence& Wrapper::
  ClassificationItem () const
  {
    return this->ClassificationItem_;
  }

  Wrapper::ClassificationItem_sequence& Wrapper::
  ClassificationItem ()
  {
    return this->ClassificationItem_;
  }

  void Wrapper::
  ClassificationItem (const ClassificationItem_sequence& s)
  {
    this->ClassificationItem_ = s;
  }

  const Wrapper::ClassificationItemPosition_sequence& Wrapper::
  ClassificationItemPosition () const
  {
    return this->ClassificationItemPosition_;
  }

  Wrapper::ClassificationItemPosition_sequence& Wrapper::
  ClassificationItemPosition ()
  {
    return this->ClassificationItemPosition_;
  }

  void Wrapper::
  ClassificationItemPosition (const ClassificationItemPosition_sequence& s)
  {
    this->ClassificationItemPosition_ = s;
  }

  const Wrapper::ClassificationItemRelationship_sequence& Wrapper::
  ClassificationItemRelationship () const
  {
    return this->ClassificationItemRelationship_;
  }

  Wrapper::ClassificationItemRelationship_sequence& Wrapper::
  ClassificationItemRelationship ()
  {
    return this->ClassificationItemRelationship_;
  }

  void Wrapper::
  ClassificationItemRelationship (const ClassificationItemRelationship_sequence& s)
  {
    this->ClassificationItemRelationship_ = s;
  }

  const Wrapper::ClassificationItemStructure_sequence& Wrapper::
  ClassificationItemStructure () const
  {
    return this->ClassificationItemStructure_;
  }

  Wrapper::ClassificationItemStructure_sequence& Wrapper::
  ClassificationItemStructure ()
  {
    return this->ClassificationItemStructure_;
  }

  void Wrapper::
  ClassificationItemStructure (const ClassificationItemStructure_sequence& s)
  {
    this->ClassificationItemStructure_ = s;
  }

  const Wrapper::ClassificationPosition_sequence& Wrapper::
  ClassificationPosition () const
  {
    return this->ClassificationPosition_;
  }

  Wrapper::ClassificationPosition_sequence& Wrapper::
  ClassificationPosition ()
  {
    return this->ClassificationPosition_;
  }

  void Wrapper::
  ClassificationPosition (const ClassificationPosition_sequence& s)
  {
    this->ClassificationPosition_ = s;
  }

  const Wrapper::ClassificationSeries_sequence& Wrapper::
  ClassificationSeries () const
  {
    return this->ClassificationSeries_;
  }

  Wrapper::ClassificationSeries_sequence& Wrapper::
  ClassificationSeries ()
  {
    return this->ClassificationSeries_;
  }

  void Wrapper::
  ClassificationSeries (const ClassificationSeries_sequence& s)
  {
    this->ClassificationSeries_ = s;
  }

  const Wrapper::ClassificationSeriesStructure_sequence& Wrapper::
  ClassificationSeriesStructure () const
  {
    return this->ClassificationSeriesStructure_;
  }

  Wrapper::ClassificationSeriesStructure_sequence& Wrapper::
  ClassificationSeriesStructure ()
  {
    return this->ClassificationSeriesStructure_;
  }

  void Wrapper::
  ClassificationSeriesStructure (const ClassificationSeriesStructure_sequence& s)
  {
    this->ClassificationSeriesStructure_ = s;
  }

  const Wrapper::Code_sequence& Wrapper::
  Code () const
  {
    return this->Code_;
  }

  Wrapper::Code_sequence& Wrapper::
  Code ()
  {
    return this->Code_;
  }

  void Wrapper::
  Code (const Code_sequence& s)
  {
    this->Code_ = s;
  }

  const Wrapper::CodeList_sequence& Wrapper::
  CodeList () const
  {
    return this->CodeList_;
  }

  Wrapper::CodeList_sequence& Wrapper::
  CodeList ()
  {
    return this->CodeList_;
  }

  void Wrapper::
  CodeList (const CodeList_sequence& s)
  {
    this->CodeList_ = s;
  }

  const Wrapper::CodeListStructure_sequence& Wrapper::
  CodeListStructure () const
  {
    return this->CodeListStructure_;
  }

  Wrapper::CodeListStructure_sequence& Wrapper::
  CodeListStructure ()
  {
    return this->CodeListStructure_;
  }

  void Wrapper::
  CodeListStructure (const CodeListStructure_sequence& s)
  {
    this->CodeListStructure_ = s;
  }

  const Wrapper::CodePosition_sequence& Wrapper::
  CodePosition () const
  {
    return this->CodePosition_;
  }

  Wrapper::CodePosition_sequence& Wrapper::
  CodePosition ()
  {
    return this->CodePosition_;
  }

  void Wrapper::
  CodePosition (const CodePosition_sequence& s)
  {
    this->CodePosition_ = s;
  }

  const Wrapper::CodeRelationship_sequence& Wrapper::
  CodeRelationship () const
  {
    return this->CodeRelationship_;
  }

  Wrapper::CodeRelationship_sequence& Wrapper::
  CodeRelationship ()
  {
    return this->CodeRelationship_;
  }

  void Wrapper::
  CodeRelationship (const CodeRelationship_sequence& s)
  {
    this->CodeRelationship_ = s;
  }

  const Wrapper::ComponentPosition_sequence& Wrapper::
  ComponentPosition () const
  {
    return this->ComponentPosition_;
  }

  Wrapper::ComponentPosition_sequence& Wrapper::
  ComponentPosition ()
  {
    return this->ComponentPosition_;
  }

  void Wrapper::
  ComponentPosition (const ComponentPosition_sequence& s)
  {
    this->ComponentPosition_ = s;
  }

  const Wrapper::Concept_sequence& Wrapper::
  Concept () const
  {
    return this->Concept_;
  }

  Wrapper::Concept_sequence& Wrapper::
  Concept ()
  {
    return this->Concept_;
  }

  void Wrapper::
  Concept (const Concept_sequence& s)
  {
    this->Concept_ = s;
  }

  const Wrapper::ConceptMap_sequence& Wrapper::
  ConceptMap () const
  {
    return this->ConceptMap_;
  }

  Wrapper::ConceptMap_sequence& Wrapper::
  ConceptMap ()
  {
    return this->ConceptMap_;
  }

  void Wrapper::
  ConceptMap (const ConceptMap_sequence& s)
  {
    this->ConceptMap_ = s;
  }

  const Wrapper::ConceptRelationship_sequence& Wrapper::
  ConceptRelationship () const
  {
    return this->ConceptRelationship_;
  }

  Wrapper::ConceptRelationship_sequence& Wrapper::
  ConceptRelationship ()
  {
    return this->ConceptRelationship_;
  }

  void Wrapper::
  ConceptRelationship (const ConceptRelationship_sequence& s)
  {
    this->ConceptRelationship_ = s;
  }

  const Wrapper::ConceptStructure_sequence& Wrapper::
  ConceptStructure () const
  {
    return this->ConceptStructure_;
  }

  Wrapper::ConceptStructure_sequence& Wrapper::
  ConceptStructure ()
  {
    return this->ConceptStructure_;
  }

  void Wrapper::
  ConceptStructure (const ConceptStructure_sequence& s)
  {
    this->ConceptStructure_ = s;
  }

  const Wrapper::ConceptSystem_sequence& Wrapper::
  ConceptSystem () const
  {
    return this->ConceptSystem_;
  }

  Wrapper::ConceptSystem_sequence& Wrapper::
  ConceptSystem ()
  {
    return this->ConceptSystem_;
  }

  void Wrapper::
  ConceptSystem (const ConceptSystem_sequence& s)
  {
    this->ConceptSystem_ = s;
  }

  const Wrapper::ConceptSystemCorrespondence_sequence& Wrapper::
  ConceptSystemCorrespondence () const
  {
    return this->ConceptSystemCorrespondence_;
  }

  Wrapper::ConceptSystemCorrespondence_sequence& Wrapper::
  ConceptSystemCorrespondence ()
  {
    return this->ConceptSystemCorrespondence_;
  }

  void Wrapper::
  ConceptSystemCorrespondence (const ConceptSystemCorrespondence_sequence& s)
  {
    this->ConceptSystemCorrespondence_ = s;
  }

  const Wrapper::ConceptualDomain_sequence& Wrapper::
  ConceptualDomain () const
  {
    return this->ConceptualDomain_;
  }

  Wrapper::ConceptualDomain_sequence& Wrapper::
  ConceptualDomain ()
  {
    return this->ConceptualDomain_;
  }

  void Wrapper::
  ConceptualDomain (const ConceptualDomain_sequence& s)
  {
    this->ConceptualDomain_ = s;
  }

  const Wrapper::ConceptualValue_sequence& Wrapper::
  ConceptualValue () const
  {
    return this->ConceptualValue_;
  }

  Wrapper::ConceptualValue_sequence& Wrapper::
  ConceptualValue ()
  {
    return this->ConceptualValue_;
  }

  void Wrapper::
  ConceptualValue (const ConceptualValue_sequence& s)
  {
    this->ConceptualValue_ = s;
  }

  const Wrapper::ConceptualVariable_sequence& Wrapper::
  ConceptualVariable () const
  {
    return this->ConceptualVariable_;
  }

  Wrapper::ConceptualVariable_sequence& Wrapper::
  ConceptualVariable ()
  {
    return this->ConceptualVariable_;
  }

  void Wrapper::
  ConceptualVariable (const ConceptualVariable_sequence& s)
  {
    this->ConceptualVariable_ = s;
  }

  const Wrapper::ConditionalControlLogic_sequence& Wrapper::
  ConditionalControlLogic () const
  {
    return this->ConditionalControlLogic_;
  }

  Wrapper::ConditionalControlLogic_sequence& Wrapper::
  ConditionalControlLogic ()
  {
    return this->ConditionalControlLogic_;
  }

  void Wrapper::
  ConditionalControlLogic (const ConditionalControlLogic_sequence& s)
  {
    this->ConditionalControlLogic_ = s;
  }

  const Wrapper::ContextualComponent_sequence& Wrapper::
  ContextualComponent () const
  {
    return this->ContextualComponent_;
  }

  Wrapper::ContextualComponent_sequence& Wrapper::
  ContextualComponent ()
  {
    return this->ContextualComponent_;
  }

  void Wrapper::
  ContextualComponent (const ContextualComponent_sequence& s)
  {
    this->ContextualComponent_ = s;
  }

  const Wrapper::ControlLogic_sequence& Wrapper::
  ControlLogic () const
  {
    return this->ControlLogic_;
  }

  Wrapper::ControlLogic_sequence& Wrapper::
  ControlLogic ()
  {
    return this->ControlLogic_;
  }

  void Wrapper::
  ControlLogic (const ControlLogic_sequence& s)
  {
    this->ControlLogic_ = s;
  }

  const Wrapper::CorrespondenceTable_sequence& Wrapper::
  CorrespondenceTable () const
  {
    return this->CorrespondenceTable_;
  }

  Wrapper::CorrespondenceTable_sequence& Wrapper::
  CorrespondenceTable ()
  {
    return this->CorrespondenceTable_;
  }

  void Wrapper::
  CorrespondenceTable (const CorrespondenceTable_sequence& s)
  {
    this->CorrespondenceTable_ = s;
  }

  const Wrapper::Curator_sequence& Wrapper::
  Curator () const
  {
    return this->Curator_;
  }

  Wrapper::Curator_sequence& Wrapper::
  Curator ()
  {
    return this->Curator_;
  }

  void Wrapper::
  Curator (const Curator_sequence& s)
  {
    this->Curator_ = s;
  }

  const Wrapper::DataPoint_sequence& Wrapper::
  DataPoint () const
  {
    return this->DataPoint_;
  }

  Wrapper::DataPoint_sequence& Wrapper::
  DataPoint ()
  {
    return this->DataPoint_;
  }

  void Wrapper::
  DataPoint (const DataPoint_sequence& s)
  {
    this->DataPoint_ = s;
  }

  const Wrapper::DataPointPosition_sequence& Wrapper::
  DataPointPosition () const
  {
    return this->DataPointPosition_;
  }

  Wrapper::DataPointPosition_sequence& Wrapper::
  DataPointPosition ()
  {
    return this->DataPointPosition_;
  }

  void Wrapper::
  DataPointPosition (const DataPointPosition_sequence& s)
  {
    this->DataPointPosition_ = s;
  }

  const Wrapper::DataPointRelationship_sequence& Wrapper::
  DataPointRelationship () const
  {
    return this->DataPointRelationship_;
  }

  Wrapper::DataPointRelationship_sequence& Wrapper::
  DataPointRelationship ()
  {
    return this->DataPointRelationship_;
  }

  void Wrapper::
  DataPointRelationship (const DataPointRelationship_sequence& s)
  {
    this->DataPointRelationship_ = s;
  }

  const Wrapper::DataSet_sequence& Wrapper::
  DataSet () const
  {
    return this->DataSet_;
  }

  Wrapper::DataSet_sequence& Wrapper::
  DataSet ()
  {
    return this->DataSet_;
  }

  void Wrapper::
  DataSet (const DataSet_sequence& s)
  {
    this->DataSet_ = s;
  }

  const Wrapper::DataStore_sequence& Wrapper::
  DataStore () const
  {
    return this->DataStore_;
  }

  Wrapper::DataStore_sequence& Wrapper::
  DataStore ()
  {
    return this->DataStore_;
  }

  void Wrapper::
  DataStore (const DataStore_sequence& s)
  {
    this->DataStore_ = s;
  }

  const Wrapper::DataStructure_sequence& Wrapper::
  DataStructure () const
  {
    return this->DataStructure_;
  }

  Wrapper::DataStructure_sequence& Wrapper::
  DataStructure ()
  {
    return this->DataStructure_;
  }

  void Wrapper::
  DataStructure (const DataStructure_sequence& s)
  {
    this->DataStructure_ = s;
  }

  const Wrapper::DataStructureComponent_sequence& Wrapper::
  DataStructureComponent () const
  {
    return this->DataStructureComponent_;
  }

  Wrapper::DataStructureComponent_sequence& Wrapper::
  DataStructureComponent ()
  {
    return this->DataStructureComponent_;
  }

  void Wrapper::
  DataStructureComponent (const DataStructureComponent_sequence& s)
  {
    this->DataStructureComponent_ = s;
  }

  const Wrapper::Datum_sequence& Wrapper::
  Datum () const
  {
    return this->Datum_;
  }

  Wrapper::Datum_sequence& Wrapper::
  Datum ()
  {
    return this->Datum_;
  }

  void Wrapper::
  Datum (const Datum_sequence& s)
  {
    this->Datum_ = s;
  }

  const Wrapper::Descriptor_sequence& Wrapper::
  Descriptor () const
  {
    return this->Descriptor_;
  }

  Wrapper::Descriptor_sequence& Wrapper::
  Descriptor ()
  {
    return this->Descriptor_;
  }

  void Wrapper::
  Descriptor (const Descriptor_sequence& s)
  {
    this->Descriptor_ = s;
  }

  const Wrapper::DescriptorValueDomain_sequence& Wrapper::
  DescriptorValueDomain () const
  {
    return this->DescriptorValueDomain_;
  }

  Wrapper::DescriptorValueDomain_sequence& Wrapper::
  DescriptorValueDomain ()
  {
    return this->DescriptorValueDomain_;
  }

  void Wrapper::
  DescriptorValueDomain (const DescriptorValueDomain_sequence& s)
  {
    this->DescriptorValueDomain_ = s;
  }

  const Wrapper::DescriptorVariable_sequence& Wrapper::
  DescriptorVariable () const
  {
    return this->DescriptorVariable_;
  }

  Wrapper::DescriptorVariable_sequence& Wrapper::
  DescriptorVariable ()
  {
    return this->DescriptorVariable_;
  }

  void Wrapper::
  DescriptorVariable (const DescriptorVariable_sequence& s)
  {
    this->DescriptorVariable_ = s;
  }

  const Wrapper::DeterministicImperative_sequence& Wrapper::
  DeterministicImperative () const
  {
    return this->DeterministicImperative_;
  }

  Wrapper::DeterministicImperative_sequence& Wrapper::
  DeterministicImperative ()
  {
    return this->DeterministicImperative_;
  }

  void Wrapper::
  DeterministicImperative (const DeterministicImperative_sequence& s)
  {
    this->DeterministicImperative_ = s;
  }

  const Wrapper::DimensionComponent_sequence& Wrapper::
  DimensionComponent () const
  {
    return this->DimensionComponent_;
  }

  Wrapper::DimensionComponent_sequence& Wrapper::
  DimensionComponent ()
  {
    return this->DimensionComponent_;
  }

  void Wrapper::
  DimensionComponent (const DimensionComponent_sequence& s)
  {
    this->DimensionComponent_ = s;
  }

  const Wrapper::DimensionGroup_sequence& Wrapper::
  DimensionGroup () const
  {
    return this->DimensionGroup_;
  }

  Wrapper::DimensionGroup_sequence& Wrapper::
  DimensionGroup ()
  {
    return this->DimensionGroup_;
  }

  void Wrapper::
  DimensionGroup (const DimensionGroup_sequence& s)
  {
    this->DimensionGroup_ = s;
  }

  const Wrapper::DimensionalDataSet_sequence& Wrapper::
  DimensionalDataSet () const
  {
    return this->DimensionalDataSet_;
  }

  Wrapper::DimensionalDataSet_sequence& Wrapper::
  DimensionalDataSet ()
  {
    return this->DimensionalDataSet_;
  }

  void Wrapper::
  DimensionalDataSet (const DimensionalDataSet_sequence& s)
  {
    this->DimensionalDataSet_ = s;
  }

  const Wrapper::DimensionalDataStructure_sequence& Wrapper::
  DimensionalDataStructure () const
  {
    return this->DimensionalDataStructure_;
  }

  Wrapper::DimensionalDataStructure_sequence& Wrapper::
  DimensionalDataStructure ()
  {
    return this->DimensionalDataStructure_;
  }

  void Wrapper::
  DimensionalDataStructure (const DimensionalDataStructure_sequence& s)
  {
    this->DimensionalDataStructure_ = s;
  }

  const Wrapper::DimensionalKey_sequence& Wrapper::
  DimensionalKey () const
  {
    return this->DimensionalKey_;
  }

  Wrapper::DimensionalKey_sequence& Wrapper::
  DimensionalKey ()
  {
    return this->DimensionalKey_;
  }

  void Wrapper::
  DimensionalKey (const DimensionalKey_sequence& s)
  {
    this->DimensionalKey_ = s;
  }

  const Wrapper::DimensionalKeyDefinition_sequence& Wrapper::
  DimensionalKeyDefinition () const
  {
    return this->DimensionalKeyDefinition_;
  }

  Wrapper::DimensionalKeyDefinition_sequence& Wrapper::
  DimensionalKeyDefinition ()
  {
    return this->DimensionalKeyDefinition_;
  }

  void Wrapper::
  DimensionalKeyDefinition (const DimensionalKeyDefinition_sequence& s)
  {
    this->DimensionalKeyDefinition_ = s;
  }

  const Wrapper::DimensionalKeyDefinitionMember_sequence& Wrapper::
  DimensionalKeyDefinitionMember () const
  {
    return this->DimensionalKeyDefinitionMember_;
  }

  Wrapper::DimensionalKeyDefinitionMember_sequence& Wrapper::
  DimensionalKeyDefinitionMember ()
  {
    return this->DimensionalKeyDefinitionMember_;
  }

  void Wrapper::
  DimensionalKeyDefinitionMember (const DimensionalKeyDefinitionMember_sequence& s)
  {
    this->DimensionalKeyDefinitionMember_ = s;
  }

  const Wrapper::DimensionalKeyMember_sequence& Wrapper::
  DimensionalKeyMember () const
  {
    return this->DimensionalKeyMember_;
  }

  Wrapper::DimensionalKeyMember_sequence& Wrapper::
  DimensionalKeyMember ()
  {
    return this->DimensionalKeyMember_;
  }

  void Wrapper::
  DimensionalKeyMember (const DimensionalKeyMember_sequence& s)
  {
    this->DimensionalKeyMember_ = s;
  }

  const Wrapper::EnumerationDomain_sequence& Wrapper::
  EnumerationDomain () const
  {
    return this->EnumerationDomain_;
  }

  Wrapper::EnumerationDomain_sequence& Wrapper::
  EnumerationDomain ()
  {
    return this->EnumerationDomain_;
  }

  void Wrapper::
  EnumerationDomain (const EnumerationDomain_sequence& s)
  {
    this->EnumerationDomain_ = s;
  }

  const Wrapper::ForeignKey_sequence& Wrapper::
  ForeignKey () const
  {
    return this->ForeignKey_;
  }

  Wrapper::ForeignKey_sequence& Wrapper::
  ForeignKey ()
  {
    return this->ForeignKey_;
  }

  void Wrapper::
  ForeignKey (const ForeignKey_sequence& s)
  {
    this->ForeignKey_ = s;
  }

  const Wrapper::ForeignKeyComponent_sequence& Wrapper::
  ForeignKeyComponent () const
  {
    return this->ForeignKeyComponent_;
  }

  Wrapper::ForeignKeyComponent_sequence& Wrapper::
  ForeignKeyComponent ()
  {
    return this->ForeignKeyComponent_;
  }

  void Wrapper::
  ForeignKeyComponent (const ForeignKeyComponent_sequence& s)
  {
    this->ForeignKeyComponent_ = s;
  }

  const Wrapper::IdentifierComponent_sequence& Wrapper::
  IdentifierComponent () const
  {
    return this->IdentifierComponent_;
  }

  Wrapper::IdentifierComponent_sequence& Wrapper::
  IdentifierComponent ()
  {
    return this->IdentifierComponent_;
  }

  void Wrapper::
  IdentifierComponent (const IdentifierComponent_sequence& s)
  {
    this->IdentifierComponent_ = s;
  }

  const Wrapper::Individual_sequence& Wrapper::
  Individual () const
  {
    return this->Individual_;
  }

  Wrapper::Individual_sequence& Wrapper::
  Individual ()
  {
    return this->Individual_;
  }

  void Wrapper::
  Individual (const Individual_sequence& s)
  {
    this->Individual_ = s;
  }

  const Wrapper::InformationFlowDefinition_sequence& Wrapper::
  InformationFlowDefinition () const
  {
    return this->InformationFlowDefinition_;
  }

  Wrapper::InformationFlowDefinition_sequence& Wrapper::
  InformationFlowDefinition ()
  {
    return this->InformationFlowDefinition_;
  }

  void Wrapper::
  InformationFlowDefinition (const InformationFlowDefinition_sequence& s)
  {
    this->InformationFlowDefinition_ = s;
  }

  const Wrapper::InstanceKey_sequence& Wrapper::
  InstanceKey () const
  {
    return this->InstanceKey_;
  }

  Wrapper::InstanceKey_sequence& Wrapper::
  InstanceKey ()
  {
    return this->InstanceKey_;
  }

  void Wrapper::
  InstanceKey (const InstanceKey_sequence& s)
  {
    this->InstanceKey_ = s;
  }

  const Wrapper::InstanceValue_sequence& Wrapper::
  InstanceValue () const
  {
    return this->InstanceValue_;
  }

  Wrapper::InstanceValue_sequence& Wrapper::
  InstanceValue ()
  {
    return this->InstanceValue_;
  }

  void Wrapper::
  InstanceValue (const InstanceValue_sequence& s)
  {
    this->InstanceValue_ = s;
  }

  const Wrapper::InstanceVariable_sequence& Wrapper::
  InstanceVariable () const
  {
    return this->InstanceVariable_;
  }

  Wrapper::InstanceVariable_sequence& Wrapper::
  InstanceVariable ()
  {
    return this->InstanceVariable_;
  }

  void Wrapper::
  InstanceVariable (const InstanceVariable_sequence& s)
  {
    this->InstanceVariable_ = s;
  }

  const Wrapper::InstanceVariableMap_sequence& Wrapper::
  InstanceVariableMap () const
  {
    return this->InstanceVariableMap_;
  }

  Wrapper::InstanceVariableMap_sequence& Wrapper::
  InstanceVariableMap ()
  {
    return this->InstanceVariableMap_;
  }

  void Wrapper::
  InstanceVariableMap (const InstanceVariableMap_sequence& s)
  {
    this->InstanceVariableMap_ = s;
  }

  const Wrapper::Key_sequence& Wrapper::
  Key () const
  {
    return this->Key_;
  }

  Wrapper::Key_sequence& Wrapper::
  Key ()
  {
    return this->Key_;
  }

  void Wrapper::
  Key (const Key_sequence& s)
  {
    this->Key_ = s;
  }

  const Wrapper::KeyDefinition_sequence& Wrapper::
  KeyDefinition () const
  {
    return this->KeyDefinition_;
  }

  Wrapper::KeyDefinition_sequence& Wrapper::
  KeyDefinition ()
  {
    return this->KeyDefinition_;
  }

  void Wrapper::
  KeyDefinition (const KeyDefinition_sequence& s)
  {
    this->KeyDefinition_ = s;
  }

  const Wrapper::KeyDefinitionMember_sequence& Wrapper::
  KeyDefinitionMember () const
  {
    return this->KeyDefinitionMember_;
  }

  Wrapper::KeyDefinitionMember_sequence& Wrapper::
  KeyDefinitionMember ()
  {
    return this->KeyDefinitionMember_;
  }

  void Wrapper::
  KeyDefinitionMember (const KeyDefinitionMember_sequence& s)
  {
    this->KeyDefinitionMember_ = s;
  }

  const Wrapper::KeyMember_sequence& Wrapper::
  KeyMember () const
  {
    return this->KeyMember_;
  }

  Wrapper::KeyMember_sequence& Wrapper::
  KeyMember ()
  {
    return this->KeyMember_;
  }

  void Wrapper::
  KeyMember (const KeyMember_sequence& s)
  {
    this->KeyMember_ = s;
  }

  const Wrapper::KeyValueDataStore_sequence& Wrapper::
  KeyValueDataStore () const
  {
    return this->KeyValueDataStore_;
  }

  Wrapper::KeyValueDataStore_sequence& Wrapper::
  KeyValueDataStore ()
  {
    return this->KeyValueDataStore_;
  }

  void Wrapper::
  KeyValueDataStore (const KeyValueDataStore_sequence& s)
  {
    this->KeyValueDataStore_ = s;
  }

  const Wrapper::KeyValueStructure_sequence& Wrapper::
  KeyValueStructure () const
  {
    return this->KeyValueStructure_;
  }

  Wrapper::KeyValueStructure_sequence& Wrapper::
  KeyValueStructure ()
  {
    return this->KeyValueStructure_;
  }

  void Wrapper::
  KeyValueStructure (const KeyValueStructure_sequence& s)
  {
    this->KeyValueStructure_ = s;
  }

  const Wrapper::Level_sequence& Wrapper::
  Level () const
  {
    return this->Level_;
  }

  Wrapper::Level_sequence& Wrapper::
  Level ()
  {
    return this->Level_;
  }

  void Wrapper::
  Level (const Level_sequence& s)
  {
    this->Level_ = s;
  }

  const Wrapper::LevelStructure_sequence& Wrapper::
  LevelStructure () const
  {
    return this->LevelStructure_;
  }

  Wrapper::LevelStructure_sequence& Wrapper::
  LevelStructure ()
  {
    return this->LevelStructure_;
  }

  void Wrapper::
  LevelStructure (const LevelStructure_sequence& s)
  {
    this->LevelStructure_ = s;
  }

  const Wrapper::LogicalRecord_sequence& Wrapper::
  LogicalRecord () const
  {
    return this->LogicalRecord_;
  }

  Wrapper::LogicalRecord_sequence& Wrapper::
  LogicalRecord ()
  {
    return this->LogicalRecord_;
  }

  void Wrapper::
  LogicalRecord (const LogicalRecord_sequence& s)
  {
    this->LogicalRecord_ = s;
  }

  const Wrapper::LogicalRecordPosition_sequence& Wrapper::
  LogicalRecordPosition () const
  {
    return this->LogicalRecordPosition_;
  }

  Wrapper::LogicalRecordPosition_sequence& Wrapper::
  LogicalRecordPosition ()
  {
    return this->LogicalRecordPosition_;
  }

  void Wrapper::
  LogicalRecordPosition (const LogicalRecordPosition_sequence& s)
  {
    this->LogicalRecordPosition_ = s;
  }

  const Wrapper::LogicalRecordRelationStructure_sequence& Wrapper::
  LogicalRecordRelationStructure () const
  {
    return this->LogicalRecordRelationStructure_;
  }

  Wrapper::LogicalRecordRelationStructure_sequence& Wrapper::
  LogicalRecordRelationStructure ()
  {
    return this->LogicalRecordRelationStructure_;
  }

  void Wrapper::
  LogicalRecordRelationStructure (const LogicalRecordRelationStructure_sequence& s)
  {
    this->LogicalRecordRelationStructure_ = s;
  }

  const Wrapper::LogicalRecordRelationship_sequence& Wrapper::
  LogicalRecordRelationship () const
  {
    return this->LogicalRecordRelationship_;
  }

  Wrapper::LogicalRecordRelationship_sequence& Wrapper::
  LogicalRecordRelationship ()
  {
    return this->LogicalRecordRelationship_;
  }

  void Wrapper::
  LogicalRecordRelationship (const LogicalRecordRelationship_sequence& s)
  {
    this->LogicalRecordRelationship_ = s;
  }

  const Wrapper::LongDataSet_sequence& Wrapper::
  LongDataSet () const
  {
    return this->LongDataSet_;
  }

  Wrapper::LongDataSet_sequence& Wrapper::
  LongDataSet ()
  {
    return this->LongDataSet_;
  }

  void Wrapper::
  LongDataSet (const LongDataSet_sequence& s)
  {
    this->LongDataSet_ = s;
  }

  const Wrapper::LongDataStructure_sequence& Wrapper::
  LongDataStructure () const
  {
    return this->LongDataStructure_;
  }

  Wrapper::LongDataStructure_sequence& Wrapper::
  LongDataStructure ()
  {
    return this->LongDataStructure_;
  }

  void Wrapper::
  LongDataStructure (const LongDataStructure_sequence& s)
  {
    this->LongDataStructure_ = s;
  }

  const Wrapper::LongKey_sequence& Wrapper::
  LongKey () const
  {
    return this->LongKey_;
  }

  Wrapper::LongKey_sequence& Wrapper::
  LongKey ()
  {
    return this->LongKey_;
  }

  void Wrapper::
  LongKey (const LongKey_sequence& s)
  {
    this->LongKey_ = s;
  }

  const Wrapper::LongMainKeyMember_sequence& Wrapper::
  LongMainKeyMember () const
  {
    return this->LongMainKeyMember_;
  }

  Wrapper::LongMainKeyMember_sequence& Wrapper::
  LongMainKeyMember ()
  {
    return this->LongMainKeyMember_;
  }

  void Wrapper::
  LongMainKeyMember (const LongMainKeyMember_sequence& s)
  {
    this->LongMainKeyMember_ = s;
  }

  const Wrapper::Machine_sequence& Wrapper::
  Machine () const
  {
    return this->Machine_;
  }

  Wrapper::Machine_sequence& Wrapper::
  Machine ()
  {
    return this->Machine_;
  }

  void Wrapper::
  Machine (const Machine_sequence& s)
  {
    this->Machine_ = s;
  }

  const Wrapper::MainKeyMember_sequence& Wrapper::
  MainKeyMember () const
  {
    return this->MainKeyMember_;
  }

  Wrapper::MainKeyMember_sequence& Wrapper::
  MainKeyMember ()
  {
    return this->MainKeyMember_;
  }

  void Wrapper::
  MainKeyMember (const MainKeyMember_sequence& s)
  {
    this->MainKeyMember_ = s;
  }

  const Wrapper::MeasureComponent_sequence& Wrapper::
  MeasureComponent () const
  {
    return this->MeasureComponent_;
  }

  Wrapper::MeasureComponent_sequence& Wrapper::
  MeasureComponent ()
  {
    return this->MeasureComponent_;
  }

  void Wrapper::
  MeasureComponent (const MeasureComponent_sequence& s)
  {
    this->MeasureComponent_ = s;
  }

  const Wrapper::NonDeterministicDeclarative_sequence& Wrapper::
  NonDeterministicDeclarative () const
  {
    return this->NonDeterministicDeclarative_;
  }

  Wrapper::NonDeterministicDeclarative_sequence& Wrapper::
  NonDeterministicDeclarative ()
  {
    return this->NonDeterministicDeclarative_;
  }

  void Wrapper::
  NonDeterministicDeclarative (const NonDeterministicDeclarative_sequence& s)
  {
    this->NonDeterministicDeclarative_ = s;
  }

  const Wrapper::Notation_sequence& Wrapper::
  Notation () const
  {
    return this->Notation_;
  }

  Wrapper::Notation_sequence& Wrapper::
  Notation ()
  {
    return this->Notation_;
  }

  void Wrapper::
  Notation (const Notation_sequence& s)
  {
    this->Notation_ = s;
  }

  const Wrapper::Organization_sequence& Wrapper::
  Organization () const
  {
    return this->Organization_;
  }

  Wrapper::Organization_sequence& Wrapper::
  Organization ()
  {
    return this->Organization_;
  }

  void Wrapper::
  Organization (const Organization_sequence& s)
  {
    this->Organization_ = s;
  }

  const Wrapper::Parameter_sequence& Wrapper::
  Parameter () const
  {
    return this->Parameter_;
  }

  Wrapper::Parameter_sequence& Wrapper::
  Parameter ()
  {
    return this->Parameter_;
  }

  void Wrapper::
  Parameter (const Parameter_sequence& s)
  {
    this->Parameter_ = s;
  }

  const Wrapper::PhysicalDataSet_sequence& Wrapper::
  PhysicalDataSet () const
  {
    return this->PhysicalDataSet_;
  }

  Wrapper::PhysicalDataSet_sequence& Wrapper::
  PhysicalDataSet ()
  {
    return this->PhysicalDataSet_;
  }

  void Wrapper::
  PhysicalDataSet (const PhysicalDataSet_sequence& s)
  {
    this->PhysicalDataSet_ = s;
  }

  const Wrapper::PhysicalDataSetStructure_sequence& Wrapper::
  PhysicalDataSetStructure () const
  {
    return this->PhysicalDataSetStructure_;
  }

  Wrapper::PhysicalDataSetStructure_sequence& Wrapper::
  PhysicalDataSetStructure ()
  {
    return this->PhysicalDataSetStructure_;
  }

  void Wrapper::
  PhysicalDataSetStructure (const PhysicalDataSetStructure_sequence& s)
  {
    this->PhysicalDataSetStructure_ = s;
  }

  const Wrapper::PhysicalLayoutRelationStructure_sequence& Wrapper::
  PhysicalLayoutRelationStructure () const
  {
    return this->PhysicalLayoutRelationStructure_;
  }

  Wrapper::PhysicalLayoutRelationStructure_sequence& Wrapper::
  PhysicalLayoutRelationStructure ()
  {
    return this->PhysicalLayoutRelationStructure_;
  }

  void Wrapper::
  PhysicalLayoutRelationStructure (const PhysicalLayoutRelationStructure_sequence& s)
  {
    this->PhysicalLayoutRelationStructure_ = s;
  }

  const Wrapper::PhysicalRecordSegment_sequence& Wrapper::
  PhysicalRecordSegment () const
  {
    return this->PhysicalRecordSegment_;
  }

  Wrapper::PhysicalRecordSegment_sequence& Wrapper::
  PhysicalRecordSegment ()
  {
    return this->PhysicalRecordSegment_;
  }

  void Wrapper::
  PhysicalRecordSegment (const PhysicalRecordSegment_sequence& s)
  {
    this->PhysicalRecordSegment_ = s;
  }

  const Wrapper::PhysicalRecordSegmentPosition_sequence& Wrapper::
  PhysicalRecordSegmentPosition () const
  {
    return this->PhysicalRecordSegmentPosition_;
  }

  Wrapper::PhysicalRecordSegmentPosition_sequence& Wrapper::
  PhysicalRecordSegmentPosition ()
  {
    return this->PhysicalRecordSegmentPosition_;
  }

  void Wrapper::
  PhysicalRecordSegmentPosition (const PhysicalRecordSegmentPosition_sequence& s)
  {
    this->PhysicalRecordSegmentPosition_ = s;
  }

  const Wrapper::PhysicalRecordSegmentRelationship_sequence& Wrapper::
  PhysicalRecordSegmentRelationship () const
  {
    return this->PhysicalRecordSegmentRelationship_;
  }

  Wrapper::PhysicalRecordSegmentRelationship_sequence& Wrapper::
  PhysicalRecordSegmentRelationship ()
  {
    return this->PhysicalRecordSegmentRelationship_;
  }

  void Wrapper::
  PhysicalRecordSegmentRelationship (const PhysicalRecordSegmentRelationship_sequence& s)
  {
    this->PhysicalRecordSegmentRelationship_ = s;
  }

  const Wrapper::PhysicalRecordSegmentStructure_sequence& Wrapper::
  PhysicalRecordSegmentStructure () const
  {
    return this->PhysicalRecordSegmentStructure_;
  }

  Wrapper::PhysicalRecordSegmentStructure_sequence& Wrapper::
  PhysicalRecordSegmentStructure ()
  {
    return this->PhysicalRecordSegmentStructure_;
  }

  void Wrapper::
  PhysicalRecordSegmentStructure (const PhysicalRecordSegmentStructure_sequence& s)
  {
    this->PhysicalRecordSegmentStructure_ = s;
  }

  const Wrapper::PhysicalSegmentLayout_sequence& Wrapper::
  PhysicalSegmentLayout () const
  {
    return this->PhysicalSegmentLayout_;
  }

  Wrapper::PhysicalSegmentLayout_sequence& Wrapper::
  PhysicalSegmentLayout ()
  {
    return this->PhysicalSegmentLayout_;
  }

  void Wrapper::
  PhysicalSegmentLayout (const PhysicalSegmentLayout_sequence& s)
  {
    this->PhysicalSegmentLayout_ = s;
  }

  const Wrapper::PhysicalSegmentLocation_sequence& Wrapper::
  PhysicalSegmentLocation () const
  {
    return this->PhysicalSegmentLocation_;
  }

  Wrapper::PhysicalSegmentLocation_sequence& Wrapper::
  PhysicalSegmentLocation ()
  {
    return this->PhysicalSegmentLocation_;
  }

  void Wrapper::
  PhysicalSegmentLocation (const PhysicalSegmentLocation_sequence& s)
  {
    this->PhysicalSegmentLocation_ = s;
  }

  const Wrapper::Population_sequence& Wrapper::
  Population () const
  {
    return this->Population_;
  }

  Wrapper::Population_sequence& Wrapper::
  Population ()
  {
    return this->Population_;
  }

  void Wrapper::
  Population (const Population_sequence& s)
  {
    this->Population_ = s;
  }

  const Wrapper::PrimaryKey_sequence& Wrapper::
  PrimaryKey () const
  {
    return this->PrimaryKey_;
  }

  Wrapper::PrimaryKey_sequence& Wrapper::
  PrimaryKey ()
  {
    return this->PrimaryKey_;
  }

  void Wrapper::
  PrimaryKey (const PrimaryKey_sequence& s)
  {
    this->PrimaryKey_ = s;
  }

  const Wrapper::PrimaryKeyComponent_sequence& Wrapper::
  PrimaryKeyComponent () const
  {
    return this->PrimaryKeyComponent_;
  }

  Wrapper::PrimaryKeyComponent_sequence& Wrapper::
  PrimaryKeyComponent ()
  {
    return this->PrimaryKeyComponent_;
  }

  void Wrapper::
  PrimaryKeyComponent (const PrimaryKeyComponent_sequence& s)
  {
    this->PrimaryKeyComponent_ = s;
  }

  const Wrapper::ProcessingAgent_sequence& Wrapper::
  ProcessingAgent () const
  {
    return this->ProcessingAgent_;
  }

  Wrapper::ProcessingAgent_sequence& Wrapper::
  ProcessingAgent ()
  {
    return this->ProcessingAgent_;
  }

  void Wrapper::
  ProcessingAgent (const ProcessingAgent_sequence& s)
  {
    this->ProcessingAgent_ = s;
  }

  const Wrapper::ProductionEnvironment_sequence& Wrapper::
  ProductionEnvironment () const
  {
    return this->ProductionEnvironment_;
  }

  Wrapper::ProductionEnvironment_sequence& Wrapper::
  ProductionEnvironment ()
  {
    return this->ProductionEnvironment_;
  }

  void Wrapper::
  ProductionEnvironment (const ProductionEnvironment_sequence& s)
  {
    this->ProductionEnvironment_ = s;
  }

  const Wrapper::QualifiedMeasure_sequence& Wrapper::
  QualifiedMeasure () const
  {
    return this->QualifiedMeasure_;
  }

  Wrapper::QualifiedMeasure_sequence& Wrapper::
  QualifiedMeasure ()
  {
    return this->QualifiedMeasure_;
  }

  void Wrapper::
  QualifiedMeasure (const QualifiedMeasure_sequence& s)
  {
    this->QualifiedMeasure_ = s;
  }

  const Wrapper::RecordRelation_sequence& Wrapper::
  RecordRelation () const
  {
    return this->RecordRelation_;
  }

  Wrapper::RecordRelation_sequence& Wrapper::
  RecordRelation ()
  {
    return this->RecordRelation_;
  }

  void Wrapper::
  RecordRelation (const RecordRelation_sequence& s)
  {
    this->RecordRelation_ = s;
  }

  const Wrapper::ReferenceValue_sequence& Wrapper::
  ReferenceValue () const
  {
    return this->ReferenceValue_;
  }

  Wrapper::ReferenceValue_sequence& Wrapper::
  ReferenceValue ()
  {
    return this->ReferenceValue_;
  }

  void Wrapper::
  ReferenceValue (const ReferenceValue_sequence& s)
  {
    this->ReferenceValue_ = s;
  }

  const Wrapper::ReferenceValueDomain_sequence& Wrapper::
  ReferenceValueDomain () const
  {
    return this->ReferenceValueDomain_;
  }

  Wrapper::ReferenceValueDomain_sequence& Wrapper::
  ReferenceValueDomain ()
  {
    return this->ReferenceValueDomain_;
  }

  void Wrapper::
  ReferenceValueDomain (const ReferenceValueDomain_sequence& s)
  {
    this->ReferenceValueDomain_ = s;
  }

  const Wrapper::ReferenceVariable_sequence& Wrapper::
  ReferenceVariable () const
  {
    return this->ReferenceVariable_;
  }

  Wrapper::ReferenceVariable_sequence& Wrapper::
  ReferenceVariable ()
  {
    return this->ReferenceVariable_;
  }

  void Wrapper::
  ReferenceVariable (const ReferenceVariable_sequence& s)
  {
    this->ReferenceVariable_ = s;
  }

  const Wrapper::RepresentedVariable_sequence& Wrapper::
  RepresentedVariable () const
  {
    return this->RepresentedVariable_;
  }

  Wrapper::RepresentedVariable_sequence& Wrapper::
  RepresentedVariable ()
  {
    return this->RepresentedVariable_;
  }

  void Wrapper::
  RepresentedVariable (const RepresentedVariable_sequence& s)
  {
    this->RepresentedVariable_ = s;
  }

  const Wrapper::RevisableDatum_sequence& Wrapper::
  RevisableDatum () const
  {
    return this->RevisableDatum_;
  }

  Wrapper::RevisableDatum_sequence& Wrapper::
  RevisableDatum ()
  {
    return this->RevisableDatum_;
  }

  void Wrapper::
  RevisableDatum (const RevisableDatum_sequence& s)
  {
    this->RevisableDatum_ = s;
  }

  const Wrapper::Revision_sequence& Wrapper::
  Revision () const
  {
    return this->Revision_;
  }

  Wrapper::Revision_sequence& Wrapper::
  Revision ()
  {
    return this->Revision_;
  }

  void Wrapper::
  Revision (const Revision_sequence& s)
  {
    this->Revision_ = s;
  }

  const Wrapper::Rule_sequence& Wrapper::
  Rule () const
  {
    return this->Rule_;
  }

  Wrapper::Rule_sequence& Wrapper::
  Rule ()
  {
    return this->Rule_;
  }

  void Wrapper::
  Rule (const Rule_sequence& s)
  {
    this->Rule_ = s;
  }

  const Wrapper::RuleBasedScheduling_sequence& Wrapper::
  RuleBasedScheduling () const
  {
    return this->RuleBasedScheduling_;
  }

  Wrapper::RuleBasedScheduling_sequence& Wrapper::
  RuleBasedScheduling ()
  {
    return this->RuleBasedScheduling_;
  }

  void Wrapper::
  RuleBasedScheduling (const RuleBasedScheduling_sequence& s)
  {
    this->RuleBasedScheduling_ = s;
  }

  const Wrapper::RuleSet_sequence& Wrapper::
  RuleSet () const
  {
    return this->RuleSet_;
  }

  Wrapper::RuleSet_sequence& Wrapper::
  RuleSet ()
  {
    return this->RuleSet_;
  }

  void Wrapper::
  RuleSet (const RuleSet_sequence& s)
  {
    this->RuleSet_ = s;
  }

  const Wrapper::ScopedMeasure_sequence& Wrapper::
  ScopedMeasure () const
  {
    return this->ScopedMeasure_;
  }

  Wrapper::ScopedMeasure_sequence& Wrapper::
  ScopedMeasure ()
  {
    return this->ScopedMeasure_;
  }

  void Wrapper::
  ScopedMeasure (const ScopedMeasure_sequence& s)
  {
    this->ScopedMeasure_ = s;
  }

  const Wrapper::SegmentByText_sequence& Wrapper::
  SegmentByText () const
  {
    return this->SegmentByText_;
  }

  Wrapper::SegmentByText_sequence& Wrapper::
  SegmentByText ()
  {
    return this->SegmentByText_;
  }

  void Wrapper::
  SegmentByText (const SegmentByText_sequence& s)
  {
    this->SegmentByText_ = s;
  }

  const Wrapper::SentinelConceptualDomain_sequence& Wrapper::
  SentinelConceptualDomain () const
  {
    return this->SentinelConceptualDomain_;
  }

  Wrapper::SentinelConceptualDomain_sequence& Wrapper::
  SentinelConceptualDomain ()
  {
    return this->SentinelConceptualDomain_;
  }

  void Wrapper::
  SentinelConceptualDomain (const SentinelConceptualDomain_sequence& s)
  {
    this->SentinelConceptualDomain_ = s;
  }

  const Wrapper::SentinelValueDomain_sequence& Wrapper::
  SentinelValueDomain () const
  {
    return this->SentinelValueDomain_;
  }

  Wrapper::SentinelValueDomain_sequence& Wrapper::
  SentinelValueDomain ()
  {
    return this->SentinelValueDomain_;
  }

  void Wrapper::
  SentinelValueDomain (const SentinelValueDomain_sequence& s)
  {
    this->SentinelValueDomain_ = s;
  }

  const Wrapper::Sequence_sequence& Wrapper::
  Sequence () const
  {
    return this->Sequence_;
  }

  Wrapper::Sequence_sequence& Wrapper::
  Sequence ()
  {
    return this->Sequence_;
  }

  void Wrapper::
  Sequence (const Sequence_sequence& s)
  {
    this->Sequence_ = s;
  }

  const Wrapper::SequencePosition_sequence& Wrapper::
  SequencePosition () const
  {
    return this->SequencePosition_;
  }

  Wrapper::SequencePosition_sequence& Wrapper::
  SequencePosition ()
  {
    return this->SequencePosition_;
  }

  void Wrapper::
  SequencePosition (const SequencePosition_sequence& s)
  {
    this->SequencePosition_ = s;
  }

  const Wrapper::Service_sequence& Wrapper::
  Service () const
  {
    return this->Service_;
  }

  Wrapper::Service_sequence& Wrapper::
  Service ()
  {
    return this->Service_;
  }

  void Wrapper::
  Service (const Service_sequence& s)
  {
    this->Service_ = s;
  }

  const Wrapper::StatisticalClassification_sequence& Wrapper::
  StatisticalClassification () const
  {
    return this->StatisticalClassification_;
  }

  Wrapper::StatisticalClassification_sequence& Wrapper::
  StatisticalClassification ()
  {
    return this->StatisticalClassification_;
  }

  void Wrapper::
  StatisticalClassification (const StatisticalClassification_sequence& s)
  {
    this->StatisticalClassification_ = s;
  }

  const Wrapper::StatisticalClassificationRelationship_sequence& Wrapper::
  StatisticalClassificationRelationship () const
  {
    return this->StatisticalClassificationRelationship_;
  }

  Wrapper::StatisticalClassificationRelationship_sequence& Wrapper::
  StatisticalClassificationRelationship ()
  {
    return this->StatisticalClassificationRelationship_;
  }

  void Wrapper::
  StatisticalClassificationRelationship (const StatisticalClassificationRelationship_sequence& s)
  {
    this->StatisticalClassificationRelationship_ = s;
  }

  const Wrapper::Step_sequence& Wrapper::
  Step () const
  {
    return this->Step_;
  }

  Wrapper::Step_sequence& Wrapper::
  Step ()
  {
    return this->Step_;
  }

  void Wrapper::
  Step (const Step_sequence& s)
  {
    this->Step_ = s;
  }

  const Wrapper::SubstantiveConceptualDomain_sequence& Wrapper::
  SubstantiveConceptualDomain () const
  {
    return this->SubstantiveConceptualDomain_;
  }

  Wrapper::SubstantiveConceptualDomain_sequence& Wrapper::
  SubstantiveConceptualDomain ()
  {
    return this->SubstantiveConceptualDomain_;
  }

  void Wrapper::
  SubstantiveConceptualDomain (const SubstantiveConceptualDomain_sequence& s)
  {
    this->SubstantiveConceptualDomain_ = s;
  }

  const Wrapper::SubstantiveValueDomain_sequence& Wrapper::
  SubstantiveValueDomain () const
  {
    return this->SubstantiveValueDomain_;
  }

  Wrapper::SubstantiveValueDomain_sequence& Wrapper::
  SubstantiveValueDomain ()
  {
    return this->SubstantiveValueDomain_;
  }

  void Wrapper::
  SubstantiveValueDomain (const SubstantiveValueDomain_sequence& s)
  {
    this->SubstantiveValueDomain_ = s;
  }

  const Wrapper::SyntheticIdComponent_sequence& Wrapper::
  SyntheticIdComponent () const
  {
    return this->SyntheticIdComponent_;
  }

  Wrapper::SyntheticIdComponent_sequence& Wrapper::
  SyntheticIdComponent ()
  {
    return this->SyntheticIdComponent_;
  }

  void Wrapper::
  SyntheticIdComponent (const SyntheticIdComponent_sequence& s)
  {
    this->SyntheticIdComponent_ = s;
  }

  const Wrapper::TemporalConstraints_sequence& Wrapper::
  TemporalConstraints () const
  {
    return this->TemporalConstraints_;
  }

  Wrapper::TemporalConstraints_sequence& Wrapper::
  TemporalConstraints ()
  {
    return this->TemporalConstraints_;
  }

  void Wrapper::
  TemporalConstraints (const TemporalConstraints_sequence& s)
  {
    this->TemporalConstraints_ = s;
  }

  const Wrapper::TemporalControlConstruct_sequence& Wrapper::
  TemporalControlConstruct () const
  {
    return this->TemporalControlConstruct_;
  }

  Wrapper::TemporalControlConstruct_sequence& Wrapper::
  TemporalControlConstruct ()
  {
    return this->TemporalControlConstruct_;
  }

  void Wrapper::
  TemporalControlConstruct (const TemporalControlConstruct_sequence& s)
  {
    this->TemporalControlConstruct_ = s;
  }

  const Wrapper::Unit_sequence& Wrapper::
  Unit () const
  {
    return this->Unit_;
  }

  Wrapper::Unit_sequence& Wrapper::
  Unit ()
  {
    return this->Unit_;
  }

  void Wrapper::
  Unit (const Unit_sequence& s)
  {
    this->Unit_ = s;
  }

  const Wrapper::UnitSegmentLayout_sequence& Wrapper::
  UnitSegmentLayout () const
  {
    return this->UnitSegmentLayout_;
  }

  Wrapper::UnitSegmentLayout_sequence& Wrapper::
  UnitSegmentLayout ()
  {
    return this->UnitSegmentLayout_;
  }

  void Wrapper::
  UnitSegmentLayout (const UnitSegmentLayout_sequence& s)
  {
    this->UnitSegmentLayout_ = s;
  }

  const Wrapper::UnitType_sequence& Wrapper::
  UnitType () const
  {
    return this->UnitType_;
  }

  Wrapper::UnitType_sequence& Wrapper::
  UnitType ()
  {
    return this->UnitType_;
  }

  void Wrapper::
  UnitType (const UnitType_sequence& s)
  {
    this->UnitType_ = s;
  }

  const Wrapper::Universe_sequence& Wrapper::
  Universe () const
  {
    return this->Universe_;
  }

  Wrapper::Universe_sequence& Wrapper::
  Universe ()
  {
    return this->Universe_;
  }

  void Wrapper::
  Universe (const Universe_sequence& s)
  {
    this->Universe_ = s;
  }

  const Wrapper::ValueAndConceptDescription_sequence& Wrapper::
  ValueAndConceptDescription () const
  {
    return this->ValueAndConceptDescription_;
  }

  Wrapper::ValueAndConceptDescription_sequence& Wrapper::
  ValueAndConceptDescription ()
  {
    return this->ValueAndConceptDescription_;
  }

  void Wrapper::
  ValueAndConceptDescription (const ValueAndConceptDescription_sequence& s)
  {
    this->ValueAndConceptDescription_ = s;
  }

  const Wrapper::ValueDomain_sequence& Wrapper::
  ValueDomain () const
  {
    return this->ValueDomain_;
  }

  Wrapper::ValueDomain_sequence& Wrapper::
  ValueDomain ()
  {
    return this->ValueDomain_;
  }

  void Wrapper::
  ValueDomain (const ValueDomain_sequence& s)
  {
    this->ValueDomain_ = s;
  }

  const Wrapper::ValueMapping_sequence& Wrapper::
  ValueMapping () const
  {
    return this->ValueMapping_;
  }

  Wrapper::ValueMapping_sequence& Wrapper::
  ValueMapping ()
  {
    return this->ValueMapping_;
  }

  void Wrapper::
  ValueMapping (const ValueMapping_sequence& s)
  {
    this->ValueMapping_ = s;
  }

  const Wrapper::ValueMappingPosition_sequence& Wrapper::
  ValueMappingPosition () const
  {
    return this->ValueMappingPosition_;
  }

  Wrapper::ValueMappingPosition_sequence& Wrapper::
  ValueMappingPosition ()
  {
    return this->ValueMappingPosition_;
  }

  void Wrapper::
  ValueMappingPosition (const ValueMappingPosition_sequence& s)
  {
    this->ValueMappingPosition_ = s;
  }

  const Wrapper::ValueMappingRelationship_sequence& Wrapper::
  ValueMappingRelationship () const
  {
    return this->ValueMappingRelationship_;
  }

  Wrapper::ValueMappingRelationship_sequence& Wrapper::
  ValueMappingRelationship ()
  {
    return this->ValueMappingRelationship_;
  }

  void Wrapper::
  ValueMappingRelationship (const ValueMappingRelationship_sequence& s)
  {
    this->ValueMappingRelationship_ = s;
  }

  const Wrapper::VariableCollection_sequence& Wrapper::
  VariableCollection () const
  {
    return this->VariableCollection_;
  }

  Wrapper::VariableCollection_sequence& Wrapper::
  VariableCollection ()
  {
    return this->VariableCollection_;
  }

  void Wrapper::
  VariableCollection (const VariableCollection_sequence& s)
  {
    this->VariableCollection_ = s;
  }

  const Wrapper::VariableDescriptorComponent_sequence& Wrapper::
  VariableDescriptorComponent () const
  {
    return this->VariableDescriptorComponent_;
  }

  Wrapper::VariableDescriptorComponent_sequence& Wrapper::
  VariableDescriptorComponent ()
  {
    return this->VariableDescriptorComponent_;
  }

  void Wrapper::
  VariableDescriptorComponent (const VariableDescriptorComponent_sequence& s)
  {
    this->VariableDescriptorComponent_ = s;
  }

  const Wrapper::VariablePosition_sequence& Wrapper::
  VariablePosition () const
  {
    return this->VariablePosition_;
  }

  Wrapper::VariablePosition_sequence& Wrapper::
  VariablePosition ()
  {
    return this->VariablePosition_;
  }

  void Wrapper::
  VariablePosition (const VariablePosition_sequence& s)
  {
    this->VariablePosition_ = s;
  }

  const Wrapper::VariableRelationship_sequence& Wrapper::
  VariableRelationship () const
  {
    return this->VariableRelationship_;
  }

  Wrapper::VariableRelationship_sequence& Wrapper::
  VariableRelationship ()
  {
    return this->VariableRelationship_;
  }

  void Wrapper::
  VariableRelationship (const VariableRelationship_sequence& s)
  {
    this->VariableRelationship_ = s;
  }

  const Wrapper::VariableStructure_sequence& Wrapper::
  VariableStructure () const
  {
    return this->VariableStructure_;
  }

  Wrapper::VariableStructure_sequence& Wrapper::
  VariableStructure ()
  {
    return this->VariableStructure_;
  }

  void Wrapper::
  VariableStructure (const VariableStructure_sequence& s)
  {
    this->VariableStructure_ = s;
  }

  const Wrapper::VariableValueComponent_sequence& Wrapper::
  VariableValueComponent () const
  {
    return this->VariableValueComponent_;
  }

  Wrapper::VariableValueComponent_sequence& Wrapper::
  VariableValueComponent ()
  {
    return this->VariableValueComponent_;
  }

  void Wrapper::
  VariableValueComponent (const VariableValueComponent_sequence& s)
  {
    this->VariableValueComponent_ = s;
  }

  const Wrapper::WideDataSet_sequence& Wrapper::
  WideDataSet () const
  {
    return this->WideDataSet_;
  }

  Wrapper::WideDataSet_sequence& Wrapper::
  WideDataSet ()
  {
    return this->WideDataSet_;
  }

  void Wrapper::
  WideDataSet (const WideDataSet_sequence& s)
  {
    this->WideDataSet_ = s;
  }

  const Wrapper::WideDataStructure_sequence& Wrapper::
  WideDataStructure () const
  {
    return this->WideDataStructure_;
  }

  Wrapper::WideDataStructure_sequence& Wrapper::
  WideDataStructure ()
  {
    return this->WideDataStructure_;
  }

  void Wrapper::
  WideDataStructure (const WideDataStructure_sequence& s)
  {
    this->WideDataStructure_ = s;
  }

  const Wrapper::WideKey_sequence& Wrapper::
  WideKey () const
  {
    return this->WideKey_;
  }

  Wrapper::WideKey_sequence& Wrapper::
  WideKey ()
  {
    return this->WideKey_;
  }

  void Wrapper::
  WideKey (const WideKey_sequence& s)
  {
    this->WideKey_ = s;
  }

  const Wrapper::WideKeyMember_sequence& Wrapper::
  WideKeyMember () const
  {
    return this->WideKeyMember_;
  }

  Wrapper::WideKeyMember_sequence& Wrapper::
  WideKeyMember ()
  {
    return this->WideKeyMember_;
  }

  void Wrapper::
  WideKeyMember (const WideKeyMember_sequence& s)
  {
    this->WideKeyMember_ = s;
  }


  // Activity
  //

  const Activity::definition_optional& Activity::
  definition () const
  {
    return this->definition_;
  }

  Activity::definition_optional& Activity::
  definition ()
  {
    return this->definition_;
  }

  void Activity::
  definition (const definition_type& x)
  {
    this->definition_.set (x);
  }

  void Activity::
  definition (const definition_optional& x)
  {
    this->definition_ = x;
  }

  void Activity::
  definition (::std::unique_ptr< definition_type > x)
  {
    this->definition_.set (std::move (x));
  }

  const Activity::description_optional& Activity::
  description () const
  {
    return this->description_;
  }

  Activity::description_optional& Activity::
  description ()
  {
    return this->description_;
  }

  void Activity::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void Activity::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void Activity::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }

  const Activity::displayLabel_sequence& Activity::
  displayLabel () const
  {
    return this->displayLabel_;
  }

  Activity::displayLabel_sequence& Activity::
  displayLabel ()
  {
    return this->displayLabel_;
  }

  void Activity::
  displayLabel (const displayLabel_sequence& s)
  {
    this->displayLabel_ = s;
  }

  const Activity::entityProduced_sequence& Activity::
  entityProduced () const
  {
    return this->entityProduced_;
  }

  Activity::entityProduced_sequence& Activity::
  entityProduced ()
  {
    return this->entityProduced_;
  }

  void Activity::
  entityProduced (const entityProduced_sequence& s)
  {
    this->entityProduced_ = s;
  }

  const Activity::entityUsed_sequence& Activity::
  entityUsed () const
  {
    return this->entityUsed_;
  }

  Activity::entityUsed_sequence& Activity::
  entityUsed ()
  {
    return this->entityUsed_;
  }

  void Activity::
  entityUsed (const entityUsed_sequence& s)
  {
    this->entityUsed_ = s;
  }

  const Activity::identifier_optional& Activity::
  identifier () const
  {
    return this->identifier_;
  }

  Activity::identifier_optional& Activity::
  identifier ()
  {
    return this->identifier_;
  }

  void Activity::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void Activity::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void Activity::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const Activity::name_sequence& Activity::
  name () const
  {
    return this->name_;
  }

  Activity::name_sequence& Activity::
  name ()
  {
    return this->name_;
  }

  void Activity::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const Activity::standardModelMapping_sequence& Activity::
  standardModelMapping () const
  {
    return this->standardModelMapping_;
  }

  Activity::standardModelMapping_sequence& Activity::
  standardModelMapping ()
  {
    return this->standardModelMapping_;
  }

  void Activity::
  standardModelMapping (const standardModelMapping_sequence& s)
  {
    this->standardModelMapping_ = s;
  }

  const Activity::Activity_hasInternal_ControlLogic_sequence& Activity::
  Activity_hasInternal_ControlLogic () const
  {
    return this->Activity_hasInternal_ControlLogic_;
  }

  Activity::Activity_hasInternal_ControlLogic_sequence& Activity::
  Activity_hasInternal_ControlLogic ()
  {
    return this->Activity_hasInternal_ControlLogic_;
  }

  void Activity::
  Activity_hasInternal_ControlLogic (const Activity_hasInternal_ControlLogic_sequence& s)
  {
    this->Activity_hasInternal_ControlLogic_ = s;
  }

  const Activity::Activity_hasSubActivity_Activity_sequence& Activity::
  Activity_hasSubActivity_Activity () const
  {
    return this->Activity_hasSubActivity_Activity_;
  }

  Activity::Activity_hasSubActivity_Activity_sequence& Activity::
  Activity_hasSubActivity_Activity ()
  {
    return this->Activity_hasSubActivity_Activity_;
  }

  void Activity::
  Activity_hasSubActivity_Activity (const Activity_hasSubActivity_Activity_sequence& s)
  {
    this->Activity_hasSubActivity_Activity_ = s;
  }

  const Activity::Activity_has_Step_sequence& Activity::
  Activity_has_Step () const
  {
    return this->Activity_has_Step_;
  }

  Activity::Activity_has_Step_sequence& Activity::
  Activity_has_Step ()
  {
    return this->Activity_has_Step_;
  }

  void Activity::
  Activity_has_Step (const Activity_has_Step_sequence& s)
  {
    this->Activity_has_Step_ = s;
  }


  // Agent
  //

  const Agent::catalogDetails_optional& Agent::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  Agent::catalogDetails_optional& Agent::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void Agent::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void Agent::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void Agent::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const Agent::identifier_optional& Agent::
  identifier () const
  {
    return this->identifier_;
  }

  Agent::identifier_optional& Agent::
  identifier ()
  {
    return this->identifier_;
  }

  void Agent::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void Agent::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void Agent::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const Agent::image_sequence& Agent::
  image () const
  {
    return this->image_;
  }

  Agent::image_sequence& Agent::
  image ()
  {
    return this->image_;
  }

  void Agent::
  image (const image_sequence& s)
  {
    this->image_ = s;
  }

  const Agent::purpose_optional& Agent::
  purpose () const
  {
    return this->purpose_;
  }

  Agent::purpose_optional& Agent::
  purpose ()
  {
    return this->purpose_;
  }

  void Agent::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void Agent::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void Agent::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }


  // AgentListing
  //

  const AgentListing::allowsDuplicates_type& AgentListing::
  allowsDuplicates () const
  {
    return this->allowsDuplicates_.get ();
  }

  AgentListing::allowsDuplicates_type& AgentListing::
  allowsDuplicates ()
  {
    return this->allowsDuplicates_.get ();
  }

  void AgentListing::
  allowsDuplicates (const allowsDuplicates_type& x)
  {
    this->allowsDuplicates_.set (x);
  }

  const AgentListing::identifier_optional& AgentListing::
  identifier () const
  {
    return this->identifier_;
  }

  AgentListing::identifier_optional& AgentListing::
  identifier ()
  {
    return this->identifier_;
  }

  void AgentListing::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void AgentListing::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void AgentListing::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const AgentListing::name_sequence& AgentListing::
  name () const
  {
    return this->name_;
  }

  AgentListing::name_sequence& AgentListing::
  name ()
  {
    return this->name_;
  }

  void AgentListing::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const AgentListing::purpose_optional& AgentListing::
  purpose () const
  {
    return this->purpose_;
  }

  AgentListing::purpose_optional& AgentListing::
  purpose ()
  {
    return this->purpose_;
  }

  void AgentListing::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void AgentListing::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void AgentListing::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const AgentListing::AgentListing_isDefinedBy_Concept_sequence& AgentListing::
  AgentListing_isDefinedBy_Concept () const
  {
    return this->AgentListing_isDefinedBy_Concept_;
  }

  AgentListing::AgentListing_isDefinedBy_Concept_sequence& AgentListing::
  AgentListing_isDefinedBy_Concept ()
  {
    return this->AgentListing_isDefinedBy_Concept_;
  }

  void AgentListing::
  AgentListing_isDefinedBy_Concept (const AgentListing_isDefinedBy_Concept_sequence& s)
  {
    this->AgentListing_isDefinedBy_Concept_ = s;
  }

  const AgentListing::AgentListing_isMaintainedBy_Agent_optional& AgentListing::
  AgentListing_isMaintainedBy_Agent () const
  {
    return this->AgentListing_isMaintainedBy_Agent_;
  }

  AgentListing::AgentListing_isMaintainedBy_Agent_optional& AgentListing::
  AgentListing_isMaintainedBy_Agent ()
  {
    return this->AgentListing_isMaintainedBy_Agent_;
  }

  void AgentListing::
  AgentListing_isMaintainedBy_Agent (const AgentListing_isMaintainedBy_Agent_type& x)
  {
    this->AgentListing_isMaintainedBy_Agent_.set (x);
  }

  void AgentListing::
  AgentListing_isMaintainedBy_Agent (const AgentListing_isMaintainedBy_Agent_optional& x)
  {
    this->AgentListing_isMaintainedBy_Agent_ = x;
  }

  void AgentListing::
  AgentListing_isMaintainedBy_Agent (::std::unique_ptr< AgentListing_isMaintainedBy_Agent_type > x)
  {
    this->AgentListing_isMaintainedBy_Agent_.set (std::move (x));
  }

  const AgentListing::AgentListing_has_AgentPosition_sequence& AgentListing::
  AgentListing_has_AgentPosition () const
  {
    return this->AgentListing_has_AgentPosition_;
  }

  AgentListing::AgentListing_has_AgentPosition_sequence& AgentListing::
  AgentListing_has_AgentPosition ()
  {
    return this->AgentListing_has_AgentPosition_;
  }

  void AgentListing::
  AgentListing_has_AgentPosition (const AgentListing_has_AgentPosition_sequence& s)
  {
    this->AgentListing_has_AgentPosition_ = s;
  }

  const AgentListing::AgentListing_has_Agent_sequence& AgentListing::
  AgentListing_has_Agent () const
  {
    return this->AgentListing_has_Agent_;
  }

  AgentListing::AgentListing_has_Agent_sequence& AgentListing::
  AgentListing_has_Agent ()
  {
    return this->AgentListing_has_Agent_;
  }

  void AgentListing::
  AgentListing_has_Agent (const AgentListing_has_Agent_sequence& s)
  {
    this->AgentListing_has_Agent_ = s;
  }


  // AgentPosition
  //

  const AgentPosition::identifier_optional& AgentPosition::
  identifier () const
  {
    return this->identifier_;
  }

  AgentPosition::identifier_optional& AgentPosition::
  identifier ()
  {
    return this->identifier_;
  }

  void AgentPosition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void AgentPosition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void AgentPosition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const AgentPosition::value_type& AgentPosition::
  value () const
  {
    return this->value_.get ();
  }

  AgentPosition::value_type& AgentPosition::
  value ()
  {
    return this->value_.get ();
  }

  void AgentPosition::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  const AgentPosition::AgentPosition_indexes_Agent_optional& AgentPosition::
  AgentPosition_indexes_Agent () const
  {
    return this->AgentPosition_indexes_Agent_;
  }

  AgentPosition::AgentPosition_indexes_Agent_optional& AgentPosition::
  AgentPosition_indexes_Agent ()
  {
    return this->AgentPosition_indexes_Agent_;
  }

  void AgentPosition::
  AgentPosition_indexes_Agent (const AgentPosition_indexes_Agent_type& x)
  {
    this->AgentPosition_indexes_Agent_.set (x);
  }

  void AgentPosition::
  AgentPosition_indexes_Agent (const AgentPosition_indexes_Agent_optional& x)
  {
    this->AgentPosition_indexes_Agent_ = x;
  }

  void AgentPosition::
  AgentPosition_indexes_Agent (::std::unique_ptr< AgentPosition_indexes_Agent_type > x)
  {
    this->AgentPosition_indexes_Agent_.set (std::move (x));
  }


  // AgentRelationship
  //

  const AgentRelationship::effectiveDates_optional& AgentRelationship::
  effectiveDates () const
  {
    return this->effectiveDates_;
  }

  AgentRelationship::effectiveDates_optional& AgentRelationship::
  effectiveDates ()
  {
    return this->effectiveDates_;
  }

  void AgentRelationship::
  effectiveDates (const effectiveDates_type& x)
  {
    this->effectiveDates_.set (x);
  }

  void AgentRelationship::
  effectiveDates (const effectiveDates_optional& x)
  {
    this->effectiveDates_ = x;
  }

  void AgentRelationship::
  effectiveDates (::std::unique_ptr< effectiveDates_type > x)
  {
    this->effectiveDates_.set (std::move (x));
  }

  const AgentRelationship::identifier_optional& AgentRelationship::
  identifier () const
  {
    return this->identifier_;
  }

  AgentRelationship::identifier_optional& AgentRelationship::
  identifier ()
  {
    return this->identifier_;
  }

  void AgentRelationship::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void AgentRelationship::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void AgentRelationship::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const AgentRelationship::semantics_optional& AgentRelationship::
  semantics () const
  {
    return this->semantics_;
  }

  AgentRelationship::semantics_optional& AgentRelationship::
  semantics ()
  {
    return this->semantics_;
  }

  void AgentRelationship::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void AgentRelationship::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void AgentRelationship::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const AgentRelationship::AgentRelationship_hasSource_Agent_type& AgentRelationship::
  AgentRelationship_hasSource_Agent () const
  {
    return this->AgentRelationship_hasSource_Agent_.get ();
  }

  AgentRelationship::AgentRelationship_hasSource_Agent_type& AgentRelationship::
  AgentRelationship_hasSource_Agent ()
  {
    return this->AgentRelationship_hasSource_Agent_.get ();
  }

  void AgentRelationship::
  AgentRelationship_hasSource_Agent (const AgentRelationship_hasSource_Agent_type& x)
  {
    this->AgentRelationship_hasSource_Agent_.set (x);
  }

  void AgentRelationship::
  AgentRelationship_hasSource_Agent (::std::unique_ptr< AgentRelationship_hasSource_Agent_type > x)
  {
    this->AgentRelationship_hasSource_Agent_.set (std::move (x));
  }

  const AgentRelationship::AgentRelationship_hasTarget_Agent_type& AgentRelationship::
  AgentRelationship_hasTarget_Agent () const
  {
    return this->AgentRelationship_hasTarget_Agent_.get ();
  }

  AgentRelationship::AgentRelationship_hasTarget_Agent_type& AgentRelationship::
  AgentRelationship_hasTarget_Agent ()
  {
    return this->AgentRelationship_hasTarget_Agent_.get ();
  }

  void AgentRelationship::
  AgentRelationship_hasTarget_Agent (const AgentRelationship_hasTarget_Agent_type& x)
  {
    this->AgentRelationship_hasTarget_Agent_.set (x);
  }

  void AgentRelationship::
  AgentRelationship_hasTarget_Agent (::std::unique_ptr< AgentRelationship_hasTarget_Agent_type > x)
  {
    this->AgentRelationship_hasTarget_Agent_.set (std::move (x));
  }


  // AgentStructure
  //

  const AgentStructure::effectiveDates_optional& AgentStructure::
  effectiveDates () const
  {
    return this->effectiveDates_;
  }

  AgentStructure::effectiveDates_optional& AgentStructure::
  effectiveDates ()
  {
    return this->effectiveDates_;
  }

  void AgentStructure::
  effectiveDates (const effectiveDates_type& x)
  {
    this->effectiveDates_.set (x);
  }

  void AgentStructure::
  effectiveDates (const effectiveDates_optional& x)
  {
    this->effectiveDates_ = x;
  }

  void AgentStructure::
  effectiveDates (::std::unique_ptr< effectiveDates_type > x)
  {
    this->effectiveDates_.set (std::move (x));
  }

  const AgentStructure::identifier_optional& AgentStructure::
  identifier () const
  {
    return this->identifier_;
  }

  AgentStructure::identifier_optional& AgentStructure::
  identifier ()
  {
    return this->identifier_;
  }

  void AgentStructure::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void AgentStructure::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void AgentStructure::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const AgentStructure::name_sequence& AgentStructure::
  name () const
  {
    return this->name_;
  }

  AgentStructure::name_sequence& AgentStructure::
  name ()
  {
    return this->name_;
  }

  void AgentStructure::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const AgentStructure::privacy_optional& AgentStructure::
  privacy () const
  {
    return this->privacy_;
  }

  AgentStructure::privacy_optional& AgentStructure::
  privacy ()
  {
    return this->privacy_;
  }

  void AgentStructure::
  privacy (const privacy_type& x)
  {
    this->privacy_.set (x);
  }

  void AgentStructure::
  privacy (const privacy_optional& x)
  {
    this->privacy_ = x;
  }

  void AgentStructure::
  privacy (::std::unique_ptr< privacy_type > x)
  {
    this->privacy_.set (std::move (x));
  }

  const AgentStructure::purpose_optional& AgentStructure::
  purpose () const
  {
    return this->purpose_;
  }

  AgentStructure::purpose_optional& AgentStructure::
  purpose ()
  {
    return this->purpose_;
  }

  void AgentStructure::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void AgentStructure::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void AgentStructure::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const AgentStructure::semantics_optional& AgentStructure::
  semantics () const
  {
    return this->semantics_;
  }

  AgentStructure::semantics_optional& AgentStructure::
  semantics ()
  {
    return this->semantics_;
  }

  void AgentStructure::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void AgentStructure::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void AgentStructure::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const AgentStructure::specification_optional& AgentStructure::
  specification () const
  {
    return this->specification_;
  }

  AgentStructure::specification_optional& AgentStructure::
  specification ()
  {
    return this->specification_;
  }

  void AgentStructure::
  specification (const specification_type& x)
  {
    this->specification_.set (x);
  }

  void AgentStructure::
  specification (const specification_optional& x)
  {
    this->specification_ = x;
  }

  void AgentStructure::
  specification (::std::unique_ptr< specification_type > x)
  {
    this->specification_.set (std::move (x));
  }

  const AgentStructure::topology_optional& AgentStructure::
  topology () const
  {
    return this->topology_;
  }

  AgentStructure::topology_optional& AgentStructure::
  topology ()
  {
    return this->topology_;
  }

  void AgentStructure::
  topology (const topology_type& x)
  {
    this->topology_.set (x);
  }

  void AgentStructure::
  topology (const topology_optional& x)
  {
    this->topology_ = x;
  }

  void AgentStructure::
  topology (::std::unique_ptr< topology_type > x)
  {
    this->topology_.set (std::move (x));
  }

  const AgentStructure::totality_optional& AgentStructure::
  totality () const
  {
    return this->totality_;
  }

  AgentStructure::totality_optional& AgentStructure::
  totality ()
  {
    return this->totality_;
  }

  void AgentStructure::
  totality (const totality_type& x)
  {
    this->totality_.set (x);
  }

  void AgentStructure::
  totality (const totality_optional& x)
  {
    this->totality_ = x;
  }

  void AgentStructure::
  totality (::std::unique_ptr< totality_type > x)
  {
    this->totality_.set (std::move (x));
  }

  const AgentStructure::AgentStructure_structures_AgentListing_optional& AgentStructure::
  AgentStructure_structures_AgentListing () const
  {
    return this->AgentStructure_structures_AgentListing_;
  }

  AgentStructure::AgentStructure_structures_AgentListing_optional& AgentStructure::
  AgentStructure_structures_AgentListing ()
  {
    return this->AgentStructure_structures_AgentListing_;
  }

  void AgentStructure::
  AgentStructure_structures_AgentListing (const AgentStructure_structures_AgentListing_type& x)
  {
    this->AgentStructure_structures_AgentListing_.set (x);
  }

  void AgentStructure::
  AgentStructure_structures_AgentListing (const AgentStructure_structures_AgentListing_optional& x)
  {
    this->AgentStructure_structures_AgentListing_ = x;
  }

  void AgentStructure::
  AgentStructure_structures_AgentListing (::std::unique_ptr< AgentStructure_structures_AgentListing_type > x)
  {
    this->AgentStructure_structures_AgentListing_.set (std::move (x));
  }

  const AgentStructure::AgentStructure_has_AgentRelationship_sequence& AgentStructure::
  AgentStructure_has_AgentRelationship () const
  {
    return this->AgentStructure_has_AgentRelationship_;
  }

  AgentStructure::AgentStructure_has_AgentRelationship_sequence& AgentStructure::
  AgentStructure_has_AgentRelationship ()
  {
    return this->AgentStructure_has_AgentRelationship_;
  }

  void AgentStructure::
  AgentStructure_has_AgentRelationship (const AgentStructure_has_AgentRelationship_sequence& s)
  {
    this->AgentStructure_has_AgentRelationship_ = s;
  }


  // ControlLogic
  //

  const ControlLogic::description_optional& ControlLogic::
  description () const
  {
    return this->description_;
  }

  ControlLogic::description_optional& ControlLogic::
  description ()
  {
    return this->description_;
  }

  void ControlLogic::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void ControlLogic::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void ControlLogic::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }

  const ControlLogic::identifier_optional& ControlLogic::
  identifier () const
  {
    return this->identifier_;
  }

  ControlLogic::identifier_optional& ControlLogic::
  identifier ()
  {
    return this->identifier_;
  }

  void ControlLogic::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ControlLogic::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ControlLogic::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ControlLogic::workflow_optional& ControlLogic::
  workflow () const
  {
    return this->workflow_;
  }

  ControlLogic::workflow_optional& ControlLogic::
  workflow ()
  {
    return this->workflow_;
  }

  void ControlLogic::
  workflow (const workflow_type& x)
  {
    this->workflow_.set (x);
  }

  void ControlLogic::
  workflow (const workflow_optional& x)
  {
    this->workflow_ = x;
  }

  void ControlLogic::
  workflow (::std::unique_ptr< workflow_type > x)
  {
    this->workflow_.set (std::move (x));
  }

  const ControlLogic::ControlLogic_informs_ProcessingAgent_sequence& ControlLogic::
  ControlLogic_informs_ProcessingAgent () const
  {
    return this->ControlLogic_informs_ProcessingAgent_;
  }

  ControlLogic::ControlLogic_informs_ProcessingAgent_sequence& ControlLogic::
  ControlLogic_informs_ProcessingAgent ()
  {
    return this->ControlLogic_informs_ProcessingAgent_;
  }

  void ControlLogic::
  ControlLogic_informs_ProcessingAgent (const ControlLogic_informs_ProcessingAgent_sequence& s)
  {
    this->ControlLogic_informs_ProcessingAgent_ = s;
  }

  const ControlLogic::ControlLogic_invokes_Activity_sequence& ControlLogic::
  ControlLogic_invokes_Activity () const
  {
    return this->ControlLogic_invokes_Activity_;
  }

  ControlLogic::ControlLogic_invokes_Activity_sequence& ControlLogic::
  ControlLogic_invokes_Activity ()
  {
    return this->ControlLogic_invokes_Activity_;
  }

  void ControlLogic::
  ControlLogic_invokes_Activity (const ControlLogic_invokes_Activity_sequence& s)
  {
    this->ControlLogic_invokes_Activity_ = s;
  }

  const ControlLogic::ControlLogic_hasSubControlLogic_ControlLogic_sequence& ControlLogic::
  ControlLogic_hasSubControlLogic_ControlLogic () const
  {
    return this->ControlLogic_hasSubControlLogic_ControlLogic_;
  }

  ControlLogic::ControlLogic_hasSubControlLogic_ControlLogic_sequence& ControlLogic::
  ControlLogic_hasSubControlLogic_ControlLogic ()
  {
    return this->ControlLogic_hasSubControlLogic_ControlLogic_;
  }

  void ControlLogic::
  ControlLogic_hasSubControlLogic_ControlLogic (const ControlLogic_hasSubControlLogic_ControlLogic_sequence& s)
  {
    this->ControlLogic_hasSubControlLogic_ControlLogic_ = s;
  }

  const ControlLogic::ControlLogic_has_InformationFlowDefinition_sequence& ControlLogic::
  ControlLogic_has_InformationFlowDefinition () const
  {
    return this->ControlLogic_has_InformationFlowDefinition_;
  }

  ControlLogic::ControlLogic_has_InformationFlowDefinition_sequence& ControlLogic::
  ControlLogic_has_InformationFlowDefinition ()
  {
    return this->ControlLogic_has_InformationFlowDefinition_;
  }

  void ControlLogic::
  ControlLogic_has_InformationFlowDefinition (const ControlLogic_has_InformationFlowDefinition_sequence& s)
  {
    this->ControlLogic_has_InformationFlowDefinition_ = s;
  }


  // NonDeterministicDeclarative
  //


  // TemporalConstraints
  //


  // AllenIntervalAlgebra
  //

  const AllenIntervalAlgebra::temporalIntervalRelation_type& AllenIntervalAlgebra::
  temporalIntervalRelation () const
  {
    return this->temporalIntervalRelation_.get ();
  }

  AllenIntervalAlgebra::temporalIntervalRelation_type& AllenIntervalAlgebra::
  temporalIntervalRelation ()
  {
    return this->temporalIntervalRelation_.get ();
  }

  void AllenIntervalAlgebra::
  temporalIntervalRelation (const temporalIntervalRelation_type& x)
  {
    this->temporalIntervalRelation_.set (x);
  }

  void AllenIntervalAlgebra::
  temporalIntervalRelation (::std::unique_ptr< temporalIntervalRelation_type > x)
  {
    this->temporalIntervalRelation_.set (std::move (x));
  }


  // DataStructureComponent
  //

  const DataStructureComponent::identifier_optional& DataStructureComponent::
  identifier () const
  {
    return this->identifier_;
  }

  DataStructureComponent::identifier_optional& DataStructureComponent::
  identifier ()
  {
    return this->identifier_;
  }

  void DataStructureComponent::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void DataStructureComponent::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void DataStructureComponent::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const DataStructureComponent::semantic_sequence& DataStructureComponent::
  semantic () const
  {
    return this->semantic_;
  }

  DataStructureComponent::semantic_sequence& DataStructureComponent::
  semantic ()
  {
    return this->semantic_;
  }

  void DataStructureComponent::
  semantic (const semantic_sequence& s)
  {
    this->semantic_ = s;
  }

  const DataStructureComponent::specialization_optional& DataStructureComponent::
  specialization () const
  {
    return this->specialization_;
  }

  DataStructureComponent::specialization_optional& DataStructureComponent::
  specialization ()
  {
    return this->specialization_;
  }

  void DataStructureComponent::
  specialization (const specialization_type& x)
  {
    this->specialization_.set (x);
  }

  void DataStructureComponent::
  specialization (const specialization_optional& x)
  {
    this->specialization_ = x;
  }

  void DataStructureComponent::
  specialization (::std::unique_ptr< specialization_type > x)
  {
    this->specialization_.set (std::move (x));
  }

  const DataStructureComponent::DataStructureComponent_isDefinedBy_RepresentedVariable_optional& DataStructureComponent::
  DataStructureComponent_isDefinedBy_RepresentedVariable () const
  {
    return this->DataStructureComponent_isDefinedBy_RepresentedVariable_;
  }

  DataStructureComponent::DataStructureComponent_isDefinedBy_RepresentedVariable_optional& DataStructureComponent::
  DataStructureComponent_isDefinedBy_RepresentedVariable ()
  {
    return this->DataStructureComponent_isDefinedBy_RepresentedVariable_;
  }

  void DataStructureComponent::
  DataStructureComponent_isDefinedBy_RepresentedVariable (const DataStructureComponent_isDefinedBy_RepresentedVariable_type& x)
  {
    this->DataStructureComponent_isDefinedBy_RepresentedVariable_.set (x);
  }

  void DataStructureComponent::
  DataStructureComponent_isDefinedBy_RepresentedVariable (const DataStructureComponent_isDefinedBy_RepresentedVariable_optional& x)
  {
    this->DataStructureComponent_isDefinedBy_RepresentedVariable_ = x;
  }

  void DataStructureComponent::
  DataStructureComponent_isDefinedBy_RepresentedVariable (::std::unique_ptr< DataStructureComponent_isDefinedBy_RepresentedVariable_type > x)
  {
    this->DataStructureComponent_isDefinedBy_RepresentedVariable_.set (std::move (x));
  }


  // AttributeComponent
  //

  const AttributeComponent::AttributeComponent_qualifies_DataStructureComponent_sequence& AttributeComponent::
  AttributeComponent_qualifies_DataStructureComponent () const
  {
    return this->AttributeComponent_qualifies_DataStructureComponent_;
  }

  AttributeComponent::AttributeComponent_qualifies_DataStructureComponent_sequence& AttributeComponent::
  AttributeComponent_qualifies_DataStructureComponent ()
  {
    return this->AttributeComponent_qualifies_DataStructureComponent_;
  }

  void AttributeComponent::
  AttributeComponent_qualifies_DataStructureComponent (const AttributeComponent_qualifies_DataStructureComponent_sequence& s)
  {
    this->AttributeComponent_qualifies_DataStructureComponent_ = s;
  }


  // AuthorizationSource
  //

  const AuthorizationSource::authorizationDate_optional& AuthorizationSource::
  authorizationDate () const
  {
    return this->authorizationDate_;
  }

  AuthorizationSource::authorizationDate_optional& AuthorizationSource::
  authorizationDate ()
  {
    return this->authorizationDate_;
  }

  void AuthorizationSource::
  authorizationDate (const authorizationDate_type& x)
  {
    this->authorizationDate_.set (x);
  }

  void AuthorizationSource::
  authorizationDate (const authorizationDate_optional& x)
  {
    this->authorizationDate_ = x;
  }

  void AuthorizationSource::
  authorizationDate (::std::unique_ptr< authorizationDate_type > x)
  {
    this->authorizationDate_.set (std::move (x));
  }

  const AuthorizationSource::catalogDetails_optional& AuthorizationSource::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  AuthorizationSource::catalogDetails_optional& AuthorizationSource::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void AuthorizationSource::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void AuthorizationSource::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void AuthorizationSource::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const AuthorizationSource::identifier_optional& AuthorizationSource::
  identifier () const
  {
    return this->identifier_;
  }

  AuthorizationSource::identifier_optional& AuthorizationSource::
  identifier ()
  {
    return this->identifier_;
  }

  void AuthorizationSource::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void AuthorizationSource::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void AuthorizationSource::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const AuthorizationSource::legalMandate_optional& AuthorizationSource::
  legalMandate () const
  {
    return this->legalMandate_;
  }

  AuthorizationSource::legalMandate_optional& AuthorizationSource::
  legalMandate ()
  {
    return this->legalMandate_;
  }

  void AuthorizationSource::
  legalMandate (const legalMandate_type& x)
  {
    this->legalMandate_.set (x);
  }

  void AuthorizationSource::
  legalMandate (const legalMandate_optional& x)
  {
    this->legalMandate_ = x;
  }

  void AuthorizationSource::
  legalMandate (::std::unique_ptr< legalMandate_type > x)
  {
    this->legalMandate_.set (std::move (x));
  }

  const AuthorizationSource::purpose_optional& AuthorizationSource::
  purpose () const
  {
    return this->purpose_;
  }

  AuthorizationSource::purpose_optional& AuthorizationSource::
  purpose ()
  {
    return this->purpose_;
  }

  void AuthorizationSource::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void AuthorizationSource::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void AuthorizationSource::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const AuthorizationSource::statementOfAuthorization_optional& AuthorizationSource::
  statementOfAuthorization () const
  {
    return this->statementOfAuthorization_;
  }

  AuthorizationSource::statementOfAuthorization_optional& AuthorizationSource::
  statementOfAuthorization ()
  {
    return this->statementOfAuthorization_;
  }

  void AuthorizationSource::
  statementOfAuthorization (const statementOfAuthorization_type& x)
  {
    this->statementOfAuthorization_.set (x);
  }

  void AuthorizationSource::
  statementOfAuthorization (const statementOfAuthorization_optional& x)
  {
    this->statementOfAuthorization_ = x;
  }

  void AuthorizationSource::
  statementOfAuthorization (::std::unique_ptr< statementOfAuthorization_type > x)
  {
    this->statementOfAuthorization_.set (std::move (x));
  }

  const AuthorizationSource::AuthorizationSource_has_Agent_sequence& AuthorizationSource::
  AuthorizationSource_has_Agent () const
  {
    return this->AuthorizationSource_has_Agent_;
  }

  AuthorizationSource::AuthorizationSource_has_Agent_sequence& AuthorizationSource::
  AuthorizationSource_has_Agent ()
  {
    return this->AuthorizationSource_has_Agent_;
  }

  void AuthorizationSource::
  AuthorizationSource_has_Agent (const AuthorizationSource_has_Agent_sequence& s)
  {
    this->AuthorizationSource_has_Agent_ = s;
  }


  // Concept
  //

  const Concept::catalogDetails_optional& Concept::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  Concept::catalogDetails_optional& Concept::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void Concept::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void Concept::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void Concept::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const Concept::definition_optional& Concept::
  definition () const
  {
    return this->definition_;
  }

  Concept::definition_optional& Concept::
  definition ()
  {
    return this->definition_;
  }

  void Concept::
  definition (const definition_type& x)
  {
    this->definition_.set (x);
  }

  void Concept::
  definition (const definition_optional& x)
  {
    this->definition_ = x;
  }

  void Concept::
  definition (::std::unique_ptr< definition_type > x)
  {
    this->definition_.set (std::move (x));
  }

  const Concept::displayLabel_sequence& Concept::
  displayLabel () const
  {
    return this->displayLabel_;
  }

  Concept::displayLabel_sequence& Concept::
  displayLabel ()
  {
    return this->displayLabel_;
  }

  void Concept::
  displayLabel (const displayLabel_sequence& s)
  {
    this->displayLabel_ = s;
  }

  const Concept::externalDefinition_optional& Concept::
  externalDefinition () const
  {
    return this->externalDefinition_;
  }

  Concept::externalDefinition_optional& Concept::
  externalDefinition ()
  {
    return this->externalDefinition_;
  }

  void Concept::
  externalDefinition (const externalDefinition_type& x)
  {
    this->externalDefinition_.set (x);
  }

  void Concept::
  externalDefinition (const externalDefinition_optional& x)
  {
    this->externalDefinition_ = x;
  }

  void Concept::
  externalDefinition (::std::unique_ptr< externalDefinition_type > x)
  {
    this->externalDefinition_.set (std::move (x));
  }

  const Concept::identifier_optional& Concept::
  identifier () const
  {
    return this->identifier_;
  }

  Concept::identifier_optional& Concept::
  identifier ()
  {
    return this->identifier_;
  }

  void Concept::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void Concept::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void Concept::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const Concept::name_sequence& Concept::
  name () const
  {
    return this->name_;
  }

  Concept::name_sequence& Concept::
  name ()
  {
    return this->name_;
  }

  void Concept::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const Concept::Concept_uses_Concept_sequence& Concept::
  Concept_uses_Concept () const
  {
    return this->Concept_uses_Concept_;
  }

  Concept::Concept_uses_Concept_sequence& Concept::
  Concept_uses_Concept ()
  {
    return this->Concept_uses_Concept_;
  }

  void Concept::
  Concept_uses_Concept (const Concept_uses_Concept_sequence& s)
  {
    this->Concept_uses_Concept_ = s;
  }


  // Category
  //

  const Category::descriptiveText_optional& Category::
  descriptiveText () const
  {
    return this->descriptiveText_;
  }

  Category::descriptiveText_optional& Category::
  descriptiveText ()
  {
    return this->descriptiveText_;
  }

  void Category::
  descriptiveText (const descriptiveText_type& x)
  {
    this->descriptiveText_.set (x);
  }

  void Category::
  descriptiveText (const descriptiveText_optional& x)
  {
    this->descriptiveText_ = x;
  }

  void Category::
  descriptiveText (::std::unique_ptr< descriptiveText_type > x)
  {
    this->descriptiveText_.set (std::move (x));
  }


  // CategoryPosition
  //

  const CategoryPosition::identifier_optional& CategoryPosition::
  identifier () const
  {
    return this->identifier_;
  }

  CategoryPosition::identifier_optional& CategoryPosition::
  identifier ()
  {
    return this->identifier_;
  }

  void CategoryPosition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void CategoryPosition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void CategoryPosition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const CategoryPosition::value_type& CategoryPosition::
  value () const
  {
    return this->value_.get ();
  }

  CategoryPosition::value_type& CategoryPosition::
  value ()
  {
    return this->value_.get ();
  }

  void CategoryPosition::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  const CategoryPosition::CategoryPosition_indexes_Category_type& CategoryPosition::
  CategoryPosition_indexes_Category () const
  {
    return this->CategoryPosition_indexes_Category_.get ();
  }

  CategoryPosition::CategoryPosition_indexes_Category_type& CategoryPosition::
  CategoryPosition_indexes_Category ()
  {
    return this->CategoryPosition_indexes_Category_.get ();
  }

  void CategoryPosition::
  CategoryPosition_indexes_Category (const CategoryPosition_indexes_Category_type& x)
  {
    this->CategoryPosition_indexes_Category_.set (x);
  }

  void CategoryPosition::
  CategoryPosition_indexes_Category (::std::unique_ptr< CategoryPosition_indexes_Category_type > x)
  {
    this->CategoryPosition_indexes_Category_.set (std::move (x));
  }


  // CategoryRelationStructure
  //

  const CategoryRelationStructure::identifier_optional& CategoryRelationStructure::
  identifier () const
  {
    return this->identifier_;
  }

  CategoryRelationStructure::identifier_optional& CategoryRelationStructure::
  identifier ()
  {
    return this->identifier_;
  }

  void CategoryRelationStructure::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void CategoryRelationStructure::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void CategoryRelationStructure::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const CategoryRelationStructure::name_sequence& CategoryRelationStructure::
  name () const
  {
    return this->name_;
  }

  CategoryRelationStructure::name_sequence& CategoryRelationStructure::
  name ()
  {
    return this->name_;
  }

  void CategoryRelationStructure::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const CategoryRelationStructure::purpose_optional& CategoryRelationStructure::
  purpose () const
  {
    return this->purpose_;
  }

  CategoryRelationStructure::purpose_optional& CategoryRelationStructure::
  purpose ()
  {
    return this->purpose_;
  }

  void CategoryRelationStructure::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void CategoryRelationStructure::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void CategoryRelationStructure::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const CategoryRelationStructure::semantics_optional& CategoryRelationStructure::
  semantics () const
  {
    return this->semantics_;
  }

  CategoryRelationStructure::semantics_optional& CategoryRelationStructure::
  semantics ()
  {
    return this->semantics_;
  }

  void CategoryRelationStructure::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void CategoryRelationStructure::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void CategoryRelationStructure::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const CategoryRelationStructure::specification_optional& CategoryRelationStructure::
  specification () const
  {
    return this->specification_;
  }

  CategoryRelationStructure::specification_optional& CategoryRelationStructure::
  specification ()
  {
    return this->specification_;
  }

  void CategoryRelationStructure::
  specification (const specification_type& x)
  {
    this->specification_.set (x);
  }

  void CategoryRelationStructure::
  specification (const specification_optional& x)
  {
    this->specification_ = x;
  }

  void CategoryRelationStructure::
  specification (::std::unique_ptr< specification_type > x)
  {
    this->specification_.set (std::move (x));
  }

  const CategoryRelationStructure::topology_optional& CategoryRelationStructure::
  topology () const
  {
    return this->topology_;
  }

  CategoryRelationStructure::topology_optional& CategoryRelationStructure::
  topology ()
  {
    return this->topology_;
  }

  void CategoryRelationStructure::
  topology (const topology_type& x)
  {
    this->topology_.set (x);
  }

  void CategoryRelationStructure::
  topology (const topology_optional& x)
  {
    this->topology_ = x;
  }

  void CategoryRelationStructure::
  topology (::std::unique_ptr< topology_type > x)
  {
    this->topology_.set (std::move (x));
  }

  const CategoryRelationStructure::totality_optional& CategoryRelationStructure::
  totality () const
  {
    return this->totality_;
  }

  CategoryRelationStructure::totality_optional& CategoryRelationStructure::
  totality ()
  {
    return this->totality_;
  }

  void CategoryRelationStructure::
  totality (const totality_type& x)
  {
    this->totality_.set (x);
  }

  void CategoryRelationStructure::
  totality (const totality_optional& x)
  {
    this->totality_ = x;
  }

  void CategoryRelationStructure::
  totality (::std::unique_ptr< totality_type > x)
  {
    this->totality_.set (std::move (x));
  }

  const CategoryRelationStructure::CategoryRelationStructure_structures_CategorySet_optional& CategoryRelationStructure::
  CategoryRelationStructure_structures_CategorySet () const
  {
    return this->CategoryRelationStructure_structures_CategorySet_;
  }

  CategoryRelationStructure::CategoryRelationStructure_structures_CategorySet_optional& CategoryRelationStructure::
  CategoryRelationStructure_structures_CategorySet ()
  {
    return this->CategoryRelationStructure_structures_CategorySet_;
  }

  void CategoryRelationStructure::
  CategoryRelationStructure_structures_CategorySet (const CategoryRelationStructure_structures_CategorySet_type& x)
  {
    this->CategoryRelationStructure_structures_CategorySet_.set (x);
  }

  void CategoryRelationStructure::
  CategoryRelationStructure_structures_CategorySet (const CategoryRelationStructure_structures_CategorySet_optional& x)
  {
    this->CategoryRelationStructure_structures_CategorySet_ = x;
  }

  void CategoryRelationStructure::
  CategoryRelationStructure_structures_CategorySet (::std::unique_ptr< CategoryRelationStructure_structures_CategorySet_type > x)
  {
    this->CategoryRelationStructure_structures_CategorySet_.set (std::move (x));
  }

  const CategoryRelationStructure::CategoryRelationStructure_has_CategoryRelationship_sequence& CategoryRelationStructure::
  CategoryRelationStructure_has_CategoryRelationship () const
  {
    return this->CategoryRelationStructure_has_CategoryRelationship_;
  }

  CategoryRelationStructure::CategoryRelationStructure_has_CategoryRelationship_sequence& CategoryRelationStructure::
  CategoryRelationStructure_has_CategoryRelationship ()
  {
    return this->CategoryRelationStructure_has_CategoryRelationship_;
  }

  void CategoryRelationStructure::
  CategoryRelationStructure_has_CategoryRelationship (const CategoryRelationStructure_has_CategoryRelationship_sequence& s)
  {
    this->CategoryRelationStructure_has_CategoryRelationship_ = s;
  }


  // CategoryRelationship
  //

  const CategoryRelationship::identifier_optional& CategoryRelationship::
  identifier () const
  {
    return this->identifier_;
  }

  CategoryRelationship::identifier_optional& CategoryRelationship::
  identifier ()
  {
    return this->identifier_;
  }

  void CategoryRelationship::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void CategoryRelationship::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void CategoryRelationship::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const CategoryRelationship::semantics_optional& CategoryRelationship::
  semantics () const
  {
    return this->semantics_;
  }

  CategoryRelationship::semantics_optional& CategoryRelationship::
  semantics ()
  {
    return this->semantics_;
  }

  void CategoryRelationship::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void CategoryRelationship::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void CategoryRelationship::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const CategoryRelationship::CategoryRelationship_hasSource_Category_sequence& CategoryRelationship::
  CategoryRelationship_hasSource_Category () const
  {
    return this->CategoryRelationship_hasSource_Category_;
  }

  CategoryRelationship::CategoryRelationship_hasSource_Category_sequence& CategoryRelationship::
  CategoryRelationship_hasSource_Category ()
  {
    return this->CategoryRelationship_hasSource_Category_;
  }

  void CategoryRelationship::
  CategoryRelationship_hasSource_Category (const CategoryRelationship_hasSource_Category_sequence& s)
  {
    this->CategoryRelationship_hasSource_Category_ = s;
  }

  const CategoryRelationship::CategoryRelationship_hasTarget_Category_sequence& CategoryRelationship::
  CategoryRelationship_hasTarget_Category () const
  {
    return this->CategoryRelationship_hasTarget_Category_;
  }

  CategoryRelationship::CategoryRelationship_hasTarget_Category_sequence& CategoryRelationship::
  CategoryRelationship_hasTarget_Category ()
  {
    return this->CategoryRelationship_hasTarget_Category_;
  }

  void CategoryRelationship::
  CategoryRelationship_hasTarget_Category (const CategoryRelationship_hasTarget_Category_sequence& s)
  {
    this->CategoryRelationship_hasTarget_Category_ = s;
  }


  // ConceptSystem
  //

  const ConceptSystem::allowsDuplicates_type& ConceptSystem::
  allowsDuplicates () const
  {
    return this->allowsDuplicates_.get ();
  }

  ConceptSystem::allowsDuplicates_type& ConceptSystem::
  allowsDuplicates ()
  {
    return this->allowsDuplicates_.get ();
  }

  void ConceptSystem::
  allowsDuplicates (const allowsDuplicates_type& x)
  {
    this->allowsDuplicates_.set (x);
  }

  const ConceptSystem::catalogDetails_optional& ConceptSystem::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  ConceptSystem::catalogDetails_optional& ConceptSystem::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void ConceptSystem::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void ConceptSystem::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void ConceptSystem::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const ConceptSystem::externalDefinition_optional& ConceptSystem::
  externalDefinition () const
  {
    return this->externalDefinition_;
  }

  ConceptSystem::externalDefinition_optional& ConceptSystem::
  externalDefinition ()
  {
    return this->externalDefinition_;
  }

  void ConceptSystem::
  externalDefinition (const externalDefinition_type& x)
  {
    this->externalDefinition_.set (x);
  }

  void ConceptSystem::
  externalDefinition (const externalDefinition_optional& x)
  {
    this->externalDefinition_ = x;
  }

  void ConceptSystem::
  externalDefinition (::std::unique_ptr< externalDefinition_type > x)
  {
    this->externalDefinition_.set (std::move (x));
  }

  const ConceptSystem::identifier_optional& ConceptSystem::
  identifier () const
  {
    return this->identifier_;
  }

  ConceptSystem::identifier_optional& ConceptSystem::
  identifier ()
  {
    return this->identifier_;
  }

  void ConceptSystem::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ConceptSystem::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ConceptSystem::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ConceptSystem::name_sequence& ConceptSystem::
  name () const
  {
    return this->name_;
  }

  ConceptSystem::name_sequence& ConceptSystem::
  name ()
  {
    return this->name_;
  }

  void ConceptSystem::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const ConceptSystem::purpose_optional& ConceptSystem::
  purpose () const
  {
    return this->purpose_;
  }

  ConceptSystem::purpose_optional& ConceptSystem::
  purpose ()
  {
    return this->purpose_;
  }

  void ConceptSystem::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void ConceptSystem::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void ConceptSystem::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const ConceptSystem::ConceptSystem_isDefinedBy_Concept_sequence& ConceptSystem::
  ConceptSystem_isDefinedBy_Concept () const
  {
    return this->ConceptSystem_isDefinedBy_Concept_;
  }

  ConceptSystem::ConceptSystem_isDefinedBy_Concept_sequence& ConceptSystem::
  ConceptSystem_isDefinedBy_Concept ()
  {
    return this->ConceptSystem_isDefinedBy_Concept_;
  }

  void ConceptSystem::
  ConceptSystem_isDefinedBy_Concept (const ConceptSystem_isDefinedBy_Concept_sequence& s)
  {
    this->ConceptSystem_isDefinedBy_Concept_ = s;
  }

  const ConceptSystem::ConceptSystem_has_Concept_sequence& ConceptSystem::
  ConceptSystem_has_Concept () const
  {
    return this->ConceptSystem_has_Concept_;
  }

  ConceptSystem::ConceptSystem_has_Concept_sequence& ConceptSystem::
  ConceptSystem_has_Concept ()
  {
    return this->ConceptSystem_has_Concept_;
  }

  void ConceptSystem::
  ConceptSystem_has_Concept (const ConceptSystem_has_Concept_sequence& s)
  {
    this->ConceptSystem_has_Concept_ = s;
  }


  // CategorySet
  //

  const CategorySet::CategorySet_has_Category_sequence& CategorySet::
  CategorySet_has_Category () const
  {
    return this->CategorySet_has_Category_;
  }

  CategorySet::CategorySet_has_Category_sequence& CategorySet::
  CategorySet_has_Category ()
  {
    return this->CategorySet_has_Category_;
  }

  void CategorySet::
  CategorySet_has_Category (const CategorySet_has_Category_sequence& s)
  {
    this->CategorySet_has_Category_ = s;
  }

  const CategorySet::CategorySet_has_CategoryPosition_sequence& CategorySet::
  CategorySet_has_CategoryPosition () const
  {
    return this->CategorySet_has_CategoryPosition_;
  }

  CategorySet::CategorySet_has_CategoryPosition_sequence& CategorySet::
  CategorySet_has_CategoryPosition ()
  {
    return this->CategorySet_has_CategoryPosition_;
  }

  void CategorySet::
  CategorySet_has_CategoryPosition (const CategorySet_has_CategoryPosition_sequence& s)
  {
    this->CategorySet_has_CategoryPosition_ = s;
  }


  // CategoryStatistic
  //

  const CategoryStatistic::identifier_optional& CategoryStatistic::
  identifier () const
  {
    return this->identifier_;
  }

  CategoryStatistic::identifier_optional& CategoryStatistic::
  identifier ()
  {
    return this->identifier_;
  }

  void CategoryStatistic::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void CategoryStatistic::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void CategoryStatistic::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const CategoryStatistic::statistic_sequence& CategoryStatistic::
  statistic () const
  {
    return this->statistic_;
  }

  CategoryStatistic::statistic_sequence& CategoryStatistic::
  statistic ()
  {
    return this->statistic_;
  }

  void CategoryStatistic::
  statistic (const statistic_sequence& s)
  {
    this->statistic_ = s;
  }

  const CategoryStatistic::typeOfCategoryStatistic_optional& CategoryStatistic::
  typeOfCategoryStatistic () const
  {
    return this->typeOfCategoryStatistic_;
  }

  CategoryStatistic::typeOfCategoryStatistic_optional& CategoryStatistic::
  typeOfCategoryStatistic ()
  {
    return this->typeOfCategoryStatistic_;
  }

  void CategoryStatistic::
  typeOfCategoryStatistic (const typeOfCategoryStatistic_type& x)
  {
    this->typeOfCategoryStatistic_.set (x);
  }

  void CategoryStatistic::
  typeOfCategoryStatistic (const typeOfCategoryStatistic_optional& x)
  {
    this->typeOfCategoryStatistic_ = x;
  }

  void CategoryStatistic::
  typeOfCategoryStatistic (::std::unique_ptr< typeOfCategoryStatistic_type > x)
  {
    this->typeOfCategoryStatistic_.set (std::move (x));
  }

  const CategoryStatistic::CategoryStatistic_appliesTo_InstanceVariable_sequence& CategoryStatistic::
  CategoryStatistic_appliesTo_InstanceVariable () const
  {
    return this->CategoryStatistic_appliesTo_InstanceVariable_;
  }

  CategoryStatistic::CategoryStatistic_appliesTo_InstanceVariable_sequence& CategoryStatistic::
  CategoryStatistic_appliesTo_InstanceVariable ()
  {
    return this->CategoryStatistic_appliesTo_InstanceVariable_;
  }

  void CategoryStatistic::
  CategoryStatistic_appliesTo_InstanceVariable (const CategoryStatistic_appliesTo_InstanceVariable_sequence& s)
  {
    this->CategoryStatistic_appliesTo_InstanceVariable_ = s;
  }

  const CategoryStatistic::CategoryStatistic_for_Category_optional& CategoryStatistic::
  CategoryStatistic_for_Category () const
  {
    return this->CategoryStatistic_for_Category_;
  }

  CategoryStatistic::CategoryStatistic_for_Category_optional& CategoryStatistic::
  CategoryStatistic_for_Category ()
  {
    return this->CategoryStatistic_for_Category_;
  }

  void CategoryStatistic::
  CategoryStatistic_for_Category (const CategoryStatistic_for_Category_type& x)
  {
    this->CategoryStatistic_for_Category_.set (x);
  }

  void CategoryStatistic::
  CategoryStatistic_for_Category (const CategoryStatistic_for_Category_optional& x)
  {
    this->CategoryStatistic_for_Category_ = x;
  }

  void CategoryStatistic::
  CategoryStatistic_for_Category (::std::unique_ptr< CategoryStatistic_for_Category_type > x)
  {
    this->CategoryStatistic_for_Category_.set (std::move (x));
  }


  // ClassificationFamily
  //

  const ClassificationFamily::catalogDetails_optional& ClassificationFamily::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  ClassificationFamily::catalogDetails_optional& ClassificationFamily::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void ClassificationFamily::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void ClassificationFamily::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void ClassificationFamily::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const ClassificationFamily::identifier_optional& ClassificationFamily::
  identifier () const
  {
    return this->identifier_;
  }

  ClassificationFamily::identifier_optional& ClassificationFamily::
  identifier ()
  {
    return this->identifier_;
  }

  void ClassificationFamily::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ClassificationFamily::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ClassificationFamily::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ClassificationFamily::name_sequence& ClassificationFamily::
  name () const
  {
    return this->name_;
  }

  ClassificationFamily::name_sequence& ClassificationFamily::
  name ()
  {
    return this->name_;
  }

  void ClassificationFamily::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const ClassificationFamily::purpose_optional& ClassificationFamily::
  purpose () const
  {
    return this->purpose_;
  }

  ClassificationFamily::purpose_optional& ClassificationFamily::
  purpose ()
  {
    return this->purpose_;
  }

  void ClassificationFamily::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void ClassificationFamily::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void ClassificationFamily::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const ClassificationFamily::ClassificationFamily_uses_ClassificationIndex_sequence& ClassificationFamily::
  ClassificationFamily_uses_ClassificationIndex () const
  {
    return this->ClassificationFamily_uses_ClassificationIndex_;
  }

  ClassificationFamily::ClassificationFamily_uses_ClassificationIndex_sequence& ClassificationFamily::
  ClassificationFamily_uses_ClassificationIndex ()
  {
    return this->ClassificationFamily_uses_ClassificationIndex_;
  }

  void ClassificationFamily::
  ClassificationFamily_uses_ClassificationIndex (const ClassificationFamily_uses_ClassificationIndex_sequence& s)
  {
    this->ClassificationFamily_uses_ClassificationIndex_ = s;
  }

  const ClassificationFamily::ClassificationFamily_isDefinedBy_Concept_sequence& ClassificationFamily::
  ClassificationFamily_isDefinedBy_Concept () const
  {
    return this->ClassificationFamily_isDefinedBy_Concept_;
  }

  ClassificationFamily::ClassificationFamily_isDefinedBy_Concept_sequence& ClassificationFamily::
  ClassificationFamily_isDefinedBy_Concept ()
  {
    return this->ClassificationFamily_isDefinedBy_Concept_;
  }

  void ClassificationFamily::
  ClassificationFamily_isDefinedBy_Concept (const ClassificationFamily_isDefinedBy_Concept_sequence& s)
  {
    this->ClassificationFamily_isDefinedBy_Concept_ = s;
  }

  const ClassificationFamily::ClassificationFamily_groups_ClassificationSeries_sequence& ClassificationFamily::
  ClassificationFamily_groups_ClassificationSeries () const
  {
    return this->ClassificationFamily_groups_ClassificationSeries_;
  }

  ClassificationFamily::ClassificationFamily_groups_ClassificationSeries_sequence& ClassificationFamily::
  ClassificationFamily_groups_ClassificationSeries ()
  {
    return this->ClassificationFamily_groups_ClassificationSeries_;
  }

  void ClassificationFamily::
  ClassificationFamily_groups_ClassificationSeries (const ClassificationFamily_groups_ClassificationSeries_sequence& s)
  {
    this->ClassificationFamily_groups_ClassificationSeries_ = s;
  }


  // ClassificationIndex
  //

  const ClassificationIndex::allowsDuplicates_type& ClassificationIndex::
  allowsDuplicates () const
  {
    return this->allowsDuplicates_.get ();
  }

  ClassificationIndex::allowsDuplicates_type& ClassificationIndex::
  allowsDuplicates ()
  {
    return this->allowsDuplicates_.get ();
  }

  void ClassificationIndex::
  allowsDuplicates (const allowsDuplicates_type& x)
  {
    this->allowsDuplicates_.set (x);
  }

  const ClassificationIndex::availableLanguage_sequence& ClassificationIndex::
  availableLanguage () const
  {
    return this->availableLanguage_;
  }

  ClassificationIndex::availableLanguage_sequence& ClassificationIndex::
  availableLanguage ()
  {
    return this->availableLanguage_;
  }

  void ClassificationIndex::
  availableLanguage (const availableLanguage_sequence& s)
  {
    this->availableLanguage_ = s;
  }

  const ClassificationIndex::catalogDetails_optional& ClassificationIndex::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  ClassificationIndex::catalogDetails_optional& ClassificationIndex::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void ClassificationIndex::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void ClassificationIndex::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void ClassificationIndex::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const ClassificationIndex::codingInstruction_sequence& ClassificationIndex::
  codingInstruction () const
  {
    return this->codingInstruction_;
  }

  ClassificationIndex::codingInstruction_sequence& ClassificationIndex::
  codingInstruction ()
  {
    return this->codingInstruction_;
  }

  void ClassificationIndex::
  codingInstruction (const codingInstruction_sequence& s)
  {
    this->codingInstruction_ = s;
  }

  const ClassificationIndex::corrections_sequence& ClassificationIndex::
  corrections () const
  {
    return this->corrections_;
  }

  ClassificationIndex::corrections_sequence& ClassificationIndex::
  corrections ()
  {
    return this->corrections_;
  }

  void ClassificationIndex::
  corrections (const corrections_sequence& s)
  {
    this->corrections_ = s;
  }

  const ClassificationIndex::identifier_optional& ClassificationIndex::
  identifier () const
  {
    return this->identifier_;
  }

  ClassificationIndex::identifier_optional& ClassificationIndex::
  identifier ()
  {
    return this->identifier_;
  }

  void ClassificationIndex::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ClassificationIndex::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ClassificationIndex::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ClassificationIndex::name_sequence& ClassificationIndex::
  name () const
  {
    return this->name_;
  }

  ClassificationIndex::name_sequence& ClassificationIndex::
  name ()
  {
    return this->name_;
  }

  void ClassificationIndex::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const ClassificationIndex::purpose_optional& ClassificationIndex::
  purpose () const
  {
    return this->purpose_;
  }

  ClassificationIndex::purpose_optional& ClassificationIndex::
  purpose ()
  {
    return this->purpose_;
  }

  void ClassificationIndex::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void ClassificationIndex::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void ClassificationIndex::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const ClassificationIndex::releaseDate_optional& ClassificationIndex::
  releaseDate () const
  {
    return this->releaseDate_;
  }

  ClassificationIndex::releaseDate_optional& ClassificationIndex::
  releaseDate ()
  {
    return this->releaseDate_;
  }

  void ClassificationIndex::
  releaseDate (const releaseDate_type& x)
  {
    this->releaseDate_.set (x);
  }

  void ClassificationIndex::
  releaseDate (const releaseDate_optional& x)
  {
    this->releaseDate_ = x;
  }

  void ClassificationIndex::
  releaseDate (::std::unique_ptr< releaseDate_type > x)
  {
    this->releaseDate_.set (std::move (x));
  }

  const ClassificationIndex::ClassificationIndex_isMaintainedBy_Agent_optional& ClassificationIndex::
  ClassificationIndex_isMaintainedBy_Agent () const
  {
    return this->ClassificationIndex_isMaintainedBy_Agent_;
  }

  ClassificationIndex::ClassificationIndex_isMaintainedBy_Agent_optional& ClassificationIndex::
  ClassificationIndex_isMaintainedBy_Agent ()
  {
    return this->ClassificationIndex_isMaintainedBy_Agent_;
  }

  void ClassificationIndex::
  ClassificationIndex_isMaintainedBy_Agent (const ClassificationIndex_isMaintainedBy_Agent_type& x)
  {
    this->ClassificationIndex_isMaintainedBy_Agent_.set (x);
  }

  void ClassificationIndex::
  ClassificationIndex_isMaintainedBy_Agent (const ClassificationIndex_isMaintainedBy_Agent_optional& x)
  {
    this->ClassificationIndex_isMaintainedBy_Agent_ = x;
  }

  void ClassificationIndex::
  ClassificationIndex_isMaintainedBy_Agent (::std::unique_ptr< ClassificationIndex_isMaintainedBy_Agent_type > x)
  {
    this->ClassificationIndex_isMaintainedBy_Agent_.set (std::move (x));
  }

  const ClassificationIndex::ClassificationIndex_hasContact_Agent_sequence& ClassificationIndex::
  ClassificationIndex_hasContact_Agent () const
  {
    return this->ClassificationIndex_hasContact_Agent_;
  }

  ClassificationIndex::ClassificationIndex_hasContact_Agent_sequence& ClassificationIndex::
  ClassificationIndex_hasContact_Agent ()
  {
    return this->ClassificationIndex_hasContact_Agent_;
  }

  void ClassificationIndex::
  ClassificationIndex_hasContact_Agent (const ClassificationIndex_hasContact_Agent_sequence& s)
  {
    this->ClassificationIndex_hasContact_Agent_ = s;
  }

  const ClassificationIndex::ClassificationIndex_isDefinedBy_Concept_sequence& ClassificationIndex::
  ClassificationIndex_isDefinedBy_Concept () const
  {
    return this->ClassificationIndex_isDefinedBy_Concept_;
  }

  ClassificationIndex::ClassificationIndex_isDefinedBy_Concept_sequence& ClassificationIndex::
  ClassificationIndex_isDefinedBy_Concept ()
  {
    return this->ClassificationIndex_isDefinedBy_Concept_;
  }

  void ClassificationIndex::
  ClassificationIndex_isDefinedBy_Concept (const ClassificationIndex_isDefinedBy_Concept_sequence& s)
  {
    this->ClassificationIndex_isDefinedBy_Concept_ = s;
  }

  const ClassificationIndex::ClassificationIndex_has_ClassificationIndexEntryPosition_sequence& ClassificationIndex::
  ClassificationIndex_has_ClassificationIndexEntryPosition () const
  {
    return this->ClassificationIndex_has_ClassificationIndexEntryPosition_;
  }

  ClassificationIndex::ClassificationIndex_has_ClassificationIndexEntryPosition_sequence& ClassificationIndex::
  ClassificationIndex_has_ClassificationIndexEntryPosition ()
  {
    return this->ClassificationIndex_has_ClassificationIndexEntryPosition_;
  }

  void ClassificationIndex::
  ClassificationIndex_has_ClassificationIndexEntryPosition (const ClassificationIndex_has_ClassificationIndexEntryPosition_sequence& s)
  {
    this->ClassificationIndex_has_ClassificationIndexEntryPosition_ = s;
  }

  const ClassificationIndex::ClassificationIndex_has_ClassificationIndexEntry_sequence& ClassificationIndex::
  ClassificationIndex_has_ClassificationIndexEntry () const
  {
    return this->ClassificationIndex_has_ClassificationIndexEntry_;
  }

  ClassificationIndex::ClassificationIndex_has_ClassificationIndexEntry_sequence& ClassificationIndex::
  ClassificationIndex_has_ClassificationIndexEntry ()
  {
    return this->ClassificationIndex_has_ClassificationIndexEntry_;
  }

  void ClassificationIndex::
  ClassificationIndex_has_ClassificationIndexEntry (const ClassificationIndex_has_ClassificationIndexEntry_sequence& s)
  {
    this->ClassificationIndex_has_ClassificationIndexEntry_ = s;
  }


  // ClassificationIndexEntry
  //

  const ClassificationIndexEntry::catalogDetails_optional& ClassificationIndexEntry::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  ClassificationIndexEntry::catalogDetails_optional& ClassificationIndexEntry::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void ClassificationIndexEntry::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void ClassificationIndexEntry::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void ClassificationIndexEntry::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const ClassificationIndexEntry::codingInstruction_optional& ClassificationIndexEntry::
  codingInstruction () const
  {
    return this->codingInstruction_;
  }

  ClassificationIndexEntry::codingInstruction_optional& ClassificationIndexEntry::
  codingInstruction ()
  {
    return this->codingInstruction_;
  }

  void ClassificationIndexEntry::
  codingInstruction (const codingInstruction_type& x)
  {
    this->codingInstruction_.set (x);
  }

  void ClassificationIndexEntry::
  codingInstruction (const codingInstruction_optional& x)
  {
    this->codingInstruction_ = x;
  }

  void ClassificationIndexEntry::
  codingInstruction (::std::unique_ptr< codingInstruction_type > x)
  {
    this->codingInstruction_.set (std::move (x));
  }

  const ClassificationIndexEntry::entry_optional& ClassificationIndexEntry::
  entry () const
  {
    return this->entry_;
  }

  ClassificationIndexEntry::entry_optional& ClassificationIndexEntry::
  entry ()
  {
    return this->entry_;
  }

  void ClassificationIndexEntry::
  entry (const entry_type& x)
  {
    this->entry_.set (x);
  }

  void ClassificationIndexEntry::
  entry (const entry_optional& x)
  {
    this->entry_ = x;
  }

  void ClassificationIndexEntry::
  entry (::std::unique_ptr< entry_type > x)
  {
    this->entry_.set (std::move (x));
  }

  const ClassificationIndexEntry::identifier_optional& ClassificationIndexEntry::
  identifier () const
  {
    return this->identifier_;
  }

  ClassificationIndexEntry::identifier_optional& ClassificationIndexEntry::
  identifier ()
  {
    return this->identifier_;
  }

  void ClassificationIndexEntry::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ClassificationIndexEntry::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ClassificationIndexEntry::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ClassificationIndexEntry::validDates_optional& ClassificationIndexEntry::
  validDates () const
  {
    return this->validDates_;
  }

  ClassificationIndexEntry::validDates_optional& ClassificationIndexEntry::
  validDates ()
  {
    return this->validDates_;
  }

  void ClassificationIndexEntry::
  validDates (const validDates_type& x)
  {
    this->validDates_.set (x);
  }

  void ClassificationIndexEntry::
  validDates (const validDates_optional& x)
  {
    this->validDates_ = x;
  }

  void ClassificationIndexEntry::
  validDates (::std::unique_ptr< validDates_type > x)
  {
    this->validDates_.set (std::move (x));
  }


  // ClassificationIndexEntryPosition
  //

  const ClassificationIndexEntryPosition::identifier_optional& ClassificationIndexEntryPosition::
  identifier () const
  {
    return this->identifier_;
  }

  ClassificationIndexEntryPosition::identifier_optional& ClassificationIndexEntryPosition::
  identifier ()
  {
    return this->identifier_;
  }

  void ClassificationIndexEntryPosition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ClassificationIndexEntryPosition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ClassificationIndexEntryPosition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ClassificationIndexEntryPosition::value_type& ClassificationIndexEntryPosition::
  value () const
  {
    return this->value_.get ();
  }

  ClassificationIndexEntryPosition::value_type& ClassificationIndexEntryPosition::
  value ()
  {
    return this->value_.get ();
  }

  void ClassificationIndexEntryPosition::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  const ClassificationIndexEntryPosition::ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type& ClassificationIndexEntryPosition::
  ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry () const
  {
    return this->ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_.get ();
  }

  ClassificationIndexEntryPosition::ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type& ClassificationIndexEntryPosition::
  ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry ()
  {
    return this->ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_.get ();
  }

  void ClassificationIndexEntryPosition::
  ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry (const ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type& x)
  {
    this->ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_.set (x);
  }

  void ClassificationIndexEntryPosition::
  ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry (::std::unique_ptr< ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type > x)
  {
    this->ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_.set (std::move (x));
  }


  // ClassificationItem
  //

  const ClassificationItem::changeFromPreviousVersion_optional& ClassificationItem::
  changeFromPreviousVersion () const
  {
    return this->changeFromPreviousVersion_;
  }

  ClassificationItem::changeFromPreviousVersion_optional& ClassificationItem::
  changeFromPreviousVersion ()
  {
    return this->changeFromPreviousVersion_;
  }

  void ClassificationItem::
  changeFromPreviousVersion (const changeFromPreviousVersion_type& x)
  {
    this->changeFromPreviousVersion_.set (x);
  }

  void ClassificationItem::
  changeFromPreviousVersion (const changeFromPreviousVersion_optional& x)
  {
    this->changeFromPreviousVersion_ = x;
  }

  void ClassificationItem::
  changeFromPreviousVersion (::std::unique_ptr< changeFromPreviousVersion_type > x)
  {
    this->changeFromPreviousVersion_.set (std::move (x));
  }

  const ClassificationItem::changeLog_optional& ClassificationItem::
  changeLog () const
  {
    return this->changeLog_;
  }

  ClassificationItem::changeLog_optional& ClassificationItem::
  changeLog ()
  {
    return this->changeLog_;
  }

  void ClassificationItem::
  changeLog (const changeLog_type& x)
  {
    this->changeLog_.set (x);
  }

  void ClassificationItem::
  changeLog (const changeLog_optional& x)
  {
    this->changeLog_ = x;
  }

  void ClassificationItem::
  changeLog (::std::unique_ptr< changeLog_type > x)
  {
    this->changeLog_.set (std::move (x));
  }

  const ClassificationItem::explanatoryNotes_sequence& ClassificationItem::
  explanatoryNotes () const
  {
    return this->explanatoryNotes_;
  }

  ClassificationItem::explanatoryNotes_sequence& ClassificationItem::
  explanatoryNotes ()
  {
    return this->explanatoryNotes_;
  }

  void ClassificationItem::
  explanatoryNotes (const explanatoryNotes_sequence& s)
  {
    this->explanatoryNotes_ = s;
  }

  const ClassificationItem::futureNotes_sequence& ClassificationItem::
  futureNotes () const
  {
    return this->futureNotes_;
  }

  ClassificationItem::futureNotes_sequence& ClassificationItem::
  futureNotes ()
  {
    return this->futureNotes_;
  }

  void ClassificationItem::
  futureNotes (const futureNotes_sequence& s)
  {
    this->futureNotes_ = s;
  }

  const ClassificationItem::identifier_optional& ClassificationItem::
  identifier () const
  {
    return this->identifier_;
  }

  ClassificationItem::identifier_optional& ClassificationItem::
  identifier ()
  {
    return this->identifier_;
  }

  void ClassificationItem::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ClassificationItem::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ClassificationItem::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ClassificationItem::isGenerated_optional& ClassificationItem::
  isGenerated () const
  {
    return this->isGenerated_;
  }

  ClassificationItem::isGenerated_optional& ClassificationItem::
  isGenerated ()
  {
    return this->isGenerated_;
  }

  void ClassificationItem::
  isGenerated (const isGenerated_type& x)
  {
    this->isGenerated_.set (x);
  }

  void ClassificationItem::
  isGenerated (const isGenerated_optional& x)
  {
    this->isGenerated_ = x;
  }

  const ClassificationItem::isValid_optional& ClassificationItem::
  isValid () const
  {
    return this->isValid_;
  }

  ClassificationItem::isValid_optional& ClassificationItem::
  isValid ()
  {
    return this->isValid_;
  }

  void ClassificationItem::
  isValid (const isValid_type& x)
  {
    this->isValid_.set (x);
  }

  void ClassificationItem::
  isValid (const isValid_optional& x)
  {
    this->isValid_ = x;
  }

  const ClassificationItem::name_sequence& ClassificationItem::
  name () const
  {
    return this->name_;
  }

  ClassificationItem::name_sequence& ClassificationItem::
  name ()
  {
    return this->name_;
  }

  void ClassificationItem::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const ClassificationItem::validDates_optional& ClassificationItem::
  validDates () const
  {
    return this->validDates_;
  }

  ClassificationItem::validDates_optional& ClassificationItem::
  validDates ()
  {
    return this->validDates_;
  }

  void ClassificationItem::
  validDates (const validDates_type& x)
  {
    this->validDates_.set (x);
  }

  void ClassificationItem::
  validDates (const validDates_optional& x)
  {
    this->validDates_ = x;
  }

  void ClassificationItem::
  validDates (::std::unique_ptr< validDates_type > x)
  {
    this->validDates_.set (std::move (x));
  }

  const ClassificationItem::ClassificationItem_excludes_ClassificationItem_sequence& ClassificationItem::
  ClassificationItem_excludes_ClassificationItem () const
  {
    return this->ClassificationItem_excludes_ClassificationItem_;
  }

  ClassificationItem::ClassificationItem_excludes_ClassificationItem_sequence& ClassificationItem::
  ClassificationItem_excludes_ClassificationItem ()
  {
    return this->ClassificationItem_excludes_ClassificationItem_;
  }

  void ClassificationItem::
  ClassificationItem_excludes_ClassificationItem (const ClassificationItem_excludes_ClassificationItem_sequence& s)
  {
    this->ClassificationItem_excludes_ClassificationItem_ = s;
  }

  const ClassificationItem::ClassificationItem_denotes_Category_type& ClassificationItem::
  ClassificationItem_denotes_Category () const
  {
    return this->ClassificationItem_denotes_Category_.get ();
  }

  ClassificationItem::ClassificationItem_denotes_Category_type& ClassificationItem::
  ClassificationItem_denotes_Category ()
  {
    return this->ClassificationItem_denotes_Category_.get ();
  }

  void ClassificationItem::
  ClassificationItem_denotes_Category (const ClassificationItem_denotes_Category_type& x)
  {
    this->ClassificationItem_denotes_Category_.set (x);
  }

  void ClassificationItem::
  ClassificationItem_denotes_Category (::std::unique_ptr< ClassificationItem_denotes_Category_type > x)
  {
    this->ClassificationItem_denotes_Category_.set (std::move (x));
  }

  const ClassificationItem::ClassificationItem_uses_Notation_type& ClassificationItem::
  ClassificationItem_uses_Notation () const
  {
    return this->ClassificationItem_uses_Notation_.get ();
  }

  ClassificationItem::ClassificationItem_uses_Notation_type& ClassificationItem::
  ClassificationItem_uses_Notation ()
  {
    return this->ClassificationItem_uses_Notation_.get ();
  }

  void ClassificationItem::
  ClassificationItem_uses_Notation (const ClassificationItem_uses_Notation_type& x)
  {
    this->ClassificationItem_uses_Notation_.set (x);
  }

  void ClassificationItem::
  ClassificationItem_uses_Notation (::std::unique_ptr< ClassificationItem_uses_Notation_type > x)
  {
    this->ClassificationItem_uses_Notation_.set (std::move (x));
  }

  const ClassificationItem::ClassificationItem_hasRulingBy_AuthorizationSource_sequence& ClassificationItem::
  ClassificationItem_hasRulingBy_AuthorizationSource () const
  {
    return this->ClassificationItem_hasRulingBy_AuthorizationSource_;
  }

  ClassificationItem::ClassificationItem_hasRulingBy_AuthorizationSource_sequence& ClassificationItem::
  ClassificationItem_hasRulingBy_AuthorizationSource ()
  {
    return this->ClassificationItem_hasRulingBy_AuthorizationSource_;
  }

  void ClassificationItem::
  ClassificationItem_hasRulingBy_AuthorizationSource (const ClassificationItem_hasRulingBy_AuthorizationSource_sequence& s)
  {
    this->ClassificationItem_hasRulingBy_AuthorizationSource_ = s;
  }


  // ClassificationItemPosition
  //

  const ClassificationItemPosition::identifier_optional& ClassificationItemPosition::
  identifier () const
  {
    return this->identifier_;
  }

  ClassificationItemPosition::identifier_optional& ClassificationItemPosition::
  identifier ()
  {
    return this->identifier_;
  }

  void ClassificationItemPosition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ClassificationItemPosition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ClassificationItemPosition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ClassificationItemPosition::value_type& ClassificationItemPosition::
  value () const
  {
    return this->value_.get ();
  }

  ClassificationItemPosition::value_type& ClassificationItemPosition::
  value ()
  {
    return this->value_.get ();
  }

  void ClassificationItemPosition::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  const ClassificationItemPosition::ClassificationItemPosition_indexes_ClassificationItem_optional& ClassificationItemPosition::
  ClassificationItemPosition_indexes_ClassificationItem () const
  {
    return this->ClassificationItemPosition_indexes_ClassificationItem_;
  }

  ClassificationItemPosition::ClassificationItemPosition_indexes_ClassificationItem_optional& ClassificationItemPosition::
  ClassificationItemPosition_indexes_ClassificationItem ()
  {
    return this->ClassificationItemPosition_indexes_ClassificationItem_;
  }

  void ClassificationItemPosition::
  ClassificationItemPosition_indexes_ClassificationItem (const ClassificationItemPosition_indexes_ClassificationItem_type& x)
  {
    this->ClassificationItemPosition_indexes_ClassificationItem_.set (x);
  }

  void ClassificationItemPosition::
  ClassificationItemPosition_indexes_ClassificationItem (const ClassificationItemPosition_indexes_ClassificationItem_optional& x)
  {
    this->ClassificationItemPosition_indexes_ClassificationItem_ = x;
  }

  void ClassificationItemPosition::
  ClassificationItemPosition_indexes_ClassificationItem (::std::unique_ptr< ClassificationItemPosition_indexes_ClassificationItem_type > x)
  {
    this->ClassificationItemPosition_indexes_ClassificationItem_.set (std::move (x));
  }


  // ClassificationItemRelationship
  //

  const ClassificationItemRelationship::identifier_optional& ClassificationItemRelationship::
  identifier () const
  {
    return this->identifier_;
  }

  ClassificationItemRelationship::identifier_optional& ClassificationItemRelationship::
  identifier ()
  {
    return this->identifier_;
  }

  void ClassificationItemRelationship::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ClassificationItemRelationship::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ClassificationItemRelationship::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ClassificationItemRelationship::semantics_optional& ClassificationItemRelationship::
  semantics () const
  {
    return this->semantics_;
  }

  ClassificationItemRelationship::semantics_optional& ClassificationItemRelationship::
  semantics ()
  {
    return this->semantics_;
  }

  void ClassificationItemRelationship::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void ClassificationItemRelationship::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void ClassificationItemRelationship::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const ClassificationItemRelationship::ClassificationItemRelationship_hasSource_ClassificationItem_sequence& ClassificationItemRelationship::
  ClassificationItemRelationship_hasSource_ClassificationItem () const
  {
    return this->ClassificationItemRelationship_hasSource_ClassificationItem_;
  }

  ClassificationItemRelationship::ClassificationItemRelationship_hasSource_ClassificationItem_sequence& ClassificationItemRelationship::
  ClassificationItemRelationship_hasSource_ClassificationItem ()
  {
    return this->ClassificationItemRelationship_hasSource_ClassificationItem_;
  }

  void ClassificationItemRelationship::
  ClassificationItemRelationship_hasSource_ClassificationItem (const ClassificationItemRelationship_hasSource_ClassificationItem_sequence& s)
  {
    this->ClassificationItemRelationship_hasSource_ClassificationItem_ = s;
  }

  const ClassificationItemRelationship::ClassificationItemRelationship_hasTarget_ClassificationItem_sequence& ClassificationItemRelationship::
  ClassificationItemRelationship_hasTarget_ClassificationItem () const
  {
    return this->ClassificationItemRelationship_hasTarget_ClassificationItem_;
  }

  ClassificationItemRelationship::ClassificationItemRelationship_hasTarget_ClassificationItem_sequence& ClassificationItemRelationship::
  ClassificationItemRelationship_hasTarget_ClassificationItem ()
  {
    return this->ClassificationItemRelationship_hasTarget_ClassificationItem_;
  }

  void ClassificationItemRelationship::
  ClassificationItemRelationship_hasTarget_ClassificationItem (const ClassificationItemRelationship_hasTarget_ClassificationItem_sequence& s)
  {
    this->ClassificationItemRelationship_hasTarget_ClassificationItem_ = s;
  }


  // ClassificationItemStructure
  //

  const ClassificationItemStructure::displayLabel_sequence& ClassificationItemStructure::
  displayLabel () const
  {
    return this->displayLabel_;
  }

  ClassificationItemStructure::displayLabel_sequence& ClassificationItemStructure::
  displayLabel ()
  {
    return this->displayLabel_;
  }

  void ClassificationItemStructure::
  displayLabel (const displayLabel_sequence& s)
  {
    this->displayLabel_ = s;
  }

  const ClassificationItemStructure::identifier_optional& ClassificationItemStructure::
  identifier () const
  {
    return this->identifier_;
  }

  ClassificationItemStructure::identifier_optional& ClassificationItemStructure::
  identifier ()
  {
    return this->identifier_;
  }

  void ClassificationItemStructure::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ClassificationItemStructure::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ClassificationItemStructure::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ClassificationItemStructure::name_sequence& ClassificationItemStructure::
  name () const
  {
    return this->name_;
  }

  ClassificationItemStructure::name_sequence& ClassificationItemStructure::
  name ()
  {
    return this->name_;
  }

  void ClassificationItemStructure::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const ClassificationItemStructure::purpose_optional& ClassificationItemStructure::
  purpose () const
  {
    return this->purpose_;
  }

  ClassificationItemStructure::purpose_optional& ClassificationItemStructure::
  purpose ()
  {
    return this->purpose_;
  }

  void ClassificationItemStructure::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void ClassificationItemStructure::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void ClassificationItemStructure::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const ClassificationItemStructure::semantics_optional& ClassificationItemStructure::
  semantics () const
  {
    return this->semantics_;
  }

  ClassificationItemStructure::semantics_optional& ClassificationItemStructure::
  semantics ()
  {
    return this->semantics_;
  }

  void ClassificationItemStructure::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void ClassificationItemStructure::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void ClassificationItemStructure::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const ClassificationItemStructure::specification_optional& ClassificationItemStructure::
  specification () const
  {
    return this->specification_;
  }

  ClassificationItemStructure::specification_optional& ClassificationItemStructure::
  specification ()
  {
    return this->specification_;
  }

  void ClassificationItemStructure::
  specification (const specification_type& x)
  {
    this->specification_.set (x);
  }

  void ClassificationItemStructure::
  specification (const specification_optional& x)
  {
    this->specification_ = x;
  }

  void ClassificationItemStructure::
  specification (::std::unique_ptr< specification_type > x)
  {
    this->specification_.set (std::move (x));
  }

  const ClassificationItemStructure::topology_optional& ClassificationItemStructure::
  topology () const
  {
    return this->topology_;
  }

  ClassificationItemStructure::topology_optional& ClassificationItemStructure::
  topology ()
  {
    return this->topology_;
  }

  void ClassificationItemStructure::
  topology (const topology_type& x)
  {
    this->topology_.set (x);
  }

  void ClassificationItemStructure::
  topology (const topology_optional& x)
  {
    this->topology_ = x;
  }

  void ClassificationItemStructure::
  topology (::std::unique_ptr< topology_type > x)
  {
    this->topology_.set (std::move (x));
  }

  const ClassificationItemStructure::totality_optional& ClassificationItemStructure::
  totality () const
  {
    return this->totality_;
  }

  ClassificationItemStructure::totality_optional& ClassificationItemStructure::
  totality ()
  {
    return this->totality_;
  }

  void ClassificationItemStructure::
  totality (const totality_type& x)
  {
    this->totality_.set (x);
  }

  void ClassificationItemStructure::
  totality (const totality_optional& x)
  {
    this->totality_ = x;
  }

  void ClassificationItemStructure::
  totality (::std::unique_ptr< totality_type > x)
  {
    this->totality_.set (std::move (x));
  }

  const ClassificationItemStructure::ClassificationItemStructure_structures_StatisticalClassification_optional& ClassificationItemStructure::
  ClassificationItemStructure_structures_StatisticalClassification () const
  {
    return this->ClassificationItemStructure_structures_StatisticalClassification_;
  }

  ClassificationItemStructure::ClassificationItemStructure_structures_StatisticalClassification_optional& ClassificationItemStructure::
  ClassificationItemStructure_structures_StatisticalClassification ()
  {
    return this->ClassificationItemStructure_structures_StatisticalClassification_;
  }

  void ClassificationItemStructure::
  ClassificationItemStructure_structures_StatisticalClassification (const ClassificationItemStructure_structures_StatisticalClassification_type& x)
  {
    this->ClassificationItemStructure_structures_StatisticalClassification_.set (x);
  }

  void ClassificationItemStructure::
  ClassificationItemStructure_structures_StatisticalClassification (const ClassificationItemStructure_structures_StatisticalClassification_optional& x)
  {
    this->ClassificationItemStructure_structures_StatisticalClassification_ = x;
  }

  void ClassificationItemStructure::
  ClassificationItemStructure_structures_StatisticalClassification (::std::unique_ptr< ClassificationItemStructure_structures_StatisticalClassification_type > x)
  {
    this->ClassificationItemStructure_structures_StatisticalClassification_.set (std::move (x));
  }

  const ClassificationItemStructure::ClassificationItemStructure_has_ClassificationItemRelationship_sequence& ClassificationItemStructure::
  ClassificationItemStructure_has_ClassificationItemRelationship () const
  {
    return this->ClassificationItemStructure_has_ClassificationItemRelationship_;
  }

  ClassificationItemStructure::ClassificationItemStructure_has_ClassificationItemRelationship_sequence& ClassificationItemStructure::
  ClassificationItemStructure_has_ClassificationItemRelationship ()
  {
    return this->ClassificationItemStructure_has_ClassificationItemRelationship_;
  }

  void ClassificationItemStructure::
  ClassificationItemStructure_has_ClassificationItemRelationship (const ClassificationItemStructure_has_ClassificationItemRelationship_sequence& s)
  {
    this->ClassificationItemStructure_has_ClassificationItemRelationship_ = s;
  }


  // ClassificationPosition
  //

  const ClassificationPosition::identifier_optional& ClassificationPosition::
  identifier () const
  {
    return this->identifier_;
  }

  ClassificationPosition::identifier_optional& ClassificationPosition::
  identifier ()
  {
    return this->identifier_;
  }

  void ClassificationPosition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ClassificationPosition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ClassificationPosition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ClassificationPosition::value_type& ClassificationPosition::
  value () const
  {
    return this->value_.get ();
  }

  ClassificationPosition::value_type& ClassificationPosition::
  value ()
  {
    return this->value_.get ();
  }

  void ClassificationPosition::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  const ClassificationPosition::ClassificationPosition_indexes_StatisticalClassification_optional& ClassificationPosition::
  ClassificationPosition_indexes_StatisticalClassification () const
  {
    return this->ClassificationPosition_indexes_StatisticalClassification_;
  }

  ClassificationPosition::ClassificationPosition_indexes_StatisticalClassification_optional& ClassificationPosition::
  ClassificationPosition_indexes_StatisticalClassification ()
  {
    return this->ClassificationPosition_indexes_StatisticalClassification_;
  }

  void ClassificationPosition::
  ClassificationPosition_indexes_StatisticalClassification (const ClassificationPosition_indexes_StatisticalClassification_type& x)
  {
    this->ClassificationPosition_indexes_StatisticalClassification_.set (x);
  }

  void ClassificationPosition::
  ClassificationPosition_indexes_StatisticalClassification (const ClassificationPosition_indexes_StatisticalClassification_optional& x)
  {
    this->ClassificationPosition_indexes_StatisticalClassification_ = x;
  }

  void ClassificationPosition::
  ClassificationPosition_indexes_StatisticalClassification (::std::unique_ptr< ClassificationPosition_indexes_StatisticalClassification_type > x)
  {
    this->ClassificationPosition_indexes_StatisticalClassification_.set (std::move (x));
  }


  // ClassificationSeries
  //

  const ClassificationSeries::allowsDuplicates_type& ClassificationSeries::
  allowsDuplicates () const
  {
    return this->allowsDuplicates_.get ();
  }

  ClassificationSeries::allowsDuplicates_type& ClassificationSeries::
  allowsDuplicates ()
  {
    return this->allowsDuplicates_.get ();
  }

  void ClassificationSeries::
  allowsDuplicates (const allowsDuplicates_type& x)
  {
    this->allowsDuplicates_.set (x);
  }

  const ClassificationSeries::catalogDetails_optional& ClassificationSeries::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  ClassificationSeries::catalogDetails_optional& ClassificationSeries::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void ClassificationSeries::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void ClassificationSeries::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void ClassificationSeries::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const ClassificationSeries::context_optional& ClassificationSeries::
  context () const
  {
    return this->context_;
  }

  ClassificationSeries::context_optional& ClassificationSeries::
  context ()
  {
    return this->context_;
  }

  void ClassificationSeries::
  context (const context_type& x)
  {
    this->context_.set (x);
  }

  void ClassificationSeries::
  context (const context_optional& x)
  {
    this->context_ = x;
  }

  void ClassificationSeries::
  context (::std::unique_ptr< context_type > x)
  {
    this->context_.set (std::move (x));
  }

  const ClassificationSeries::identifier_optional& ClassificationSeries::
  identifier () const
  {
    return this->identifier_;
  }

  ClassificationSeries::identifier_optional& ClassificationSeries::
  identifier ()
  {
    return this->identifier_;
  }

  void ClassificationSeries::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ClassificationSeries::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ClassificationSeries::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ClassificationSeries::keyword_sequence& ClassificationSeries::
  keyword () const
  {
    return this->keyword_;
  }

  ClassificationSeries::keyword_sequence& ClassificationSeries::
  keyword ()
  {
    return this->keyword_;
  }

  void ClassificationSeries::
  keyword (const keyword_sequence& s)
  {
    this->keyword_ = s;
  }

  const ClassificationSeries::name_sequence& ClassificationSeries::
  name () const
  {
    return this->name_;
  }

  ClassificationSeries::name_sequence& ClassificationSeries::
  name ()
  {
    return this->name_;
  }

  void ClassificationSeries::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const ClassificationSeries::objectsOrUnitsClassified_optional& ClassificationSeries::
  objectsOrUnitsClassified () const
  {
    return this->objectsOrUnitsClassified_;
  }

  ClassificationSeries::objectsOrUnitsClassified_optional& ClassificationSeries::
  objectsOrUnitsClassified ()
  {
    return this->objectsOrUnitsClassified_;
  }

  void ClassificationSeries::
  objectsOrUnitsClassified (const objectsOrUnitsClassified_type& x)
  {
    this->objectsOrUnitsClassified_.set (x);
  }

  void ClassificationSeries::
  objectsOrUnitsClassified (const objectsOrUnitsClassified_optional& x)
  {
    this->objectsOrUnitsClassified_ = x;
  }

  void ClassificationSeries::
  objectsOrUnitsClassified (::std::unique_ptr< objectsOrUnitsClassified_type > x)
  {
    this->objectsOrUnitsClassified_.set (std::move (x));
  }

  const ClassificationSeries::purpose_optional& ClassificationSeries::
  purpose () const
  {
    return this->purpose_;
  }

  ClassificationSeries::purpose_optional& ClassificationSeries::
  purpose ()
  {
    return this->purpose_;
  }

  void ClassificationSeries::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void ClassificationSeries::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void ClassificationSeries::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const ClassificationSeries::subject_sequence& ClassificationSeries::
  subject () const
  {
    return this->subject_;
  }

  ClassificationSeries::subject_sequence& ClassificationSeries::
  subject ()
  {
    return this->subject_;
  }

  void ClassificationSeries::
  subject (const subject_sequence& s)
  {
    this->subject_ = s;
  }

  const ClassificationSeries::ClassificationSeries_isOwnedBy_Agent_sequence& ClassificationSeries::
  ClassificationSeries_isOwnedBy_Agent () const
  {
    return this->ClassificationSeries_isOwnedBy_Agent_;
  }

  ClassificationSeries::ClassificationSeries_isOwnedBy_Agent_sequence& ClassificationSeries::
  ClassificationSeries_isOwnedBy_Agent ()
  {
    return this->ClassificationSeries_isOwnedBy_Agent_;
  }

  void ClassificationSeries::
  ClassificationSeries_isOwnedBy_Agent (const ClassificationSeries_isOwnedBy_Agent_sequence& s)
  {
    this->ClassificationSeries_isOwnedBy_Agent_ = s;
  }

  const ClassificationSeries::ClassificationSeries_isDefinedBy_Concept_sequence& ClassificationSeries::
  ClassificationSeries_isDefinedBy_Concept () const
  {
    return this->ClassificationSeries_isDefinedBy_Concept_;
  }

  ClassificationSeries::ClassificationSeries_isDefinedBy_Concept_sequence& ClassificationSeries::
  ClassificationSeries_isDefinedBy_Concept ()
  {
    return this->ClassificationSeries_isDefinedBy_Concept_;
  }

  void ClassificationSeries::
  ClassificationSeries_isDefinedBy_Concept (const ClassificationSeries_isDefinedBy_Concept_sequence& s)
  {
    this->ClassificationSeries_isDefinedBy_Concept_ = s;
  }

  const ClassificationSeries::ClassificationSeries_has_StatisticalClassification_sequence& ClassificationSeries::
  ClassificationSeries_has_StatisticalClassification () const
  {
    return this->ClassificationSeries_has_StatisticalClassification_;
  }

  ClassificationSeries::ClassificationSeries_has_StatisticalClassification_sequence& ClassificationSeries::
  ClassificationSeries_has_StatisticalClassification ()
  {
    return this->ClassificationSeries_has_StatisticalClassification_;
  }

  void ClassificationSeries::
  ClassificationSeries_has_StatisticalClassification (const ClassificationSeries_has_StatisticalClassification_sequence& s)
  {
    this->ClassificationSeries_has_StatisticalClassification_ = s;
  }

  const ClassificationSeries::ClassificationSeries_has_ClassificationPosition_sequence& ClassificationSeries::
  ClassificationSeries_has_ClassificationPosition () const
  {
    return this->ClassificationSeries_has_ClassificationPosition_;
  }

  ClassificationSeries::ClassificationSeries_has_ClassificationPosition_sequence& ClassificationSeries::
  ClassificationSeries_has_ClassificationPosition ()
  {
    return this->ClassificationSeries_has_ClassificationPosition_;
  }

  void ClassificationSeries::
  ClassificationSeries_has_ClassificationPosition (const ClassificationSeries_has_ClassificationPosition_sequence& s)
  {
    this->ClassificationSeries_has_ClassificationPosition_ = s;
  }


  // ClassificationSeriesStructure
  //

  const ClassificationSeriesStructure::identifier_optional& ClassificationSeriesStructure::
  identifier () const
  {
    return this->identifier_;
  }

  ClassificationSeriesStructure::identifier_optional& ClassificationSeriesStructure::
  identifier ()
  {
    return this->identifier_;
  }

  void ClassificationSeriesStructure::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ClassificationSeriesStructure::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ClassificationSeriesStructure::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ClassificationSeriesStructure::name_sequence& ClassificationSeriesStructure::
  name () const
  {
    return this->name_;
  }

  ClassificationSeriesStructure::name_sequence& ClassificationSeriesStructure::
  name ()
  {
    return this->name_;
  }

  void ClassificationSeriesStructure::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const ClassificationSeriesStructure::purpose_optional& ClassificationSeriesStructure::
  purpose () const
  {
    return this->purpose_;
  }

  ClassificationSeriesStructure::purpose_optional& ClassificationSeriesStructure::
  purpose ()
  {
    return this->purpose_;
  }

  void ClassificationSeriesStructure::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void ClassificationSeriesStructure::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void ClassificationSeriesStructure::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const ClassificationSeriesStructure::semantics_optional& ClassificationSeriesStructure::
  semantics () const
  {
    return this->semantics_;
  }

  ClassificationSeriesStructure::semantics_optional& ClassificationSeriesStructure::
  semantics ()
  {
    return this->semantics_;
  }

  void ClassificationSeriesStructure::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void ClassificationSeriesStructure::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void ClassificationSeriesStructure::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const ClassificationSeriesStructure::specification_optional& ClassificationSeriesStructure::
  specification () const
  {
    return this->specification_;
  }

  ClassificationSeriesStructure::specification_optional& ClassificationSeriesStructure::
  specification ()
  {
    return this->specification_;
  }

  void ClassificationSeriesStructure::
  specification (const specification_type& x)
  {
    this->specification_.set (x);
  }

  void ClassificationSeriesStructure::
  specification (const specification_optional& x)
  {
    this->specification_ = x;
  }

  void ClassificationSeriesStructure::
  specification (::std::unique_ptr< specification_type > x)
  {
    this->specification_.set (std::move (x));
  }

  const ClassificationSeriesStructure::topology_optional& ClassificationSeriesStructure::
  topology () const
  {
    return this->topology_;
  }

  ClassificationSeriesStructure::topology_optional& ClassificationSeriesStructure::
  topology ()
  {
    return this->topology_;
  }

  void ClassificationSeriesStructure::
  topology (const topology_type& x)
  {
    this->topology_.set (x);
  }

  void ClassificationSeriesStructure::
  topology (const topology_optional& x)
  {
    this->topology_ = x;
  }

  void ClassificationSeriesStructure::
  topology (::std::unique_ptr< topology_type > x)
  {
    this->topology_.set (std::move (x));
  }

  const ClassificationSeriesStructure::totality_optional& ClassificationSeriesStructure::
  totality () const
  {
    return this->totality_;
  }

  ClassificationSeriesStructure::totality_optional& ClassificationSeriesStructure::
  totality ()
  {
    return this->totality_;
  }

  void ClassificationSeriesStructure::
  totality (const totality_type& x)
  {
    this->totality_.set (x);
  }

  void ClassificationSeriesStructure::
  totality (const totality_optional& x)
  {
    this->totality_ = x;
  }

  void ClassificationSeriesStructure::
  totality (::std::unique_ptr< totality_type > x)
  {
    this->totality_.set (std::move (x));
  }

  const ClassificationSeriesStructure::ClassificationSeriesStructure_structures_ClassificationSeries_optional& ClassificationSeriesStructure::
  ClassificationSeriesStructure_structures_ClassificationSeries () const
  {
    return this->ClassificationSeriesStructure_structures_ClassificationSeries_;
  }

  ClassificationSeriesStructure::ClassificationSeriesStructure_structures_ClassificationSeries_optional& ClassificationSeriesStructure::
  ClassificationSeriesStructure_structures_ClassificationSeries ()
  {
    return this->ClassificationSeriesStructure_structures_ClassificationSeries_;
  }

  void ClassificationSeriesStructure::
  ClassificationSeriesStructure_structures_ClassificationSeries (const ClassificationSeriesStructure_structures_ClassificationSeries_type& x)
  {
    this->ClassificationSeriesStructure_structures_ClassificationSeries_.set (x);
  }

  void ClassificationSeriesStructure::
  ClassificationSeriesStructure_structures_ClassificationSeries (const ClassificationSeriesStructure_structures_ClassificationSeries_optional& x)
  {
    this->ClassificationSeriesStructure_structures_ClassificationSeries_ = x;
  }

  void ClassificationSeriesStructure::
  ClassificationSeriesStructure_structures_ClassificationSeries (::std::unique_ptr< ClassificationSeriesStructure_structures_ClassificationSeries_type > x)
  {
    this->ClassificationSeriesStructure_structures_ClassificationSeries_.set (std::move (x));
  }

  const ClassificationSeriesStructure::ClassificationSeriesStructure_has_StatisticalClassificationRelationship_sequence& ClassificationSeriesStructure::
  ClassificationSeriesStructure_has_StatisticalClassificationRelationship () const
  {
    return this->ClassificationSeriesStructure_has_StatisticalClassificationRelationship_;
  }

  ClassificationSeriesStructure::ClassificationSeriesStructure_has_StatisticalClassificationRelationship_sequence& ClassificationSeriesStructure::
  ClassificationSeriesStructure_has_StatisticalClassificationRelationship ()
  {
    return this->ClassificationSeriesStructure_has_StatisticalClassificationRelationship_;
  }

  void ClassificationSeriesStructure::
  ClassificationSeriesStructure_has_StatisticalClassificationRelationship (const ClassificationSeriesStructure_has_StatisticalClassificationRelationship_sequence& s)
  {
    this->ClassificationSeriesStructure_has_StatisticalClassificationRelationship_ = s;
  }


  // Code
  //

  const Code::identifier_optional& Code::
  identifier () const
  {
    return this->identifier_;
  }

  Code::identifier_optional& Code::
  identifier ()
  {
    return this->identifier_;
  }

  void Code::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void Code::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void Code::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const Code::Code_denotes_Category_type& Code::
  Code_denotes_Category () const
  {
    return this->Code_denotes_Category_.get ();
  }

  Code::Code_denotes_Category_type& Code::
  Code_denotes_Category ()
  {
    return this->Code_denotes_Category_.get ();
  }

  void Code::
  Code_denotes_Category (const Code_denotes_Category_type& x)
  {
    this->Code_denotes_Category_.set (x);
  }

  void Code::
  Code_denotes_Category (::std::unique_ptr< Code_denotes_Category_type > x)
  {
    this->Code_denotes_Category_.set (std::move (x));
  }

  const Code::Code_uses_Notation_type& Code::
  Code_uses_Notation () const
  {
    return this->Code_uses_Notation_.get ();
  }

  Code::Code_uses_Notation_type& Code::
  Code_uses_Notation ()
  {
    return this->Code_uses_Notation_.get ();
  }

  void Code::
  Code_uses_Notation (const Code_uses_Notation_type& x)
  {
    this->Code_uses_Notation_.set (x);
  }

  void Code::
  Code_uses_Notation (::std::unique_ptr< Code_uses_Notation_type > x)
  {
    this->Code_uses_Notation_.set (std::move (x));
  }


  // EnumerationDomain
  //

  const EnumerationDomain::identifier_optional& EnumerationDomain::
  identifier () const
  {
    return this->identifier_;
  }

  EnumerationDomain::identifier_optional& EnumerationDomain::
  identifier ()
  {
    return this->identifier_;
  }

  void EnumerationDomain::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void EnumerationDomain::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void EnumerationDomain::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const EnumerationDomain::name_sequence& EnumerationDomain::
  name () const
  {
    return this->name_;
  }

  EnumerationDomain::name_sequence& EnumerationDomain::
  name ()
  {
    return this->name_;
  }

  void EnumerationDomain::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const EnumerationDomain::purpose_optional& EnumerationDomain::
  purpose () const
  {
    return this->purpose_;
  }

  EnumerationDomain::purpose_optional& EnumerationDomain::
  purpose ()
  {
    return this->purpose_;
  }

  void EnumerationDomain::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void EnumerationDomain::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void EnumerationDomain::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const EnumerationDomain::EnumerationDomain_uses_LevelStructure_optional& EnumerationDomain::
  EnumerationDomain_uses_LevelStructure () const
  {
    return this->EnumerationDomain_uses_LevelStructure_;
  }

  EnumerationDomain::EnumerationDomain_uses_LevelStructure_optional& EnumerationDomain::
  EnumerationDomain_uses_LevelStructure ()
  {
    return this->EnumerationDomain_uses_LevelStructure_;
  }

  void EnumerationDomain::
  EnumerationDomain_uses_LevelStructure (const EnumerationDomain_uses_LevelStructure_type& x)
  {
    this->EnumerationDomain_uses_LevelStructure_.set (x);
  }

  void EnumerationDomain::
  EnumerationDomain_uses_LevelStructure (const EnumerationDomain_uses_LevelStructure_optional& x)
  {
    this->EnumerationDomain_uses_LevelStructure_ = x;
  }

  void EnumerationDomain::
  EnumerationDomain_uses_LevelStructure (::std::unique_ptr< EnumerationDomain_uses_LevelStructure_type > x)
  {
    this->EnumerationDomain_uses_LevelStructure_.set (std::move (x));
  }

  const EnumerationDomain::EnumerationDomain_references_CategorySet_optional& EnumerationDomain::
  EnumerationDomain_references_CategorySet () const
  {
    return this->EnumerationDomain_references_CategorySet_;
  }

  EnumerationDomain::EnumerationDomain_references_CategorySet_optional& EnumerationDomain::
  EnumerationDomain_references_CategorySet ()
  {
    return this->EnumerationDomain_references_CategorySet_;
  }

  void EnumerationDomain::
  EnumerationDomain_references_CategorySet (const EnumerationDomain_references_CategorySet_type& x)
  {
    this->EnumerationDomain_references_CategorySet_.set (x);
  }

  void EnumerationDomain::
  EnumerationDomain_references_CategorySet (const EnumerationDomain_references_CategorySet_optional& x)
  {
    this->EnumerationDomain_references_CategorySet_ = x;
  }

  void EnumerationDomain::
  EnumerationDomain_references_CategorySet (::std::unique_ptr< EnumerationDomain_references_CategorySet_type > x)
  {
    this->EnumerationDomain_references_CategorySet_.set (std::move (x));
  }

  const EnumerationDomain::EnumerationDomain_isDefinedBy_Concept_sequence& EnumerationDomain::
  EnumerationDomain_isDefinedBy_Concept () const
  {
    return this->EnumerationDomain_isDefinedBy_Concept_;
  }

  EnumerationDomain::EnumerationDomain_isDefinedBy_Concept_sequence& EnumerationDomain::
  EnumerationDomain_isDefinedBy_Concept ()
  {
    return this->EnumerationDomain_isDefinedBy_Concept_;
  }

  void EnumerationDomain::
  EnumerationDomain_isDefinedBy_Concept (const EnumerationDomain_isDefinedBy_Concept_sequence& s)
  {
    this->EnumerationDomain_isDefinedBy_Concept_ = s;
  }


  // CodeList
  //

  const CodeList::allowsDuplicates_type& CodeList::
  allowsDuplicates () const
  {
    return this->allowsDuplicates_.get ();
  }

  CodeList::allowsDuplicates_type& CodeList::
  allowsDuplicates ()
  {
    return this->allowsDuplicates_.get ();
  }

  void CodeList::
  allowsDuplicates (const allowsDuplicates_type& x)
  {
    this->allowsDuplicates_.set (x);
  }

  const CodeList::CodeList_has_CodePosition_sequence& CodeList::
  CodeList_has_CodePosition () const
  {
    return this->CodeList_has_CodePosition_;
  }

  CodeList::CodeList_has_CodePosition_sequence& CodeList::
  CodeList_has_CodePosition ()
  {
    return this->CodeList_has_CodePosition_;
  }

  void CodeList::
  CodeList_has_CodePosition (const CodeList_has_CodePosition_sequence& s)
  {
    this->CodeList_has_CodePosition_ = s;
  }

  const CodeList::CodeList_has_Code_sequence& CodeList::
  CodeList_has_Code () const
  {
    return this->CodeList_has_Code_;
  }

  CodeList::CodeList_has_Code_sequence& CodeList::
  CodeList_has_Code ()
  {
    return this->CodeList_has_Code_;
  }

  void CodeList::
  CodeList_has_Code (const CodeList_has_Code_sequence& s)
  {
    this->CodeList_has_Code_ = s;
  }


  // CodeListStructure
  //

  const CodeListStructure::identifier_optional& CodeListStructure::
  identifier () const
  {
    return this->identifier_;
  }

  CodeListStructure::identifier_optional& CodeListStructure::
  identifier ()
  {
    return this->identifier_;
  }

  void CodeListStructure::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void CodeListStructure::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void CodeListStructure::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const CodeListStructure::name_sequence& CodeListStructure::
  name () const
  {
    return this->name_;
  }

  CodeListStructure::name_sequence& CodeListStructure::
  name ()
  {
    return this->name_;
  }

  void CodeListStructure::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const CodeListStructure::purpose_optional& CodeListStructure::
  purpose () const
  {
    return this->purpose_;
  }

  CodeListStructure::purpose_optional& CodeListStructure::
  purpose ()
  {
    return this->purpose_;
  }

  void CodeListStructure::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void CodeListStructure::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void CodeListStructure::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const CodeListStructure::semantics_optional& CodeListStructure::
  semantics () const
  {
    return this->semantics_;
  }

  CodeListStructure::semantics_optional& CodeListStructure::
  semantics ()
  {
    return this->semantics_;
  }

  void CodeListStructure::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void CodeListStructure::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void CodeListStructure::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const CodeListStructure::specification_optional& CodeListStructure::
  specification () const
  {
    return this->specification_;
  }

  CodeListStructure::specification_optional& CodeListStructure::
  specification ()
  {
    return this->specification_;
  }

  void CodeListStructure::
  specification (const specification_type& x)
  {
    this->specification_.set (x);
  }

  void CodeListStructure::
  specification (const specification_optional& x)
  {
    this->specification_ = x;
  }

  void CodeListStructure::
  specification (::std::unique_ptr< specification_type > x)
  {
    this->specification_.set (std::move (x));
  }

  const CodeListStructure::topology_type& CodeListStructure::
  topology () const
  {
    return this->topology_.get ();
  }

  CodeListStructure::topology_type& CodeListStructure::
  topology ()
  {
    return this->topology_.get ();
  }

  void CodeListStructure::
  topology (const topology_type& x)
  {
    this->topology_.set (x);
  }

  void CodeListStructure::
  topology (::std::unique_ptr< topology_type > x)
  {
    this->topology_.set (std::move (x));
  }

  const CodeListStructure::totality_optional& CodeListStructure::
  totality () const
  {
    return this->totality_;
  }

  CodeListStructure::totality_optional& CodeListStructure::
  totality ()
  {
    return this->totality_;
  }

  void CodeListStructure::
  totality (const totality_type& x)
  {
    this->totality_.set (x);
  }

  void CodeListStructure::
  totality (const totality_optional& x)
  {
    this->totality_ = x;
  }

  void CodeListStructure::
  totality (::std::unique_ptr< totality_type > x)
  {
    this->totality_.set (std::move (x));
  }

  const CodeListStructure::CodeListStructure_structures_CodeList_optional& CodeListStructure::
  CodeListStructure_structures_CodeList () const
  {
    return this->CodeListStructure_structures_CodeList_;
  }

  CodeListStructure::CodeListStructure_structures_CodeList_optional& CodeListStructure::
  CodeListStructure_structures_CodeList ()
  {
    return this->CodeListStructure_structures_CodeList_;
  }

  void CodeListStructure::
  CodeListStructure_structures_CodeList (const CodeListStructure_structures_CodeList_type& x)
  {
    this->CodeListStructure_structures_CodeList_.set (x);
  }

  void CodeListStructure::
  CodeListStructure_structures_CodeList (const CodeListStructure_structures_CodeList_optional& x)
  {
    this->CodeListStructure_structures_CodeList_ = x;
  }

  void CodeListStructure::
  CodeListStructure_structures_CodeList (::std::unique_ptr< CodeListStructure_structures_CodeList_type > x)
  {
    this->CodeListStructure_structures_CodeList_.set (std::move (x));
  }

  const CodeListStructure::CodeListStructure_has_CodeRelationship_sequence& CodeListStructure::
  CodeListStructure_has_CodeRelationship () const
  {
    return this->CodeListStructure_has_CodeRelationship_;
  }

  CodeListStructure::CodeListStructure_has_CodeRelationship_sequence& CodeListStructure::
  CodeListStructure_has_CodeRelationship ()
  {
    return this->CodeListStructure_has_CodeRelationship_;
  }

  void CodeListStructure::
  CodeListStructure_has_CodeRelationship (const CodeListStructure_has_CodeRelationship_sequence& s)
  {
    this->CodeListStructure_has_CodeRelationship_ = s;
  }


  // CodePosition
  //

  const CodePosition::identifier_optional& CodePosition::
  identifier () const
  {
    return this->identifier_;
  }

  CodePosition::identifier_optional& CodePosition::
  identifier ()
  {
    return this->identifier_;
  }

  void CodePosition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void CodePosition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void CodePosition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const CodePosition::value_type& CodePosition::
  value () const
  {
    return this->value_.get ();
  }

  CodePosition::value_type& CodePosition::
  value ()
  {
    return this->value_.get ();
  }

  void CodePosition::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  const CodePosition::CodePosition_indexes_Code_optional& CodePosition::
  CodePosition_indexes_Code () const
  {
    return this->CodePosition_indexes_Code_;
  }

  CodePosition::CodePosition_indexes_Code_optional& CodePosition::
  CodePosition_indexes_Code ()
  {
    return this->CodePosition_indexes_Code_;
  }

  void CodePosition::
  CodePosition_indexes_Code (const CodePosition_indexes_Code_type& x)
  {
    this->CodePosition_indexes_Code_.set (x);
  }

  void CodePosition::
  CodePosition_indexes_Code (const CodePosition_indexes_Code_optional& x)
  {
    this->CodePosition_indexes_Code_ = x;
  }

  void CodePosition::
  CodePosition_indexes_Code (::std::unique_ptr< CodePosition_indexes_Code_type > x)
  {
    this->CodePosition_indexes_Code_.set (std::move (x));
  }


  // CodeRelationship
  //

  const CodeRelationship::identifier_optional& CodeRelationship::
  identifier () const
  {
    return this->identifier_;
  }

  CodeRelationship::identifier_optional& CodeRelationship::
  identifier ()
  {
    return this->identifier_;
  }

  void CodeRelationship::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void CodeRelationship::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void CodeRelationship::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const CodeRelationship::semantics_optional& CodeRelationship::
  semantics () const
  {
    return this->semantics_;
  }

  CodeRelationship::semantics_optional& CodeRelationship::
  semantics ()
  {
    return this->semantics_;
  }

  void CodeRelationship::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void CodeRelationship::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void CodeRelationship::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const CodeRelationship::CodeRelationship_hasTarget_Code_sequence& CodeRelationship::
  CodeRelationship_hasTarget_Code () const
  {
    return this->CodeRelationship_hasTarget_Code_;
  }

  CodeRelationship::CodeRelationship_hasTarget_Code_sequence& CodeRelationship::
  CodeRelationship_hasTarget_Code ()
  {
    return this->CodeRelationship_hasTarget_Code_;
  }

  void CodeRelationship::
  CodeRelationship_hasTarget_Code (const CodeRelationship_hasTarget_Code_sequence& s)
  {
    this->CodeRelationship_hasTarget_Code_ = s;
  }

  const CodeRelationship::CodeRelationship_hasSource_Code_sequence& CodeRelationship::
  CodeRelationship_hasSource_Code () const
  {
    return this->CodeRelationship_hasSource_Code_;
  }

  CodeRelationship::CodeRelationship_hasSource_Code_sequence& CodeRelationship::
  CodeRelationship_hasSource_Code ()
  {
    return this->CodeRelationship_hasSource_Code_;
  }

  void CodeRelationship::
  CodeRelationship_hasSource_Code (const CodeRelationship_hasSource_Code_sequence& s)
  {
    this->CodeRelationship_hasSource_Code_ = s;
  }


  // ComponentPosition
  //

  const ComponentPosition::identifier_optional& ComponentPosition::
  identifier () const
  {
    return this->identifier_;
  }

  ComponentPosition::identifier_optional& ComponentPosition::
  identifier ()
  {
    return this->identifier_;
  }

  void ComponentPosition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ComponentPosition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ComponentPosition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ComponentPosition::value_type& ComponentPosition::
  value () const
  {
    return this->value_.get ();
  }

  ComponentPosition::value_type& ComponentPosition::
  value ()
  {
    return this->value_.get ();
  }

  void ComponentPosition::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  const ComponentPosition::ComponentPosition_indexes_DataStructureComponent_optional& ComponentPosition::
  ComponentPosition_indexes_DataStructureComponent () const
  {
    return this->ComponentPosition_indexes_DataStructureComponent_;
  }

  ComponentPosition::ComponentPosition_indexes_DataStructureComponent_optional& ComponentPosition::
  ComponentPosition_indexes_DataStructureComponent ()
  {
    return this->ComponentPosition_indexes_DataStructureComponent_;
  }

  void ComponentPosition::
  ComponentPosition_indexes_DataStructureComponent (const ComponentPosition_indexes_DataStructureComponent_type& x)
  {
    this->ComponentPosition_indexes_DataStructureComponent_.set (x);
  }

  void ComponentPosition::
  ComponentPosition_indexes_DataStructureComponent (const ComponentPosition_indexes_DataStructureComponent_optional& x)
  {
    this->ComponentPosition_indexes_DataStructureComponent_ = x;
  }

  void ComponentPosition::
  ComponentPosition_indexes_DataStructureComponent (::std::unique_ptr< ComponentPosition_indexes_DataStructureComponent_type > x)
  {
    this->ComponentPosition_indexes_DataStructureComponent_.set (std::move (x));
  }


  // ConceptMap
  //

  const ConceptMap::correspondence_optional& ConceptMap::
  correspondence () const
  {
    return this->correspondence_;
  }

  ConceptMap::correspondence_optional& ConceptMap::
  correspondence ()
  {
    return this->correspondence_;
  }

  void ConceptMap::
  correspondence (const correspondence_type& x)
  {
    this->correspondence_.set (x);
  }

  void ConceptMap::
  correspondence (const correspondence_optional& x)
  {
    this->correspondence_ = x;
  }

  void ConceptMap::
  correspondence (::std::unique_ptr< correspondence_type > x)
  {
    this->correspondence_.set (std::move (x));
  }

  const ConceptMap::displayLabel_optional& ConceptMap::
  displayLabel () const
  {
    return this->displayLabel_;
  }

  ConceptMap::displayLabel_optional& ConceptMap::
  displayLabel ()
  {
    return this->displayLabel_;
  }

  void ConceptMap::
  displayLabel (const displayLabel_type& x)
  {
    this->displayLabel_.set (x);
  }

  void ConceptMap::
  displayLabel (const displayLabel_optional& x)
  {
    this->displayLabel_ = x;
  }

  void ConceptMap::
  displayLabel (::std::unique_ptr< displayLabel_type > x)
  {
    this->displayLabel_.set (std::move (x));
  }

  const ConceptMap::identifier_optional& ConceptMap::
  identifier () const
  {
    return this->identifier_;
  }

  ConceptMap::identifier_optional& ConceptMap::
  identifier ()
  {
    return this->identifier_;
  }

  void ConceptMap::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ConceptMap::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ConceptMap::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ConceptMap::usage_optional& ConceptMap::
  usage () const
  {
    return this->usage_;
  }

  ConceptMap::usage_optional& ConceptMap::
  usage ()
  {
    return this->usage_;
  }

  void ConceptMap::
  usage (const usage_type& x)
  {
    this->usage_.set (x);
  }

  void ConceptMap::
  usage (const usage_optional& x)
  {
    this->usage_ = x;
  }

  void ConceptMap::
  usage (::std::unique_ptr< usage_type > x)
  {
    this->usage_.set (std::move (x));
  }

  const ConceptMap::validDates_optional& ConceptMap::
  validDates () const
  {
    return this->validDates_;
  }

  ConceptMap::validDates_optional& ConceptMap::
  validDates ()
  {
    return this->validDates_;
  }

  void ConceptMap::
  validDates (const validDates_type& x)
  {
    this->validDates_.set (x);
  }

  void ConceptMap::
  validDates (const validDates_optional& x)
  {
    this->validDates_ = x;
  }

  void ConceptMap::
  validDates (::std::unique_ptr< validDates_type > x)
  {
    this->validDates_.set (std::move (x));
  }

  const ConceptMap::ConceptMap_hasSource_Concept_sequence& ConceptMap::
  ConceptMap_hasSource_Concept () const
  {
    return this->ConceptMap_hasSource_Concept_;
  }

  ConceptMap::ConceptMap_hasSource_Concept_sequence& ConceptMap::
  ConceptMap_hasSource_Concept ()
  {
    return this->ConceptMap_hasSource_Concept_;
  }

  void ConceptMap::
  ConceptMap_hasSource_Concept (const ConceptMap_hasSource_Concept_sequence& s)
  {
    this->ConceptMap_hasSource_Concept_ = s;
  }

  const ConceptMap::ConceptMap_hasTarget_Concept_sequence& ConceptMap::
  ConceptMap_hasTarget_Concept () const
  {
    return this->ConceptMap_hasTarget_Concept_;
  }

  ConceptMap::ConceptMap_hasTarget_Concept_sequence& ConceptMap::
  ConceptMap_hasTarget_Concept ()
  {
    return this->ConceptMap_hasTarget_Concept_;
  }

  void ConceptMap::
  ConceptMap_hasTarget_Concept (const ConceptMap_hasTarget_Concept_sequence& s)
  {
    this->ConceptMap_hasTarget_Concept_ = s;
  }


  // ConceptRelationship
  //

  const ConceptRelationship::identifier_optional& ConceptRelationship::
  identifier () const
  {
    return this->identifier_;
  }

  ConceptRelationship::identifier_optional& ConceptRelationship::
  identifier ()
  {
    return this->identifier_;
  }

  void ConceptRelationship::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ConceptRelationship::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ConceptRelationship::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ConceptRelationship::semantics_optional& ConceptRelationship::
  semantics () const
  {
    return this->semantics_;
  }

  ConceptRelationship::semantics_optional& ConceptRelationship::
  semantics ()
  {
    return this->semantics_;
  }

  void ConceptRelationship::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void ConceptRelationship::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void ConceptRelationship::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const ConceptRelationship::ConceptRelationship_hasSource_Concept_type& ConceptRelationship::
  ConceptRelationship_hasSource_Concept () const
  {
    return this->ConceptRelationship_hasSource_Concept_.get ();
  }

  ConceptRelationship::ConceptRelationship_hasSource_Concept_type& ConceptRelationship::
  ConceptRelationship_hasSource_Concept ()
  {
    return this->ConceptRelationship_hasSource_Concept_.get ();
  }

  void ConceptRelationship::
  ConceptRelationship_hasSource_Concept (const ConceptRelationship_hasSource_Concept_type& x)
  {
    this->ConceptRelationship_hasSource_Concept_.set (x);
  }

  void ConceptRelationship::
  ConceptRelationship_hasSource_Concept (::std::unique_ptr< ConceptRelationship_hasSource_Concept_type > x)
  {
    this->ConceptRelationship_hasSource_Concept_.set (std::move (x));
  }

  const ConceptRelationship::ConceptRelationship_hasTarget_Concept_type& ConceptRelationship::
  ConceptRelationship_hasTarget_Concept () const
  {
    return this->ConceptRelationship_hasTarget_Concept_.get ();
  }

  ConceptRelationship::ConceptRelationship_hasTarget_Concept_type& ConceptRelationship::
  ConceptRelationship_hasTarget_Concept ()
  {
    return this->ConceptRelationship_hasTarget_Concept_.get ();
  }

  void ConceptRelationship::
  ConceptRelationship_hasTarget_Concept (const ConceptRelationship_hasTarget_Concept_type& x)
  {
    this->ConceptRelationship_hasTarget_Concept_.set (x);
  }

  void ConceptRelationship::
  ConceptRelationship_hasTarget_Concept (::std::unique_ptr< ConceptRelationship_hasTarget_Concept_type > x)
  {
    this->ConceptRelationship_hasTarget_Concept_.set (std::move (x));
  }


  // ConceptStructure
  //

  const ConceptStructure::identifier_optional& ConceptStructure::
  identifier () const
  {
    return this->identifier_;
  }

  ConceptStructure::identifier_optional& ConceptStructure::
  identifier ()
  {
    return this->identifier_;
  }

  void ConceptStructure::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ConceptStructure::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ConceptStructure::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ConceptStructure::name_sequence& ConceptStructure::
  name () const
  {
    return this->name_;
  }

  ConceptStructure::name_sequence& ConceptStructure::
  name ()
  {
    return this->name_;
  }

  void ConceptStructure::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const ConceptStructure::purpose_optional& ConceptStructure::
  purpose () const
  {
    return this->purpose_;
  }

  ConceptStructure::purpose_optional& ConceptStructure::
  purpose ()
  {
    return this->purpose_;
  }

  void ConceptStructure::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void ConceptStructure::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void ConceptStructure::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const ConceptStructure::semantics_optional& ConceptStructure::
  semantics () const
  {
    return this->semantics_;
  }

  ConceptStructure::semantics_optional& ConceptStructure::
  semantics ()
  {
    return this->semantics_;
  }

  void ConceptStructure::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void ConceptStructure::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void ConceptStructure::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const ConceptStructure::specification_optional& ConceptStructure::
  specification () const
  {
    return this->specification_;
  }

  ConceptStructure::specification_optional& ConceptStructure::
  specification ()
  {
    return this->specification_;
  }

  void ConceptStructure::
  specification (const specification_type& x)
  {
    this->specification_.set (x);
  }

  void ConceptStructure::
  specification (const specification_optional& x)
  {
    this->specification_ = x;
  }

  void ConceptStructure::
  specification (::std::unique_ptr< specification_type > x)
  {
    this->specification_.set (std::move (x));
  }

  const ConceptStructure::topology_optional& ConceptStructure::
  topology () const
  {
    return this->topology_;
  }

  ConceptStructure::topology_optional& ConceptStructure::
  topology ()
  {
    return this->topology_;
  }

  void ConceptStructure::
  topology (const topology_type& x)
  {
    this->topology_.set (x);
  }

  void ConceptStructure::
  topology (const topology_optional& x)
  {
    this->topology_ = x;
  }

  void ConceptStructure::
  topology (::std::unique_ptr< topology_type > x)
  {
    this->topology_.set (std::move (x));
  }

  const ConceptStructure::totality_optional& ConceptStructure::
  totality () const
  {
    return this->totality_;
  }

  ConceptStructure::totality_optional& ConceptStructure::
  totality ()
  {
    return this->totality_;
  }

  void ConceptStructure::
  totality (const totality_type& x)
  {
    this->totality_.set (x);
  }

  void ConceptStructure::
  totality (const totality_optional& x)
  {
    this->totality_ = x;
  }

  void ConceptStructure::
  totality (::std::unique_ptr< totality_type > x)
  {
    this->totality_.set (std::move (x));
  }

  const ConceptStructure::ConceptStructure_structures_ConceptSystem_optional& ConceptStructure::
  ConceptStructure_structures_ConceptSystem () const
  {
    return this->ConceptStructure_structures_ConceptSystem_;
  }

  ConceptStructure::ConceptStructure_structures_ConceptSystem_optional& ConceptStructure::
  ConceptStructure_structures_ConceptSystem ()
  {
    return this->ConceptStructure_structures_ConceptSystem_;
  }

  void ConceptStructure::
  ConceptStructure_structures_ConceptSystem (const ConceptStructure_structures_ConceptSystem_type& x)
  {
    this->ConceptStructure_structures_ConceptSystem_.set (x);
  }

  void ConceptStructure::
  ConceptStructure_structures_ConceptSystem (const ConceptStructure_structures_ConceptSystem_optional& x)
  {
    this->ConceptStructure_structures_ConceptSystem_ = x;
  }

  void ConceptStructure::
  ConceptStructure_structures_ConceptSystem (::std::unique_ptr< ConceptStructure_structures_ConceptSystem_type > x)
  {
    this->ConceptStructure_structures_ConceptSystem_.set (std::move (x));
  }

  const ConceptStructure::ConceptStructure_has_ConceptRelationship_sequence& ConceptStructure::
  ConceptStructure_has_ConceptRelationship () const
  {
    return this->ConceptStructure_has_ConceptRelationship_;
  }

  ConceptStructure::ConceptStructure_has_ConceptRelationship_sequence& ConceptStructure::
  ConceptStructure_has_ConceptRelationship ()
  {
    return this->ConceptStructure_has_ConceptRelationship_;
  }

  void ConceptStructure::
  ConceptStructure_has_ConceptRelationship (const ConceptStructure_has_ConceptRelationship_sequence& s)
  {
    this->ConceptStructure_has_ConceptRelationship_ = s;
  }


  // ConceptSystemCorrespondence
  //

  const ConceptSystemCorrespondence::catalogDetails_optional& ConceptSystemCorrespondence::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  ConceptSystemCorrespondence::catalogDetails_optional& ConceptSystemCorrespondence::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void ConceptSystemCorrespondence::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void ConceptSystemCorrespondence::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void ConceptSystemCorrespondence::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const ConceptSystemCorrespondence::displayLabel_sequence& ConceptSystemCorrespondence::
  displayLabel () const
  {
    return this->displayLabel_;
  }

  ConceptSystemCorrespondence::displayLabel_sequence& ConceptSystemCorrespondence::
  displayLabel ()
  {
    return this->displayLabel_;
  }

  void ConceptSystemCorrespondence::
  displayLabel (const displayLabel_sequence& s)
  {
    this->displayLabel_ = s;
  }

  const ConceptSystemCorrespondence::identifier_optional& ConceptSystemCorrespondence::
  identifier () const
  {
    return this->identifier_;
  }

  ConceptSystemCorrespondence::identifier_optional& ConceptSystemCorrespondence::
  identifier ()
  {
    return this->identifier_;
  }

  void ConceptSystemCorrespondence::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ConceptSystemCorrespondence::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ConceptSystemCorrespondence::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ConceptSystemCorrespondence::purpose_optional& ConceptSystemCorrespondence::
  purpose () const
  {
    return this->purpose_;
  }

  ConceptSystemCorrespondence::purpose_optional& ConceptSystemCorrespondence::
  purpose ()
  {
    return this->purpose_;
  }

  void ConceptSystemCorrespondence::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void ConceptSystemCorrespondence::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void ConceptSystemCorrespondence::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const ConceptSystemCorrespondence::usage_optional& ConceptSystemCorrespondence::
  usage () const
  {
    return this->usage_;
  }

  ConceptSystemCorrespondence::usage_optional& ConceptSystemCorrespondence::
  usage ()
  {
    return this->usage_;
  }

  void ConceptSystemCorrespondence::
  usage (const usage_type& x)
  {
    this->usage_.set (x);
  }

  void ConceptSystemCorrespondence::
  usage (const usage_optional& x)
  {
    this->usage_ = x;
  }

  void ConceptSystemCorrespondence::
  usage (::std::unique_ptr< usage_type > x)
  {
    this->usage_.set (std::move (x));
  }

  const ConceptSystemCorrespondence::ConceptSystemCorrespondence_maps_ConceptSystem_sequence& ConceptSystemCorrespondence::
  ConceptSystemCorrespondence_maps_ConceptSystem () const
  {
    return this->ConceptSystemCorrespondence_maps_ConceptSystem_;
  }

  ConceptSystemCorrespondence::ConceptSystemCorrespondence_maps_ConceptSystem_sequence& ConceptSystemCorrespondence::
  ConceptSystemCorrespondence_maps_ConceptSystem ()
  {
    return this->ConceptSystemCorrespondence_maps_ConceptSystem_;
  }

  void ConceptSystemCorrespondence::
  ConceptSystemCorrespondence_maps_ConceptSystem (const ConceptSystemCorrespondence_maps_ConceptSystem_sequence& s)
  {
    this->ConceptSystemCorrespondence_maps_ConceptSystem_ = s;
  }

  const ConceptSystemCorrespondence::ConceptSystemCorrespondence_has_ConceptMap_sequence& ConceptSystemCorrespondence::
  ConceptSystemCorrespondence_has_ConceptMap () const
  {
    return this->ConceptSystemCorrespondence_has_ConceptMap_;
  }

  ConceptSystemCorrespondence::ConceptSystemCorrespondence_has_ConceptMap_sequence& ConceptSystemCorrespondence::
  ConceptSystemCorrespondence_has_ConceptMap ()
  {
    return this->ConceptSystemCorrespondence_has_ConceptMap_;
  }

  void ConceptSystemCorrespondence::
  ConceptSystemCorrespondence_has_ConceptMap (const ConceptSystemCorrespondence_has_ConceptMap_sequence& s)
  {
    this->ConceptSystemCorrespondence_has_ConceptMap_ = s;
  }


  // ConceptualDomain
  //

  const ConceptualDomain::catalogDetails_optional& ConceptualDomain::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  ConceptualDomain::catalogDetails_optional& ConceptualDomain::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void ConceptualDomain::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void ConceptualDomain::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void ConceptualDomain::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const ConceptualDomain::displayLabel_sequence& ConceptualDomain::
  displayLabel () const
  {
    return this->displayLabel_;
  }

  ConceptualDomain::displayLabel_sequence& ConceptualDomain::
  displayLabel ()
  {
    return this->displayLabel_;
  }

  void ConceptualDomain::
  displayLabel (const displayLabel_sequence& s)
  {
    this->displayLabel_ = s;
  }

  const ConceptualDomain::identifier_optional& ConceptualDomain::
  identifier () const
  {
    return this->identifier_;
  }

  ConceptualDomain::identifier_optional& ConceptualDomain::
  identifier ()
  {
    return this->identifier_;
  }

  void ConceptualDomain::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ConceptualDomain::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ConceptualDomain::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ConceptualDomain::ConceptualDomain_isDescribedBy_ValueAndConceptDescription_optional& ConceptualDomain::
  ConceptualDomain_isDescribedBy_ValueAndConceptDescription () const
  {
    return this->ConceptualDomain_isDescribedBy_ValueAndConceptDescription_;
  }

  ConceptualDomain::ConceptualDomain_isDescribedBy_ValueAndConceptDescription_optional& ConceptualDomain::
  ConceptualDomain_isDescribedBy_ValueAndConceptDescription ()
  {
    return this->ConceptualDomain_isDescribedBy_ValueAndConceptDescription_;
  }

  void ConceptualDomain::
  ConceptualDomain_isDescribedBy_ValueAndConceptDescription (const ConceptualDomain_isDescribedBy_ValueAndConceptDescription_type& x)
  {
    this->ConceptualDomain_isDescribedBy_ValueAndConceptDescription_.set (x);
  }

  void ConceptualDomain::
  ConceptualDomain_isDescribedBy_ValueAndConceptDescription (const ConceptualDomain_isDescribedBy_ValueAndConceptDescription_optional& x)
  {
    this->ConceptualDomain_isDescribedBy_ValueAndConceptDescription_ = x;
  }

  void ConceptualDomain::
  ConceptualDomain_isDescribedBy_ValueAndConceptDescription (::std::unique_ptr< ConceptualDomain_isDescribedBy_ValueAndConceptDescription_type > x)
  {
    this->ConceptualDomain_isDescribedBy_ValueAndConceptDescription_.set (std::move (x));
  }

  const ConceptualDomain::ConceptualDomain_takesConceptsFrom_ConceptSystem_optional& ConceptualDomain::
  ConceptualDomain_takesConceptsFrom_ConceptSystem () const
  {
    return this->ConceptualDomain_takesConceptsFrom_ConceptSystem_;
  }

  ConceptualDomain::ConceptualDomain_takesConceptsFrom_ConceptSystem_optional& ConceptualDomain::
  ConceptualDomain_takesConceptsFrom_ConceptSystem ()
  {
    return this->ConceptualDomain_takesConceptsFrom_ConceptSystem_;
  }

  void ConceptualDomain::
  ConceptualDomain_takesConceptsFrom_ConceptSystem (const ConceptualDomain_takesConceptsFrom_ConceptSystem_type& x)
  {
    this->ConceptualDomain_takesConceptsFrom_ConceptSystem_.set (x);
  }

  void ConceptualDomain::
  ConceptualDomain_takesConceptsFrom_ConceptSystem (const ConceptualDomain_takesConceptsFrom_ConceptSystem_optional& x)
  {
    this->ConceptualDomain_takesConceptsFrom_ConceptSystem_ = x;
  }

  void ConceptualDomain::
  ConceptualDomain_takesConceptsFrom_ConceptSystem (::std::unique_ptr< ConceptualDomain_takesConceptsFrom_ConceptSystem_type > x)
  {
    this->ConceptualDomain_takesConceptsFrom_ConceptSystem_.set (std::move (x));
  }


  // ConceptualValue
  //

  const ConceptualValue::ConceptualValue_hasConceptFrom_ConceptualDomain_type& ConceptualValue::
  ConceptualValue_hasConceptFrom_ConceptualDomain () const
  {
    return this->ConceptualValue_hasConceptFrom_ConceptualDomain_.get ();
  }

  ConceptualValue::ConceptualValue_hasConceptFrom_ConceptualDomain_type& ConceptualValue::
  ConceptualValue_hasConceptFrom_ConceptualDomain ()
  {
    return this->ConceptualValue_hasConceptFrom_ConceptualDomain_.get ();
  }

  void ConceptualValue::
  ConceptualValue_hasConceptFrom_ConceptualDomain (const ConceptualValue_hasConceptFrom_ConceptualDomain_type& x)
  {
    this->ConceptualValue_hasConceptFrom_ConceptualDomain_.set (x);
  }

  void ConceptualValue::
  ConceptualValue_hasConceptFrom_ConceptualDomain (::std::unique_ptr< ConceptualValue_hasConceptFrom_ConceptualDomain_type > x)
  {
    this->ConceptualValue_hasConceptFrom_ConceptualDomain_.set (std::move (x));
  }


  // ConceptualVariable
  //

  const ConceptualVariable::descriptiveText_optional& ConceptualVariable::
  descriptiveText () const
  {
    return this->descriptiveText_;
  }

  ConceptualVariable::descriptiveText_optional& ConceptualVariable::
  descriptiveText ()
  {
    return this->descriptiveText_;
  }

  void ConceptualVariable::
  descriptiveText (const descriptiveText_type& x)
  {
    this->descriptiveText_.set (x);
  }

  void ConceptualVariable::
  descriptiveText (const descriptiveText_optional& x)
  {
    this->descriptiveText_ = x;
  }

  void ConceptualVariable::
  descriptiveText (::std::unique_ptr< descriptiveText_type > x)
  {
    this->descriptiveText_.set (std::move (x));
  }

  const ConceptualVariable::unitOfMeasureKind_optional& ConceptualVariable::
  unitOfMeasureKind () const
  {
    return this->unitOfMeasureKind_;
  }

  ConceptualVariable::unitOfMeasureKind_optional& ConceptualVariable::
  unitOfMeasureKind ()
  {
    return this->unitOfMeasureKind_;
  }

  void ConceptualVariable::
  unitOfMeasureKind (const unitOfMeasureKind_type& x)
  {
    this->unitOfMeasureKind_.set (x);
  }

  void ConceptualVariable::
  unitOfMeasureKind (const unitOfMeasureKind_optional& x)
  {
    this->unitOfMeasureKind_ = x;
  }

  void ConceptualVariable::
  unitOfMeasureKind (::std::unique_ptr< unitOfMeasureKind_type > x)
  {
    this->unitOfMeasureKind_.set (std::move (x));
  }

  const ConceptualVariable::ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_optional& ConceptualVariable::
  ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain () const
  {
    return this->ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_;
  }

  ConceptualVariable::ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_optional& ConceptualVariable::
  ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain ()
  {
    return this->ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_;
  }

  void ConceptualVariable::
  ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain (const ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_type& x)
  {
    this->ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_.set (x);
  }

  void ConceptualVariable::
  ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain (const ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_optional& x)
  {
    this->ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_ = x;
  }

  void ConceptualVariable::
  ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain (::std::unique_ptr< ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_type > x)
  {
    this->ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_.set (std::move (x));
  }

  const ConceptualVariable::ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_optional& ConceptualVariable::
  ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain () const
  {
    return this->ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_;
  }

  ConceptualVariable::ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_optional& ConceptualVariable::
  ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain ()
  {
    return this->ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_;
  }

  void ConceptualVariable::
  ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain (const ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_type& x)
  {
    this->ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_.set (x);
  }

  void ConceptualVariable::
  ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain (const ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_optional& x)
  {
    this->ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_ = x;
  }

  void ConceptualVariable::
  ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain (::std::unique_ptr< ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_type > x)
  {
    this->ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_.set (std::move (x));
  }

  const ConceptualVariable::ConceptualVariable_measures_UnitType_optional& ConceptualVariable::
  ConceptualVariable_measures_UnitType () const
  {
    return this->ConceptualVariable_measures_UnitType_;
  }

  ConceptualVariable::ConceptualVariable_measures_UnitType_optional& ConceptualVariable::
  ConceptualVariable_measures_UnitType ()
  {
    return this->ConceptualVariable_measures_UnitType_;
  }

  void ConceptualVariable::
  ConceptualVariable_measures_UnitType (const ConceptualVariable_measures_UnitType_type& x)
  {
    this->ConceptualVariable_measures_UnitType_.set (x);
  }

  void ConceptualVariable::
  ConceptualVariable_measures_UnitType (const ConceptualVariable_measures_UnitType_optional& x)
  {
    this->ConceptualVariable_measures_UnitType_ = x;
  }

  void ConceptualVariable::
  ConceptualVariable_measures_UnitType (::std::unique_ptr< ConceptualVariable_measures_UnitType_type > x)
  {
    this->ConceptualVariable_measures_UnitType_.set (std::move (x));
  }


  // DeterministicImperative
  //


  // ConditionalControlLogic
  //

  const ConditionalControlLogic::condition_type& ConditionalControlLogic::
  condition () const
  {
    return this->condition_.get ();
  }

  ConditionalControlLogic::condition_type& ConditionalControlLogic::
  condition ()
  {
    return this->condition_.get ();
  }

  void ConditionalControlLogic::
  condition (const condition_type& x)
  {
    this->condition_.set (x);
  }

  void ConditionalControlLogic::
  condition (::std::unique_ptr< condition_type > x)
  {
    this->condition_.set (std::move (x));
  }

  const ConditionalControlLogic::construct_type& ConditionalControlLogic::
  construct () const
  {
    return this->construct_.get ();
  }

  ConditionalControlLogic::construct_type& ConditionalControlLogic::
  construct ()
  {
    return this->construct_.get ();
  }

  void ConditionalControlLogic::
  construct (const construct_type& x)
  {
    this->construct_.set (x);
  }

  void ConditionalControlLogic::
  construct (::std::unique_ptr< construct_type > x)
  {
    this->construct_.set (std::move (x));
  }


  // ContextualComponent
  //


  // CorrespondenceTable
  //

  const CorrespondenceTable::catalogDetails_optional& CorrespondenceTable::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  CorrespondenceTable::catalogDetails_optional& CorrespondenceTable::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void CorrespondenceTable::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void CorrespondenceTable::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void CorrespondenceTable::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const CorrespondenceTable::effectiveDates_optional& CorrespondenceTable::
  effectiveDates () const
  {
    return this->effectiveDates_;
  }

  CorrespondenceTable::effectiveDates_optional& CorrespondenceTable::
  effectiveDates ()
  {
    return this->effectiveDates_;
  }

  void CorrespondenceTable::
  effectiveDates (const effectiveDates_type& x)
  {
    this->effectiveDates_.set (x);
  }

  void CorrespondenceTable::
  effectiveDates (const effectiveDates_optional& x)
  {
    this->effectiveDates_ = x;
  }

  void CorrespondenceTable::
  effectiveDates (::std::unique_ptr< effectiveDates_type > x)
  {
    this->effectiveDates_.set (std::move (x));
  }

  const CorrespondenceTable::identifier_optional& CorrespondenceTable::
  identifier () const
  {
    return this->identifier_;
  }

  CorrespondenceTable::identifier_optional& CorrespondenceTable::
  identifier ()
  {
    return this->identifier_;
  }

  void CorrespondenceTable::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void CorrespondenceTable::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void CorrespondenceTable::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const CorrespondenceTable::CorrespondenceTable_hasSource_Level_optional& CorrespondenceTable::
  CorrespondenceTable_hasSource_Level () const
  {
    return this->CorrespondenceTable_hasSource_Level_;
  }

  CorrespondenceTable::CorrespondenceTable_hasSource_Level_optional& CorrespondenceTable::
  CorrespondenceTable_hasSource_Level ()
  {
    return this->CorrespondenceTable_hasSource_Level_;
  }

  void CorrespondenceTable::
  CorrespondenceTable_hasSource_Level (const CorrespondenceTable_hasSource_Level_type& x)
  {
    this->CorrespondenceTable_hasSource_Level_.set (x);
  }

  void CorrespondenceTable::
  CorrespondenceTable_hasSource_Level (const CorrespondenceTable_hasSource_Level_optional& x)
  {
    this->CorrespondenceTable_hasSource_Level_ = x;
  }

  void CorrespondenceTable::
  CorrespondenceTable_hasSource_Level (::std::unique_ptr< CorrespondenceTable_hasSource_Level_type > x)
  {
    this->CorrespondenceTable_hasSource_Level_.set (std::move (x));
  }

  const CorrespondenceTable::CorrespondenceTable_hasTarget_Level_optional& CorrespondenceTable::
  CorrespondenceTable_hasTarget_Level () const
  {
    return this->CorrespondenceTable_hasTarget_Level_;
  }

  CorrespondenceTable::CorrespondenceTable_hasTarget_Level_optional& CorrespondenceTable::
  CorrespondenceTable_hasTarget_Level ()
  {
    return this->CorrespondenceTable_hasTarget_Level_;
  }

  void CorrespondenceTable::
  CorrespondenceTable_hasTarget_Level (const CorrespondenceTable_hasTarget_Level_type& x)
  {
    this->CorrespondenceTable_hasTarget_Level_.set (x);
  }

  void CorrespondenceTable::
  CorrespondenceTable_hasTarget_Level (const CorrespondenceTable_hasTarget_Level_optional& x)
  {
    this->CorrespondenceTable_hasTarget_Level_ = x;
  }

  void CorrespondenceTable::
  CorrespondenceTable_hasTarget_Level (::std::unique_ptr< CorrespondenceTable_hasTarget_Level_type > x)
  {
    this->CorrespondenceTable_hasTarget_Level_.set (std::move (x));
  }

  const CorrespondenceTable::CorrespondenceTable_isOwnedBy_Agent_sequence& CorrespondenceTable::
  CorrespondenceTable_isOwnedBy_Agent () const
  {
    return this->CorrespondenceTable_isOwnedBy_Agent_;
  }

  CorrespondenceTable::CorrespondenceTable_isOwnedBy_Agent_sequence& CorrespondenceTable::
  CorrespondenceTable_isOwnedBy_Agent ()
  {
    return this->CorrespondenceTable_isOwnedBy_Agent_;
  }

  void CorrespondenceTable::
  CorrespondenceTable_isOwnedBy_Agent (const CorrespondenceTable_isOwnedBy_Agent_sequence& s)
  {
    this->CorrespondenceTable_isOwnedBy_Agent_ = s;
  }

  const CorrespondenceTable::CorrespondenceTable_mapsTo_StatisticalClassification_sequence& CorrespondenceTable::
  CorrespondenceTable_mapsTo_StatisticalClassification () const
  {
    return this->CorrespondenceTable_mapsTo_StatisticalClassification_;
  }

  CorrespondenceTable::CorrespondenceTable_mapsTo_StatisticalClassification_sequence& CorrespondenceTable::
  CorrespondenceTable_mapsTo_StatisticalClassification ()
  {
    return this->CorrespondenceTable_mapsTo_StatisticalClassification_;
  }

  void CorrespondenceTable::
  CorrespondenceTable_mapsTo_StatisticalClassification (const CorrespondenceTable_mapsTo_StatisticalClassification_sequence& s)
  {
    this->CorrespondenceTable_mapsTo_StatisticalClassification_ = s;
  }

  const CorrespondenceTable::CorrespondenceTable_hasContact_Agent_sequence& CorrespondenceTable::
  CorrespondenceTable_hasContact_Agent () const
  {
    return this->CorrespondenceTable_hasContact_Agent_;
  }

  CorrespondenceTable::CorrespondenceTable_hasContact_Agent_sequence& CorrespondenceTable::
  CorrespondenceTable_hasContact_Agent ()
  {
    return this->CorrespondenceTable_hasContact_Agent_;
  }

  void CorrespondenceTable::
  CorrespondenceTable_hasContact_Agent (const CorrespondenceTable_hasContact_Agent_sequence& s)
  {
    this->CorrespondenceTable_hasContact_Agent_ = s;
  }

  const CorrespondenceTable::CorrespondenceTable_isMaintainedBy_Agent_optional& CorrespondenceTable::
  CorrespondenceTable_isMaintainedBy_Agent () const
  {
    return this->CorrespondenceTable_isMaintainedBy_Agent_;
  }

  CorrespondenceTable::CorrespondenceTable_isMaintainedBy_Agent_optional& CorrespondenceTable::
  CorrespondenceTable_isMaintainedBy_Agent ()
  {
    return this->CorrespondenceTable_isMaintainedBy_Agent_;
  }

  void CorrespondenceTable::
  CorrespondenceTable_isMaintainedBy_Agent (const CorrespondenceTable_isMaintainedBy_Agent_type& x)
  {
    this->CorrespondenceTable_isMaintainedBy_Agent_.set (x);
  }

  void CorrespondenceTable::
  CorrespondenceTable_isMaintainedBy_Agent (const CorrespondenceTable_isMaintainedBy_Agent_optional& x)
  {
    this->CorrespondenceTable_isMaintainedBy_Agent_ = x;
  }

  void CorrespondenceTable::
  CorrespondenceTable_isMaintainedBy_Agent (::std::unique_ptr< CorrespondenceTable_isMaintainedBy_Agent_type > x)
  {
    this->CorrespondenceTable_isMaintainedBy_Agent_.set (std::move (x));
  }

  const CorrespondenceTable::CorrespondenceTable_has_ConceptMap_sequence& CorrespondenceTable::
  CorrespondenceTable_has_ConceptMap () const
  {
    return this->CorrespondenceTable_has_ConceptMap_;
  }

  CorrespondenceTable::CorrespondenceTable_has_ConceptMap_sequence& CorrespondenceTable::
  CorrespondenceTable_has_ConceptMap ()
  {
    return this->CorrespondenceTable_has_ConceptMap_;
  }

  void CorrespondenceTable::
  CorrespondenceTable_has_ConceptMap (const CorrespondenceTable_has_ConceptMap_sequence& s)
  {
    this->CorrespondenceTable_has_ConceptMap_ = s;
  }


  // ProcessingAgent
  //

  const ProcessingAgent::ProcessingAgent_performs_Activity_sequence& ProcessingAgent::
  ProcessingAgent_performs_Activity () const
  {
    return this->ProcessingAgent_performs_Activity_;
  }

  ProcessingAgent::ProcessingAgent_performs_Activity_sequence& ProcessingAgent::
  ProcessingAgent_performs_Activity ()
  {
    return this->ProcessingAgent_performs_Activity_;
  }

  void ProcessingAgent::
  ProcessingAgent_performs_Activity (const ProcessingAgent_performs_Activity_sequence& s)
  {
    this->ProcessingAgent_performs_Activity_ = s;
  }

  const ProcessingAgent::ProcessingAgent_operatesOn_ProductionEnvironment_sequence& ProcessingAgent::
  ProcessingAgent_operatesOn_ProductionEnvironment () const
  {
    return this->ProcessingAgent_operatesOn_ProductionEnvironment_;
  }

  ProcessingAgent::ProcessingAgent_operatesOn_ProductionEnvironment_sequence& ProcessingAgent::
  ProcessingAgent_operatesOn_ProductionEnvironment ()
  {
    return this->ProcessingAgent_operatesOn_ProductionEnvironment_;
  }

  void ProcessingAgent::
  ProcessingAgent_operatesOn_ProductionEnvironment (const ProcessingAgent_operatesOn_ProductionEnvironment_sequence& s)
  {
    this->ProcessingAgent_operatesOn_ProductionEnvironment_ = s;
  }


  // Curator
  //


  // DataPoint
  //

  const DataPoint::catalogDetails_optional& DataPoint::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  DataPoint::catalogDetails_optional& DataPoint::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void DataPoint::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void DataPoint::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void DataPoint::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const DataPoint::identifier_optional& DataPoint::
  identifier () const
  {
    return this->identifier_;
  }

  DataPoint::identifier_optional& DataPoint::
  identifier ()
  {
    return this->identifier_;
  }

  void DataPoint::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void DataPoint::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void DataPoint::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const DataPoint::DataPoint_correspondsTo_DataStructureComponent_sequence& DataPoint::
  DataPoint_correspondsTo_DataStructureComponent () const
  {
    return this->DataPoint_correspondsTo_DataStructureComponent_;
  }

  DataPoint::DataPoint_correspondsTo_DataStructureComponent_sequence& DataPoint::
  DataPoint_correspondsTo_DataStructureComponent ()
  {
    return this->DataPoint_correspondsTo_DataStructureComponent_;
  }

  void DataPoint::
  DataPoint_correspondsTo_DataStructureComponent (const DataPoint_correspondsTo_DataStructureComponent_sequence& s)
  {
    this->DataPoint_correspondsTo_DataStructureComponent_ = s;
  }

  const DataPoint::DataPoint_isDescribedBy_InstanceVariable_type& DataPoint::
  DataPoint_isDescribedBy_InstanceVariable () const
  {
    return this->DataPoint_isDescribedBy_InstanceVariable_.get ();
  }

  DataPoint::DataPoint_isDescribedBy_InstanceVariable_type& DataPoint::
  DataPoint_isDescribedBy_InstanceVariable ()
  {
    return this->DataPoint_isDescribedBy_InstanceVariable_.get ();
  }

  void DataPoint::
  DataPoint_isDescribedBy_InstanceVariable (const DataPoint_isDescribedBy_InstanceVariable_type& x)
  {
    this->DataPoint_isDescribedBy_InstanceVariable_.set (x);
  }

  void DataPoint::
  DataPoint_isDescribedBy_InstanceVariable (::std::unique_ptr< DataPoint_isDescribedBy_InstanceVariable_type > x)
  {
    this->DataPoint_isDescribedBy_InstanceVariable_.set (std::move (x));
  }


  // DataPointPosition
  //

  const DataPointPosition::identifier_optional& DataPointPosition::
  identifier () const
  {
    return this->identifier_;
  }

  DataPointPosition::identifier_optional& DataPointPosition::
  identifier ()
  {
    return this->identifier_;
  }

  void DataPointPosition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void DataPointPosition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void DataPointPosition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const DataPointPosition::value_type& DataPointPosition::
  value () const
  {
    return this->value_.get ();
  }

  DataPointPosition::value_type& DataPointPosition::
  value ()
  {
    return this->value_.get ();
  }

  void DataPointPosition::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  const DataPointPosition::DataPointPosition_indexes_DataPoint_optional& DataPointPosition::
  DataPointPosition_indexes_DataPoint () const
  {
    return this->DataPointPosition_indexes_DataPoint_;
  }

  DataPointPosition::DataPointPosition_indexes_DataPoint_optional& DataPointPosition::
  DataPointPosition_indexes_DataPoint ()
  {
    return this->DataPointPosition_indexes_DataPoint_;
  }

  void DataPointPosition::
  DataPointPosition_indexes_DataPoint (const DataPointPosition_indexes_DataPoint_type& x)
  {
    this->DataPointPosition_indexes_DataPoint_.set (x);
  }

  void DataPointPosition::
  DataPointPosition_indexes_DataPoint (const DataPointPosition_indexes_DataPoint_optional& x)
  {
    this->DataPointPosition_indexes_DataPoint_ = x;
  }

  void DataPointPosition::
  DataPointPosition_indexes_DataPoint (::std::unique_ptr< DataPointPosition_indexes_DataPoint_type > x)
  {
    this->DataPointPosition_indexes_DataPoint_.set (std::move (x));
  }


  // DataPointRelationship
  //

  const DataPointRelationship::identifier_optional& DataPointRelationship::
  identifier () const
  {
    return this->identifier_;
  }

  DataPointRelationship::identifier_optional& DataPointRelationship::
  identifier ()
  {
    return this->identifier_;
  }

  void DataPointRelationship::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void DataPointRelationship::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void DataPointRelationship::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const DataPointRelationship::semantics_optional& DataPointRelationship::
  semantics () const
  {
    return this->semantics_;
  }

  DataPointRelationship::semantics_optional& DataPointRelationship::
  semantics ()
  {
    return this->semantics_;
  }

  void DataPointRelationship::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void DataPointRelationship::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void DataPointRelationship::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const DataPointRelationship::DataPointRelationship_hasTarget_DataPoint_sequence& DataPointRelationship::
  DataPointRelationship_hasTarget_DataPoint () const
  {
    return this->DataPointRelationship_hasTarget_DataPoint_;
  }

  DataPointRelationship::DataPointRelationship_hasTarget_DataPoint_sequence& DataPointRelationship::
  DataPointRelationship_hasTarget_DataPoint ()
  {
    return this->DataPointRelationship_hasTarget_DataPoint_;
  }

  void DataPointRelationship::
  DataPointRelationship_hasTarget_DataPoint (const DataPointRelationship_hasTarget_DataPoint_sequence& s)
  {
    this->DataPointRelationship_hasTarget_DataPoint_ = s;
  }

  const DataPointRelationship::DataPointRelationship_hasSource_DataPoint_sequence& DataPointRelationship::
  DataPointRelationship_hasSource_DataPoint () const
  {
    return this->DataPointRelationship_hasSource_DataPoint_;
  }

  DataPointRelationship::DataPointRelationship_hasSource_DataPoint_sequence& DataPointRelationship::
  DataPointRelationship_hasSource_DataPoint ()
  {
    return this->DataPointRelationship_hasSource_DataPoint_;
  }

  void DataPointRelationship::
  DataPointRelationship_hasSource_DataPoint (const DataPointRelationship_hasSource_DataPoint_sequence& s)
  {
    this->DataPointRelationship_hasSource_DataPoint_ = s;
  }


  // DataSet
  //

  const DataSet::catalogDetails_optional& DataSet::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  DataSet::catalogDetails_optional& DataSet::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void DataSet::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void DataSet::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void DataSet::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const DataSet::identifier_optional& DataSet::
  identifier () const
  {
    return this->identifier_;
  }

  DataSet::identifier_optional& DataSet::
  identifier ()
  {
    return this->identifier_;
  }

  void DataSet::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void DataSet::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void DataSet::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const DataSet::DataSet_isStructuredBy_DataStructure_sequence& DataSet::
  DataSet_isStructuredBy_DataStructure () const
  {
    return this->DataSet_isStructuredBy_DataStructure_;
  }

  DataSet::DataSet_isStructuredBy_DataStructure_sequence& DataSet::
  DataSet_isStructuredBy_DataStructure ()
  {
    return this->DataSet_isStructuredBy_DataStructure_;
  }

  void DataSet::
  DataSet_isStructuredBy_DataStructure (const DataSet_isStructuredBy_DataStructure_sequence& s)
  {
    this->DataSet_isStructuredBy_DataStructure_ = s;
  }

  const DataSet::DataSet_has_DataPoint_sequence& DataSet::
  DataSet_has_DataPoint () const
  {
    return this->DataSet_has_DataPoint_;
  }

  DataSet::DataSet_has_DataPoint_sequence& DataSet::
  DataSet_has_DataPoint ()
  {
    return this->DataSet_has_DataPoint_;
  }

  void DataSet::
  DataSet_has_DataPoint (const DataSet_has_DataPoint_sequence& s)
  {
    this->DataSet_has_DataPoint_ = s;
  }

  const DataSet::DataSet_has_Key_sequence& DataSet::
  DataSet_has_Key () const
  {
    return this->DataSet_has_Key_;
  }

  DataSet::DataSet_has_Key_sequence& DataSet::
  DataSet_has_Key ()
  {
    return this->DataSet_has_Key_;
  }

  void DataSet::
  DataSet_has_Key (const DataSet_has_Key_sequence& s)
  {
    this->DataSet_has_Key_ = s;
  }


  // DataStore
  //

  const DataStore::aboutMissing_optional& DataStore::
  aboutMissing () const
  {
    return this->aboutMissing_;
  }

  DataStore::aboutMissing_optional& DataStore::
  aboutMissing ()
  {
    return this->aboutMissing_;
  }

  void DataStore::
  aboutMissing (const aboutMissing_type& x)
  {
    this->aboutMissing_.set (x);
  }

  void DataStore::
  aboutMissing (const aboutMissing_optional& x)
  {
    this->aboutMissing_ = x;
  }

  void DataStore::
  aboutMissing (::std::unique_ptr< aboutMissing_type > x)
  {
    this->aboutMissing_.set (std::move (x));
  }

  const DataStore::allowsDuplicates_type& DataStore::
  allowsDuplicates () const
  {
    return this->allowsDuplicates_.get ();
  }

  DataStore::allowsDuplicates_type& DataStore::
  allowsDuplicates ()
  {
    return this->allowsDuplicates_.get ();
  }

  void DataStore::
  allowsDuplicates (const allowsDuplicates_type& x)
  {
    this->allowsDuplicates_.set (x);
  }

  const DataStore::catalogDetails_optional& DataStore::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  DataStore::catalogDetails_optional& DataStore::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void DataStore::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void DataStore::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void DataStore::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const DataStore::characterSet_optional& DataStore::
  characterSet () const
  {
    return this->characterSet_;
  }

  DataStore::characterSet_optional& DataStore::
  characterSet ()
  {
    return this->characterSet_;
  }

  void DataStore::
  characterSet (const characterSet_type& x)
  {
    this->characterSet_.set (x);
  }

  void DataStore::
  characterSet (const characterSet_optional& x)
  {
    this->characterSet_ = x;
  }

  void DataStore::
  characterSet (::std::unique_ptr< characterSet_type > x)
  {
    this->characterSet_.set (std::move (x));
  }

  const DataStore::dataStoreType_optional& DataStore::
  dataStoreType () const
  {
    return this->dataStoreType_;
  }

  DataStore::dataStoreType_optional& DataStore::
  dataStoreType ()
  {
    return this->dataStoreType_;
  }

  void DataStore::
  dataStoreType (const dataStoreType_type& x)
  {
    this->dataStoreType_.set (x);
  }

  void DataStore::
  dataStoreType (const dataStoreType_optional& x)
  {
    this->dataStoreType_ = x;
  }

  void DataStore::
  dataStoreType (::std::unique_ptr< dataStoreType_type > x)
  {
    this->dataStoreType_.set (std::move (x));
  }

  const DataStore::identifier_optional& DataStore::
  identifier () const
  {
    return this->identifier_;
  }

  DataStore::identifier_optional& DataStore::
  identifier ()
  {
    return this->identifier_;
  }

  void DataStore::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void DataStore::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void DataStore::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const DataStore::name_sequence& DataStore::
  name () const
  {
    return this->name_;
  }

  DataStore::name_sequence& DataStore::
  name ()
  {
    return this->name_;
  }

  void DataStore::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const DataStore::purpose_optional& DataStore::
  purpose () const
  {
    return this->purpose_;
  }

  DataStore::purpose_optional& DataStore::
  purpose ()
  {
    return this->purpose_;
  }

  void DataStore::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void DataStore::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void DataStore::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const DataStore::recordCount_optional& DataStore::
  recordCount () const
  {
    return this->recordCount_;
  }

  DataStore::recordCount_optional& DataStore::
  recordCount ()
  {
    return this->recordCount_;
  }

  void DataStore::
  recordCount (const recordCount_type& x)
  {
    this->recordCount_.set (x);
  }

  void DataStore::
  recordCount (const recordCount_optional& x)
  {
    this->recordCount_ = x;
  }

  const DataStore::DataStore_isDefinedBy_Concept_sequence& DataStore::
  DataStore_isDefinedBy_Concept () const
  {
    return this->DataStore_isDefinedBy_Concept_;
  }

  DataStore::DataStore_isDefinedBy_Concept_sequence& DataStore::
  DataStore_isDefinedBy_Concept ()
  {
    return this->DataStore_isDefinedBy_Concept_;
  }

  void DataStore::
  DataStore_isDefinedBy_Concept (const DataStore_isDefinedBy_Concept_sequence& s)
  {
    this->DataStore_isDefinedBy_Concept_ = s;
  }

  const DataStore::DataStore_has_LogicalRecordPosition_sequence& DataStore::
  DataStore_has_LogicalRecordPosition () const
  {
    return this->DataStore_has_LogicalRecordPosition_;
  }

  DataStore::DataStore_has_LogicalRecordPosition_sequence& DataStore::
  DataStore_has_LogicalRecordPosition ()
  {
    return this->DataStore_has_LogicalRecordPosition_;
  }

  void DataStore::
  DataStore_has_LogicalRecordPosition (const DataStore_has_LogicalRecordPosition_sequence& s)
  {
    this->DataStore_has_LogicalRecordPosition_ = s;
  }

  const DataStore::DataStore_has_LogicalRecord_sequence& DataStore::
  DataStore_has_LogicalRecord () const
  {
    return this->DataStore_has_LogicalRecord_;
  }

  DataStore::DataStore_has_LogicalRecord_sequence& DataStore::
  DataStore_has_LogicalRecord ()
  {
    return this->DataStore_has_LogicalRecord_;
  }

  void DataStore::
  DataStore_has_LogicalRecord (const DataStore_has_LogicalRecord_sequence& s)
  {
    this->DataStore_has_LogicalRecord_ = s;
  }

  const DataStore::DataStore_has_RecordRelation_optional& DataStore::
  DataStore_has_RecordRelation () const
  {
    return this->DataStore_has_RecordRelation_;
  }

  DataStore::DataStore_has_RecordRelation_optional& DataStore::
  DataStore_has_RecordRelation ()
  {
    return this->DataStore_has_RecordRelation_;
  }

  void DataStore::
  DataStore_has_RecordRelation (const DataStore_has_RecordRelation_type& x)
  {
    this->DataStore_has_RecordRelation_.set (x);
  }

  void DataStore::
  DataStore_has_RecordRelation (const DataStore_has_RecordRelation_optional& x)
  {
    this->DataStore_has_RecordRelation_ = x;
  }

  void DataStore::
  DataStore_has_RecordRelation (::std::unique_ptr< DataStore_has_RecordRelation_type > x)
  {
    this->DataStore_has_RecordRelation_.set (std::move (x));
  }


  // DataStructure
  //

  const DataStructure::DataStructure_has_ForeignKey_sequence& DataStructure::
  DataStructure_has_ForeignKey () const
  {
    return this->DataStructure_has_ForeignKey_;
  }

  DataStructure::DataStructure_has_ForeignKey_sequence& DataStructure::
  DataStructure_has_ForeignKey ()
  {
    return this->DataStructure_has_ForeignKey_;
  }

  void DataStructure::
  DataStructure_has_ForeignKey (const DataStructure_has_ForeignKey_sequence& s)
  {
    this->DataStructure_has_ForeignKey_ = s;
  }

  const DataStructure::DataStructure_has_DataStructureComponent_sequence& DataStructure::
  DataStructure_has_DataStructureComponent () const
  {
    return this->DataStructure_has_DataStructureComponent_;
  }

  DataStructure::DataStructure_has_DataStructureComponent_sequence& DataStructure::
  DataStructure_has_DataStructureComponent ()
  {
    return this->DataStructure_has_DataStructureComponent_;
  }

  void DataStructure::
  DataStructure_has_DataStructureComponent (const DataStructure_has_DataStructureComponent_sequence& s)
  {
    this->DataStructure_has_DataStructureComponent_ = s;
  }

  const DataStructure::DataStructure_has_ComponentPosition_sequence& DataStructure::
  DataStructure_has_ComponentPosition () const
  {
    return this->DataStructure_has_ComponentPosition_;
  }

  DataStructure::DataStructure_has_ComponentPosition_sequence& DataStructure::
  DataStructure_has_ComponentPosition ()
  {
    return this->DataStructure_has_ComponentPosition_;
  }

  void DataStructure::
  DataStructure_has_ComponentPosition (const DataStructure_has_ComponentPosition_sequence& s)
  {
    this->DataStructure_has_ComponentPosition_ = s;
  }

  const DataStructure::DataStructure_has_PrimaryKey_optional& DataStructure::
  DataStructure_has_PrimaryKey () const
  {
    return this->DataStructure_has_PrimaryKey_;
  }

  DataStructure::DataStructure_has_PrimaryKey_optional& DataStructure::
  DataStructure_has_PrimaryKey ()
  {
    return this->DataStructure_has_PrimaryKey_;
  }

  void DataStructure::
  DataStructure_has_PrimaryKey (const DataStructure_has_PrimaryKey_type& x)
  {
    this->DataStructure_has_PrimaryKey_.set (x);
  }

  void DataStructure::
  DataStructure_has_PrimaryKey (const DataStructure_has_PrimaryKey_optional& x)
  {
    this->DataStructure_has_PrimaryKey_ = x;
  }

  void DataStructure::
  DataStructure_has_PrimaryKey (::std::unique_ptr< DataStructure_has_PrimaryKey_type > x)
  {
    this->DataStructure_has_PrimaryKey_.set (std::move (x));
  }


  // Datum
  //

  const Datum::catalogDetails_optional& Datum::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  Datum::catalogDetails_optional& Datum::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void Datum::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void Datum::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void Datum::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const Datum::identifier_optional& Datum::
  identifier () const
  {
    return this->identifier_;
  }

  Datum::identifier_optional& Datum::
  identifier ()
  {
    return this->identifier_;
  }

  void Datum::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void Datum::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void Datum::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const Datum::Datum_uses_Notation_optional& Datum::
  Datum_uses_Notation () const
  {
    return this->Datum_uses_Notation_;
  }

  Datum::Datum_uses_Notation_optional& Datum::
  Datum_uses_Notation ()
  {
    return this->Datum_uses_Notation_;
  }

  void Datum::
  Datum_uses_Notation (const Datum_uses_Notation_type& x)
  {
    this->Datum_uses_Notation_.set (x);
  }

  void Datum::
  Datum_uses_Notation (const Datum_uses_Notation_optional& x)
  {
    this->Datum_uses_Notation_ = x;
  }

  void Datum::
  Datum_uses_Notation (::std::unique_ptr< Datum_uses_Notation_type > x)
  {
    this->Datum_uses_Notation_.set (std::move (x));
  }

  const Datum::Datum_denotes_ConceptualValue_type& Datum::
  Datum_denotes_ConceptualValue () const
  {
    return this->Datum_denotes_ConceptualValue_.get ();
  }

  Datum::Datum_denotes_ConceptualValue_type& Datum::
  Datum_denotes_ConceptualValue ()
  {
    return this->Datum_denotes_ConceptualValue_.get ();
  }

  void Datum::
  Datum_denotes_ConceptualValue (const Datum_denotes_ConceptualValue_type& x)
  {
    this->Datum_denotes_ConceptualValue_.set (x);
  }

  void Datum::
  Datum_denotes_ConceptualValue (::std::unique_ptr< Datum_denotes_ConceptualValue_type > x)
  {
    this->Datum_denotes_ConceptualValue_.set (std::move (x));
  }

  const Datum::Datum_uses_InstanceValue_sequence& Datum::
  Datum_uses_InstanceValue () const
  {
    return this->Datum_uses_InstanceValue_;
  }

  Datum::Datum_uses_InstanceValue_sequence& Datum::
  Datum_uses_InstanceValue ()
  {
    return this->Datum_uses_InstanceValue_;
  }

  void Datum::
  Datum_uses_InstanceValue (const Datum_uses_InstanceValue_sequence& s)
  {
    this->Datum_uses_InstanceValue_ = s;
  }

  const Datum::Datum_isBoundedBy_InstanceVariable_sequence& Datum::
  Datum_isBoundedBy_InstanceVariable () const
  {
    return this->Datum_isBoundedBy_InstanceVariable_;
  }

  Datum::Datum_isBoundedBy_InstanceVariable_sequence& Datum::
  Datum_isBoundedBy_InstanceVariable ()
  {
    return this->Datum_isBoundedBy_InstanceVariable_;
  }

  void Datum::
  Datum_isBoundedBy_InstanceVariable (const Datum_isBoundedBy_InstanceVariable_sequence& s)
  {
    this->Datum_isBoundedBy_InstanceVariable_ = s;
  }


  // InstanceValue
  //

  const InstanceValue::content_optional& InstanceValue::
  content () const
  {
    return this->content_;
  }

  InstanceValue::content_optional& InstanceValue::
  content ()
  {
    return this->content_;
  }

  void InstanceValue::
  content (const content_type& x)
  {
    this->content_.set (x);
  }

  void InstanceValue::
  content (const content_optional& x)
  {
    this->content_ = x;
  }

  void InstanceValue::
  content (::std::unique_ptr< content_type > x)
  {
    this->content_.set (std::move (x));
  }

  const InstanceValue::identifier_optional& InstanceValue::
  identifier () const
  {
    return this->identifier_;
  }

  InstanceValue::identifier_optional& InstanceValue::
  identifier ()
  {
    return this->identifier_;
  }

  void InstanceValue::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void InstanceValue::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void InstanceValue::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const InstanceValue::whiteSpace_optional& InstanceValue::
  whiteSpace () const
  {
    return this->whiteSpace_;
  }

  InstanceValue::whiteSpace_optional& InstanceValue::
  whiteSpace ()
  {
    return this->whiteSpace_;
  }

  void InstanceValue::
  whiteSpace (const whiteSpace_type& x)
  {
    this->whiteSpace_.set (x);
  }

  void InstanceValue::
  whiteSpace (const whiteSpace_optional& x)
  {
    this->whiteSpace_ = x;
  }

  void InstanceValue::
  whiteSpace (::std::unique_ptr< whiteSpace_type > x)
  {
    this->whiteSpace_.set (std::move (x));
  }

  const InstanceValue::InstanceValue_hasValueFrom_ValueDomain_type& InstanceValue::
  InstanceValue_hasValueFrom_ValueDomain () const
  {
    return this->InstanceValue_hasValueFrom_ValueDomain_.get ();
  }

  InstanceValue::InstanceValue_hasValueFrom_ValueDomain_type& InstanceValue::
  InstanceValue_hasValueFrom_ValueDomain ()
  {
    return this->InstanceValue_hasValueFrom_ValueDomain_.get ();
  }

  void InstanceValue::
  InstanceValue_hasValueFrom_ValueDomain (const InstanceValue_hasValueFrom_ValueDomain_type& x)
  {
    this->InstanceValue_hasValueFrom_ValueDomain_.set (x);
  }

  void InstanceValue::
  InstanceValue_hasValueFrom_ValueDomain (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type > x)
  {
    this->InstanceValue_hasValueFrom_ValueDomain_.set (std::move (x));
  }

  const InstanceValue::InstanceValue_isStoredIn_DataPoint_optional& InstanceValue::
  InstanceValue_isStoredIn_DataPoint () const
  {
    return this->InstanceValue_isStoredIn_DataPoint_;
  }

  InstanceValue::InstanceValue_isStoredIn_DataPoint_optional& InstanceValue::
  InstanceValue_isStoredIn_DataPoint ()
  {
    return this->InstanceValue_isStoredIn_DataPoint_;
  }

  void InstanceValue::
  InstanceValue_isStoredIn_DataPoint (const InstanceValue_isStoredIn_DataPoint_type& x)
  {
    this->InstanceValue_isStoredIn_DataPoint_.set (x);
  }

  void InstanceValue::
  InstanceValue_isStoredIn_DataPoint (const InstanceValue_isStoredIn_DataPoint_optional& x)
  {
    this->InstanceValue_isStoredIn_DataPoint_ = x;
  }

  void InstanceValue::
  InstanceValue_isStoredIn_DataPoint (::std::unique_ptr< InstanceValue_isStoredIn_DataPoint_type > x)
  {
    this->InstanceValue_isStoredIn_DataPoint_.set (std::move (x));
  }

  const InstanceValue::InstanceValue_represents_ConceptualValue_optional& InstanceValue::
  InstanceValue_represents_ConceptualValue () const
  {
    return this->InstanceValue_represents_ConceptualValue_;
  }

  InstanceValue::InstanceValue_represents_ConceptualValue_optional& InstanceValue::
  InstanceValue_represents_ConceptualValue ()
  {
    return this->InstanceValue_represents_ConceptualValue_;
  }

  void InstanceValue::
  InstanceValue_represents_ConceptualValue (const InstanceValue_represents_ConceptualValue_type& x)
  {
    this->InstanceValue_represents_ConceptualValue_.set (x);
  }

  void InstanceValue::
  InstanceValue_represents_ConceptualValue (const InstanceValue_represents_ConceptualValue_optional& x)
  {
    this->InstanceValue_represents_ConceptualValue_ = x;
  }

  void InstanceValue::
  InstanceValue_represents_ConceptualValue (::std::unique_ptr< InstanceValue_represents_ConceptualValue_type > x)
  {
    this->InstanceValue_represents_ConceptualValue_.set (std::move (x));
  }


  // KeyMember
  //

  const KeyMember::KeyMember_isBasedOn_DataStructureComponent_sequence& KeyMember::
  KeyMember_isBasedOn_DataStructureComponent () const
  {
    return this->KeyMember_isBasedOn_DataStructureComponent_;
  }

  KeyMember::KeyMember_isBasedOn_DataStructureComponent_sequence& KeyMember::
  KeyMember_isBasedOn_DataStructureComponent ()
  {
    return this->KeyMember_isBasedOn_DataStructureComponent_;
  }

  void KeyMember::
  KeyMember_isBasedOn_DataStructureComponent (const KeyMember_isBasedOn_DataStructureComponent_sequence& s)
  {
    this->KeyMember_isBasedOn_DataStructureComponent_ = s;
  }


  // Descriptor
  //

  const Descriptor::Descriptor_refersTo_ReferenceValue_sequence& Descriptor::
  Descriptor_refersTo_ReferenceValue () const
  {
    return this->Descriptor_refersTo_ReferenceValue_;
  }

  Descriptor::Descriptor_refersTo_ReferenceValue_sequence& Descriptor::
  Descriptor_refersTo_ReferenceValue ()
  {
    return this->Descriptor_refersTo_ReferenceValue_;
  }

  void Descriptor::
  Descriptor_refersTo_ReferenceValue (const Descriptor_refersTo_ReferenceValue_sequence& s)
  {
    this->Descriptor_refersTo_ReferenceValue_ = s;
  }

  const Descriptor::Descriptor_identifies_ReferenceVariable_type& Descriptor::
  Descriptor_identifies_ReferenceVariable () const
  {
    return this->Descriptor_identifies_ReferenceVariable_.get ();
  }

  Descriptor::Descriptor_identifies_ReferenceVariable_type& Descriptor::
  Descriptor_identifies_ReferenceVariable ()
  {
    return this->Descriptor_identifies_ReferenceVariable_.get ();
  }

  void Descriptor::
  Descriptor_identifies_ReferenceVariable (const Descriptor_identifies_ReferenceVariable_type& x)
  {
    this->Descriptor_identifies_ReferenceVariable_.set (x);
  }

  void Descriptor::
  Descriptor_identifies_ReferenceVariable (::std::unique_ptr< Descriptor_identifies_ReferenceVariable_type > x)
  {
    this->Descriptor_identifies_ReferenceVariable_.set (std::move (x));
  }

  const Descriptor::Descriptor_hasValueFrom_DescriptorValueDomain_type& Descriptor::
  Descriptor_hasValueFrom_DescriptorValueDomain () const
  {
    return this->Descriptor_hasValueFrom_DescriptorValueDomain_.get ();
  }

  Descriptor::Descriptor_hasValueFrom_DescriptorValueDomain_type& Descriptor::
  Descriptor_hasValueFrom_DescriptorValueDomain ()
  {
    return this->Descriptor_hasValueFrom_DescriptorValueDomain_.get ();
  }

  void Descriptor::
  Descriptor_hasValueFrom_DescriptorValueDomain (const Descriptor_hasValueFrom_DescriptorValueDomain_type& x)
  {
    this->Descriptor_hasValueFrom_DescriptorValueDomain_.set (x);
  }

  void Descriptor::
  Descriptor_hasValueFrom_DescriptorValueDomain (::std::unique_ptr< Descriptor_hasValueFrom_DescriptorValueDomain_type > x)
  {
    this->Descriptor_hasValueFrom_DescriptorValueDomain_.set (std::move (x));
  }


  // ValueDomain
  //

  const ValueDomain::catalogDetails_optional& ValueDomain::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  ValueDomain::catalogDetails_optional& ValueDomain::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void ValueDomain::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void ValueDomain::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void ValueDomain::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const ValueDomain::displayLabel_sequence& ValueDomain::
  displayLabel () const
  {
    return this->displayLabel_;
  }

  ValueDomain::displayLabel_sequence& ValueDomain::
  displayLabel ()
  {
    return this->displayLabel_;
  }

  void ValueDomain::
  displayLabel (const displayLabel_sequence& s)
  {
    this->displayLabel_ = s;
  }

  const ValueDomain::identifier_optional& ValueDomain::
  identifier () const
  {
    return this->identifier_;
  }

  ValueDomain::identifier_optional& ValueDomain::
  identifier ()
  {
    return this->identifier_;
  }

  void ValueDomain::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ValueDomain::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ValueDomain::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ValueDomain::recommendedDataType_sequence& ValueDomain::
  recommendedDataType () const
  {
    return this->recommendedDataType_;
  }

  ValueDomain::recommendedDataType_sequence& ValueDomain::
  recommendedDataType ()
  {
    return this->recommendedDataType_;
  }

  void ValueDomain::
  recommendedDataType (const recommendedDataType_sequence& s)
  {
    this->recommendedDataType_ = s;
  }


  // SubstantiveValueDomain
  //

  const SubstantiveValueDomain::SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_optional& SubstantiveValueDomain::
  SubstantiveValueDomain_takesValuesFrom_EnumerationDomain () const
  {
    return this->SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_;
  }

  SubstantiveValueDomain::SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_optional& SubstantiveValueDomain::
  SubstantiveValueDomain_takesValuesFrom_EnumerationDomain ()
  {
    return this->SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_;
  }

  void SubstantiveValueDomain::
  SubstantiveValueDomain_takesValuesFrom_EnumerationDomain (const SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_type& x)
  {
    this->SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_.set (x);
  }

  void SubstantiveValueDomain::
  SubstantiveValueDomain_takesValuesFrom_EnumerationDomain (const SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_optional& x)
  {
    this->SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_ = x;
  }

  void SubstantiveValueDomain::
  SubstantiveValueDomain_takesValuesFrom_EnumerationDomain (::std::unique_ptr< SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_type > x)
  {
    this->SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_.set (std::move (x));
  }

  const SubstantiveValueDomain::SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_optional& SubstantiveValueDomain::
  SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription () const
  {
    return this->SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_;
  }

  SubstantiveValueDomain::SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_optional& SubstantiveValueDomain::
  SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription ()
  {
    return this->SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_;
  }

  void SubstantiveValueDomain::
  SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription (const SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_type& x)
  {
    this->SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_.set (x);
  }

  void SubstantiveValueDomain::
  SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription (const SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_optional& x)
  {
    this->SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_ = x;
  }

  void SubstantiveValueDomain::
  SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription (::std::unique_ptr< SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_type > x)
  {
    this->SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_.set (std::move (x));
  }

  const SubstantiveValueDomain::SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_optional& SubstantiveValueDomain::
  SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain () const
  {
    return this->SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_;
  }

  SubstantiveValueDomain::SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_optional& SubstantiveValueDomain::
  SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain ()
  {
    return this->SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_;
  }

  void SubstantiveValueDomain::
  SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain (const SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_type& x)
  {
    this->SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_.set (x);
  }

  void SubstantiveValueDomain::
  SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain (const SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_optional& x)
  {
    this->SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_ = x;
  }

  void SubstantiveValueDomain::
  SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain (::std::unique_ptr< SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_type > x)
  {
    this->SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_.set (std::move (x));
  }


  // DescriptorValueDomain
  //


  // RepresentedVariable
  //

  const RepresentedVariable::describedUnitOfMeasure_optional& RepresentedVariable::
  describedUnitOfMeasure () const
  {
    return this->describedUnitOfMeasure_;
  }

  RepresentedVariable::describedUnitOfMeasure_optional& RepresentedVariable::
  describedUnitOfMeasure ()
  {
    return this->describedUnitOfMeasure_;
  }

  void RepresentedVariable::
  describedUnitOfMeasure (const describedUnitOfMeasure_type& x)
  {
    this->describedUnitOfMeasure_.set (x);
  }

  void RepresentedVariable::
  describedUnitOfMeasure (const describedUnitOfMeasure_optional& x)
  {
    this->describedUnitOfMeasure_ = x;
  }

  void RepresentedVariable::
  describedUnitOfMeasure (::std::unique_ptr< describedUnitOfMeasure_type > x)
  {
    this->describedUnitOfMeasure_.set (std::move (x));
  }

  const RepresentedVariable::hasIntendedDataType_optional& RepresentedVariable::
  hasIntendedDataType () const
  {
    return this->hasIntendedDataType_;
  }

  RepresentedVariable::hasIntendedDataType_optional& RepresentedVariable::
  hasIntendedDataType ()
  {
    return this->hasIntendedDataType_;
  }

  void RepresentedVariable::
  hasIntendedDataType (const hasIntendedDataType_type& x)
  {
    this->hasIntendedDataType_.set (x);
  }

  void RepresentedVariable::
  hasIntendedDataType (const hasIntendedDataType_optional& x)
  {
    this->hasIntendedDataType_ = x;
  }

  void RepresentedVariable::
  hasIntendedDataType (::std::unique_ptr< hasIntendedDataType_type > x)
  {
    this->hasIntendedDataType_.set (std::move (x));
  }

  const RepresentedVariable::simpleUnitOfMeasure_optional& RepresentedVariable::
  simpleUnitOfMeasure () const
  {
    return this->simpleUnitOfMeasure_;
  }

  RepresentedVariable::simpleUnitOfMeasure_optional& RepresentedVariable::
  simpleUnitOfMeasure ()
  {
    return this->simpleUnitOfMeasure_;
  }

  void RepresentedVariable::
  simpleUnitOfMeasure (const simpleUnitOfMeasure_type& x)
  {
    this->simpleUnitOfMeasure_.set (x);
  }

  void RepresentedVariable::
  simpleUnitOfMeasure (const simpleUnitOfMeasure_optional& x)
  {
    this->simpleUnitOfMeasure_ = x;
  }

  void RepresentedVariable::
  simpleUnitOfMeasure (::std::unique_ptr< simpleUnitOfMeasure_type > x)
  {
    this->simpleUnitOfMeasure_.set (std::move (x));
  }

  const RepresentedVariable::RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_sequence& RepresentedVariable::
  RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain () const
  {
    return this->RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_;
  }

  RepresentedVariable::RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_sequence& RepresentedVariable::
  RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain ()
  {
    return this->RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_;
  }

  void RepresentedVariable::
  RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain (const RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_sequence& s)
  {
    this->RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_ = s;
  }

  const RepresentedVariable::RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_optional& RepresentedVariable::
  RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain () const
  {
    return this->RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_;
  }

  RepresentedVariable::RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_optional& RepresentedVariable::
  RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain ()
  {
    return this->RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_;
  }

  void RepresentedVariable::
  RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain (const RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_type& x)
  {
    this->RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_.set (x);
  }

  void RepresentedVariable::
  RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain (const RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_optional& x)
  {
    this->RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_ = x;
  }

  void RepresentedVariable::
  RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain (::std::unique_ptr< RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_type > x)
  {
    this->RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_.set (std::move (x));
  }


  // DescriptorVariable
  //

  const DescriptorVariable::DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_optional& DescriptorVariable::
  DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain () const
  {
    return this->DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_;
  }

  DescriptorVariable::DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_optional& DescriptorVariable::
  DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain ()
  {
    return this->DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_;
  }

  void DescriptorVariable::
  DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain (const DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_type& x)
  {
    this->DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_.set (x);
  }

  void DescriptorVariable::
  DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain (const DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_optional& x)
  {
    this->DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_ = x;
  }

  void DescriptorVariable::
  DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain (::std::unique_ptr< DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_type > x)
  {
    this->DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_.set (std::move (x));
  }


  // DimensionComponent
  //

  const DimensionComponent::categoricalAdditivity_optional& DimensionComponent::
  categoricalAdditivity () const
  {
    return this->categoricalAdditivity_;
  }

  DimensionComponent::categoricalAdditivity_optional& DimensionComponent::
  categoricalAdditivity ()
  {
    return this->categoricalAdditivity_;
  }

  void DimensionComponent::
  categoricalAdditivity (const categoricalAdditivity_type& x)
  {
    this->categoricalAdditivity_.set (x);
  }

  void DimensionComponent::
  categoricalAdditivity (const categoricalAdditivity_optional& x)
  {
    this->categoricalAdditivity_ = x;
  }

  const DimensionComponent::DimensionComponent_isStructuredBy_ValueDomain_optional& DimensionComponent::
  DimensionComponent_isStructuredBy_ValueDomain () const
  {
    return this->DimensionComponent_isStructuredBy_ValueDomain_;
  }

  DimensionComponent::DimensionComponent_isStructuredBy_ValueDomain_optional& DimensionComponent::
  DimensionComponent_isStructuredBy_ValueDomain ()
  {
    return this->DimensionComponent_isStructuredBy_ValueDomain_;
  }

  void DimensionComponent::
  DimensionComponent_isStructuredBy_ValueDomain (const DimensionComponent_isStructuredBy_ValueDomain_type& x)
  {
    this->DimensionComponent_isStructuredBy_ValueDomain_.set (x);
  }

  void DimensionComponent::
  DimensionComponent_isStructuredBy_ValueDomain (const DimensionComponent_isStructuredBy_ValueDomain_optional& x)
  {
    this->DimensionComponent_isStructuredBy_ValueDomain_ = x;
  }

  void DimensionComponent::
  DimensionComponent_isStructuredBy_ValueDomain (::std::unique_ptr< DimensionComponent_isStructuredBy_ValueDomain_type > x)
  {
    this->DimensionComponent_isStructuredBy_ValueDomain_.set (std::move (x));
  }


  // DimensionGroup
  //

  const DimensionGroup::identifier_optional& DimensionGroup::
  identifier () const
  {
    return this->identifier_;
  }

  DimensionGroup::identifier_optional& DimensionGroup::
  identifier ()
  {
    return this->identifier_;
  }

  void DimensionGroup::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void DimensionGroup::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void DimensionGroup::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const DimensionGroup::name_sequence& DimensionGroup::
  name () const
  {
    return this->name_;
  }

  DimensionGroup::name_sequence& DimensionGroup::
  name ()
  {
    return this->name_;
  }

  void DimensionGroup::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const DimensionGroup::DimensionGroup_has_DimensionComponent_sequence& DimensionGroup::
  DimensionGroup_has_DimensionComponent () const
  {
    return this->DimensionGroup_has_DimensionComponent_;
  }

  DimensionGroup::DimensionGroup_has_DimensionComponent_sequence& DimensionGroup::
  DimensionGroup_has_DimensionComponent ()
  {
    return this->DimensionGroup_has_DimensionComponent_;
  }

  void DimensionGroup::
  DimensionGroup_has_DimensionComponent (const DimensionGroup_has_DimensionComponent_sequence& s)
  {
    this->DimensionGroup_has_DimensionComponent_ = s;
  }


  // DimensionalDataSet
  //

  const DimensionalDataSet::name_sequence& DimensionalDataSet::
  name () const
  {
    return this->name_;
  }

  DimensionalDataSet::name_sequence& DimensionalDataSet::
  name ()
  {
    return this->name_;
  }

  void DimensionalDataSet::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const DimensionalDataSet::DimensionalDataSet_represents_ScopedMeasure_sequence& DimensionalDataSet::
  DimensionalDataSet_represents_ScopedMeasure () const
  {
    return this->DimensionalDataSet_represents_ScopedMeasure_;
  }

  DimensionalDataSet::DimensionalDataSet_represents_ScopedMeasure_sequence& DimensionalDataSet::
  DimensionalDataSet_represents_ScopedMeasure ()
  {
    return this->DimensionalDataSet_represents_ScopedMeasure_;
  }

  void DimensionalDataSet::
  DimensionalDataSet_represents_ScopedMeasure (const DimensionalDataSet_represents_ScopedMeasure_sequence& s)
  {
    this->DimensionalDataSet_represents_ScopedMeasure_ = s;
  }


  // DimensionalDataStructure
  //

  const DimensionalDataStructure::DimensionalDataStructure_uses_DimensionGroup_sequence& DimensionalDataStructure::
  DimensionalDataStructure_uses_DimensionGroup () const
  {
    return this->DimensionalDataStructure_uses_DimensionGroup_;
  }

  DimensionalDataStructure::DimensionalDataStructure_uses_DimensionGroup_sequence& DimensionalDataStructure::
  DimensionalDataStructure_uses_DimensionGroup ()
  {
    return this->DimensionalDataStructure_uses_DimensionGroup_;
  }

  void DimensionalDataStructure::
  DimensionalDataStructure_uses_DimensionGroup (const DimensionalDataStructure_uses_DimensionGroup_sequence& s)
  {
    this->DimensionalDataStructure_uses_DimensionGroup_ = s;
  }


  // Key
  //

  const Key::identifier_optional& Key::
  identifier () const
  {
    return this->identifier_;
  }

  Key::identifier_optional& Key::
  identifier ()
  {
    return this->identifier_;
  }

  void Key::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void Key::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void Key::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const Key::Key_correspondsTo_Unit_optional& Key::
  Key_correspondsTo_Unit () const
  {
    return this->Key_correspondsTo_Unit_;
  }

  Key::Key_correspondsTo_Unit_optional& Key::
  Key_correspondsTo_Unit ()
  {
    return this->Key_correspondsTo_Unit_;
  }

  void Key::
  Key_correspondsTo_Unit (const Key_correspondsTo_Unit_type& x)
  {
    this->Key_correspondsTo_Unit_.set (x);
  }

  void Key::
  Key_correspondsTo_Unit (const Key_correspondsTo_Unit_optional& x)
  {
    this->Key_correspondsTo_Unit_ = x;
  }

  void Key::
  Key_correspondsTo_Unit (::std::unique_ptr< Key_correspondsTo_Unit_type > x)
  {
    this->Key_correspondsTo_Unit_.set (std::move (x));
  }

  const Key::Key_represents_KeyDefinition_optional& Key::
  Key_represents_KeyDefinition () const
  {
    return this->Key_represents_KeyDefinition_;
  }

  Key::Key_represents_KeyDefinition_optional& Key::
  Key_represents_KeyDefinition ()
  {
    return this->Key_represents_KeyDefinition_;
  }

  void Key::
  Key_represents_KeyDefinition (const Key_represents_KeyDefinition_type& x)
  {
    this->Key_represents_KeyDefinition_.set (x);
  }

  void Key::
  Key_represents_KeyDefinition (const Key_represents_KeyDefinition_optional& x)
  {
    this->Key_represents_KeyDefinition_ = x;
  }

  void Key::
  Key_represents_KeyDefinition (::std::unique_ptr< Key_represents_KeyDefinition_type > x)
  {
    this->Key_represents_KeyDefinition_.set (std::move (x));
  }

  const Key::Key_identifies_DataPoint_sequence& Key::
  Key_identifies_DataPoint () const
  {
    return this->Key_identifies_DataPoint_;
  }

  Key::Key_identifies_DataPoint_sequence& Key::
  Key_identifies_DataPoint ()
  {
    return this->Key_identifies_DataPoint_;
  }

  void Key::
  Key_identifies_DataPoint (const Key_identifies_DataPoint_sequence& s)
  {
    this->Key_identifies_DataPoint_ = s;
  }

  const Key::Key_correspondsTo_Universe_optional& Key::
  Key_correspondsTo_Universe () const
  {
    return this->Key_correspondsTo_Universe_;
  }

  Key::Key_correspondsTo_Universe_optional& Key::
  Key_correspondsTo_Universe ()
  {
    return this->Key_correspondsTo_Universe_;
  }

  void Key::
  Key_correspondsTo_Universe (const Key_correspondsTo_Universe_type& x)
  {
    this->Key_correspondsTo_Universe_.set (x);
  }

  void Key::
  Key_correspondsTo_Universe (const Key_correspondsTo_Universe_optional& x)
  {
    this->Key_correspondsTo_Universe_ = x;
  }

  void Key::
  Key_correspondsTo_Universe (::std::unique_ptr< Key_correspondsTo_Universe_type > x)
  {
    this->Key_correspondsTo_Universe_.set (std::move (x));
  }

  const Key::Key_has_KeyMember_sequence& Key::
  Key_has_KeyMember () const
  {
    return this->Key_has_KeyMember_;
  }

  Key::Key_has_KeyMember_sequence& Key::
  Key_has_KeyMember ()
  {
    return this->Key_has_KeyMember_;
  }

  void Key::
  Key_has_KeyMember (const Key_has_KeyMember_sequence& s)
  {
    this->Key_has_KeyMember_ = s;
  }


  // DimensionalKey
  //


  // KeyDefinition
  //

  const KeyDefinition::identifier_optional& KeyDefinition::
  identifier () const
  {
    return this->identifier_;
  }

  KeyDefinition::identifier_optional& KeyDefinition::
  identifier ()
  {
    return this->identifier_;
  }

  void KeyDefinition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void KeyDefinition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void KeyDefinition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const KeyDefinition::KeyDefinition_correspondsTo_Universe_optional& KeyDefinition::
  KeyDefinition_correspondsTo_Universe () const
  {
    return this->KeyDefinition_correspondsTo_Universe_;
  }

  KeyDefinition::KeyDefinition_correspondsTo_Universe_optional& KeyDefinition::
  KeyDefinition_correspondsTo_Universe ()
  {
    return this->KeyDefinition_correspondsTo_Universe_;
  }

  void KeyDefinition::
  KeyDefinition_correspondsTo_Universe (const KeyDefinition_correspondsTo_Universe_type& x)
  {
    this->KeyDefinition_correspondsTo_Universe_.set (x);
  }

  void KeyDefinition::
  KeyDefinition_correspondsTo_Universe (const KeyDefinition_correspondsTo_Universe_optional& x)
  {
    this->KeyDefinition_correspondsTo_Universe_ = x;
  }

  void KeyDefinition::
  KeyDefinition_correspondsTo_Universe (::std::unique_ptr< KeyDefinition_correspondsTo_Universe_type > x)
  {
    this->KeyDefinition_correspondsTo_Universe_.set (std::move (x));
  }

  const KeyDefinition::KeyDefinition_correspondsTo_Unit_optional& KeyDefinition::
  KeyDefinition_correspondsTo_Unit () const
  {
    return this->KeyDefinition_correspondsTo_Unit_;
  }

  KeyDefinition::KeyDefinition_correspondsTo_Unit_optional& KeyDefinition::
  KeyDefinition_correspondsTo_Unit ()
  {
    return this->KeyDefinition_correspondsTo_Unit_;
  }

  void KeyDefinition::
  KeyDefinition_correspondsTo_Unit (const KeyDefinition_correspondsTo_Unit_type& x)
  {
    this->KeyDefinition_correspondsTo_Unit_.set (x);
  }

  void KeyDefinition::
  KeyDefinition_correspondsTo_Unit (const KeyDefinition_correspondsTo_Unit_optional& x)
  {
    this->KeyDefinition_correspondsTo_Unit_ = x;
  }

  void KeyDefinition::
  KeyDefinition_correspondsTo_Unit (::std::unique_ptr< KeyDefinition_correspondsTo_Unit_type > x)
  {
    this->KeyDefinition_correspondsTo_Unit_.set (std::move (x));
  }

  const KeyDefinition::KeyDefinition_has_KeyDefinitionMember_sequence& KeyDefinition::
  KeyDefinition_has_KeyDefinitionMember () const
  {
    return this->KeyDefinition_has_KeyDefinitionMember_;
  }

  KeyDefinition::KeyDefinition_has_KeyDefinitionMember_sequence& KeyDefinition::
  KeyDefinition_has_KeyDefinitionMember ()
  {
    return this->KeyDefinition_has_KeyDefinitionMember_;
  }

  void KeyDefinition::
  KeyDefinition_has_KeyDefinitionMember (const KeyDefinition_has_KeyDefinitionMember_sequence& s)
  {
    this->KeyDefinition_has_KeyDefinitionMember_ = s;
  }


  // DimensionalKeyDefinition
  //


  // DimensionalKeyDefinitionMember
  //

  const DimensionalKeyDefinitionMember::DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_sequence& DimensionalKeyDefinitionMember::
  DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember () const
  {
    return this->DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_;
  }

  DimensionalKeyDefinitionMember::DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_sequence& DimensionalKeyDefinitionMember::
  DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember ()
  {
    return this->DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_;
  }

  void DimensionalKeyDefinitionMember::
  DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember (const DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_sequence& s)
  {
    this->DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_ = s;
  }


  // DimensionalKeyMember
  //

  const DimensionalKeyMember::DimensionalKeyMember_hasValueFrom_CodeList_type& DimensionalKeyMember::
  DimensionalKeyMember_hasValueFrom_CodeList () const
  {
    return this->DimensionalKeyMember_hasValueFrom_CodeList_.get ();
  }

  DimensionalKeyMember::DimensionalKeyMember_hasValueFrom_CodeList_type& DimensionalKeyMember::
  DimensionalKeyMember_hasValueFrom_CodeList ()
  {
    return this->DimensionalKeyMember_hasValueFrom_CodeList_.get ();
  }

  void DimensionalKeyMember::
  DimensionalKeyMember_hasValueFrom_CodeList (const DimensionalKeyMember_hasValueFrom_CodeList_type& x)
  {
    this->DimensionalKeyMember_hasValueFrom_CodeList_.set (x);
  }

  void DimensionalKeyMember::
  DimensionalKeyMember_hasValueFrom_CodeList (::std::unique_ptr< DimensionalKeyMember_hasValueFrom_CodeList_type > x)
  {
    this->DimensionalKeyMember_hasValueFrom_CodeList_.set (std::move (x));
  }


  // ForeignKey
  //

  const ForeignKey::identifier_optional& ForeignKey::
  identifier () const
  {
    return this->identifier_;
  }

  ForeignKey::identifier_optional& ForeignKey::
  identifier ()
  {
    return this->identifier_;
  }

  void ForeignKey::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ForeignKey::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ForeignKey::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ForeignKey::ForeignKey_isComposedOf_ForeignKeyComponent_sequence& ForeignKey::
  ForeignKey_isComposedOf_ForeignKeyComponent () const
  {
    return this->ForeignKey_isComposedOf_ForeignKeyComponent_;
  }

  ForeignKey::ForeignKey_isComposedOf_ForeignKeyComponent_sequence& ForeignKey::
  ForeignKey_isComposedOf_ForeignKeyComponent ()
  {
    return this->ForeignKey_isComposedOf_ForeignKeyComponent_;
  }

  void ForeignKey::
  ForeignKey_isComposedOf_ForeignKeyComponent (const ForeignKey_isComposedOf_ForeignKeyComponent_sequence& s)
  {
    this->ForeignKey_isComposedOf_ForeignKeyComponent_ = s;
  }


  // ForeignKeyComponent
  //

  const ForeignKeyComponent::identifier_optional& ForeignKeyComponent::
  identifier () const
  {
    return this->identifier_;
  }

  ForeignKeyComponent::identifier_optional& ForeignKeyComponent::
  identifier ()
  {
    return this->identifier_;
  }

  void ForeignKeyComponent::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ForeignKeyComponent::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ForeignKeyComponent::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ForeignKeyComponent::ForeignKeyComponent_references_PrimaryKeyComponent_type& ForeignKeyComponent::
  ForeignKeyComponent_references_PrimaryKeyComponent () const
  {
    return this->ForeignKeyComponent_references_PrimaryKeyComponent_.get ();
  }

  ForeignKeyComponent::ForeignKeyComponent_references_PrimaryKeyComponent_type& ForeignKeyComponent::
  ForeignKeyComponent_references_PrimaryKeyComponent ()
  {
    return this->ForeignKeyComponent_references_PrimaryKeyComponent_.get ();
  }

  void ForeignKeyComponent::
  ForeignKeyComponent_references_PrimaryKeyComponent (const ForeignKeyComponent_references_PrimaryKeyComponent_type& x)
  {
    this->ForeignKeyComponent_references_PrimaryKeyComponent_.set (x);
  }

  void ForeignKeyComponent::
  ForeignKeyComponent_references_PrimaryKeyComponent (::std::unique_ptr< ForeignKeyComponent_references_PrimaryKeyComponent_type > x)
  {
    this->ForeignKeyComponent_references_PrimaryKeyComponent_.set (std::move (x));
  }

  const ForeignKeyComponent::ForeignKeyComponent_correspondsTo_DataStructureComponent_type& ForeignKeyComponent::
  ForeignKeyComponent_correspondsTo_DataStructureComponent () const
  {
    return this->ForeignKeyComponent_correspondsTo_DataStructureComponent_.get ();
  }

  ForeignKeyComponent::ForeignKeyComponent_correspondsTo_DataStructureComponent_type& ForeignKeyComponent::
  ForeignKeyComponent_correspondsTo_DataStructureComponent ()
  {
    return this->ForeignKeyComponent_correspondsTo_DataStructureComponent_.get ();
  }

  void ForeignKeyComponent::
  ForeignKeyComponent_correspondsTo_DataStructureComponent (const ForeignKeyComponent_correspondsTo_DataStructureComponent_type& x)
  {
    this->ForeignKeyComponent_correspondsTo_DataStructureComponent_.set (x);
  }

  void ForeignKeyComponent::
  ForeignKeyComponent_correspondsTo_DataStructureComponent (::std::unique_ptr< ForeignKeyComponent_correspondsTo_DataStructureComponent_type > x)
  {
    this->ForeignKeyComponent_correspondsTo_DataStructureComponent_.set (std::move (x));
  }


  // IdentifierComponent
  //


  // Individual
  //

  const Individual::contactInformation_optional& Individual::
  contactInformation () const
  {
    return this->contactInformation_;
  }

  Individual::contactInformation_optional& Individual::
  contactInformation ()
  {
    return this->contactInformation_;
  }

  void Individual::
  contactInformation (const contactInformation_type& x)
  {
    this->contactInformation_.set (x);
  }

  void Individual::
  contactInformation (const contactInformation_optional& x)
  {
    this->contactInformation_ = x;
  }

  void Individual::
  contactInformation (::std::unique_ptr< contactInformation_type > x)
  {
    this->contactInformation_.set (std::move (x));
  }

  const Individual::individualName_sequence& Individual::
  individualName () const
  {
    return this->individualName_;
  }

  Individual::individualName_sequence& Individual::
  individualName ()
  {
    return this->individualName_;
  }

  void Individual::
  individualName (const individualName_sequence& s)
  {
    this->individualName_ = s;
  }


  // InformationFlowDefinition
  //

  const InformationFlowDefinition::identifier_optional& InformationFlowDefinition::
  identifier () const
  {
    return this->identifier_;
  }

  InformationFlowDefinition::identifier_optional& InformationFlowDefinition::
  identifier ()
  {
    return this->identifier_;
  }

  void InformationFlowDefinition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void InformationFlowDefinition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void InformationFlowDefinition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const InformationFlowDefinition::InformationFlowDefinition_from_Parameter_optional& InformationFlowDefinition::
  InformationFlowDefinition_from_Parameter () const
  {
    return this->InformationFlowDefinition_from_Parameter_;
  }

  InformationFlowDefinition::InformationFlowDefinition_from_Parameter_optional& InformationFlowDefinition::
  InformationFlowDefinition_from_Parameter ()
  {
    return this->InformationFlowDefinition_from_Parameter_;
  }

  void InformationFlowDefinition::
  InformationFlowDefinition_from_Parameter (const InformationFlowDefinition_from_Parameter_type& x)
  {
    this->InformationFlowDefinition_from_Parameter_.set (x);
  }

  void InformationFlowDefinition::
  InformationFlowDefinition_from_Parameter (const InformationFlowDefinition_from_Parameter_optional& x)
  {
    this->InformationFlowDefinition_from_Parameter_ = x;
  }

  void InformationFlowDefinition::
  InformationFlowDefinition_from_Parameter (::std::unique_ptr< InformationFlowDefinition_from_Parameter_type > x)
  {
    this->InformationFlowDefinition_from_Parameter_.set (std::move (x));
  }

  const InformationFlowDefinition::InformationFlowDefinition_to_Parameter_sequence& InformationFlowDefinition::
  InformationFlowDefinition_to_Parameter () const
  {
    return this->InformationFlowDefinition_to_Parameter_;
  }

  InformationFlowDefinition::InformationFlowDefinition_to_Parameter_sequence& InformationFlowDefinition::
  InformationFlowDefinition_to_Parameter ()
  {
    return this->InformationFlowDefinition_to_Parameter_;
  }

  void InformationFlowDefinition::
  InformationFlowDefinition_to_Parameter (const InformationFlowDefinition_to_Parameter_sequence& s)
  {
    this->InformationFlowDefinition_to_Parameter_ = s;
  }


  // InstanceKey
  //

  const InstanceKey::InstanceKey_has_InstanceValue_optional& InstanceKey::
  InstanceKey_has_InstanceValue () const
  {
    return this->InstanceKey_has_InstanceValue_;
  }

  InstanceKey::InstanceKey_has_InstanceValue_optional& InstanceKey::
  InstanceKey_has_InstanceValue ()
  {
    return this->InstanceKey_has_InstanceValue_;
  }

  void InstanceKey::
  InstanceKey_has_InstanceValue (const InstanceKey_has_InstanceValue_type& x)
  {
    this->InstanceKey_has_InstanceValue_.set (x);
  }

  void InstanceKey::
  InstanceKey_has_InstanceValue (const InstanceKey_has_InstanceValue_optional& x)
  {
    this->InstanceKey_has_InstanceValue_ = x;
  }

  void InstanceKey::
  InstanceKey_has_InstanceValue (::std::unique_ptr< InstanceKey_has_InstanceValue_type > x)
  {
    this->InstanceKey_has_InstanceValue_.set (std::move (x));
  }

  const InstanceKey::InstanceKey_refersTo_ReferenceValue_type& InstanceKey::
  InstanceKey_refersTo_ReferenceValue () const
  {
    return this->InstanceKey_refersTo_ReferenceValue_.get ();
  }

  InstanceKey::InstanceKey_refersTo_ReferenceValue_type& InstanceKey::
  InstanceKey_refersTo_ReferenceValue ()
  {
    return this->InstanceKey_refersTo_ReferenceValue_.get ();
  }

  void InstanceKey::
  InstanceKey_refersTo_ReferenceValue (const InstanceKey_refersTo_ReferenceValue_type& x)
  {
    this->InstanceKey_refersTo_ReferenceValue_.set (x);
  }

  void InstanceKey::
  InstanceKey_refersTo_ReferenceValue (::std::unique_ptr< InstanceKey_refersTo_ReferenceValue_type > x)
  {
    this->InstanceKey_refersTo_ReferenceValue_.set (std::move (x));
  }


  // InstanceVariable
  //

  const InstanceVariable::physicalDataType_optional& InstanceVariable::
  physicalDataType () const
  {
    return this->physicalDataType_;
  }

  InstanceVariable::physicalDataType_optional& InstanceVariable::
  physicalDataType ()
  {
    return this->physicalDataType_;
  }

  void InstanceVariable::
  physicalDataType (const physicalDataType_type& x)
  {
    this->physicalDataType_.set (x);
  }

  void InstanceVariable::
  physicalDataType (const physicalDataType_optional& x)
  {
    this->physicalDataType_ = x;
  }

  void InstanceVariable::
  physicalDataType (::std::unique_ptr< physicalDataType_type > x)
  {
    this->physicalDataType_.set (std::move (x));
  }

  const InstanceVariable::platformType_optional& InstanceVariable::
  platformType () const
  {
    return this->platformType_;
  }

  InstanceVariable::platformType_optional& InstanceVariable::
  platformType ()
  {
    return this->platformType_;
  }

  void InstanceVariable::
  platformType (const platformType_type& x)
  {
    this->platformType_.set (x);
  }

  void InstanceVariable::
  platformType (const platformType_optional& x)
  {
    this->platformType_ = x;
  }

  void InstanceVariable::
  platformType (::std::unique_ptr< platformType_type > x)
  {
    this->platformType_.set (std::move (x));
  }

  const InstanceVariable::source_optional& InstanceVariable::
  source () const
  {
    return this->source_;
  }

  InstanceVariable::source_optional& InstanceVariable::
  source ()
  {
    return this->source_;
  }

  void InstanceVariable::
  source (const source_type& x)
  {
    this->source_.set (x);
  }

  void InstanceVariable::
  source (const source_optional& x)
  {
    this->source_ = x;
  }

  void InstanceVariable::
  source (::std::unique_ptr< source_type > x)
  {
    this->source_.set (std::move (x));
  }

  const InstanceVariable::variableFunction_sequence& InstanceVariable::
  variableFunction () const
  {
    return this->variableFunction_;
  }

  InstanceVariable::variableFunction_sequence& InstanceVariable::
  variableFunction ()
  {
    return this->variableFunction_;
  }

  void InstanceVariable::
  variableFunction (const variableFunction_sequence& s)
  {
    this->variableFunction_ = s;
  }


  // InstanceVariableMap
  //

  const InstanceVariableMap::comparison_type& InstanceVariableMap::
  comparison () const
  {
    return this->comparison_.get ();
  }

  InstanceVariableMap::comparison_type& InstanceVariableMap::
  comparison ()
  {
    return this->comparison_.get ();
  }

  void InstanceVariableMap::
  comparison (const comparison_type& x)
  {
    this->comparison_.set (x);
  }

  void InstanceVariableMap::
  comparison (::std::unique_ptr< comparison_type > x)
  {
    this->comparison_.set (std::move (x));
  }

  const InstanceVariableMap::correspondence_type& InstanceVariableMap::
  correspondence () const
  {
    return this->correspondence_.get ();
  }

  InstanceVariableMap::correspondence_type& InstanceVariableMap::
  correspondence ()
  {
    return this->correspondence_.get ();
  }

  void InstanceVariableMap::
  correspondence (const correspondence_type& x)
  {
    this->correspondence_.set (x);
  }

  void InstanceVariableMap::
  correspondence (::std::unique_ptr< correspondence_type > x)
  {
    this->correspondence_.set (std::move (x));
  }

  const InstanceVariableMap::identifier_optional& InstanceVariableMap::
  identifier () const
  {
    return this->identifier_;
  }

  InstanceVariableMap::identifier_optional& InstanceVariableMap::
  identifier ()
  {
    return this->identifier_;
  }

  void InstanceVariableMap::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void InstanceVariableMap::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void InstanceVariableMap::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const InstanceVariableMap::setValue_type& InstanceVariableMap::
  setValue () const
  {
    return this->setValue_.get ();
  }

  InstanceVariableMap::setValue_type& InstanceVariableMap::
  setValue ()
  {
    return this->setValue_.get ();
  }

  void InstanceVariableMap::
  setValue (const setValue_type& x)
  {
    this->setValue_.set (x);
  }

  void InstanceVariableMap::
  setValue (::std::unique_ptr< setValue_type > x)
  {
    this->setValue_.set (std::move (x));
  }

  const InstanceVariableMap::InstanceVariableMap_hasTarget_InstanceVariable_sequence& InstanceVariableMap::
  InstanceVariableMap_hasTarget_InstanceVariable () const
  {
    return this->InstanceVariableMap_hasTarget_InstanceVariable_;
  }

  InstanceVariableMap::InstanceVariableMap_hasTarget_InstanceVariable_sequence& InstanceVariableMap::
  InstanceVariableMap_hasTarget_InstanceVariable ()
  {
    return this->InstanceVariableMap_hasTarget_InstanceVariable_;
  }

  void InstanceVariableMap::
  InstanceVariableMap_hasTarget_InstanceVariable (const InstanceVariableMap_hasTarget_InstanceVariable_sequence& s)
  {
    this->InstanceVariableMap_hasTarget_InstanceVariable_ = s;
  }

  const InstanceVariableMap::InstanceVariableMap_hasSource_InstanceVariable_sequence& InstanceVariableMap::
  InstanceVariableMap_hasSource_InstanceVariable () const
  {
    return this->InstanceVariableMap_hasSource_InstanceVariable_;
  }

  InstanceVariableMap::InstanceVariableMap_hasSource_InstanceVariable_sequence& InstanceVariableMap::
  InstanceVariableMap_hasSource_InstanceVariable ()
  {
    return this->InstanceVariableMap_hasSource_InstanceVariable_;
  }

  void InstanceVariableMap::
  InstanceVariableMap_hasSource_InstanceVariable (const InstanceVariableMap_hasSource_InstanceVariable_sequence& s)
  {
    this->InstanceVariableMap_hasSource_InstanceVariable_ = s;
  }


  // KeyDefinitionMember
  //


  // KeyValueDataStore
  //


  // KeyValueStructure
  //


  // Level
  //

  const Level::displayLabel_sequence& Level::
  displayLabel () const
  {
    return this->displayLabel_;
  }

  Level::displayLabel_sequence& Level::
  displayLabel ()
  {
    return this->displayLabel_;
  }

  void Level::
  displayLabel (const displayLabel_sequence& s)
  {
    this->displayLabel_ = s;
  }

  const Level::identifier_optional& Level::
  identifier () const
  {
    return this->identifier_;
  }

  Level::identifier_optional& Level::
  identifier ()
  {
    return this->identifier_;
  }

  void Level::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void Level::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void Level::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const Level::levelNumber_type& Level::
  levelNumber () const
  {
    return this->levelNumber_.get ();
  }

  Level::levelNumber_type& Level::
  levelNumber ()
  {
    return this->levelNumber_.get ();
  }

  void Level::
  levelNumber (const levelNumber_type& x)
  {
    this->levelNumber_.set (x);
  }

  const Level::Level_isDefinedBy_Concept_optional& Level::
  Level_isDefinedBy_Concept () const
  {
    return this->Level_isDefinedBy_Concept_;
  }

  Level::Level_isDefinedBy_Concept_optional& Level::
  Level_isDefinedBy_Concept ()
  {
    return this->Level_isDefinedBy_Concept_;
  }

  void Level::
  Level_isDefinedBy_Concept (const Level_isDefinedBy_Concept_type& x)
  {
    this->Level_isDefinedBy_Concept_.set (x);
  }

  void Level::
  Level_isDefinedBy_Concept (const Level_isDefinedBy_Concept_optional& x)
  {
    this->Level_isDefinedBy_Concept_ = x;
  }

  void Level::
  Level_isDefinedBy_Concept (::std::unique_ptr< Level_isDefinedBy_Concept_type > x)
  {
    this->Level_isDefinedBy_Concept_.set (std::move (x));
  }

  const Level::Level_groups_ClassificationItem_sequence& Level::
  Level_groups_ClassificationItem () const
  {
    return this->Level_groups_ClassificationItem_;
  }

  Level::Level_groups_ClassificationItem_sequence& Level::
  Level_groups_ClassificationItem ()
  {
    return this->Level_groups_ClassificationItem_;
  }

  void Level::
  Level_groups_ClassificationItem (const Level_groups_ClassificationItem_sequence& s)
  {
    this->Level_groups_ClassificationItem_ = s;
  }


  // LevelStructure
  //

  const LevelStructure::catalogDetails_optional& LevelStructure::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  LevelStructure::catalogDetails_optional& LevelStructure::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void LevelStructure::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void LevelStructure::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void LevelStructure::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const LevelStructure::identifier_optional& LevelStructure::
  identifier () const
  {
    return this->identifier_;
  }

  LevelStructure::identifier_optional& LevelStructure::
  identifier ()
  {
    return this->identifier_;
  }

  void LevelStructure::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void LevelStructure::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void LevelStructure::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const LevelStructure::name_sequence& LevelStructure::
  name () const
  {
    return this->name_;
  }

  LevelStructure::name_sequence& LevelStructure::
  name ()
  {
    return this->name_;
  }

  void LevelStructure::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const LevelStructure::usage_optional& LevelStructure::
  usage () const
  {
    return this->usage_;
  }

  LevelStructure::usage_optional& LevelStructure::
  usage ()
  {
    return this->usage_;
  }

  void LevelStructure::
  usage (const usage_type& x)
  {
    this->usage_.set (x);
  }

  void LevelStructure::
  usage (const usage_optional& x)
  {
    this->usage_ = x;
  }

  void LevelStructure::
  usage (::std::unique_ptr< usage_type > x)
  {
    this->usage_.set (std::move (x));
  }

  const LevelStructure::validDateRange_optional& LevelStructure::
  validDateRange () const
  {
    return this->validDateRange_;
  }

  LevelStructure::validDateRange_optional& LevelStructure::
  validDateRange ()
  {
    return this->validDateRange_;
  }

  void LevelStructure::
  validDateRange (const validDateRange_type& x)
  {
    this->validDateRange_.set (x);
  }

  void LevelStructure::
  validDateRange (const validDateRange_optional& x)
  {
    this->validDateRange_ = x;
  }

  void LevelStructure::
  validDateRange (::std::unique_ptr< validDateRange_type > x)
  {
    this->validDateRange_.set (std::move (x));
  }

  const LevelStructure::LevelStructure_has_Level_sequence& LevelStructure::
  LevelStructure_has_Level () const
  {
    return this->LevelStructure_has_Level_;
  }

  LevelStructure::LevelStructure_has_Level_sequence& LevelStructure::
  LevelStructure_has_Level ()
  {
    return this->LevelStructure_has_Level_;
  }

  void LevelStructure::
  LevelStructure_has_Level (const LevelStructure_has_Level_sequence& s)
  {
    this->LevelStructure_has_Level_ = s;
  }


  // LogicalRecord
  //

  const LogicalRecord::identifier_optional& LogicalRecord::
  identifier () const
  {
    return this->identifier_;
  }

  LogicalRecord::identifier_optional& LogicalRecord::
  identifier ()
  {
    return this->identifier_;
  }

  void LogicalRecord::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void LogicalRecord::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void LogicalRecord::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const LogicalRecord::LogicalRecord_organizes_DataSet_sequence& LogicalRecord::
  LogicalRecord_organizes_DataSet () const
  {
    return this->LogicalRecord_organizes_DataSet_;
  }

  LogicalRecord::LogicalRecord_organizes_DataSet_sequence& LogicalRecord::
  LogicalRecord_organizes_DataSet ()
  {
    return this->LogicalRecord_organizes_DataSet_;
  }

  void LogicalRecord::
  LogicalRecord_organizes_DataSet (const LogicalRecord_organizes_DataSet_sequence& s)
  {
    this->LogicalRecord_organizes_DataSet_ = s;
  }

  const LogicalRecord::LogicalRecord_isDefinedBy_Concept_sequence& LogicalRecord::
  LogicalRecord_isDefinedBy_Concept () const
  {
    return this->LogicalRecord_isDefinedBy_Concept_;
  }

  LogicalRecord::LogicalRecord_isDefinedBy_Concept_sequence& LogicalRecord::
  LogicalRecord_isDefinedBy_Concept ()
  {
    return this->LogicalRecord_isDefinedBy_Concept_;
  }

  void LogicalRecord::
  LogicalRecord_isDefinedBy_Concept (const LogicalRecord_isDefinedBy_Concept_sequence& s)
  {
    this->LogicalRecord_isDefinedBy_Concept_ = s;
  }

  const LogicalRecord::LogicalRecord_has_InstanceVariable_sequence& LogicalRecord::
  LogicalRecord_has_InstanceVariable () const
  {
    return this->LogicalRecord_has_InstanceVariable_;
  }

  LogicalRecord::LogicalRecord_has_InstanceVariable_sequence& LogicalRecord::
  LogicalRecord_has_InstanceVariable ()
  {
    return this->LogicalRecord_has_InstanceVariable_;
  }

  void LogicalRecord::
  LogicalRecord_has_InstanceVariable (const LogicalRecord_has_InstanceVariable_sequence& s)
  {
    this->LogicalRecord_has_InstanceVariable_ = s;
  }


  // LogicalRecordPosition
  //

  const LogicalRecordPosition::identifier_optional& LogicalRecordPosition::
  identifier () const
  {
    return this->identifier_;
  }

  LogicalRecordPosition::identifier_optional& LogicalRecordPosition::
  identifier ()
  {
    return this->identifier_;
  }

  void LogicalRecordPosition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void LogicalRecordPosition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void LogicalRecordPosition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const LogicalRecordPosition::value_type& LogicalRecordPosition::
  value () const
  {
    return this->value_.get ();
  }

  LogicalRecordPosition::value_type& LogicalRecordPosition::
  value ()
  {
    return this->value_.get ();
  }

  void LogicalRecordPosition::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  const LogicalRecordPosition::LogicalRecordPosition_indexes_LogicalRecord_type& LogicalRecordPosition::
  LogicalRecordPosition_indexes_LogicalRecord () const
  {
    return this->LogicalRecordPosition_indexes_LogicalRecord_.get ();
  }

  LogicalRecordPosition::LogicalRecordPosition_indexes_LogicalRecord_type& LogicalRecordPosition::
  LogicalRecordPosition_indexes_LogicalRecord ()
  {
    return this->LogicalRecordPosition_indexes_LogicalRecord_.get ();
  }

  void LogicalRecordPosition::
  LogicalRecordPosition_indexes_LogicalRecord (const LogicalRecordPosition_indexes_LogicalRecord_type& x)
  {
    this->LogicalRecordPosition_indexes_LogicalRecord_.set (x);
  }

  void LogicalRecordPosition::
  LogicalRecordPosition_indexes_LogicalRecord (::std::unique_ptr< LogicalRecordPosition_indexes_LogicalRecord_type > x)
  {
    this->LogicalRecordPosition_indexes_LogicalRecord_.set (std::move (x));
  }


  // LogicalRecordRelationStructure
  //

  const LogicalRecordRelationStructure::identifier_optional& LogicalRecordRelationStructure::
  identifier () const
  {
    return this->identifier_;
  }

  LogicalRecordRelationStructure::identifier_optional& LogicalRecordRelationStructure::
  identifier ()
  {
    return this->identifier_;
  }

  void LogicalRecordRelationStructure::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void LogicalRecordRelationStructure::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void LogicalRecordRelationStructure::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const LogicalRecordRelationStructure::name_sequence& LogicalRecordRelationStructure::
  name () const
  {
    return this->name_;
  }

  LogicalRecordRelationStructure::name_sequence& LogicalRecordRelationStructure::
  name ()
  {
    return this->name_;
  }

  void LogicalRecordRelationStructure::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const LogicalRecordRelationStructure::purpose_optional& LogicalRecordRelationStructure::
  purpose () const
  {
    return this->purpose_;
  }

  LogicalRecordRelationStructure::purpose_optional& LogicalRecordRelationStructure::
  purpose ()
  {
    return this->purpose_;
  }

  void LogicalRecordRelationStructure::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void LogicalRecordRelationStructure::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void LogicalRecordRelationStructure::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const LogicalRecordRelationStructure::semantics_optional& LogicalRecordRelationStructure::
  semantics () const
  {
    return this->semantics_;
  }

  LogicalRecordRelationStructure::semantics_optional& LogicalRecordRelationStructure::
  semantics ()
  {
    return this->semantics_;
  }

  void LogicalRecordRelationStructure::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void LogicalRecordRelationStructure::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void LogicalRecordRelationStructure::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const LogicalRecordRelationStructure::specification_optional& LogicalRecordRelationStructure::
  specification () const
  {
    return this->specification_;
  }

  LogicalRecordRelationStructure::specification_optional& LogicalRecordRelationStructure::
  specification ()
  {
    return this->specification_;
  }

  void LogicalRecordRelationStructure::
  specification (const specification_type& x)
  {
    this->specification_.set (x);
  }

  void LogicalRecordRelationStructure::
  specification (const specification_optional& x)
  {
    this->specification_ = x;
  }

  void LogicalRecordRelationStructure::
  specification (::std::unique_ptr< specification_type > x)
  {
    this->specification_.set (std::move (x));
  }

  const LogicalRecordRelationStructure::topology_optional& LogicalRecordRelationStructure::
  topology () const
  {
    return this->topology_;
  }

  LogicalRecordRelationStructure::topology_optional& LogicalRecordRelationStructure::
  topology ()
  {
    return this->topology_;
  }

  void LogicalRecordRelationStructure::
  topology (const topology_type& x)
  {
    this->topology_.set (x);
  }

  void LogicalRecordRelationStructure::
  topology (const topology_optional& x)
  {
    this->topology_ = x;
  }

  void LogicalRecordRelationStructure::
  topology (::std::unique_ptr< topology_type > x)
  {
    this->topology_.set (std::move (x));
  }

  const LogicalRecordRelationStructure::totality_optional& LogicalRecordRelationStructure::
  totality () const
  {
    return this->totality_;
  }

  LogicalRecordRelationStructure::totality_optional& LogicalRecordRelationStructure::
  totality ()
  {
    return this->totality_;
  }

  void LogicalRecordRelationStructure::
  totality (const totality_type& x)
  {
    this->totality_.set (x);
  }

  void LogicalRecordRelationStructure::
  totality (const totality_optional& x)
  {
    this->totality_ = x;
  }

  void LogicalRecordRelationStructure::
  totality (::std::unique_ptr< totality_type > x)
  {
    this->totality_.set (std::move (x));
  }

  const LogicalRecordRelationStructure::LogicalRecordRelationStructure_structures_DataStore_sequence& LogicalRecordRelationStructure::
  LogicalRecordRelationStructure_structures_DataStore () const
  {
    return this->LogicalRecordRelationStructure_structures_DataStore_;
  }

  LogicalRecordRelationStructure::LogicalRecordRelationStructure_structures_DataStore_sequence& LogicalRecordRelationStructure::
  LogicalRecordRelationStructure_structures_DataStore ()
  {
    return this->LogicalRecordRelationStructure_structures_DataStore_;
  }

  void LogicalRecordRelationStructure::
  LogicalRecordRelationStructure_structures_DataStore (const LogicalRecordRelationStructure_structures_DataStore_sequence& s)
  {
    this->LogicalRecordRelationStructure_structures_DataStore_ = s;
  }

  const LogicalRecordRelationStructure::LogicalRecordRelationStructure_has_LogicalRecordRelationship_sequence& LogicalRecordRelationStructure::
  LogicalRecordRelationStructure_has_LogicalRecordRelationship () const
  {
    return this->LogicalRecordRelationStructure_has_LogicalRecordRelationship_;
  }

  LogicalRecordRelationStructure::LogicalRecordRelationStructure_has_LogicalRecordRelationship_sequence& LogicalRecordRelationStructure::
  LogicalRecordRelationStructure_has_LogicalRecordRelationship ()
  {
    return this->LogicalRecordRelationStructure_has_LogicalRecordRelationship_;
  }

  void LogicalRecordRelationStructure::
  LogicalRecordRelationStructure_has_LogicalRecordRelationship (const LogicalRecordRelationStructure_has_LogicalRecordRelationship_sequence& s)
  {
    this->LogicalRecordRelationStructure_has_LogicalRecordRelationship_ = s;
  }


  // LogicalRecordRelationship
  //

  const LogicalRecordRelationship::identifier_optional& LogicalRecordRelationship::
  identifier () const
  {
    return this->identifier_;
  }

  LogicalRecordRelationship::identifier_optional& LogicalRecordRelationship::
  identifier ()
  {
    return this->identifier_;
  }

  void LogicalRecordRelationship::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void LogicalRecordRelationship::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void LogicalRecordRelationship::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const LogicalRecordRelationship::semantics_optional& LogicalRecordRelationship::
  semantics () const
  {
    return this->semantics_;
  }

  LogicalRecordRelationship::semantics_optional& LogicalRecordRelationship::
  semantics ()
  {
    return this->semantics_;
  }

  void LogicalRecordRelationship::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void LogicalRecordRelationship::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void LogicalRecordRelationship::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const LogicalRecordRelationship::LogicalRecordRelationship_hasTarget_LogicalRecord_sequence& LogicalRecordRelationship::
  LogicalRecordRelationship_hasTarget_LogicalRecord () const
  {
    return this->LogicalRecordRelationship_hasTarget_LogicalRecord_;
  }

  LogicalRecordRelationship::LogicalRecordRelationship_hasTarget_LogicalRecord_sequence& LogicalRecordRelationship::
  LogicalRecordRelationship_hasTarget_LogicalRecord ()
  {
    return this->LogicalRecordRelationship_hasTarget_LogicalRecord_;
  }

  void LogicalRecordRelationship::
  LogicalRecordRelationship_hasTarget_LogicalRecord (const LogicalRecordRelationship_hasTarget_LogicalRecord_sequence& s)
  {
    this->LogicalRecordRelationship_hasTarget_LogicalRecord_ = s;
  }

  const LogicalRecordRelationship::LogicalRecordRelationship_hasSource_LogicalRecord_sequence& LogicalRecordRelationship::
  LogicalRecordRelationship_hasSource_LogicalRecord () const
  {
    return this->LogicalRecordRelationship_hasSource_LogicalRecord_;
  }

  LogicalRecordRelationship::LogicalRecordRelationship_hasSource_LogicalRecord_sequence& LogicalRecordRelationship::
  LogicalRecordRelationship_hasSource_LogicalRecord ()
  {
    return this->LogicalRecordRelationship_hasSource_LogicalRecord_;
  }

  void LogicalRecordRelationship::
  LogicalRecordRelationship_hasSource_LogicalRecord (const LogicalRecordRelationship_hasSource_LogicalRecord_sequence& s)
  {
    this->LogicalRecordRelationship_hasSource_LogicalRecord_ = s;
  }


  // LongDataSet
  //


  // LongDataStructure
  //


  // LongKey
  //


  // LongMainKeyMember
  //


  // Machine
  //

  const Machine::accessLocation_optional& Machine::
  accessLocation () const
  {
    return this->accessLocation_;
  }

  Machine::accessLocation_optional& Machine::
  accessLocation ()
  {
    return this->accessLocation_;
  }

  void Machine::
  accessLocation (const accessLocation_type& x)
  {
    this->accessLocation_.set (x);
  }

  void Machine::
  accessLocation (const accessLocation_optional& x)
  {
    this->accessLocation_ = x;
  }

  void Machine::
  accessLocation (::std::unique_ptr< accessLocation_type > x)
  {
    this->accessLocation_.set (std::move (x));
  }

  const Machine::function_sequence& Machine::
  function () const
  {
    return this->function_;
  }

  Machine::function_sequence& Machine::
  function ()
  {
    return this->function_;
  }

  void Machine::
  function (const function_sequence& s)
  {
    this->function_ = s;
  }

  const Machine::machineInterface_sequence& Machine::
  machineInterface () const
  {
    return this->machineInterface_;
  }

  Machine::machineInterface_sequence& Machine::
  machineInterface ()
  {
    return this->machineInterface_;
  }

  void Machine::
  machineInterface (const machineInterface_sequence& s)
  {
    this->machineInterface_ = s;
  }

  const Machine::name_sequence& Machine::
  name () const
  {
    return this->name_;
  }

  Machine::name_sequence& Machine::
  name ()
  {
    return this->name_;
  }

  void Machine::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const Machine::ownerOperatorContact_optional& Machine::
  ownerOperatorContact () const
  {
    return this->ownerOperatorContact_;
  }

  Machine::ownerOperatorContact_optional& Machine::
  ownerOperatorContact ()
  {
    return this->ownerOperatorContact_;
  }

  void Machine::
  ownerOperatorContact (const ownerOperatorContact_type& x)
  {
    this->ownerOperatorContact_.set (x);
  }

  void Machine::
  ownerOperatorContact (const ownerOperatorContact_optional& x)
  {
    this->ownerOperatorContact_ = x;
  }

  void Machine::
  ownerOperatorContact (::std::unique_ptr< ownerOperatorContact_type > x)
  {
    this->ownerOperatorContact_.set (std::move (x));
  }

  const Machine::typeOfMachine_optional& Machine::
  typeOfMachine () const
  {
    return this->typeOfMachine_;
  }

  Machine::typeOfMachine_optional& Machine::
  typeOfMachine ()
  {
    return this->typeOfMachine_;
  }

  void Machine::
  typeOfMachine (const typeOfMachine_type& x)
  {
    this->typeOfMachine_.set (x);
  }

  void Machine::
  typeOfMachine (const typeOfMachine_optional& x)
  {
    this->typeOfMachine_ = x;
  }

  void Machine::
  typeOfMachine (::std::unique_ptr< typeOfMachine_type > x)
  {
    this->typeOfMachine_.set (std::move (x));
  }


  // MainKeyMember
  //

  const MainKeyMember::MainKeyMember_hasValueFrom_SubstantiveValueDomain_optional& MainKeyMember::
  MainKeyMember_hasValueFrom_SubstantiveValueDomain () const
  {
    return this->MainKeyMember_hasValueFrom_SubstantiveValueDomain_;
  }

  MainKeyMember::MainKeyMember_hasValueFrom_SubstantiveValueDomain_optional& MainKeyMember::
  MainKeyMember_hasValueFrom_SubstantiveValueDomain ()
  {
    return this->MainKeyMember_hasValueFrom_SubstantiveValueDomain_;
  }

  void MainKeyMember::
  MainKeyMember_hasValueFrom_SubstantiveValueDomain (const MainKeyMember_hasValueFrom_SubstantiveValueDomain_type& x)
  {
    this->MainKeyMember_hasValueFrom_SubstantiveValueDomain_.set (x);
  }

  void MainKeyMember::
  MainKeyMember_hasValueFrom_SubstantiveValueDomain (const MainKeyMember_hasValueFrom_SubstantiveValueDomain_optional& x)
  {
    this->MainKeyMember_hasValueFrom_SubstantiveValueDomain_ = x;
  }

  void MainKeyMember::
  MainKeyMember_hasValueFrom_SubstantiveValueDomain (::std::unique_ptr< MainKeyMember_hasValueFrom_SubstantiveValueDomain_type > x)
  {
    this->MainKeyMember_hasValueFrom_SubstantiveValueDomain_.set (std::move (x));
  }


  // MeasureComponent
  //

  const MeasureComponent::name_sequence& MeasureComponent::
  name () const
  {
    return this->name_;
  }

  MeasureComponent::name_sequence& MeasureComponent::
  name ()
  {
    return this->name_;
  }

  void MeasureComponent::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }


  // Notation
  //

  const Notation::content_optional& Notation::
  content () const
  {
    return this->content_;
  }

  Notation::content_optional& Notation::
  content ()
  {
    return this->content_;
  }

  void Notation::
  content (const content_type& x)
  {
    this->content_.set (x);
  }

  void Notation::
  content (const content_optional& x)
  {
    this->content_ = x;
  }

  void Notation::
  content (::std::unique_ptr< content_type > x)
  {
    this->content_.set (std::move (x));
  }

  const Notation::identifier_optional& Notation::
  identifier () const
  {
    return this->identifier_;
  }

  Notation::identifier_optional& Notation::
  identifier ()
  {
    return this->identifier_;
  }

  void Notation::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void Notation::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void Notation::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const Notation::whiteSpace_optional& Notation::
  whiteSpace () const
  {
    return this->whiteSpace_;
  }

  Notation::whiteSpace_optional& Notation::
  whiteSpace ()
  {
    return this->whiteSpace_;
  }

  void Notation::
  whiteSpace (const whiteSpace_type& x)
  {
    this->whiteSpace_.set (x);
  }

  void Notation::
  whiteSpace (const whiteSpace_optional& x)
  {
    this->whiteSpace_ = x;
  }

  void Notation::
  whiteSpace (::std::unique_ptr< whiteSpace_type > x)
  {
    this->whiteSpace_.set (std::move (x));
  }

  const Notation::Notation_represents_Category_sequence& Notation::
  Notation_represents_Category () const
  {
    return this->Notation_represents_Category_;
  }

  Notation::Notation_represents_Category_sequence& Notation::
  Notation_represents_Category ()
  {
    return this->Notation_represents_Category_;
  }

  void Notation::
  Notation_represents_Category (const Notation_represents_Category_sequence& s)
  {
    this->Notation_represents_Category_ = s;
  }


  // Organization
  //

  const Organization::contactInformation_optional& Organization::
  contactInformation () const
  {
    return this->contactInformation_;
  }

  Organization::contactInformation_optional& Organization::
  contactInformation ()
  {
    return this->contactInformation_;
  }

  void Organization::
  contactInformation (const contactInformation_type& x)
  {
    this->contactInformation_.set (x);
  }

  void Organization::
  contactInformation (const contactInformation_optional& x)
  {
    this->contactInformation_ = x;
  }

  void Organization::
  contactInformation (::std::unique_ptr< contactInformation_type > x)
  {
    this->contactInformation_.set (std::move (x));
  }

  const Organization::organizationName_sequence& Organization::
  organizationName () const
  {
    return this->organizationName_;
  }

  Organization::organizationName_sequence& Organization::
  organizationName ()
  {
    return this->organizationName_;
  }

  void Organization::
  organizationName (const organizationName_sequence& s)
  {
    this->organizationName_ = s;
  }


  // Parameter
  //

  const Parameter::entityBound_sequence& Parameter::
  entityBound () const
  {
    return this->entityBound_;
  }

  Parameter::entityBound_sequence& Parameter::
  entityBound ()
  {
    return this->entityBound_;
  }

  void Parameter::
  entityBound (const entityBound_sequence& s)
  {
    this->entityBound_ = s;
  }

  const Parameter::identifier_optional& Parameter::
  identifier () const
  {
    return this->identifier_;
  }

  Parameter::identifier_optional& Parameter::
  identifier ()
  {
    return this->identifier_;
  }

  void Parameter::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void Parameter::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void Parameter::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const Parameter::name_sequence& Parameter::
  name () const
  {
    return this->name_;
  }

  Parameter::name_sequence& Parameter::
  name ()
  {
    return this->name_;
  }

  void Parameter::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }


  // PhysicalDataSet
  //

  const PhysicalDataSet::allowsDuplicates_type& PhysicalDataSet::
  allowsDuplicates () const
  {
    return this->allowsDuplicates_.get ();
  }

  PhysicalDataSet::allowsDuplicates_type& PhysicalDataSet::
  allowsDuplicates ()
  {
    return this->allowsDuplicates_.get ();
  }

  void PhysicalDataSet::
  allowsDuplicates (const allowsDuplicates_type& x)
  {
    this->allowsDuplicates_.set (x);
  }

  const PhysicalDataSet::catalogDetails_optional& PhysicalDataSet::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  PhysicalDataSet::catalogDetails_optional& PhysicalDataSet::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void PhysicalDataSet::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void PhysicalDataSet::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void PhysicalDataSet::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const PhysicalDataSet::identifier_optional& PhysicalDataSet::
  identifier () const
  {
    return this->identifier_;
  }

  PhysicalDataSet::identifier_optional& PhysicalDataSet::
  identifier ()
  {
    return this->identifier_;
  }

  void PhysicalDataSet::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void PhysicalDataSet::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void PhysicalDataSet::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const PhysicalDataSet::name_optional& PhysicalDataSet::
  name () const
  {
    return this->name_;
  }

  PhysicalDataSet::name_optional& PhysicalDataSet::
  name ()
  {
    return this->name_;
  }

  void PhysicalDataSet::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void PhysicalDataSet::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void PhysicalDataSet::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const PhysicalDataSet::numberOfSegments_optional& PhysicalDataSet::
  numberOfSegments () const
  {
    return this->numberOfSegments_;
  }

  PhysicalDataSet::numberOfSegments_optional& PhysicalDataSet::
  numberOfSegments ()
  {
    return this->numberOfSegments_;
  }

  void PhysicalDataSet::
  numberOfSegments (const numberOfSegments_type& x)
  {
    this->numberOfSegments_.set (x);
  }

  void PhysicalDataSet::
  numberOfSegments (const numberOfSegments_optional& x)
  {
    this->numberOfSegments_ = x;
  }

  const PhysicalDataSet::overview_optional& PhysicalDataSet::
  overview () const
  {
    return this->overview_;
  }

  PhysicalDataSet::overview_optional& PhysicalDataSet::
  overview ()
  {
    return this->overview_;
  }

  void PhysicalDataSet::
  overview (const overview_type& x)
  {
    this->overview_.set (x);
  }

  void PhysicalDataSet::
  overview (const overview_optional& x)
  {
    this->overview_ = x;
  }

  void PhysicalDataSet::
  overview (::std::unique_ptr< overview_type > x)
  {
    this->overview_.set (std::move (x));
  }

  const PhysicalDataSet::physicalFileName_optional& PhysicalDataSet::
  physicalFileName () const
  {
    return this->physicalFileName_;
  }

  PhysicalDataSet::physicalFileName_optional& PhysicalDataSet::
  physicalFileName ()
  {
    return this->physicalFileName_;
  }

  void PhysicalDataSet::
  physicalFileName (const physicalFileName_type& x)
  {
    this->physicalFileName_.set (x);
  }

  void PhysicalDataSet::
  physicalFileName (const physicalFileName_optional& x)
  {
    this->physicalFileName_ = x;
  }

  void PhysicalDataSet::
  physicalFileName (::std::unique_ptr< physicalFileName_type > x)
  {
    this->physicalFileName_.set (std::move (x));
  }

  const PhysicalDataSet::purpose_optional& PhysicalDataSet::
  purpose () const
  {
    return this->purpose_;
  }

  PhysicalDataSet::purpose_optional& PhysicalDataSet::
  purpose ()
  {
    return this->purpose_;
  }

  void PhysicalDataSet::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void PhysicalDataSet::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void PhysicalDataSet::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const PhysicalDataSet::PhysicalDataSet_isDefinedBy_Concept_sequence& PhysicalDataSet::
  PhysicalDataSet_isDefinedBy_Concept () const
  {
    return this->PhysicalDataSet_isDefinedBy_Concept_;
  }

  PhysicalDataSet::PhysicalDataSet_isDefinedBy_Concept_sequence& PhysicalDataSet::
  PhysicalDataSet_isDefinedBy_Concept ()
  {
    return this->PhysicalDataSet_isDefinedBy_Concept_;
  }

  void PhysicalDataSet::
  PhysicalDataSet_isDefinedBy_Concept (const PhysicalDataSet_isDefinedBy_Concept_sequence& s)
  {
    this->PhysicalDataSet_isDefinedBy_Concept_ = s;
  }

  const PhysicalDataSet::PhysicalDataSet_formats_DataStore_sequence& PhysicalDataSet::
  PhysicalDataSet_formats_DataStore () const
  {
    return this->PhysicalDataSet_formats_DataStore_;
  }

  PhysicalDataSet::PhysicalDataSet_formats_DataStore_sequence& PhysicalDataSet::
  PhysicalDataSet_formats_DataStore ()
  {
    return this->PhysicalDataSet_formats_DataStore_;
  }

  void PhysicalDataSet::
  PhysicalDataSet_formats_DataStore (const PhysicalDataSet_formats_DataStore_sequence& s)
  {
    this->PhysicalDataSet_formats_DataStore_ = s;
  }

  const PhysicalDataSet::PhysicalDataSet_has_InstanceVariable_sequence& PhysicalDataSet::
  PhysicalDataSet_has_InstanceVariable () const
  {
    return this->PhysicalDataSet_has_InstanceVariable_;
  }

  PhysicalDataSet::PhysicalDataSet_has_InstanceVariable_sequence& PhysicalDataSet::
  PhysicalDataSet_has_InstanceVariable ()
  {
    return this->PhysicalDataSet_has_InstanceVariable_;
  }

  void PhysicalDataSet::
  PhysicalDataSet_has_InstanceVariable (const PhysicalDataSet_has_InstanceVariable_sequence& s)
  {
    this->PhysicalDataSet_has_InstanceVariable_ = s;
  }

  const PhysicalDataSet::PhysicalDataSet_has_PhysicalRecordSegment_sequence& PhysicalDataSet::
  PhysicalDataSet_has_PhysicalRecordSegment () const
  {
    return this->PhysicalDataSet_has_PhysicalRecordSegment_;
  }

  PhysicalDataSet::PhysicalDataSet_has_PhysicalRecordSegment_sequence& PhysicalDataSet::
  PhysicalDataSet_has_PhysicalRecordSegment ()
  {
    return this->PhysicalDataSet_has_PhysicalRecordSegment_;
  }

  void PhysicalDataSet::
  PhysicalDataSet_has_PhysicalRecordSegment (const PhysicalDataSet_has_PhysicalRecordSegment_sequence& s)
  {
    this->PhysicalDataSet_has_PhysicalRecordSegment_ = s;
  }

  const PhysicalDataSet::PhysicalDataSet_has_PhysicalRecordSegmentPosition_sequence& PhysicalDataSet::
  PhysicalDataSet_has_PhysicalRecordSegmentPosition () const
  {
    return this->PhysicalDataSet_has_PhysicalRecordSegmentPosition_;
  }

  PhysicalDataSet::PhysicalDataSet_has_PhysicalRecordSegmentPosition_sequence& PhysicalDataSet::
  PhysicalDataSet_has_PhysicalRecordSegmentPosition ()
  {
    return this->PhysicalDataSet_has_PhysicalRecordSegmentPosition_;
  }

  void PhysicalDataSet::
  PhysicalDataSet_has_PhysicalRecordSegmentPosition (const PhysicalDataSet_has_PhysicalRecordSegmentPosition_sequence& s)
  {
    this->PhysicalDataSet_has_PhysicalRecordSegmentPosition_ = s;
  }


  // PhysicalDataSetStructure
  //

  const PhysicalDataSetStructure::identifier_optional& PhysicalDataSetStructure::
  identifier () const
  {
    return this->identifier_;
  }

  PhysicalDataSetStructure::identifier_optional& PhysicalDataSetStructure::
  identifier ()
  {
    return this->identifier_;
  }

  void PhysicalDataSetStructure::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void PhysicalDataSetStructure::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void PhysicalDataSetStructure::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const PhysicalDataSetStructure::name_optional& PhysicalDataSetStructure::
  name () const
  {
    return this->name_;
  }

  PhysicalDataSetStructure::name_optional& PhysicalDataSetStructure::
  name ()
  {
    return this->name_;
  }

  void PhysicalDataSetStructure::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void PhysicalDataSetStructure::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void PhysicalDataSetStructure::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const PhysicalDataSetStructure::purpose_optional& PhysicalDataSetStructure::
  purpose () const
  {
    return this->purpose_;
  }

  PhysicalDataSetStructure::purpose_optional& PhysicalDataSetStructure::
  purpose ()
  {
    return this->purpose_;
  }

  void PhysicalDataSetStructure::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void PhysicalDataSetStructure::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void PhysicalDataSetStructure::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const PhysicalDataSetStructure::semantics_optional& PhysicalDataSetStructure::
  semantics () const
  {
    return this->semantics_;
  }

  PhysicalDataSetStructure::semantics_optional& PhysicalDataSetStructure::
  semantics ()
  {
    return this->semantics_;
  }

  void PhysicalDataSetStructure::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void PhysicalDataSetStructure::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void PhysicalDataSetStructure::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const PhysicalDataSetStructure::specification_optional& PhysicalDataSetStructure::
  specification () const
  {
    return this->specification_;
  }

  PhysicalDataSetStructure::specification_optional& PhysicalDataSetStructure::
  specification ()
  {
    return this->specification_;
  }

  void PhysicalDataSetStructure::
  specification (const specification_type& x)
  {
    this->specification_.set (x);
  }

  void PhysicalDataSetStructure::
  specification (const specification_optional& x)
  {
    this->specification_ = x;
  }

  void PhysicalDataSetStructure::
  specification (::std::unique_ptr< specification_type > x)
  {
    this->specification_.set (std::move (x));
  }

  const PhysicalDataSetStructure::topology_optional& PhysicalDataSetStructure::
  topology () const
  {
    return this->topology_;
  }

  PhysicalDataSetStructure::topology_optional& PhysicalDataSetStructure::
  topology ()
  {
    return this->topology_;
  }

  void PhysicalDataSetStructure::
  topology (const topology_type& x)
  {
    this->topology_.set (x);
  }

  void PhysicalDataSetStructure::
  topology (const topology_optional& x)
  {
    this->topology_ = x;
  }

  void PhysicalDataSetStructure::
  topology (::std::unique_ptr< topology_type > x)
  {
    this->topology_.set (std::move (x));
  }

  const PhysicalDataSetStructure::totality_optional& PhysicalDataSetStructure::
  totality () const
  {
    return this->totality_;
  }

  PhysicalDataSetStructure::totality_optional& PhysicalDataSetStructure::
  totality ()
  {
    return this->totality_;
  }

  void PhysicalDataSetStructure::
  totality (const totality_type& x)
  {
    this->totality_.set (x);
  }

  void PhysicalDataSetStructure::
  totality (const totality_optional& x)
  {
    this->totality_ = x;
  }

  void PhysicalDataSetStructure::
  totality (::std::unique_ptr< totality_type > x)
  {
    this->totality_.set (std::move (x));
  }

  const PhysicalDataSetStructure::PhysicalDataSetStructure_structures_PhysicalDataSet_optional& PhysicalDataSetStructure::
  PhysicalDataSetStructure_structures_PhysicalDataSet () const
  {
    return this->PhysicalDataSetStructure_structures_PhysicalDataSet_;
  }

  PhysicalDataSetStructure::PhysicalDataSetStructure_structures_PhysicalDataSet_optional& PhysicalDataSetStructure::
  PhysicalDataSetStructure_structures_PhysicalDataSet ()
  {
    return this->PhysicalDataSetStructure_structures_PhysicalDataSet_;
  }

  void PhysicalDataSetStructure::
  PhysicalDataSetStructure_structures_PhysicalDataSet (const PhysicalDataSetStructure_structures_PhysicalDataSet_type& x)
  {
    this->PhysicalDataSetStructure_structures_PhysicalDataSet_.set (x);
  }

  void PhysicalDataSetStructure::
  PhysicalDataSetStructure_structures_PhysicalDataSet (const PhysicalDataSetStructure_structures_PhysicalDataSet_optional& x)
  {
    this->PhysicalDataSetStructure_structures_PhysicalDataSet_ = x;
  }

  void PhysicalDataSetStructure::
  PhysicalDataSetStructure_structures_PhysicalDataSet (::std::unique_ptr< PhysicalDataSetStructure_structures_PhysicalDataSet_type > x)
  {
    this->PhysicalDataSetStructure_structures_PhysicalDataSet_.set (std::move (x));
  }

  const PhysicalDataSetStructure::PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_sequence& PhysicalDataSetStructure::
  PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship () const
  {
    return this->PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_;
  }

  PhysicalDataSetStructure::PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_sequence& PhysicalDataSetStructure::
  PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship ()
  {
    return this->PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_;
  }

  void PhysicalDataSetStructure::
  PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship (const PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_sequence& s)
  {
    this->PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_ = s;
  }


  // PhysicalLayoutRelationStructure
  //

  const PhysicalLayoutRelationStructure::criteria_optional& PhysicalLayoutRelationStructure::
  criteria () const
  {
    return this->criteria_;
  }

  PhysicalLayoutRelationStructure::criteria_optional& PhysicalLayoutRelationStructure::
  criteria ()
  {
    return this->criteria_;
  }

  void PhysicalLayoutRelationStructure::
  criteria (const criteria_type& x)
  {
    this->criteria_.set (x);
  }

  void PhysicalLayoutRelationStructure::
  criteria (const criteria_optional& x)
  {
    this->criteria_ = x;
  }

  void PhysicalLayoutRelationStructure::
  criteria (::std::unique_ptr< criteria_type > x)
  {
    this->criteria_.set (std::move (x));
  }

  const PhysicalLayoutRelationStructure::identifier_optional& PhysicalLayoutRelationStructure::
  identifier () const
  {
    return this->identifier_;
  }

  PhysicalLayoutRelationStructure::identifier_optional& PhysicalLayoutRelationStructure::
  identifier ()
  {
    return this->identifier_;
  }

  void PhysicalLayoutRelationStructure::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void PhysicalLayoutRelationStructure::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void PhysicalLayoutRelationStructure::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const PhysicalLayoutRelationStructure::name_sequence& PhysicalLayoutRelationStructure::
  name () const
  {
    return this->name_;
  }

  PhysicalLayoutRelationStructure::name_sequence& PhysicalLayoutRelationStructure::
  name ()
  {
    return this->name_;
  }

  void PhysicalLayoutRelationStructure::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const PhysicalLayoutRelationStructure::purpose_optional& PhysicalLayoutRelationStructure::
  purpose () const
  {
    return this->purpose_;
  }

  PhysicalLayoutRelationStructure::purpose_optional& PhysicalLayoutRelationStructure::
  purpose ()
  {
    return this->purpose_;
  }

  void PhysicalLayoutRelationStructure::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void PhysicalLayoutRelationStructure::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void PhysicalLayoutRelationStructure::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const PhysicalLayoutRelationStructure::semantics_optional& PhysicalLayoutRelationStructure::
  semantics () const
  {
    return this->semantics_;
  }

  PhysicalLayoutRelationStructure::semantics_optional& PhysicalLayoutRelationStructure::
  semantics ()
  {
    return this->semantics_;
  }

  void PhysicalLayoutRelationStructure::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void PhysicalLayoutRelationStructure::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void PhysicalLayoutRelationStructure::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const PhysicalLayoutRelationStructure::specification_optional& PhysicalLayoutRelationStructure::
  specification () const
  {
    return this->specification_;
  }

  PhysicalLayoutRelationStructure::specification_optional& PhysicalLayoutRelationStructure::
  specification ()
  {
    return this->specification_;
  }

  void PhysicalLayoutRelationStructure::
  specification (const specification_type& x)
  {
    this->specification_.set (x);
  }

  void PhysicalLayoutRelationStructure::
  specification (const specification_optional& x)
  {
    this->specification_ = x;
  }

  void PhysicalLayoutRelationStructure::
  specification (::std::unique_ptr< specification_type > x)
  {
    this->specification_.set (std::move (x));
  }

  const PhysicalLayoutRelationStructure::topology_type& PhysicalLayoutRelationStructure::
  topology () const
  {
    return this->topology_.get ();
  }

  PhysicalLayoutRelationStructure::topology_type& PhysicalLayoutRelationStructure::
  topology ()
  {
    return this->topology_.get ();
  }

  void PhysicalLayoutRelationStructure::
  topology (const topology_type& x)
  {
    this->topology_.set (x);
  }

  void PhysicalLayoutRelationStructure::
  topology (::std::unique_ptr< topology_type > x)
  {
    this->topology_.set (std::move (x));
  }

  const PhysicalLayoutRelationStructure::totality_optional& PhysicalLayoutRelationStructure::
  totality () const
  {
    return this->totality_;
  }

  PhysicalLayoutRelationStructure::totality_optional& PhysicalLayoutRelationStructure::
  totality ()
  {
    return this->totality_;
  }

  void PhysicalLayoutRelationStructure::
  totality (const totality_type& x)
  {
    this->totality_.set (x);
  }

  void PhysicalLayoutRelationStructure::
  totality (const totality_optional& x)
  {
    this->totality_ = x;
  }

  void PhysicalLayoutRelationStructure::
  totality (::std::unique_ptr< totality_type > x)
  {
    this->totality_.set (std::move (x));
  }

  const PhysicalLayoutRelationStructure::PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_optional& PhysicalLayoutRelationStructure::
  PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout () const
  {
    return this->PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_;
  }

  PhysicalLayoutRelationStructure::PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_optional& PhysicalLayoutRelationStructure::
  PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout ()
  {
    return this->PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_;
  }

  void PhysicalLayoutRelationStructure::
  PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout (const PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_type& x)
  {
    this->PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_.set (x);
  }

  void PhysicalLayoutRelationStructure::
  PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout (const PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_optional& x)
  {
    this->PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_ = x;
  }

  void PhysicalLayoutRelationStructure::
  PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout (::std::unique_ptr< PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_type > x)
  {
    this->PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_.set (std::move (x));
  }

  const PhysicalLayoutRelationStructure::PhysicalLayoutRelationStructure_has_ValueMappingRelationship_sequence& PhysicalLayoutRelationStructure::
  PhysicalLayoutRelationStructure_has_ValueMappingRelationship () const
  {
    return this->PhysicalLayoutRelationStructure_has_ValueMappingRelationship_;
  }

  PhysicalLayoutRelationStructure::PhysicalLayoutRelationStructure_has_ValueMappingRelationship_sequence& PhysicalLayoutRelationStructure::
  PhysicalLayoutRelationStructure_has_ValueMappingRelationship ()
  {
    return this->PhysicalLayoutRelationStructure_has_ValueMappingRelationship_;
  }

  void PhysicalLayoutRelationStructure::
  PhysicalLayoutRelationStructure_has_ValueMappingRelationship (const PhysicalLayoutRelationStructure_has_ValueMappingRelationship_sequence& s)
  {
    this->PhysicalLayoutRelationStructure_has_ValueMappingRelationship_ = s;
  }


  // PhysicalRecordSegment
  //

  const PhysicalRecordSegment::allowsDuplicates_type& PhysicalRecordSegment::
  allowsDuplicates () const
  {
    return this->allowsDuplicates_.get ();
  }

  PhysicalRecordSegment::allowsDuplicates_type& PhysicalRecordSegment::
  allowsDuplicates ()
  {
    return this->allowsDuplicates_.get ();
  }

  void PhysicalRecordSegment::
  allowsDuplicates (const allowsDuplicates_type& x)
  {
    this->allowsDuplicates_.set (x);
  }

  const PhysicalRecordSegment::catalogDetails_optional& PhysicalRecordSegment::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  PhysicalRecordSegment::catalogDetails_optional& PhysicalRecordSegment::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void PhysicalRecordSegment::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void PhysicalRecordSegment::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void PhysicalRecordSegment::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const PhysicalRecordSegment::identifier_optional& PhysicalRecordSegment::
  identifier () const
  {
    return this->identifier_;
  }

  PhysicalRecordSegment::identifier_optional& PhysicalRecordSegment::
  identifier ()
  {
    return this->identifier_;
  }

  void PhysicalRecordSegment::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void PhysicalRecordSegment::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void PhysicalRecordSegment::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const PhysicalRecordSegment::name_sequence& PhysicalRecordSegment::
  name () const
  {
    return this->name_;
  }

  PhysicalRecordSegment::name_sequence& PhysicalRecordSegment::
  name ()
  {
    return this->name_;
  }

  void PhysicalRecordSegment::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const PhysicalRecordSegment::physicalFileName_optional& PhysicalRecordSegment::
  physicalFileName () const
  {
    return this->physicalFileName_;
  }

  PhysicalRecordSegment::physicalFileName_optional& PhysicalRecordSegment::
  physicalFileName ()
  {
    return this->physicalFileName_;
  }

  void PhysicalRecordSegment::
  physicalFileName (const physicalFileName_type& x)
  {
    this->physicalFileName_.set (x);
  }

  void PhysicalRecordSegment::
  physicalFileName (const physicalFileName_optional& x)
  {
    this->physicalFileName_ = x;
  }

  void PhysicalRecordSegment::
  physicalFileName (::std::unique_ptr< physicalFileName_type > x)
  {
    this->physicalFileName_.set (std::move (x));
  }

  const PhysicalRecordSegment::purpose_optional& PhysicalRecordSegment::
  purpose () const
  {
    return this->purpose_;
  }

  PhysicalRecordSegment::purpose_optional& PhysicalRecordSegment::
  purpose ()
  {
    return this->purpose_;
  }

  void PhysicalRecordSegment::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void PhysicalRecordSegment::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void PhysicalRecordSegment::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const PhysicalRecordSegment::PhysicalRecordSegment_represents_Population_optional& PhysicalRecordSegment::
  PhysicalRecordSegment_represents_Population () const
  {
    return this->PhysicalRecordSegment_represents_Population_;
  }

  PhysicalRecordSegment::PhysicalRecordSegment_represents_Population_optional& PhysicalRecordSegment::
  PhysicalRecordSegment_represents_Population ()
  {
    return this->PhysicalRecordSegment_represents_Population_;
  }

  void PhysicalRecordSegment::
  PhysicalRecordSegment_represents_Population (const PhysicalRecordSegment_represents_Population_type& x)
  {
    this->PhysicalRecordSegment_represents_Population_.set (x);
  }

  void PhysicalRecordSegment::
  PhysicalRecordSegment_represents_Population (const PhysicalRecordSegment_represents_Population_optional& x)
  {
    this->PhysicalRecordSegment_represents_Population_ = x;
  }

  void PhysicalRecordSegment::
  PhysicalRecordSegment_represents_Population (::std::unique_ptr< PhysicalRecordSegment_represents_Population_type > x)
  {
    this->PhysicalRecordSegment_represents_Population_.set (std::move (x));
  }

  const PhysicalRecordSegment::PhysicalRecordSegment_isDefinedBy_Concept_sequence& PhysicalRecordSegment::
  PhysicalRecordSegment_isDefinedBy_Concept () const
  {
    return this->PhysicalRecordSegment_isDefinedBy_Concept_;
  }

  PhysicalRecordSegment::PhysicalRecordSegment_isDefinedBy_Concept_sequence& PhysicalRecordSegment::
  PhysicalRecordSegment_isDefinedBy_Concept ()
  {
    return this->PhysicalRecordSegment_isDefinedBy_Concept_;
  }

  void PhysicalRecordSegment::
  PhysicalRecordSegment_isDefinedBy_Concept (const PhysicalRecordSegment_isDefinedBy_Concept_sequence& s)
  {
    this->PhysicalRecordSegment_isDefinedBy_Concept_ = s;
  }

  const PhysicalRecordSegment::PhysicalRecordSegment_has_PhysicalSegmentLayout_optional& PhysicalRecordSegment::
  PhysicalRecordSegment_has_PhysicalSegmentLayout () const
  {
    return this->PhysicalRecordSegment_has_PhysicalSegmentLayout_;
  }

  PhysicalRecordSegment::PhysicalRecordSegment_has_PhysicalSegmentLayout_optional& PhysicalRecordSegment::
  PhysicalRecordSegment_has_PhysicalSegmentLayout ()
  {
    return this->PhysicalRecordSegment_has_PhysicalSegmentLayout_;
  }

  void PhysicalRecordSegment::
  PhysicalRecordSegment_has_PhysicalSegmentLayout (const PhysicalRecordSegment_has_PhysicalSegmentLayout_type& x)
  {
    this->PhysicalRecordSegment_has_PhysicalSegmentLayout_.set (x);
  }

  void PhysicalRecordSegment::
  PhysicalRecordSegment_has_PhysicalSegmentLayout (const PhysicalRecordSegment_has_PhysicalSegmentLayout_optional& x)
  {
    this->PhysicalRecordSegment_has_PhysicalSegmentLayout_ = x;
  }

  void PhysicalRecordSegment::
  PhysicalRecordSegment_has_PhysicalSegmentLayout (::std::unique_ptr< PhysicalRecordSegment_has_PhysicalSegmentLayout_type > x)
  {
    this->PhysicalRecordSegment_has_PhysicalSegmentLayout_.set (std::move (x));
  }

  const PhysicalRecordSegment::PhysicalRecordSegment_mapsTo_LogicalRecord_optional& PhysicalRecordSegment::
  PhysicalRecordSegment_mapsTo_LogicalRecord () const
  {
    return this->PhysicalRecordSegment_mapsTo_LogicalRecord_;
  }

  PhysicalRecordSegment::PhysicalRecordSegment_mapsTo_LogicalRecord_optional& PhysicalRecordSegment::
  PhysicalRecordSegment_mapsTo_LogicalRecord ()
  {
    return this->PhysicalRecordSegment_mapsTo_LogicalRecord_;
  }

  void PhysicalRecordSegment::
  PhysicalRecordSegment_mapsTo_LogicalRecord (const PhysicalRecordSegment_mapsTo_LogicalRecord_type& x)
  {
    this->PhysicalRecordSegment_mapsTo_LogicalRecord_.set (x);
  }

  void PhysicalRecordSegment::
  PhysicalRecordSegment_mapsTo_LogicalRecord (const PhysicalRecordSegment_mapsTo_LogicalRecord_optional& x)
  {
    this->PhysicalRecordSegment_mapsTo_LogicalRecord_ = x;
  }

  void PhysicalRecordSegment::
  PhysicalRecordSegment_mapsTo_LogicalRecord (::std::unique_ptr< PhysicalRecordSegment_mapsTo_LogicalRecord_type > x)
  {
    this->PhysicalRecordSegment_mapsTo_LogicalRecord_.set (std::move (x));
  }

  const PhysicalRecordSegment::PhysicalRecordSegment_has_DataPointPosition_sequence& PhysicalRecordSegment::
  PhysicalRecordSegment_has_DataPointPosition () const
  {
    return this->PhysicalRecordSegment_has_DataPointPosition_;
  }

  PhysicalRecordSegment::PhysicalRecordSegment_has_DataPointPosition_sequence& PhysicalRecordSegment::
  PhysicalRecordSegment_has_DataPointPosition ()
  {
    return this->PhysicalRecordSegment_has_DataPointPosition_;
  }

  void PhysicalRecordSegment::
  PhysicalRecordSegment_has_DataPointPosition (const PhysicalRecordSegment_has_DataPointPosition_sequence& s)
  {
    this->PhysicalRecordSegment_has_DataPointPosition_ = s;
  }

  const PhysicalRecordSegment::PhysicalRecordSegment_has_DataPoint_sequence& PhysicalRecordSegment::
  PhysicalRecordSegment_has_DataPoint () const
  {
    return this->PhysicalRecordSegment_has_DataPoint_;
  }

  PhysicalRecordSegment::PhysicalRecordSegment_has_DataPoint_sequence& PhysicalRecordSegment::
  PhysicalRecordSegment_has_DataPoint ()
  {
    return this->PhysicalRecordSegment_has_DataPoint_;
  }

  void PhysicalRecordSegment::
  PhysicalRecordSegment_has_DataPoint (const PhysicalRecordSegment_has_DataPoint_sequence& s)
  {
    this->PhysicalRecordSegment_has_DataPoint_ = s;
  }


  // PhysicalRecordSegmentPosition
  //

  const PhysicalRecordSegmentPosition::identifier_optional& PhysicalRecordSegmentPosition::
  identifier () const
  {
    return this->identifier_;
  }

  PhysicalRecordSegmentPosition::identifier_optional& PhysicalRecordSegmentPosition::
  identifier ()
  {
    return this->identifier_;
  }

  void PhysicalRecordSegmentPosition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void PhysicalRecordSegmentPosition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void PhysicalRecordSegmentPosition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const PhysicalRecordSegmentPosition::value_type& PhysicalRecordSegmentPosition::
  value () const
  {
    return this->value_.get ();
  }

  PhysicalRecordSegmentPosition::value_type& PhysicalRecordSegmentPosition::
  value ()
  {
    return this->value_.get ();
  }

  void PhysicalRecordSegmentPosition::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  const PhysicalRecordSegmentPosition::PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type& PhysicalRecordSegmentPosition::
  PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment () const
  {
    return this->PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_.get ();
  }

  PhysicalRecordSegmentPosition::PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type& PhysicalRecordSegmentPosition::
  PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment ()
  {
    return this->PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_.get ();
  }

  void PhysicalRecordSegmentPosition::
  PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment (const PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type& x)
  {
    this->PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_.set (x);
  }

  void PhysicalRecordSegmentPosition::
  PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment (::std::unique_ptr< PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type > x)
  {
    this->PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_.set (std::move (x));
  }


  // PhysicalRecordSegmentRelationship
  //

  const PhysicalRecordSegmentRelationship::identifier_optional& PhysicalRecordSegmentRelationship::
  identifier () const
  {
    return this->identifier_;
  }

  PhysicalRecordSegmentRelationship::identifier_optional& PhysicalRecordSegmentRelationship::
  identifier ()
  {
    return this->identifier_;
  }

  void PhysicalRecordSegmentRelationship::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void PhysicalRecordSegmentRelationship::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void PhysicalRecordSegmentRelationship::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const PhysicalRecordSegmentRelationship::semantics_optional& PhysicalRecordSegmentRelationship::
  semantics () const
  {
    return this->semantics_;
  }

  PhysicalRecordSegmentRelationship::semantics_optional& PhysicalRecordSegmentRelationship::
  semantics ()
  {
    return this->semantics_;
  }

  void PhysicalRecordSegmentRelationship::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void PhysicalRecordSegmentRelationship::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void PhysicalRecordSegmentRelationship::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const PhysicalRecordSegmentRelationship::PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_sequence& PhysicalRecordSegmentRelationship::
  PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment () const
  {
    return this->PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_;
  }

  PhysicalRecordSegmentRelationship::PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_sequence& PhysicalRecordSegmentRelationship::
  PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment ()
  {
    return this->PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_;
  }

  void PhysicalRecordSegmentRelationship::
  PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment (const PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_sequence& s)
  {
    this->PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_ = s;
  }

  const PhysicalRecordSegmentRelationship::PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_optional& PhysicalRecordSegmentRelationship::
  PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment () const
  {
    return this->PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_;
  }

  PhysicalRecordSegmentRelationship::PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_optional& PhysicalRecordSegmentRelationship::
  PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment ()
  {
    return this->PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_;
  }

  void PhysicalRecordSegmentRelationship::
  PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment (const PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_type& x)
  {
    this->PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_.set (x);
  }

  void PhysicalRecordSegmentRelationship::
  PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment (const PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_optional& x)
  {
    this->PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_ = x;
  }

  void PhysicalRecordSegmentRelationship::
  PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment (::std::unique_ptr< PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_type > x)
  {
    this->PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_.set (std::move (x));
  }


  // PhysicalRecordSegmentStructure
  //

  const PhysicalRecordSegmentStructure::identifier_optional& PhysicalRecordSegmentStructure::
  identifier () const
  {
    return this->identifier_;
  }

  PhysicalRecordSegmentStructure::identifier_optional& PhysicalRecordSegmentStructure::
  identifier ()
  {
    return this->identifier_;
  }

  void PhysicalRecordSegmentStructure::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void PhysicalRecordSegmentStructure::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void PhysicalRecordSegmentStructure::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const PhysicalRecordSegmentStructure::name_optional& PhysicalRecordSegmentStructure::
  name () const
  {
    return this->name_;
  }

  PhysicalRecordSegmentStructure::name_optional& PhysicalRecordSegmentStructure::
  name ()
  {
    return this->name_;
  }

  void PhysicalRecordSegmentStructure::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void PhysicalRecordSegmentStructure::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void PhysicalRecordSegmentStructure::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const PhysicalRecordSegmentStructure::purpose_optional& PhysicalRecordSegmentStructure::
  purpose () const
  {
    return this->purpose_;
  }

  PhysicalRecordSegmentStructure::purpose_optional& PhysicalRecordSegmentStructure::
  purpose ()
  {
    return this->purpose_;
  }

  void PhysicalRecordSegmentStructure::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void PhysicalRecordSegmentStructure::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void PhysicalRecordSegmentStructure::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const PhysicalRecordSegmentStructure::semantics_optional& PhysicalRecordSegmentStructure::
  semantics () const
  {
    return this->semantics_;
  }

  PhysicalRecordSegmentStructure::semantics_optional& PhysicalRecordSegmentStructure::
  semantics ()
  {
    return this->semantics_;
  }

  void PhysicalRecordSegmentStructure::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void PhysicalRecordSegmentStructure::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void PhysicalRecordSegmentStructure::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const PhysicalRecordSegmentStructure::specification_optional& PhysicalRecordSegmentStructure::
  specification () const
  {
    return this->specification_;
  }

  PhysicalRecordSegmentStructure::specification_optional& PhysicalRecordSegmentStructure::
  specification ()
  {
    return this->specification_;
  }

  void PhysicalRecordSegmentStructure::
  specification (const specification_type& x)
  {
    this->specification_.set (x);
  }

  void PhysicalRecordSegmentStructure::
  specification (const specification_optional& x)
  {
    this->specification_ = x;
  }

  void PhysicalRecordSegmentStructure::
  specification (::std::unique_ptr< specification_type > x)
  {
    this->specification_.set (std::move (x));
  }

  const PhysicalRecordSegmentStructure::topology_optional& PhysicalRecordSegmentStructure::
  topology () const
  {
    return this->topology_;
  }

  PhysicalRecordSegmentStructure::topology_optional& PhysicalRecordSegmentStructure::
  topology ()
  {
    return this->topology_;
  }

  void PhysicalRecordSegmentStructure::
  topology (const topology_type& x)
  {
    this->topology_.set (x);
  }

  void PhysicalRecordSegmentStructure::
  topology (const topology_optional& x)
  {
    this->topology_ = x;
  }

  void PhysicalRecordSegmentStructure::
  topology (::std::unique_ptr< topology_type > x)
  {
    this->topology_.set (std::move (x));
  }

  const PhysicalRecordSegmentStructure::totality_optional& PhysicalRecordSegmentStructure::
  totality () const
  {
    return this->totality_;
  }

  PhysicalRecordSegmentStructure::totality_optional& PhysicalRecordSegmentStructure::
  totality ()
  {
    return this->totality_;
  }

  void PhysicalRecordSegmentStructure::
  totality (const totality_type& x)
  {
    this->totality_.set (x);
  }

  void PhysicalRecordSegmentStructure::
  totality (const totality_optional& x)
  {
    this->totality_ = x;
  }

  void PhysicalRecordSegmentStructure::
  totality (::std::unique_ptr< totality_type > x)
  {
    this->totality_.set (std::move (x));
  }

  const PhysicalRecordSegmentStructure::PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_optional& PhysicalRecordSegmentStructure::
  PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment () const
  {
    return this->PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_;
  }

  PhysicalRecordSegmentStructure::PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_optional& PhysicalRecordSegmentStructure::
  PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment ()
  {
    return this->PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_;
  }

  void PhysicalRecordSegmentStructure::
  PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment (const PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_type& x)
  {
    this->PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_.set (x);
  }

  void PhysicalRecordSegmentStructure::
  PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment (const PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_optional& x)
  {
    this->PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_ = x;
  }

  void PhysicalRecordSegmentStructure::
  PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment (::std::unique_ptr< PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_type > x)
  {
    this->PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_.set (std::move (x));
  }

  const PhysicalRecordSegmentStructure::PhysicalRecordSegmentStructure_has_DataPointRelationship_sequence& PhysicalRecordSegmentStructure::
  PhysicalRecordSegmentStructure_has_DataPointRelationship () const
  {
    return this->PhysicalRecordSegmentStructure_has_DataPointRelationship_;
  }

  PhysicalRecordSegmentStructure::PhysicalRecordSegmentStructure_has_DataPointRelationship_sequence& PhysicalRecordSegmentStructure::
  PhysicalRecordSegmentStructure_has_DataPointRelationship ()
  {
    return this->PhysicalRecordSegmentStructure_has_DataPointRelationship_;
  }

  void PhysicalRecordSegmentStructure::
  PhysicalRecordSegmentStructure_has_DataPointRelationship (const PhysicalRecordSegmentStructure_has_DataPointRelationship_sequence& s)
  {
    this->PhysicalRecordSegmentStructure_has_DataPointRelationship_ = s;
  }


  // PhysicalSegmentLayout
  //

  const PhysicalSegmentLayout::allowsDuplicates_type& PhysicalSegmentLayout::
  allowsDuplicates () const
  {
    return this->allowsDuplicates_.get ();
  }

  PhysicalSegmentLayout::allowsDuplicates_type& PhysicalSegmentLayout::
  allowsDuplicates ()
  {
    return this->allowsDuplicates_.get ();
  }

  void PhysicalSegmentLayout::
  allowsDuplicates (const allowsDuplicates_type& x)
  {
    this->allowsDuplicates_.set (x);
  }

  const PhysicalSegmentLayout::arrayBase_optional& PhysicalSegmentLayout::
  arrayBase () const
  {
    return this->arrayBase_;
  }

  PhysicalSegmentLayout::arrayBase_optional& PhysicalSegmentLayout::
  arrayBase ()
  {
    return this->arrayBase_;
  }

  void PhysicalSegmentLayout::
  arrayBase (const arrayBase_type& x)
  {
    this->arrayBase_.set (x);
  }

  void PhysicalSegmentLayout::
  arrayBase (const arrayBase_optional& x)
  {
    this->arrayBase_ = x;
  }

  const PhysicalSegmentLayout::catalogDetails_optional& PhysicalSegmentLayout::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  PhysicalSegmentLayout::catalogDetails_optional& PhysicalSegmentLayout::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void PhysicalSegmentLayout::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void PhysicalSegmentLayout::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void PhysicalSegmentLayout::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const PhysicalSegmentLayout::commentPrefix_optional& PhysicalSegmentLayout::
  commentPrefix () const
  {
    return this->commentPrefix_;
  }

  PhysicalSegmentLayout::commentPrefix_optional& PhysicalSegmentLayout::
  commentPrefix ()
  {
    return this->commentPrefix_;
  }

  void PhysicalSegmentLayout::
  commentPrefix (const commentPrefix_type& x)
  {
    this->commentPrefix_.set (x);
  }

  void PhysicalSegmentLayout::
  commentPrefix (const commentPrefix_optional& x)
  {
    this->commentPrefix_ = x;
  }

  void PhysicalSegmentLayout::
  commentPrefix (::std::unique_ptr< commentPrefix_type > x)
  {
    this->commentPrefix_.set (std::move (x));
  }

  const PhysicalSegmentLayout::delimiter_optional& PhysicalSegmentLayout::
  delimiter () const
  {
    return this->delimiter_;
  }

  PhysicalSegmentLayout::delimiter_optional& PhysicalSegmentLayout::
  delimiter ()
  {
    return this->delimiter_;
  }

  void PhysicalSegmentLayout::
  delimiter (const delimiter_type& x)
  {
    this->delimiter_.set (x);
  }

  void PhysicalSegmentLayout::
  delimiter (const delimiter_optional& x)
  {
    this->delimiter_ = x;
  }

  void PhysicalSegmentLayout::
  delimiter (::std::unique_ptr< delimiter_type > x)
  {
    this->delimiter_.set (std::move (x));
  }

  const PhysicalSegmentLayout::encoding_optional& PhysicalSegmentLayout::
  encoding () const
  {
    return this->encoding_;
  }

  PhysicalSegmentLayout::encoding_optional& PhysicalSegmentLayout::
  encoding ()
  {
    return this->encoding_;
  }

  void PhysicalSegmentLayout::
  encoding (const encoding_type& x)
  {
    this->encoding_.set (x);
  }

  void PhysicalSegmentLayout::
  encoding (const encoding_optional& x)
  {
    this->encoding_ = x;
  }

  void PhysicalSegmentLayout::
  encoding (::std::unique_ptr< encoding_type > x)
  {
    this->encoding_.set (std::move (x));
  }

  const PhysicalSegmentLayout::escapeCharacter_optional& PhysicalSegmentLayout::
  escapeCharacter () const
  {
    return this->escapeCharacter_;
  }

  PhysicalSegmentLayout::escapeCharacter_optional& PhysicalSegmentLayout::
  escapeCharacter ()
  {
    return this->escapeCharacter_;
  }

  void PhysicalSegmentLayout::
  escapeCharacter (const escapeCharacter_type& x)
  {
    this->escapeCharacter_.set (x);
  }

  void PhysicalSegmentLayout::
  escapeCharacter (const escapeCharacter_optional& x)
  {
    this->escapeCharacter_ = x;
  }

  void PhysicalSegmentLayout::
  escapeCharacter (::std::unique_ptr< escapeCharacter_type > x)
  {
    this->escapeCharacter_.set (std::move (x));
  }

  const PhysicalSegmentLayout::hasHeader_optional& PhysicalSegmentLayout::
  hasHeader () const
  {
    return this->hasHeader_;
  }

  PhysicalSegmentLayout::hasHeader_optional& PhysicalSegmentLayout::
  hasHeader ()
  {
    return this->hasHeader_;
  }

  void PhysicalSegmentLayout::
  hasHeader (const hasHeader_type& x)
  {
    this->hasHeader_.set (x);
  }

  void PhysicalSegmentLayout::
  hasHeader (const hasHeader_optional& x)
  {
    this->hasHeader_ = x;
  }

  const PhysicalSegmentLayout::headerIsCaseSensitive_optional& PhysicalSegmentLayout::
  headerIsCaseSensitive () const
  {
    return this->headerIsCaseSensitive_;
  }

  PhysicalSegmentLayout::headerIsCaseSensitive_optional& PhysicalSegmentLayout::
  headerIsCaseSensitive ()
  {
    return this->headerIsCaseSensitive_;
  }

  void PhysicalSegmentLayout::
  headerIsCaseSensitive (const headerIsCaseSensitive_type& x)
  {
    this->headerIsCaseSensitive_.set (x);
  }

  void PhysicalSegmentLayout::
  headerIsCaseSensitive (const headerIsCaseSensitive_optional& x)
  {
    this->headerIsCaseSensitive_ = x;
  }

  const PhysicalSegmentLayout::headerRowCount_optional& PhysicalSegmentLayout::
  headerRowCount () const
  {
    return this->headerRowCount_;
  }

  PhysicalSegmentLayout::headerRowCount_optional& PhysicalSegmentLayout::
  headerRowCount ()
  {
    return this->headerRowCount_;
  }

  void PhysicalSegmentLayout::
  headerRowCount (const headerRowCount_type& x)
  {
    this->headerRowCount_.set (x);
  }

  void PhysicalSegmentLayout::
  headerRowCount (const headerRowCount_optional& x)
  {
    this->headerRowCount_ = x;
  }

  const PhysicalSegmentLayout::identifier_optional& PhysicalSegmentLayout::
  identifier () const
  {
    return this->identifier_;
  }

  PhysicalSegmentLayout::identifier_optional& PhysicalSegmentLayout::
  identifier ()
  {
    return this->identifier_;
  }

  void PhysicalSegmentLayout::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void PhysicalSegmentLayout::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void PhysicalSegmentLayout::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const PhysicalSegmentLayout::isDelimited_type& PhysicalSegmentLayout::
  isDelimited () const
  {
    return this->isDelimited_.get ();
  }

  PhysicalSegmentLayout::isDelimited_type& PhysicalSegmentLayout::
  isDelimited ()
  {
    return this->isDelimited_.get ();
  }

  void PhysicalSegmentLayout::
  isDelimited (const isDelimited_type& x)
  {
    this->isDelimited_.set (x);
  }

  const PhysicalSegmentLayout::isFixedWidth_type& PhysicalSegmentLayout::
  isFixedWidth () const
  {
    return this->isFixedWidth_.get ();
  }

  PhysicalSegmentLayout::isFixedWidth_type& PhysicalSegmentLayout::
  isFixedWidth ()
  {
    return this->isFixedWidth_.get ();
  }

  void PhysicalSegmentLayout::
  isFixedWidth (const isFixedWidth_type& x)
  {
    this->isFixedWidth_.set (x);
  }

  const PhysicalSegmentLayout::lineTerminator_sequence& PhysicalSegmentLayout::
  lineTerminator () const
  {
    return this->lineTerminator_;
  }

  PhysicalSegmentLayout::lineTerminator_sequence& PhysicalSegmentLayout::
  lineTerminator ()
  {
    return this->lineTerminator_;
  }

  void PhysicalSegmentLayout::
  lineTerminator (const lineTerminator_sequence& s)
  {
    this->lineTerminator_ = s;
  }

  const PhysicalSegmentLayout::name_sequence& PhysicalSegmentLayout::
  name () const
  {
    return this->name_;
  }

  PhysicalSegmentLayout::name_sequence& PhysicalSegmentLayout::
  name ()
  {
    return this->name_;
  }

  void PhysicalSegmentLayout::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const PhysicalSegmentLayout::nullSequence_optional& PhysicalSegmentLayout::
  nullSequence () const
  {
    return this->nullSequence_;
  }

  PhysicalSegmentLayout::nullSequence_optional& PhysicalSegmentLayout::
  nullSequence ()
  {
    return this->nullSequence_;
  }

  void PhysicalSegmentLayout::
  nullSequence (const nullSequence_type& x)
  {
    this->nullSequence_.set (x);
  }

  void PhysicalSegmentLayout::
  nullSequence (const nullSequence_optional& x)
  {
    this->nullSequence_ = x;
  }

  void PhysicalSegmentLayout::
  nullSequence (::std::unique_ptr< nullSequence_type > x)
  {
    this->nullSequence_.set (std::move (x));
  }

  const PhysicalSegmentLayout::overview_optional& PhysicalSegmentLayout::
  overview () const
  {
    return this->overview_;
  }

  PhysicalSegmentLayout::overview_optional& PhysicalSegmentLayout::
  overview ()
  {
    return this->overview_;
  }

  void PhysicalSegmentLayout::
  overview (const overview_type& x)
  {
    this->overview_.set (x);
  }

  void PhysicalSegmentLayout::
  overview (const overview_optional& x)
  {
    this->overview_ = x;
  }

  void PhysicalSegmentLayout::
  overview (::std::unique_ptr< overview_type > x)
  {
    this->overview_.set (std::move (x));
  }

  const PhysicalSegmentLayout::purpose_optional& PhysicalSegmentLayout::
  purpose () const
  {
    return this->purpose_;
  }

  PhysicalSegmentLayout::purpose_optional& PhysicalSegmentLayout::
  purpose ()
  {
    return this->purpose_;
  }

  void PhysicalSegmentLayout::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void PhysicalSegmentLayout::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void PhysicalSegmentLayout::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const PhysicalSegmentLayout::quoteCharacter_optional& PhysicalSegmentLayout::
  quoteCharacter () const
  {
    return this->quoteCharacter_;
  }

  PhysicalSegmentLayout::quoteCharacter_optional& PhysicalSegmentLayout::
  quoteCharacter ()
  {
    return this->quoteCharacter_;
  }

  void PhysicalSegmentLayout::
  quoteCharacter (const quoteCharacter_type& x)
  {
    this->quoteCharacter_.set (x);
  }

  void PhysicalSegmentLayout::
  quoteCharacter (const quoteCharacter_optional& x)
  {
    this->quoteCharacter_ = x;
  }

  void PhysicalSegmentLayout::
  quoteCharacter (::std::unique_ptr< quoteCharacter_type > x)
  {
    this->quoteCharacter_.set (std::move (x));
  }

  const PhysicalSegmentLayout::skipBlankRows_optional& PhysicalSegmentLayout::
  skipBlankRows () const
  {
    return this->skipBlankRows_;
  }

  PhysicalSegmentLayout::skipBlankRows_optional& PhysicalSegmentLayout::
  skipBlankRows ()
  {
    return this->skipBlankRows_;
  }

  void PhysicalSegmentLayout::
  skipBlankRows (const skipBlankRows_type& x)
  {
    this->skipBlankRows_.set (x);
  }

  void PhysicalSegmentLayout::
  skipBlankRows (const skipBlankRows_optional& x)
  {
    this->skipBlankRows_ = x;
  }

  const PhysicalSegmentLayout::skipDataColumns_optional& PhysicalSegmentLayout::
  skipDataColumns () const
  {
    return this->skipDataColumns_;
  }

  PhysicalSegmentLayout::skipDataColumns_optional& PhysicalSegmentLayout::
  skipDataColumns ()
  {
    return this->skipDataColumns_;
  }

  void PhysicalSegmentLayout::
  skipDataColumns (const skipDataColumns_type& x)
  {
    this->skipDataColumns_.set (x);
  }

  void PhysicalSegmentLayout::
  skipDataColumns (const skipDataColumns_optional& x)
  {
    this->skipDataColumns_ = x;
  }

  const PhysicalSegmentLayout::skipInitialSpace_optional& PhysicalSegmentLayout::
  skipInitialSpace () const
  {
    return this->skipInitialSpace_;
  }

  PhysicalSegmentLayout::skipInitialSpace_optional& PhysicalSegmentLayout::
  skipInitialSpace ()
  {
    return this->skipInitialSpace_;
  }

  void PhysicalSegmentLayout::
  skipInitialSpace (const skipInitialSpace_type& x)
  {
    this->skipInitialSpace_.set (x);
  }

  void PhysicalSegmentLayout::
  skipInitialSpace (const skipInitialSpace_optional& x)
  {
    this->skipInitialSpace_ = x;
  }

  const PhysicalSegmentLayout::skipRows_optional& PhysicalSegmentLayout::
  skipRows () const
  {
    return this->skipRows_;
  }

  PhysicalSegmentLayout::skipRows_optional& PhysicalSegmentLayout::
  skipRows ()
  {
    return this->skipRows_;
  }

  void PhysicalSegmentLayout::
  skipRows (const skipRows_type& x)
  {
    this->skipRows_.set (x);
  }

  void PhysicalSegmentLayout::
  skipRows (const skipRows_optional& x)
  {
    this->skipRows_ = x;
  }

  const PhysicalSegmentLayout::tableDirection_optional& PhysicalSegmentLayout::
  tableDirection () const
  {
    return this->tableDirection_;
  }

  PhysicalSegmentLayout::tableDirection_optional& PhysicalSegmentLayout::
  tableDirection ()
  {
    return this->tableDirection_;
  }

  void PhysicalSegmentLayout::
  tableDirection (const tableDirection_type& x)
  {
    this->tableDirection_.set (x);
  }

  void PhysicalSegmentLayout::
  tableDirection (const tableDirection_optional& x)
  {
    this->tableDirection_ = x;
  }

  void PhysicalSegmentLayout::
  tableDirection (::std::unique_ptr< tableDirection_type > x)
  {
    this->tableDirection_.set (std::move (x));
  }

  const PhysicalSegmentLayout::textDirection_optional& PhysicalSegmentLayout::
  textDirection () const
  {
    return this->textDirection_;
  }

  PhysicalSegmentLayout::textDirection_optional& PhysicalSegmentLayout::
  textDirection ()
  {
    return this->textDirection_;
  }

  void PhysicalSegmentLayout::
  textDirection (const textDirection_type& x)
  {
    this->textDirection_.set (x);
  }

  void PhysicalSegmentLayout::
  textDirection (const textDirection_optional& x)
  {
    this->textDirection_ = x;
  }

  void PhysicalSegmentLayout::
  textDirection (::std::unique_ptr< textDirection_type > x)
  {
    this->textDirection_.set (std::move (x));
  }

  const PhysicalSegmentLayout::treatConsecutiveDelimitersAsOne_optional& PhysicalSegmentLayout::
  treatConsecutiveDelimitersAsOne () const
  {
    return this->treatConsecutiveDelimitersAsOne_;
  }

  PhysicalSegmentLayout::treatConsecutiveDelimitersAsOne_optional& PhysicalSegmentLayout::
  treatConsecutiveDelimitersAsOne ()
  {
    return this->treatConsecutiveDelimitersAsOne_;
  }

  void PhysicalSegmentLayout::
  treatConsecutiveDelimitersAsOne (const treatConsecutiveDelimitersAsOne_type& x)
  {
    this->treatConsecutiveDelimitersAsOne_.set (x);
  }

  void PhysicalSegmentLayout::
  treatConsecutiveDelimitersAsOne (const treatConsecutiveDelimitersAsOne_optional& x)
  {
    this->treatConsecutiveDelimitersAsOne_ = x;
  }

  const PhysicalSegmentLayout::trim_optional& PhysicalSegmentLayout::
  trim () const
  {
    return this->trim_;
  }

  PhysicalSegmentLayout::trim_optional& PhysicalSegmentLayout::
  trim ()
  {
    return this->trim_;
  }

  void PhysicalSegmentLayout::
  trim (const trim_type& x)
  {
    this->trim_.set (x);
  }

  void PhysicalSegmentLayout::
  trim (const trim_optional& x)
  {
    this->trim_ = x;
  }

  void PhysicalSegmentLayout::
  trim (::std::unique_ptr< trim_type > x)
  {
    this->trim_.set (std::move (x));
  }

  const PhysicalSegmentLayout::PhysicalSegmentLayout_isDefinedBy_Concept_sequence& PhysicalSegmentLayout::
  PhysicalSegmentLayout_isDefinedBy_Concept () const
  {
    return this->PhysicalSegmentLayout_isDefinedBy_Concept_;
  }

  PhysicalSegmentLayout::PhysicalSegmentLayout_isDefinedBy_Concept_sequence& PhysicalSegmentLayout::
  PhysicalSegmentLayout_isDefinedBy_Concept ()
  {
    return this->PhysicalSegmentLayout_isDefinedBy_Concept_;
  }

  void PhysicalSegmentLayout::
  PhysicalSegmentLayout_isDefinedBy_Concept (const PhysicalSegmentLayout_isDefinedBy_Concept_sequence& s)
  {
    this->PhysicalSegmentLayout_isDefinedBy_Concept_ = s;
  }

  const PhysicalSegmentLayout::PhysicalSegmentLayout_formats_LogicalRecord_optional& PhysicalSegmentLayout::
  PhysicalSegmentLayout_formats_LogicalRecord () const
  {
    return this->PhysicalSegmentLayout_formats_LogicalRecord_;
  }

  PhysicalSegmentLayout::PhysicalSegmentLayout_formats_LogicalRecord_optional& PhysicalSegmentLayout::
  PhysicalSegmentLayout_formats_LogicalRecord ()
  {
    return this->PhysicalSegmentLayout_formats_LogicalRecord_;
  }

  void PhysicalSegmentLayout::
  PhysicalSegmentLayout_formats_LogicalRecord (const PhysicalSegmentLayout_formats_LogicalRecord_type& x)
  {
    this->PhysicalSegmentLayout_formats_LogicalRecord_.set (x);
  }

  void PhysicalSegmentLayout::
  PhysicalSegmentLayout_formats_LogicalRecord (const PhysicalSegmentLayout_formats_LogicalRecord_optional& x)
  {
    this->PhysicalSegmentLayout_formats_LogicalRecord_ = x;
  }

  void PhysicalSegmentLayout::
  PhysicalSegmentLayout_formats_LogicalRecord (::std::unique_ptr< PhysicalSegmentLayout_formats_LogicalRecord_type > x)
  {
    this->PhysicalSegmentLayout_formats_LogicalRecord_.set (std::move (x));
  }

  const PhysicalSegmentLayout::PhysicalSegmentLayout_has_ValueMapping_sequence& PhysicalSegmentLayout::
  PhysicalSegmentLayout_has_ValueMapping () const
  {
    return this->PhysicalSegmentLayout_has_ValueMapping_;
  }

  PhysicalSegmentLayout::PhysicalSegmentLayout_has_ValueMapping_sequence& PhysicalSegmentLayout::
  PhysicalSegmentLayout_has_ValueMapping ()
  {
    return this->PhysicalSegmentLayout_has_ValueMapping_;
  }

  void PhysicalSegmentLayout::
  PhysicalSegmentLayout_has_ValueMapping (const PhysicalSegmentLayout_has_ValueMapping_sequence& s)
  {
    this->PhysicalSegmentLayout_has_ValueMapping_ = s;
  }

  const PhysicalSegmentLayout::PhysicalSegmentLayout_has_ValueMappingPosition_sequence& PhysicalSegmentLayout::
  PhysicalSegmentLayout_has_ValueMappingPosition () const
  {
    return this->PhysicalSegmentLayout_has_ValueMappingPosition_;
  }

  PhysicalSegmentLayout::PhysicalSegmentLayout_has_ValueMappingPosition_sequence& PhysicalSegmentLayout::
  PhysicalSegmentLayout_has_ValueMappingPosition ()
  {
    return this->PhysicalSegmentLayout_has_ValueMappingPosition_;
  }

  void PhysicalSegmentLayout::
  PhysicalSegmentLayout_has_ValueMappingPosition (const PhysicalSegmentLayout_has_ValueMappingPosition_sequence& s)
  {
    this->PhysicalSegmentLayout_has_ValueMappingPosition_ = s;
  }


  // PhysicalSegmentLocation
  //

  const PhysicalSegmentLocation::catalogDetails_optional& PhysicalSegmentLocation::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  PhysicalSegmentLocation::catalogDetails_optional& PhysicalSegmentLocation::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void PhysicalSegmentLocation::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void PhysicalSegmentLocation::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void PhysicalSegmentLocation::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const PhysicalSegmentLocation::identifier_optional& PhysicalSegmentLocation::
  identifier () const
  {
    return this->identifier_;
  }

  PhysicalSegmentLocation::identifier_optional& PhysicalSegmentLocation::
  identifier ()
  {
    return this->identifier_;
  }

  void PhysicalSegmentLocation::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void PhysicalSegmentLocation::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void PhysicalSegmentLocation::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }


  // UnitType
  //

  const UnitType::descriptiveText_optional& UnitType::
  descriptiveText () const
  {
    return this->descriptiveText_;
  }

  UnitType::descriptiveText_optional& UnitType::
  descriptiveText ()
  {
    return this->descriptiveText_;
  }

  void UnitType::
  descriptiveText (const descriptiveText_type& x)
  {
    this->descriptiveText_.set (x);
  }

  void UnitType::
  descriptiveText (const descriptiveText_optional& x)
  {
    this->descriptiveText_ = x;
  }

  void UnitType::
  descriptiveText (::std::unique_ptr< descriptiveText_type > x)
  {
    this->descriptiveText_.set (std::move (x));
  }


  // Universe
  //

  const Universe::isInclusive_optional& Universe::
  isInclusive () const
  {
    return this->isInclusive_;
  }

  Universe::isInclusive_optional& Universe::
  isInclusive ()
  {
    return this->isInclusive_;
  }

  void Universe::
  isInclusive (const isInclusive_type& x)
  {
    this->isInclusive_.set (x);
  }

  void Universe::
  isInclusive (const isInclusive_optional& x)
  {
    this->isInclusive_ = x;
  }


  // Population
  //

  const Population::timePeriodOfPopulation_sequence& Population::
  timePeriodOfPopulation () const
  {
    return this->timePeriodOfPopulation_;
  }

  Population::timePeriodOfPopulation_sequence& Population::
  timePeriodOfPopulation ()
  {
    return this->timePeriodOfPopulation_;
  }

  void Population::
  timePeriodOfPopulation (const timePeriodOfPopulation_sequence& s)
  {
    this->timePeriodOfPopulation_ = s;
  }

  const Population::Population_isComposedOf_Unit_sequence& Population::
  Population_isComposedOf_Unit () const
  {
    return this->Population_isComposedOf_Unit_;
  }

  Population::Population_isComposedOf_Unit_sequence& Population::
  Population_isComposedOf_Unit ()
  {
    return this->Population_isComposedOf_Unit_;
  }

  void Population::
  Population_isComposedOf_Unit (const Population_isComposedOf_Unit_sequence& s)
  {
    this->Population_isComposedOf_Unit_ = s;
  }


  // PrimaryKey
  //

  const PrimaryKey::identifier_optional& PrimaryKey::
  identifier () const
  {
    return this->identifier_;
  }

  PrimaryKey::identifier_optional& PrimaryKey::
  identifier ()
  {
    return this->identifier_;
  }

  void PrimaryKey::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void PrimaryKey::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void PrimaryKey::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const PrimaryKey::PrimaryKey_isComposedOf_PrimaryKeyComponent_sequence& PrimaryKey::
  PrimaryKey_isComposedOf_PrimaryKeyComponent () const
  {
    return this->PrimaryKey_isComposedOf_PrimaryKeyComponent_;
  }

  PrimaryKey::PrimaryKey_isComposedOf_PrimaryKeyComponent_sequence& PrimaryKey::
  PrimaryKey_isComposedOf_PrimaryKeyComponent ()
  {
    return this->PrimaryKey_isComposedOf_PrimaryKeyComponent_;
  }

  void PrimaryKey::
  PrimaryKey_isComposedOf_PrimaryKeyComponent (const PrimaryKey_isComposedOf_PrimaryKeyComponent_sequence& s)
  {
    this->PrimaryKey_isComposedOf_PrimaryKeyComponent_ = s;
  }


  // PrimaryKeyComponent
  //

  const PrimaryKeyComponent::identifier_optional& PrimaryKeyComponent::
  identifier () const
  {
    return this->identifier_;
  }

  PrimaryKeyComponent::identifier_optional& PrimaryKeyComponent::
  identifier ()
  {
    return this->identifier_;
  }

  void PrimaryKeyComponent::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void PrimaryKeyComponent::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void PrimaryKeyComponent::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const PrimaryKeyComponent::PrimaryKeyComponent_correspondsTo_DataStructureComponent_type& PrimaryKeyComponent::
  PrimaryKeyComponent_correspondsTo_DataStructureComponent () const
  {
    return this->PrimaryKeyComponent_correspondsTo_DataStructureComponent_.get ();
  }

  PrimaryKeyComponent::PrimaryKeyComponent_correspondsTo_DataStructureComponent_type& PrimaryKeyComponent::
  PrimaryKeyComponent_correspondsTo_DataStructureComponent ()
  {
    return this->PrimaryKeyComponent_correspondsTo_DataStructureComponent_.get ();
  }

  void PrimaryKeyComponent::
  PrimaryKeyComponent_correspondsTo_DataStructureComponent (const PrimaryKeyComponent_correspondsTo_DataStructureComponent_type& x)
  {
    this->PrimaryKeyComponent_correspondsTo_DataStructureComponent_.set (x);
  }

  void PrimaryKeyComponent::
  PrimaryKeyComponent_correspondsTo_DataStructureComponent (::std::unique_ptr< PrimaryKeyComponent_correspondsTo_DataStructureComponent_type > x)
  {
    this->PrimaryKeyComponent_correspondsTo_DataStructureComponent_.set (std::move (x));
  }


  // ProductionEnvironment
  //

  const ProductionEnvironment::identifier_optional& ProductionEnvironment::
  identifier () const
  {
    return this->identifier_;
  }

  ProductionEnvironment::identifier_optional& ProductionEnvironment::
  identifier ()
  {
    return this->identifier_;
  }

  void ProductionEnvironment::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ProductionEnvironment::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ProductionEnvironment::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }


  // QualifiedMeasure
  //

  const QualifiedMeasure::QualifiedMeasure_refines_MeasureComponent_optional& QualifiedMeasure::
  QualifiedMeasure_refines_MeasureComponent () const
  {
    return this->QualifiedMeasure_refines_MeasureComponent_;
  }

  QualifiedMeasure::QualifiedMeasure_refines_MeasureComponent_optional& QualifiedMeasure::
  QualifiedMeasure_refines_MeasureComponent ()
  {
    return this->QualifiedMeasure_refines_MeasureComponent_;
  }

  void QualifiedMeasure::
  QualifiedMeasure_refines_MeasureComponent (const QualifiedMeasure_refines_MeasureComponent_type& x)
  {
    this->QualifiedMeasure_refines_MeasureComponent_.set (x);
  }

  void QualifiedMeasure::
  QualifiedMeasure_refines_MeasureComponent (const QualifiedMeasure_refines_MeasureComponent_optional& x)
  {
    this->QualifiedMeasure_refines_MeasureComponent_ = x;
  }

  void QualifiedMeasure::
  QualifiedMeasure_refines_MeasureComponent (::std::unique_ptr< QualifiedMeasure_refines_MeasureComponent_type > x)
  {
    this->QualifiedMeasure_refines_MeasureComponent_.set (std::move (x));
  }


  // RecordRelation
  //

  const RecordRelation::catalogDetails_optional& RecordRelation::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  RecordRelation::catalogDetails_optional& RecordRelation::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void RecordRelation::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void RecordRelation::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void RecordRelation::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const RecordRelation::displayLabel_sequence& RecordRelation::
  displayLabel () const
  {
    return this->displayLabel_;
  }

  RecordRelation::displayLabel_sequence& RecordRelation::
  displayLabel ()
  {
    return this->displayLabel_;
  }

  void RecordRelation::
  displayLabel (const displayLabel_sequence& s)
  {
    this->displayLabel_ = s;
  }

  const RecordRelation::identifier_optional& RecordRelation::
  identifier () const
  {
    return this->identifier_;
  }

  RecordRelation::identifier_optional& RecordRelation::
  identifier ()
  {
    return this->identifier_;
  }

  void RecordRelation::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void RecordRelation::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void RecordRelation::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const RecordRelation::purpose_optional& RecordRelation::
  purpose () const
  {
    return this->purpose_;
  }

  RecordRelation::purpose_optional& RecordRelation::
  purpose ()
  {
    return this->purpose_;
  }

  void RecordRelation::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void RecordRelation::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void RecordRelation::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const RecordRelation::usage_optional& RecordRelation::
  usage () const
  {
    return this->usage_;
  }

  RecordRelation::usage_optional& RecordRelation::
  usage ()
  {
    return this->usage_;
  }

  void RecordRelation::
  usage (const usage_type& x)
  {
    this->usage_.set (x);
  }

  void RecordRelation::
  usage (const usage_optional& x)
  {
    this->usage_ = x;
  }

  void RecordRelation::
  usage (::std::unique_ptr< usage_type > x)
  {
    this->usage_.set (std::move (x));
  }

  const RecordRelation::RecordRelation_maps_LogicalRecord_sequence& RecordRelation::
  RecordRelation_maps_LogicalRecord () const
  {
    return this->RecordRelation_maps_LogicalRecord_;
  }

  RecordRelation::RecordRelation_maps_LogicalRecord_sequence& RecordRelation::
  RecordRelation_maps_LogicalRecord ()
  {
    return this->RecordRelation_maps_LogicalRecord_;
  }

  void RecordRelation::
  RecordRelation_maps_LogicalRecord (const RecordRelation_maps_LogicalRecord_sequence& s)
  {
    this->RecordRelation_maps_LogicalRecord_ = s;
  }

  const RecordRelation::RecordRelation_has_InstanceVariableMap_sequence& RecordRelation::
  RecordRelation_has_InstanceVariableMap () const
  {
    return this->RecordRelation_has_InstanceVariableMap_;
  }

  RecordRelation::RecordRelation_has_InstanceVariableMap_sequence& RecordRelation::
  RecordRelation_has_InstanceVariableMap ()
  {
    return this->RecordRelation_has_InstanceVariableMap_;
  }

  void RecordRelation::
  RecordRelation_has_InstanceVariableMap (const RecordRelation_has_InstanceVariableMap_sequence& s)
  {
    this->RecordRelation_has_InstanceVariableMap_ = s;
  }


  // ReferenceValue
  //

  const ReferenceValue::ReferenceValue_correspondsTo_VariableValueComponent_type& ReferenceValue::
  ReferenceValue_correspondsTo_VariableValueComponent () const
  {
    return this->ReferenceValue_correspondsTo_VariableValueComponent_.get ();
  }

  ReferenceValue::ReferenceValue_correspondsTo_VariableValueComponent_type& ReferenceValue::
  ReferenceValue_correspondsTo_VariableValueComponent ()
  {
    return this->ReferenceValue_correspondsTo_VariableValueComponent_.get ();
  }

  void ReferenceValue::
  ReferenceValue_correspondsTo_VariableValueComponent (const ReferenceValue_correspondsTo_VariableValueComponent_type& x)
  {
    this->ReferenceValue_correspondsTo_VariableValueComponent_.set (x);
  }

  void ReferenceValue::
  ReferenceValue_correspondsTo_VariableValueComponent (::std::unique_ptr< ReferenceValue_correspondsTo_VariableValueComponent_type > x)
  {
    this->ReferenceValue_correspondsTo_VariableValueComponent_.set (std::move (x));
  }

  const ReferenceValue::ReferenceValue_hasValueFrom_ReferenceValueDomain_type& ReferenceValue::
  ReferenceValue_hasValueFrom_ReferenceValueDomain () const
  {
    return this->ReferenceValue_hasValueFrom_ReferenceValueDomain_.get ();
  }

  ReferenceValue::ReferenceValue_hasValueFrom_ReferenceValueDomain_type& ReferenceValue::
  ReferenceValue_hasValueFrom_ReferenceValueDomain ()
  {
    return this->ReferenceValue_hasValueFrom_ReferenceValueDomain_.get ();
  }

  void ReferenceValue::
  ReferenceValue_hasValueFrom_ReferenceValueDomain (const ReferenceValue_hasValueFrom_ReferenceValueDomain_type& x)
  {
    this->ReferenceValue_hasValueFrom_ReferenceValueDomain_.set (x);
  }

  void ReferenceValue::
  ReferenceValue_hasValueFrom_ReferenceValueDomain (::std::unique_ptr< ReferenceValue_hasValueFrom_ReferenceValueDomain_type > x)
  {
    this->ReferenceValue_hasValueFrom_ReferenceValueDomain_.set (std::move (x));
  }


  // ReferenceValueDomain
  //


  // ReferenceVariable
  //

  const ReferenceVariable::ReferenceVariable_takesValuesFrom_ReferenceValueDomain_optional& ReferenceVariable::
  ReferenceVariable_takesValuesFrom_ReferenceValueDomain () const
  {
    return this->ReferenceVariable_takesValuesFrom_ReferenceValueDomain_;
  }

  ReferenceVariable::ReferenceVariable_takesValuesFrom_ReferenceValueDomain_optional& ReferenceVariable::
  ReferenceVariable_takesValuesFrom_ReferenceValueDomain ()
  {
    return this->ReferenceVariable_takesValuesFrom_ReferenceValueDomain_;
  }

  void ReferenceVariable::
  ReferenceVariable_takesValuesFrom_ReferenceValueDomain (const ReferenceVariable_takesValuesFrom_ReferenceValueDomain_type& x)
  {
    this->ReferenceVariable_takesValuesFrom_ReferenceValueDomain_.set (x);
  }

  void ReferenceVariable::
  ReferenceVariable_takesValuesFrom_ReferenceValueDomain (const ReferenceVariable_takesValuesFrom_ReferenceValueDomain_optional& x)
  {
    this->ReferenceVariable_takesValuesFrom_ReferenceValueDomain_ = x;
  }

  void ReferenceVariable::
  ReferenceVariable_takesValuesFrom_ReferenceValueDomain (::std::unique_ptr< ReferenceVariable_takesValuesFrom_ReferenceValueDomain_type > x)
  {
    this->ReferenceVariable_takesValuesFrom_ReferenceValueDomain_.set (std::move (x));
  }


  // RevisableDatum
  //

  const RevisableDatum::vintage_type& RevisableDatum::
  vintage () const
  {
    return this->vintage_.get ();
  }

  RevisableDatum::vintage_type& RevisableDatum::
  vintage ()
  {
    return this->vintage_.get ();
  }

  void RevisableDatum::
  vintage (const vintage_type& x)
  {
    this->vintage_.set (x);
  }

  const RevisableDatum::RevisableDatum_correspondsTo_Revision_optional& RevisableDatum::
  RevisableDatum_correspondsTo_Revision () const
  {
    return this->RevisableDatum_correspondsTo_Revision_;
  }

  RevisableDatum::RevisableDatum_correspondsTo_Revision_optional& RevisableDatum::
  RevisableDatum_correspondsTo_Revision ()
  {
    return this->RevisableDatum_correspondsTo_Revision_;
  }

  void RevisableDatum::
  RevisableDatum_correspondsTo_Revision (const RevisableDatum_correspondsTo_Revision_type& x)
  {
    this->RevisableDatum_correspondsTo_Revision_.set (x);
  }

  void RevisableDatum::
  RevisableDatum_correspondsTo_Revision (const RevisableDatum_correspondsTo_Revision_optional& x)
  {
    this->RevisableDatum_correspondsTo_Revision_ = x;
  }

  void RevisableDatum::
  RevisableDatum_correspondsTo_Revision (::std::unique_ptr< RevisableDatum_correspondsTo_Revision_type > x)
  {
    this->RevisableDatum_correspondsTo_Revision_.set (std::move (x));
  }


  // Revision
  //

  const Revision::algorithm_optional& Revision::
  algorithm () const
  {
    return this->algorithm_;
  }

  Revision::algorithm_optional& Revision::
  algorithm ()
  {
    return this->algorithm_;
  }

  void Revision::
  algorithm (const algorithm_type& x)
  {
    this->algorithm_.set (x);
  }

  void Revision::
  algorithm (const algorithm_optional& x)
  {
    this->algorithm_ = x;
  }

  void Revision::
  algorithm (::std::unique_ptr< algorithm_type > x)
  {
    this->algorithm_.set (std::move (x));
  }

  const Revision::identifier_optional& Revision::
  identifier () const
  {
    return this->identifier_;
  }

  Revision::identifier_optional& Revision::
  identifier ()
  {
    return this->identifier_;
  }

  void Revision::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void Revision::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void Revision::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const Revision::overview_optional& Revision::
  overview () const
  {
    return this->overview_;
  }

  Revision::overview_optional& Revision::
  overview ()
  {
    return this->overview_;
  }

  void Revision::
  overview (const overview_type& x)
  {
    this->overview_.set (x);
  }

  void Revision::
  overview (const overview_optional& x)
  {
    this->overview_ = x;
  }

  void Revision::
  overview (::std::unique_ptr< overview_type > x)
  {
    this->overview_.set (std::move (x));
  }


  // Rule
  //

  const Rule::identifier_optional& Rule::
  identifier () const
  {
    return this->identifier_;
  }

  Rule::identifier_optional& Rule::
  identifier ()
  {
    return this->identifier_;
  }

  void Rule::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void Rule::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void Rule::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const Rule::Rule_hasPrecondition_ConditionalControlLogic_sequence& Rule::
  Rule_hasPrecondition_ConditionalControlLogic () const
  {
    return this->Rule_hasPrecondition_ConditionalControlLogic_;
  }

  Rule::Rule_hasPrecondition_ConditionalControlLogic_sequence& Rule::
  Rule_hasPrecondition_ConditionalControlLogic ()
  {
    return this->Rule_hasPrecondition_ConditionalControlLogic_;
  }

  void Rule::
  Rule_hasPrecondition_ConditionalControlLogic (const Rule_hasPrecondition_ConditionalControlLogic_sequence& s)
  {
    this->Rule_hasPrecondition_ConditionalControlLogic_ = s;
  }


  // RuleBasedScheduling
  //

  const RuleBasedScheduling::schedulingType_type& RuleBasedScheduling::
  schedulingType () const
  {
    return this->schedulingType_.get ();
  }

  RuleBasedScheduling::schedulingType_type& RuleBasedScheduling::
  schedulingType ()
  {
    return this->schedulingType_.get ();
  }

  void RuleBasedScheduling::
  schedulingType (const schedulingType_type& x)
  {
    this->schedulingType_.set (x);
  }

  void RuleBasedScheduling::
  schedulingType (::std::unique_ptr< schedulingType_type > x)
  {
    this->schedulingType_.set (std::move (x));
  }

  const RuleBasedScheduling::RuleBasedScheduling_has_RuleSet_sequence& RuleBasedScheduling::
  RuleBasedScheduling_has_RuleSet () const
  {
    return this->RuleBasedScheduling_has_RuleSet_;
  }

  RuleBasedScheduling::RuleBasedScheduling_has_RuleSet_sequence& RuleBasedScheduling::
  RuleBasedScheduling_has_RuleSet ()
  {
    return this->RuleBasedScheduling_has_RuleSet_;
  }

  void RuleBasedScheduling::
  RuleBasedScheduling_has_RuleSet (const RuleBasedScheduling_has_RuleSet_sequence& s)
  {
    this->RuleBasedScheduling_has_RuleSet_ = s;
  }

  const RuleBasedScheduling::RuleBasedScheduling_has_Curator_sequence& RuleBasedScheduling::
  RuleBasedScheduling_has_Curator () const
  {
    return this->RuleBasedScheduling_has_Curator_;
  }

  RuleBasedScheduling::RuleBasedScheduling_has_Curator_sequence& RuleBasedScheduling::
  RuleBasedScheduling_has_Curator ()
  {
    return this->RuleBasedScheduling_has_Curator_;
  }

  void RuleBasedScheduling::
  RuleBasedScheduling_has_Curator (const RuleBasedScheduling_has_Curator_sequence& s)
  {
    this->RuleBasedScheduling_has_Curator_ = s;
  }


  // RuleSet
  //

  const RuleSet::identifier_optional& RuleSet::
  identifier () const
  {
    return this->identifier_;
  }

  RuleSet::identifier_optional& RuleSet::
  identifier ()
  {
    return this->identifier_;
  }

  void RuleSet::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void RuleSet::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void RuleSet::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const RuleSet::RuleSet_has_Rule_sequence& RuleSet::
  RuleSet_has_Rule () const
  {
    return this->RuleSet_has_Rule_;
  }

  RuleSet::RuleSet_has_Rule_sequence& RuleSet::
  RuleSet_has_Rule ()
  {
    return this->RuleSet_has_Rule_;
  }

  void RuleSet::
  RuleSet_has_Rule (const RuleSet_has_Rule_sequence& s)
  {
    this->RuleSet_has_Rule_ = s;
  }


  // ScopedMeasure
  //

  const ScopedMeasure::frequency_optional& ScopedMeasure::
  frequency () const
  {
    return this->frequency_;
  }

  ScopedMeasure::frequency_optional& ScopedMeasure::
  frequency ()
  {
    return this->frequency_;
  }

  void ScopedMeasure::
  frequency (const frequency_type& x)
  {
    this->frequency_.set (x);
  }

  void ScopedMeasure::
  frequency (const frequency_optional& x)
  {
    this->frequency_ = x;
  }

  void ScopedMeasure::
  frequency (::std::unique_ptr< frequency_type > x)
  {
    this->frequency_.set (std::move (x));
  }

  const ScopedMeasure::identifier_optional& ScopedMeasure::
  identifier () const
  {
    return this->identifier_;
  }

  ScopedMeasure::identifier_optional& ScopedMeasure::
  identifier ()
  {
    return this->identifier_;
  }

  void ScopedMeasure::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ScopedMeasure::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ScopedMeasure::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ScopedMeasure::ScopedMeasure_circumscribes_DimensionalKeyDefinition_optional& ScopedMeasure::
  ScopedMeasure_circumscribes_DimensionalKeyDefinition () const
  {
    return this->ScopedMeasure_circumscribes_DimensionalKeyDefinition_;
  }

  ScopedMeasure::ScopedMeasure_circumscribes_DimensionalKeyDefinition_optional& ScopedMeasure::
  ScopedMeasure_circumscribes_DimensionalKeyDefinition ()
  {
    return this->ScopedMeasure_circumscribes_DimensionalKeyDefinition_;
  }

  void ScopedMeasure::
  ScopedMeasure_circumscribes_DimensionalKeyDefinition (const ScopedMeasure_circumscribes_DimensionalKeyDefinition_type& x)
  {
    this->ScopedMeasure_circumscribes_DimensionalKeyDefinition_.set (x);
  }

  void ScopedMeasure::
  ScopedMeasure_circumscribes_DimensionalKeyDefinition (const ScopedMeasure_circumscribes_DimensionalKeyDefinition_optional& x)
  {
    this->ScopedMeasure_circumscribes_DimensionalKeyDefinition_ = x;
  }

  void ScopedMeasure::
  ScopedMeasure_circumscribes_DimensionalKeyDefinition (::std::unique_ptr< ScopedMeasure_circumscribes_DimensionalKeyDefinition_type > x)
  {
    this->ScopedMeasure_circumscribes_DimensionalKeyDefinition_.set (std::move (x));
  }

  const ScopedMeasure::ScopedMeasure_restricts_QualifiedMeasure_optional& ScopedMeasure::
  ScopedMeasure_restricts_QualifiedMeasure () const
  {
    return this->ScopedMeasure_restricts_QualifiedMeasure_;
  }

  ScopedMeasure::ScopedMeasure_restricts_QualifiedMeasure_optional& ScopedMeasure::
  ScopedMeasure_restricts_QualifiedMeasure ()
  {
    return this->ScopedMeasure_restricts_QualifiedMeasure_;
  }

  void ScopedMeasure::
  ScopedMeasure_restricts_QualifiedMeasure (const ScopedMeasure_restricts_QualifiedMeasure_type& x)
  {
    this->ScopedMeasure_restricts_QualifiedMeasure_.set (x);
  }

  void ScopedMeasure::
  ScopedMeasure_restricts_QualifiedMeasure (const ScopedMeasure_restricts_QualifiedMeasure_optional& x)
  {
    this->ScopedMeasure_restricts_QualifiedMeasure_ = x;
  }

  void ScopedMeasure::
  ScopedMeasure_restricts_QualifiedMeasure (::std::unique_ptr< ScopedMeasure_restricts_QualifiedMeasure_type > x)
  {
    this->ScopedMeasure_restricts_QualifiedMeasure_.set (std::move (x));
  }

  const ScopedMeasure::ScopedMeasure_generates_RevisableDatum_type& ScopedMeasure::
  ScopedMeasure_generates_RevisableDatum () const
  {
    return this->ScopedMeasure_generates_RevisableDatum_.get ();
  }

  ScopedMeasure::ScopedMeasure_generates_RevisableDatum_type& ScopedMeasure::
  ScopedMeasure_generates_RevisableDatum ()
  {
    return this->ScopedMeasure_generates_RevisableDatum_.get ();
  }

  void ScopedMeasure::
  ScopedMeasure_generates_RevisableDatum (const ScopedMeasure_generates_RevisableDatum_type& x)
  {
    this->ScopedMeasure_generates_RevisableDatum_.set (x);
  }

  void ScopedMeasure::
  ScopedMeasure_generates_RevisableDatum (::std::unique_ptr< ScopedMeasure_generates_RevisableDatum_type > x)
  {
    this->ScopedMeasure_generates_RevisableDatum_.set (std::move (x));
  }


  // SegmentByText
  //

  const SegmentByText::characterLength_optional& SegmentByText::
  characterLength () const
  {
    return this->characterLength_;
  }

  SegmentByText::characterLength_optional& SegmentByText::
  characterLength ()
  {
    return this->characterLength_;
  }

  void SegmentByText::
  characterLength (const characterLength_type& x)
  {
    this->characterLength_.set (x);
  }

  void SegmentByText::
  characterLength (const characterLength_optional& x)
  {
    this->characterLength_ = x;
  }

  const SegmentByText::endCharacterPosition_optional& SegmentByText::
  endCharacterPosition () const
  {
    return this->endCharacterPosition_;
  }

  SegmentByText::endCharacterPosition_optional& SegmentByText::
  endCharacterPosition ()
  {
    return this->endCharacterPosition_;
  }

  void SegmentByText::
  endCharacterPosition (const endCharacterPosition_type& x)
  {
    this->endCharacterPosition_.set (x);
  }

  void SegmentByText::
  endCharacterPosition (const endCharacterPosition_optional& x)
  {
    this->endCharacterPosition_ = x;
  }

  const SegmentByText::endLine_optional& SegmentByText::
  endLine () const
  {
    return this->endLine_;
  }

  SegmentByText::endLine_optional& SegmentByText::
  endLine ()
  {
    return this->endLine_;
  }

  void SegmentByText::
  endLine (const endLine_type& x)
  {
    this->endLine_.set (x);
  }

  void SegmentByText::
  endLine (const endLine_optional& x)
  {
    this->endLine_ = x;
  }

  const SegmentByText::startCharacterPosition_optional& SegmentByText::
  startCharacterPosition () const
  {
    return this->startCharacterPosition_;
  }

  SegmentByText::startCharacterPosition_optional& SegmentByText::
  startCharacterPosition ()
  {
    return this->startCharacterPosition_;
  }

  void SegmentByText::
  startCharacterPosition (const startCharacterPosition_type& x)
  {
    this->startCharacterPosition_.set (x);
  }

  void SegmentByText::
  startCharacterPosition (const startCharacterPosition_optional& x)
  {
    this->startCharacterPosition_ = x;
  }

  const SegmentByText::startLine_optional& SegmentByText::
  startLine () const
  {
    return this->startLine_;
  }

  SegmentByText::startLine_optional& SegmentByText::
  startLine ()
  {
    return this->startLine_;
  }

  void SegmentByText::
  startLine (const startLine_type& x)
  {
    this->startLine_.set (x);
  }

  void SegmentByText::
  startLine (const startLine_optional& x)
  {
    this->startLine_ = x;
  }


  // SentinelConceptualDomain
  //


  // SentinelValueDomain
  //

  const SentinelValueDomain::platformType_optional& SentinelValueDomain::
  platformType () const
  {
    return this->platformType_;
  }

  SentinelValueDomain::platformType_optional& SentinelValueDomain::
  platformType ()
  {
    return this->platformType_;
  }

  void SentinelValueDomain::
  platformType (const platformType_type& x)
  {
    this->platformType_.set (x);
  }

  void SentinelValueDomain::
  platformType (const platformType_optional& x)
  {
    this->platformType_ = x;
  }

  void SentinelValueDomain::
  platformType (::std::unique_ptr< platformType_type > x)
  {
    this->platformType_.set (std::move (x));
  }

  const SentinelValueDomain::SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_optional& SentinelValueDomain::
  SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain () const
  {
    return this->SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_;
  }

  SentinelValueDomain::SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_optional& SentinelValueDomain::
  SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain ()
  {
    return this->SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_;
  }

  void SentinelValueDomain::
  SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain (const SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_type& x)
  {
    this->SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_.set (x);
  }

  void SentinelValueDomain::
  SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain (const SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_optional& x)
  {
    this->SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_ = x;
  }

  void SentinelValueDomain::
  SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain (::std::unique_ptr< SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_type > x)
  {
    this->SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_.set (std::move (x));
  }

  const SentinelValueDomain::SentinelValueDomain_takesValuesFrom_EnumerationDomain_optional& SentinelValueDomain::
  SentinelValueDomain_takesValuesFrom_EnumerationDomain () const
  {
    return this->SentinelValueDomain_takesValuesFrom_EnumerationDomain_;
  }

  SentinelValueDomain::SentinelValueDomain_takesValuesFrom_EnumerationDomain_optional& SentinelValueDomain::
  SentinelValueDomain_takesValuesFrom_EnumerationDomain ()
  {
    return this->SentinelValueDomain_takesValuesFrom_EnumerationDomain_;
  }

  void SentinelValueDomain::
  SentinelValueDomain_takesValuesFrom_EnumerationDomain (const SentinelValueDomain_takesValuesFrom_EnumerationDomain_type& x)
  {
    this->SentinelValueDomain_takesValuesFrom_EnumerationDomain_.set (x);
  }

  void SentinelValueDomain::
  SentinelValueDomain_takesValuesFrom_EnumerationDomain (const SentinelValueDomain_takesValuesFrom_EnumerationDomain_optional& x)
  {
    this->SentinelValueDomain_takesValuesFrom_EnumerationDomain_ = x;
  }

  void SentinelValueDomain::
  SentinelValueDomain_takesValuesFrom_EnumerationDomain (::std::unique_ptr< SentinelValueDomain_takesValuesFrom_EnumerationDomain_type > x)
  {
    this->SentinelValueDomain_takesValuesFrom_EnumerationDomain_.set (std::move (x));
  }

  const SentinelValueDomain::SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_optional& SentinelValueDomain::
  SentinelValueDomain_isDescribedBy_ValueAndConceptDescription () const
  {
    return this->SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_;
  }

  SentinelValueDomain::SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_optional& SentinelValueDomain::
  SentinelValueDomain_isDescribedBy_ValueAndConceptDescription ()
  {
    return this->SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_;
  }

  void SentinelValueDomain::
  SentinelValueDomain_isDescribedBy_ValueAndConceptDescription (const SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_type& x)
  {
    this->SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_.set (x);
  }

  void SentinelValueDomain::
  SentinelValueDomain_isDescribedBy_ValueAndConceptDescription (const SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_optional& x)
  {
    this->SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_ = x;
  }

  void SentinelValueDomain::
  SentinelValueDomain_isDescribedBy_ValueAndConceptDescription (::std::unique_ptr< SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_type > x)
  {
    this->SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_.set (std::move (x));
  }


  // Sequence
  //

  const Sequence::Sequence_has_SequencePosition_sequence& Sequence::
  Sequence_has_SequencePosition () const
  {
    return this->Sequence_has_SequencePosition_;
  }

  Sequence::Sequence_has_SequencePosition_sequence& Sequence::
  Sequence_has_SequencePosition ()
  {
    return this->Sequence_has_SequencePosition_;
  }

  void Sequence::
  Sequence_has_SequencePosition (const Sequence_has_SequencePosition_sequence& s)
  {
    this->Sequence_has_SequencePosition_ = s;
  }


  // SequencePosition
  //

  const SequencePosition::identifier_optional& SequencePosition::
  identifier () const
  {
    return this->identifier_;
  }

  SequencePosition::identifier_optional& SequencePosition::
  identifier ()
  {
    return this->identifier_;
  }

  void SequencePosition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void SequencePosition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void SequencePosition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const SequencePosition::value_type& SequencePosition::
  value () const
  {
    return this->value_.get ();
  }

  SequencePosition::value_type& SequencePosition::
  value ()
  {
    return this->value_.get ();
  }

  void SequencePosition::
  value (const value_type& x)
  {
    this->value_.set (x);
  }


  // Service
  //


  // StatisticalClassification
  //

  const StatisticalClassification::allowsDuplicates_type& StatisticalClassification::
  allowsDuplicates () const
  {
    return this->allowsDuplicates_.get ();
  }

  StatisticalClassification::allowsDuplicates_type& StatisticalClassification::
  allowsDuplicates ()
  {
    return this->allowsDuplicates_.get ();
  }

  void StatisticalClassification::
  allowsDuplicates (const allowsDuplicates_type& x)
  {
    this->allowsDuplicates_.set (x);
  }

  const StatisticalClassification::availableLanguage_sequence& StatisticalClassification::
  availableLanguage () const
  {
    return this->availableLanguage_;
  }

  StatisticalClassification::availableLanguage_sequence& StatisticalClassification::
  availableLanguage ()
  {
    return this->availableLanguage_;
  }

  void StatisticalClassification::
  availableLanguage (const availableLanguage_sequence& s)
  {
    this->availableLanguage_ = s;
  }

  const StatisticalClassification::catalogDetails_optional& StatisticalClassification::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  StatisticalClassification::catalogDetails_optional& StatisticalClassification::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void StatisticalClassification::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void StatisticalClassification::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void StatisticalClassification::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const StatisticalClassification::changeFromBase_optional& StatisticalClassification::
  changeFromBase () const
  {
    return this->changeFromBase_;
  }

  StatisticalClassification::changeFromBase_optional& StatisticalClassification::
  changeFromBase ()
  {
    return this->changeFromBase_;
  }

  void StatisticalClassification::
  changeFromBase (const changeFromBase_type& x)
  {
    this->changeFromBase_.set (x);
  }

  void StatisticalClassification::
  changeFromBase (const changeFromBase_optional& x)
  {
    this->changeFromBase_ = x;
  }

  void StatisticalClassification::
  changeFromBase (::std::unique_ptr< changeFromBase_type > x)
  {
    this->changeFromBase_.set (std::move (x));
  }

  const StatisticalClassification::copyright_sequence& StatisticalClassification::
  copyright () const
  {
    return this->copyright_;
  }

  StatisticalClassification::copyright_sequence& StatisticalClassification::
  copyright ()
  {
    return this->copyright_;
  }

  void StatisticalClassification::
  copyright (const copyright_sequence& s)
  {
    this->copyright_ = s;
  }

  const StatisticalClassification::displayLabel_sequence& StatisticalClassification::
  displayLabel () const
  {
    return this->displayLabel_;
  }

  StatisticalClassification::displayLabel_sequence& StatisticalClassification::
  displayLabel ()
  {
    return this->displayLabel_;
  }

  void StatisticalClassification::
  displayLabel (const displayLabel_sequence& s)
  {
    this->displayLabel_ = s;
  }

  const StatisticalClassification::isCurrent_optional& StatisticalClassification::
  isCurrent () const
  {
    return this->isCurrent_;
  }

  StatisticalClassification::isCurrent_optional& StatisticalClassification::
  isCurrent ()
  {
    return this->isCurrent_;
  }

  void StatisticalClassification::
  isCurrent (const isCurrent_type& x)
  {
    this->isCurrent_.set (x);
  }

  void StatisticalClassification::
  isCurrent (const isCurrent_optional& x)
  {
    this->isCurrent_ = x;
  }

  const StatisticalClassification::isFloating_optional& StatisticalClassification::
  isFloating () const
  {
    return this->isFloating_;
  }

  StatisticalClassification::isFloating_optional& StatisticalClassification::
  isFloating ()
  {
    return this->isFloating_;
  }

  void StatisticalClassification::
  isFloating (const isFloating_type& x)
  {
    this->isFloating_.set (x);
  }

  void StatisticalClassification::
  isFloating (const isFloating_optional& x)
  {
    this->isFloating_ = x;
  }

  const StatisticalClassification::purposeOfVariant_optional& StatisticalClassification::
  purposeOfVariant () const
  {
    return this->purposeOfVariant_;
  }

  StatisticalClassification::purposeOfVariant_optional& StatisticalClassification::
  purposeOfVariant ()
  {
    return this->purposeOfVariant_;
  }

  void StatisticalClassification::
  purposeOfVariant (const purposeOfVariant_type& x)
  {
    this->purposeOfVariant_.set (x);
  }

  void StatisticalClassification::
  purposeOfVariant (const purposeOfVariant_optional& x)
  {
    this->purposeOfVariant_ = x;
  }

  void StatisticalClassification::
  purposeOfVariant (::std::unique_ptr< purposeOfVariant_type > x)
  {
    this->purposeOfVariant_.set (std::move (x));
  }

  const StatisticalClassification::rationale_optional& StatisticalClassification::
  rationale () const
  {
    return this->rationale_;
  }

  StatisticalClassification::rationale_optional& StatisticalClassification::
  rationale ()
  {
    return this->rationale_;
  }

  void StatisticalClassification::
  rationale (const rationale_type& x)
  {
    this->rationale_.set (x);
  }

  void StatisticalClassification::
  rationale (const rationale_optional& x)
  {
    this->rationale_ = x;
  }

  void StatisticalClassification::
  rationale (::std::unique_ptr< rationale_type > x)
  {
    this->rationale_.set (std::move (x));
  }

  const StatisticalClassification::releaseDate_optional& StatisticalClassification::
  releaseDate () const
  {
    return this->releaseDate_;
  }

  StatisticalClassification::releaseDate_optional& StatisticalClassification::
  releaseDate ()
  {
    return this->releaseDate_;
  }

  void StatisticalClassification::
  releaseDate (const releaseDate_type& x)
  {
    this->releaseDate_.set (x);
  }

  void StatisticalClassification::
  releaseDate (const releaseDate_optional& x)
  {
    this->releaseDate_ = x;
  }

  void StatisticalClassification::
  releaseDate (::std::unique_ptr< releaseDate_type > x)
  {
    this->releaseDate_.set (std::move (x));
  }

  const StatisticalClassification::updateChanges_sequence& StatisticalClassification::
  updateChanges () const
  {
    return this->updateChanges_;
  }

  StatisticalClassification::updateChanges_sequence& StatisticalClassification::
  updateChanges ()
  {
    return this->updateChanges_;
  }

  void StatisticalClassification::
  updateChanges (const updateChanges_sequence& s)
  {
    this->updateChanges_ = s;
  }

  const StatisticalClassification::usage_optional& StatisticalClassification::
  usage () const
  {
    return this->usage_;
  }

  StatisticalClassification::usage_optional& StatisticalClassification::
  usage ()
  {
    return this->usage_;
  }

  void StatisticalClassification::
  usage (const usage_type& x)
  {
    this->usage_.set (x);
  }

  void StatisticalClassification::
  usage (const usage_optional& x)
  {
    this->usage_ = x;
  }

  void StatisticalClassification::
  usage (::std::unique_ptr< usage_type > x)
  {
    this->usage_.set (std::move (x));
  }

  const StatisticalClassification::validDates_optional& StatisticalClassification::
  validDates () const
  {
    return this->validDates_;
  }

  StatisticalClassification::validDates_optional& StatisticalClassification::
  validDates ()
  {
    return this->validDates_;
  }

  void StatisticalClassification::
  validDates (const validDates_type& x)
  {
    this->validDates_.set (x);
  }

  void StatisticalClassification::
  validDates (const validDates_optional& x)
  {
    this->validDates_ = x;
  }

  void StatisticalClassification::
  validDates (::std::unique_ptr< validDates_type > x)
  {
    this->validDates_.set (std::move (x));
  }

  const StatisticalClassification::StatisticalClassification_isMaintainedBy_Organization_sequence& StatisticalClassification::
  StatisticalClassification_isMaintainedBy_Organization () const
  {
    return this->StatisticalClassification_isMaintainedBy_Organization_;
  }

  StatisticalClassification::StatisticalClassification_isMaintainedBy_Organization_sequence& StatisticalClassification::
  StatisticalClassification_isMaintainedBy_Organization ()
  {
    return this->StatisticalClassification_isMaintainedBy_Organization_;
  }

  void StatisticalClassification::
  StatisticalClassification_isMaintainedBy_Organization (const StatisticalClassification_isMaintainedBy_Organization_sequence& s)
  {
    this->StatisticalClassification_isMaintainedBy_Organization_ = s;
  }

  const StatisticalClassification::StatisticalClassification_isIndexedBy_ClassificationIndex_sequence& StatisticalClassification::
  StatisticalClassification_isIndexedBy_ClassificationIndex () const
  {
    return this->StatisticalClassification_isIndexedBy_ClassificationIndex_;
  }

  StatisticalClassification::StatisticalClassification_isIndexedBy_ClassificationIndex_sequence& StatisticalClassification::
  StatisticalClassification_isIndexedBy_ClassificationIndex ()
  {
    return this->StatisticalClassification_isIndexedBy_ClassificationIndex_;
  }

  void StatisticalClassification::
  StatisticalClassification_isIndexedBy_ClassificationIndex (const StatisticalClassification_isIndexedBy_ClassificationIndex_sequence& s)
  {
    this->StatisticalClassification_isIndexedBy_ClassificationIndex_ = s;
  }

  const StatisticalClassification::StatisticalClassification_isVariantOf_StatisticalClassification_optional& StatisticalClassification::
  StatisticalClassification_isVariantOf_StatisticalClassification () const
  {
    return this->StatisticalClassification_isVariantOf_StatisticalClassification_;
  }

  StatisticalClassification::StatisticalClassification_isVariantOf_StatisticalClassification_optional& StatisticalClassification::
  StatisticalClassification_isVariantOf_StatisticalClassification ()
  {
    return this->StatisticalClassification_isVariantOf_StatisticalClassification_;
  }

  void StatisticalClassification::
  StatisticalClassification_isVariantOf_StatisticalClassification (const StatisticalClassification_isVariantOf_StatisticalClassification_type& x)
  {
    this->StatisticalClassification_isVariantOf_StatisticalClassification_.set (x);
  }

  void StatisticalClassification::
  StatisticalClassification_isVariantOf_StatisticalClassification (const StatisticalClassification_isVariantOf_StatisticalClassification_optional& x)
  {
    this->StatisticalClassification_isVariantOf_StatisticalClassification_ = x;
  }

  void StatisticalClassification::
  StatisticalClassification_isVariantOf_StatisticalClassification (::std::unique_ptr< StatisticalClassification_isVariantOf_StatisticalClassification_type > x)
  {
    this->StatisticalClassification_isVariantOf_StatisticalClassification_.set (std::move (x));
  }

  const StatisticalClassification::StatisticalClassification_isSuccessorOf_StatisticalClassification_sequence& StatisticalClassification::
  StatisticalClassification_isSuccessorOf_StatisticalClassification () const
  {
    return this->StatisticalClassification_isSuccessorOf_StatisticalClassification_;
  }

  StatisticalClassification::StatisticalClassification_isSuccessorOf_StatisticalClassification_sequence& StatisticalClassification::
  StatisticalClassification_isSuccessorOf_StatisticalClassification ()
  {
    return this->StatisticalClassification_isSuccessorOf_StatisticalClassification_;
  }

  void StatisticalClassification::
  StatisticalClassification_isSuccessorOf_StatisticalClassification (const StatisticalClassification_isSuccessorOf_StatisticalClassification_sequence& s)
  {
    this->StatisticalClassification_isSuccessorOf_StatisticalClassification_ = s;
  }

  const StatisticalClassification::StatisticalClassification_isPredecessorOf_StatisticalClassification_sequence& StatisticalClassification::
  StatisticalClassification_isPredecessorOf_StatisticalClassification () const
  {
    return this->StatisticalClassification_isPredecessorOf_StatisticalClassification_;
  }

  StatisticalClassification::StatisticalClassification_isPredecessorOf_StatisticalClassification_sequence& StatisticalClassification::
  StatisticalClassification_isPredecessorOf_StatisticalClassification ()
  {
    return this->StatisticalClassification_isPredecessorOf_StatisticalClassification_;
  }

  void StatisticalClassification::
  StatisticalClassification_isPredecessorOf_StatisticalClassification (const StatisticalClassification_isPredecessorOf_StatisticalClassification_sequence& s)
  {
    this->StatisticalClassification_isPredecessorOf_StatisticalClassification_ = s;
  }

  const StatisticalClassification::StatisticalClassification_has_ClassificationItemPosition_sequence& StatisticalClassification::
  StatisticalClassification_has_ClassificationItemPosition () const
  {
    return this->StatisticalClassification_has_ClassificationItemPosition_;
  }

  StatisticalClassification::StatisticalClassification_has_ClassificationItemPosition_sequence& StatisticalClassification::
  StatisticalClassification_has_ClassificationItemPosition ()
  {
    return this->StatisticalClassification_has_ClassificationItemPosition_;
  }

  void StatisticalClassification::
  StatisticalClassification_has_ClassificationItemPosition (const StatisticalClassification_has_ClassificationItemPosition_sequence& s)
  {
    this->StatisticalClassification_has_ClassificationItemPosition_ = s;
  }

  const StatisticalClassification::StatisticalClassification_has_ClassificationItem_sequence& StatisticalClassification::
  StatisticalClassification_has_ClassificationItem () const
  {
    return this->StatisticalClassification_has_ClassificationItem_;
  }

  StatisticalClassification::StatisticalClassification_has_ClassificationItem_sequence& StatisticalClassification::
  StatisticalClassification_has_ClassificationItem ()
  {
    return this->StatisticalClassification_has_ClassificationItem_;
  }

  void StatisticalClassification::
  StatisticalClassification_has_ClassificationItem (const StatisticalClassification_has_ClassificationItem_sequence& s)
  {
    this->StatisticalClassification_has_ClassificationItem_ = s;
  }

  const StatisticalClassification::StatisticalClassification_has_LevelStructure_optional& StatisticalClassification::
  StatisticalClassification_has_LevelStructure () const
  {
    return this->StatisticalClassification_has_LevelStructure_;
  }

  StatisticalClassification::StatisticalClassification_has_LevelStructure_optional& StatisticalClassification::
  StatisticalClassification_has_LevelStructure ()
  {
    return this->StatisticalClassification_has_LevelStructure_;
  }

  void StatisticalClassification::
  StatisticalClassification_has_LevelStructure (const StatisticalClassification_has_LevelStructure_type& x)
  {
    this->StatisticalClassification_has_LevelStructure_.set (x);
  }

  void StatisticalClassification::
  StatisticalClassification_has_LevelStructure (const StatisticalClassification_has_LevelStructure_optional& x)
  {
    this->StatisticalClassification_has_LevelStructure_ = x;
  }

  void StatisticalClassification::
  StatisticalClassification_has_LevelStructure (::std::unique_ptr< StatisticalClassification_has_LevelStructure_type > x)
  {
    this->StatisticalClassification_has_LevelStructure_.set (std::move (x));
  }


  // StatisticalClassificationRelationship
  //

  const StatisticalClassificationRelationship::identifier_optional& StatisticalClassificationRelationship::
  identifier () const
  {
    return this->identifier_;
  }

  StatisticalClassificationRelationship::identifier_optional& StatisticalClassificationRelationship::
  identifier ()
  {
    return this->identifier_;
  }

  void StatisticalClassificationRelationship::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void StatisticalClassificationRelationship::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void StatisticalClassificationRelationship::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const StatisticalClassificationRelationship::semantics_optional& StatisticalClassificationRelationship::
  semantics () const
  {
    return this->semantics_;
  }

  StatisticalClassificationRelationship::semantics_optional& StatisticalClassificationRelationship::
  semantics ()
  {
    return this->semantics_;
  }

  void StatisticalClassificationRelationship::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void StatisticalClassificationRelationship::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void StatisticalClassificationRelationship::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const StatisticalClassificationRelationship::StatisticalClassificationRelationship_hasTarget_StatisticalClassification_sequence& StatisticalClassificationRelationship::
  StatisticalClassificationRelationship_hasTarget_StatisticalClassification () const
  {
    return this->StatisticalClassificationRelationship_hasTarget_StatisticalClassification_;
  }

  StatisticalClassificationRelationship::StatisticalClassificationRelationship_hasTarget_StatisticalClassification_sequence& StatisticalClassificationRelationship::
  StatisticalClassificationRelationship_hasTarget_StatisticalClassification ()
  {
    return this->StatisticalClassificationRelationship_hasTarget_StatisticalClassification_;
  }

  void StatisticalClassificationRelationship::
  StatisticalClassificationRelationship_hasTarget_StatisticalClassification (const StatisticalClassificationRelationship_hasTarget_StatisticalClassification_sequence& s)
  {
    this->StatisticalClassificationRelationship_hasTarget_StatisticalClassification_ = s;
  }

  const StatisticalClassificationRelationship::StatisticalClassificationRelationship_hasSource_StatisticalClassification_sequence& StatisticalClassificationRelationship::
  StatisticalClassificationRelationship_hasSource_StatisticalClassification () const
  {
    return this->StatisticalClassificationRelationship_hasSource_StatisticalClassification_;
  }

  StatisticalClassificationRelationship::StatisticalClassificationRelationship_hasSource_StatisticalClassification_sequence& StatisticalClassificationRelationship::
  StatisticalClassificationRelationship_hasSource_StatisticalClassification ()
  {
    return this->StatisticalClassificationRelationship_hasSource_StatisticalClassification_;
  }

  void StatisticalClassificationRelationship::
  StatisticalClassificationRelationship_hasSource_StatisticalClassification (const StatisticalClassificationRelationship_hasSource_StatisticalClassification_sequence& s)
  {
    this->StatisticalClassificationRelationship_hasSource_StatisticalClassification_ = s;
  }


  // Step
  //

  const Step::script_optional& Step::
  script () const
  {
    return this->script_;
  }

  Step::script_optional& Step::
  script ()
  {
    return this->script_;
  }

  void Step::
  script (const script_type& x)
  {
    this->script_.set (x);
  }

  void Step::
  script (const script_optional& x)
  {
    this->script_ = x;
  }

  void Step::
  script (::std::unique_ptr< script_type > x)
  {
    this->script_.set (std::move (x));
  }

  const Step::scriptingLanguage_optional& Step::
  scriptingLanguage () const
  {
    return this->scriptingLanguage_;
  }

  Step::scriptingLanguage_optional& Step::
  scriptingLanguage ()
  {
    return this->scriptingLanguage_;
  }

  void Step::
  scriptingLanguage (const scriptingLanguage_type& x)
  {
    this->scriptingLanguage_.set (x);
  }

  void Step::
  scriptingLanguage (const scriptingLanguage_optional& x)
  {
    this->scriptingLanguage_ = x;
  }

  void Step::
  scriptingLanguage (::std::unique_ptr< scriptingLanguage_type > x)
  {
    this->scriptingLanguage_.set (std::move (x));
  }

  const Step::Step_produces_Parameter_sequence& Step::
  Step_produces_Parameter () const
  {
    return this->Step_produces_Parameter_;
  }

  Step::Step_produces_Parameter_sequence& Step::
  Step_produces_Parameter ()
  {
    return this->Step_produces_Parameter_;
  }

  void Step::
  Step_produces_Parameter (const Step_produces_Parameter_sequence& s)
  {
    this->Step_produces_Parameter_ = s;
  }

  const Step::Step_receives_Parameter_sequence& Step::
  Step_receives_Parameter () const
  {
    return this->Step_receives_Parameter_;
  }

  Step::Step_receives_Parameter_sequence& Step::
  Step_receives_Parameter ()
  {
    return this->Step_receives_Parameter_;
  }

  void Step::
  Step_receives_Parameter (const Step_receives_Parameter_sequence& s)
  {
    this->Step_receives_Parameter_ = s;
  }

  const Step::Step_hasSubStep_Step_sequence& Step::
  Step_hasSubStep_Step () const
  {
    return this->Step_hasSubStep_Step_;
  }

  Step::Step_hasSubStep_Step_sequence& Step::
  Step_hasSubStep_Step ()
  {
    return this->Step_hasSubStep_Step_;
  }

  void Step::
  Step_hasSubStep_Step (const Step_hasSubStep_Step_sequence& s)
  {
    this->Step_hasSubStep_Step_ = s;
  }


  // SubstantiveConceptualDomain
  //


  // SyntheticIdComponent
  //


  // TemporalControlConstruct
  //

  const TemporalControlConstruct::temporalControl_type& TemporalControlConstruct::
  temporalControl () const
  {
    return this->temporalControl_.get ();
  }

  TemporalControlConstruct::temporalControl_type& TemporalControlConstruct::
  temporalControl ()
  {
    return this->temporalControl_.get ();
  }

  void TemporalControlConstruct::
  temporalControl (const temporalControl_type& x)
  {
    this->temporalControl_.set (x);
  }

  void TemporalControlConstruct::
  temporalControl (::std::unique_ptr< temporalControl_type > x)
  {
    this->temporalControl_.set (std::move (x));
  }


  // Unit
  //

  const Unit::catalogDetails_optional& Unit::
  catalogDetails () const
  {
    return this->catalogDetails_;
  }

  Unit::catalogDetails_optional& Unit::
  catalogDetails ()
  {
    return this->catalogDetails_;
  }

  void Unit::
  catalogDetails (const catalogDetails_type& x)
  {
    this->catalogDetails_.set (x);
  }

  void Unit::
  catalogDetails (const catalogDetails_optional& x)
  {
    this->catalogDetails_ = x;
  }

  void Unit::
  catalogDetails (::std::unique_ptr< catalogDetails_type > x)
  {
    this->catalogDetails_.set (std::move (x));
  }

  const Unit::definition_optional& Unit::
  definition () const
  {
    return this->definition_;
  }

  Unit::definition_optional& Unit::
  definition ()
  {
    return this->definition_;
  }

  void Unit::
  definition (const definition_type& x)
  {
    this->definition_.set (x);
  }

  void Unit::
  definition (const definition_optional& x)
  {
    this->definition_ = x;
  }

  void Unit::
  definition (::std::unique_ptr< definition_type > x)
  {
    this->definition_.set (std::move (x));
  }

  const Unit::displayLabel_sequence& Unit::
  displayLabel () const
  {
    return this->displayLabel_;
  }

  Unit::displayLabel_sequence& Unit::
  displayLabel ()
  {
    return this->displayLabel_;
  }

  void Unit::
  displayLabel (const displayLabel_sequence& s)
  {
    this->displayLabel_ = s;
  }

  const Unit::identifier_optional& Unit::
  identifier () const
  {
    return this->identifier_;
  }

  Unit::identifier_optional& Unit::
  identifier ()
  {
    return this->identifier_;
  }

  void Unit::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void Unit::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void Unit::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const Unit::name_sequence& Unit::
  name () const
  {
    return this->name_;
  }

  Unit::name_sequence& Unit::
  name ()
  {
    return this->name_;
  }

  void Unit::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const Unit::Unit_has_UnitType_sequence& Unit::
  Unit_has_UnitType () const
  {
    return this->Unit_has_UnitType_;
  }

  Unit::Unit_has_UnitType_sequence& Unit::
  Unit_has_UnitType ()
  {
    return this->Unit_has_UnitType_;
  }

  void Unit::
  Unit_has_UnitType (const Unit_has_UnitType_sequence& s)
  {
    this->Unit_has_UnitType_ = s;
  }


  // UnitSegmentLayout
  //


  // ValueAndConceptDescription
  //

  const ValueAndConceptDescription::classificationLevel_optional& ValueAndConceptDescription::
  classificationLevel () const
  {
    return this->classificationLevel_;
  }

  ValueAndConceptDescription::classificationLevel_optional& ValueAndConceptDescription::
  classificationLevel ()
  {
    return this->classificationLevel_;
  }

  void ValueAndConceptDescription::
  classificationLevel (const classificationLevel_type& x)
  {
    this->classificationLevel_.set (x);
  }

  void ValueAndConceptDescription::
  classificationLevel (const classificationLevel_optional& x)
  {
    this->classificationLevel_ = x;
  }

  void ValueAndConceptDescription::
  classificationLevel (::std::unique_ptr< classificationLevel_type > x)
  {
    this->classificationLevel_.set (std::move (x));
  }

  const ValueAndConceptDescription::description_optional& ValueAndConceptDescription::
  description () const
  {
    return this->description_;
  }

  ValueAndConceptDescription::description_optional& ValueAndConceptDescription::
  description ()
  {
    return this->description_;
  }

  void ValueAndConceptDescription::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void ValueAndConceptDescription::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void ValueAndConceptDescription::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }

  const ValueAndConceptDescription::formatPattern_optional& ValueAndConceptDescription::
  formatPattern () const
  {
    return this->formatPattern_;
  }

  ValueAndConceptDescription::formatPattern_optional& ValueAndConceptDescription::
  formatPattern ()
  {
    return this->formatPattern_;
  }

  void ValueAndConceptDescription::
  formatPattern (const formatPattern_type& x)
  {
    this->formatPattern_.set (x);
  }

  void ValueAndConceptDescription::
  formatPattern (const formatPattern_optional& x)
  {
    this->formatPattern_ = x;
  }

  void ValueAndConceptDescription::
  formatPattern (::std::unique_ptr< formatPattern_type > x)
  {
    this->formatPattern_.set (std::move (x));
  }

  const ValueAndConceptDescription::identifier_optional& ValueAndConceptDescription::
  identifier () const
  {
    return this->identifier_;
  }

  ValueAndConceptDescription::identifier_optional& ValueAndConceptDescription::
  identifier ()
  {
    return this->identifier_;
  }

  void ValueAndConceptDescription::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ValueAndConceptDescription::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ValueAndConceptDescription::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ValueAndConceptDescription::logicalExpression_optional& ValueAndConceptDescription::
  logicalExpression () const
  {
    return this->logicalExpression_;
  }

  ValueAndConceptDescription::logicalExpression_optional& ValueAndConceptDescription::
  logicalExpression ()
  {
    return this->logicalExpression_;
  }

  void ValueAndConceptDescription::
  logicalExpression (const logicalExpression_type& x)
  {
    this->logicalExpression_.set (x);
  }

  void ValueAndConceptDescription::
  logicalExpression (const logicalExpression_optional& x)
  {
    this->logicalExpression_ = x;
  }

  void ValueAndConceptDescription::
  logicalExpression (::std::unique_ptr< logicalExpression_type > x)
  {
    this->logicalExpression_.set (std::move (x));
  }

  const ValueAndConceptDescription::maximumValueExclusive_optional& ValueAndConceptDescription::
  maximumValueExclusive () const
  {
    return this->maximumValueExclusive_;
  }

  ValueAndConceptDescription::maximumValueExclusive_optional& ValueAndConceptDescription::
  maximumValueExclusive ()
  {
    return this->maximumValueExclusive_;
  }

  void ValueAndConceptDescription::
  maximumValueExclusive (const maximumValueExclusive_type& x)
  {
    this->maximumValueExclusive_.set (x);
  }

  void ValueAndConceptDescription::
  maximumValueExclusive (const maximumValueExclusive_optional& x)
  {
    this->maximumValueExclusive_ = x;
  }

  void ValueAndConceptDescription::
  maximumValueExclusive (::std::unique_ptr< maximumValueExclusive_type > x)
  {
    this->maximumValueExclusive_.set (std::move (x));
  }

  const ValueAndConceptDescription::maximumValueInclusive_optional& ValueAndConceptDescription::
  maximumValueInclusive () const
  {
    return this->maximumValueInclusive_;
  }

  ValueAndConceptDescription::maximumValueInclusive_optional& ValueAndConceptDescription::
  maximumValueInclusive ()
  {
    return this->maximumValueInclusive_;
  }

  void ValueAndConceptDescription::
  maximumValueInclusive (const maximumValueInclusive_type& x)
  {
    this->maximumValueInclusive_.set (x);
  }

  void ValueAndConceptDescription::
  maximumValueInclusive (const maximumValueInclusive_optional& x)
  {
    this->maximumValueInclusive_ = x;
  }

  void ValueAndConceptDescription::
  maximumValueInclusive (::std::unique_ptr< maximumValueInclusive_type > x)
  {
    this->maximumValueInclusive_.set (std::move (x));
  }

  const ValueAndConceptDescription::minimumValueExclusive_optional& ValueAndConceptDescription::
  minimumValueExclusive () const
  {
    return this->minimumValueExclusive_;
  }

  ValueAndConceptDescription::minimumValueExclusive_optional& ValueAndConceptDescription::
  minimumValueExclusive ()
  {
    return this->minimumValueExclusive_;
  }

  void ValueAndConceptDescription::
  minimumValueExclusive (const minimumValueExclusive_type& x)
  {
    this->minimumValueExclusive_.set (x);
  }

  void ValueAndConceptDescription::
  minimumValueExclusive (const minimumValueExclusive_optional& x)
  {
    this->minimumValueExclusive_ = x;
  }

  void ValueAndConceptDescription::
  minimumValueExclusive (::std::unique_ptr< minimumValueExclusive_type > x)
  {
    this->minimumValueExclusive_.set (std::move (x));
  }

  const ValueAndConceptDescription::minimumValueInclusive_optional& ValueAndConceptDescription::
  minimumValueInclusive () const
  {
    return this->minimumValueInclusive_;
  }

  ValueAndConceptDescription::minimumValueInclusive_optional& ValueAndConceptDescription::
  minimumValueInclusive ()
  {
    return this->minimumValueInclusive_;
  }

  void ValueAndConceptDescription::
  minimumValueInclusive (const minimumValueInclusive_type& x)
  {
    this->minimumValueInclusive_.set (x);
  }

  void ValueAndConceptDescription::
  minimumValueInclusive (const minimumValueInclusive_optional& x)
  {
    this->minimumValueInclusive_ = x;
  }

  void ValueAndConceptDescription::
  minimumValueInclusive (::std::unique_ptr< minimumValueInclusive_type > x)
  {
    this->minimumValueInclusive_.set (std::move (x));
  }

  const ValueAndConceptDescription::regularExpression_optional& ValueAndConceptDescription::
  regularExpression () const
  {
    return this->regularExpression_;
  }

  ValueAndConceptDescription::regularExpression_optional& ValueAndConceptDescription::
  regularExpression ()
  {
    return this->regularExpression_;
  }

  void ValueAndConceptDescription::
  regularExpression (const regularExpression_type& x)
  {
    this->regularExpression_.set (x);
  }

  void ValueAndConceptDescription::
  regularExpression (const regularExpression_optional& x)
  {
    this->regularExpression_ = x;
  }

  void ValueAndConceptDescription::
  regularExpression (::std::unique_ptr< regularExpression_type > x)
  {
    this->regularExpression_.set (std::move (x));
  }


  // ValueMapping
  //

  const ValueMapping::decimalPositions_optional& ValueMapping::
  decimalPositions () const
  {
    return this->decimalPositions_;
  }

  ValueMapping::decimalPositions_optional& ValueMapping::
  decimalPositions ()
  {
    return this->decimalPositions_;
  }

  void ValueMapping::
  decimalPositions (const decimalPositions_type& x)
  {
    this->decimalPositions_.set (x);
  }

  void ValueMapping::
  decimalPositions (const decimalPositions_optional& x)
  {
    this->decimalPositions_ = x;
  }

  const ValueMapping::defaultDecimalSeparator_optional& ValueMapping::
  defaultDecimalSeparator () const
  {
    return this->defaultDecimalSeparator_;
  }

  ValueMapping::defaultDecimalSeparator_optional& ValueMapping::
  defaultDecimalSeparator ()
  {
    return this->defaultDecimalSeparator_;
  }

  void ValueMapping::
  defaultDecimalSeparator (const defaultDecimalSeparator_type& x)
  {
    this->defaultDecimalSeparator_.set (x);
  }

  void ValueMapping::
  defaultDecimalSeparator (const defaultDecimalSeparator_optional& x)
  {
    this->defaultDecimalSeparator_ = x;
  }

  void ValueMapping::
  defaultDecimalSeparator (::std::unique_ptr< defaultDecimalSeparator_type > x)
  {
    this->defaultDecimalSeparator_.set (std::move (x));
  }

  const ValueMapping::defaultDigitGroupSeparator_optional& ValueMapping::
  defaultDigitGroupSeparator () const
  {
    return this->defaultDigitGroupSeparator_;
  }

  ValueMapping::defaultDigitGroupSeparator_optional& ValueMapping::
  defaultDigitGroupSeparator ()
  {
    return this->defaultDigitGroupSeparator_;
  }

  void ValueMapping::
  defaultDigitGroupSeparator (const defaultDigitGroupSeparator_type& x)
  {
    this->defaultDigitGroupSeparator_.set (x);
  }

  void ValueMapping::
  defaultDigitGroupSeparator (const defaultDigitGroupSeparator_optional& x)
  {
    this->defaultDigitGroupSeparator_ = x;
  }

  void ValueMapping::
  defaultDigitGroupSeparator (::std::unique_ptr< defaultDigitGroupSeparator_type > x)
  {
    this->defaultDigitGroupSeparator_.set (std::move (x));
  }

  const ValueMapping::defaultValue_type& ValueMapping::
  defaultValue () const
  {
    return this->defaultValue_.get ();
  }

  ValueMapping::defaultValue_type& ValueMapping::
  defaultValue ()
  {
    return this->defaultValue_.get ();
  }

  void ValueMapping::
  defaultValue (const defaultValue_type& x)
  {
    this->defaultValue_.set (x);
  }

  void ValueMapping::
  defaultValue (::std::unique_ptr< defaultValue_type > x)
  {
    this->defaultValue_.set (std::move (x));
  }

  const ValueMapping::format_optional& ValueMapping::
  format () const
  {
    return this->format_;
  }

  ValueMapping::format_optional& ValueMapping::
  format ()
  {
    return this->format_;
  }

  void ValueMapping::
  format (const format_type& x)
  {
    this->format_.set (x);
  }

  void ValueMapping::
  format (const format_optional& x)
  {
    this->format_ = x;
  }

  void ValueMapping::
  format (::std::unique_ptr< format_type > x)
  {
    this->format_.set (std::move (x));
  }

  const ValueMapping::identifier_optional& ValueMapping::
  identifier () const
  {
    return this->identifier_;
  }

  ValueMapping::identifier_optional& ValueMapping::
  identifier ()
  {
    return this->identifier_;
  }

  void ValueMapping::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ValueMapping::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ValueMapping::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ValueMapping::isRequired_optional& ValueMapping::
  isRequired () const
  {
    return this->isRequired_;
  }

  ValueMapping::isRequired_optional& ValueMapping::
  isRequired ()
  {
    return this->isRequired_;
  }

  void ValueMapping::
  isRequired (const isRequired_type& x)
  {
    this->isRequired_.set (x);
  }

  void ValueMapping::
  isRequired (const isRequired_optional& x)
  {
    this->isRequired_ = x;
  }

  const ValueMapping::length_optional& ValueMapping::
  length () const
  {
    return this->length_;
  }

  ValueMapping::length_optional& ValueMapping::
  length ()
  {
    return this->length_;
  }

  void ValueMapping::
  length (const length_type& x)
  {
    this->length_.set (x);
  }

  void ValueMapping::
  length (const length_optional& x)
  {
    this->length_ = x;
  }

  const ValueMapping::maximumLength_optional& ValueMapping::
  maximumLength () const
  {
    return this->maximumLength_;
  }

  ValueMapping::maximumLength_optional& ValueMapping::
  maximumLength ()
  {
    return this->maximumLength_;
  }

  void ValueMapping::
  maximumLength (const maximumLength_type& x)
  {
    this->maximumLength_.set (x);
  }

  void ValueMapping::
  maximumLength (const maximumLength_optional& x)
  {
    this->maximumLength_ = x;
  }

  const ValueMapping::minimumLength_optional& ValueMapping::
  minimumLength () const
  {
    return this->minimumLength_;
  }

  ValueMapping::minimumLength_optional& ValueMapping::
  minimumLength ()
  {
    return this->minimumLength_;
  }

  void ValueMapping::
  minimumLength (const minimumLength_type& x)
  {
    this->minimumLength_.set (x);
  }

  void ValueMapping::
  minimumLength (const minimumLength_optional& x)
  {
    this->minimumLength_ = x;
  }

  const ValueMapping::nullSequence_optional& ValueMapping::
  nullSequence () const
  {
    return this->nullSequence_;
  }

  ValueMapping::nullSequence_optional& ValueMapping::
  nullSequence ()
  {
    return this->nullSequence_;
  }

  void ValueMapping::
  nullSequence (const nullSequence_type& x)
  {
    this->nullSequence_.set (x);
  }

  void ValueMapping::
  nullSequence (const nullSequence_optional& x)
  {
    this->nullSequence_ = x;
  }

  void ValueMapping::
  nullSequence (::std::unique_ptr< nullSequence_type > x)
  {
    this->nullSequence_.set (std::move (x));
  }

  const ValueMapping::numberPattern_optional& ValueMapping::
  numberPattern () const
  {
    return this->numberPattern_;
  }

  ValueMapping::numberPattern_optional& ValueMapping::
  numberPattern ()
  {
    return this->numberPattern_;
  }

  void ValueMapping::
  numberPattern (const numberPattern_type& x)
  {
    this->numberPattern_.set (x);
  }

  void ValueMapping::
  numberPattern (const numberPattern_optional& x)
  {
    this->numberPattern_ = x;
  }

  void ValueMapping::
  numberPattern (::std::unique_ptr< numberPattern_type > x)
  {
    this->numberPattern_.set (std::move (x));
  }

  const ValueMapping::physicalDataType_optional& ValueMapping::
  physicalDataType () const
  {
    return this->physicalDataType_;
  }

  ValueMapping::physicalDataType_optional& ValueMapping::
  physicalDataType ()
  {
    return this->physicalDataType_;
  }

  void ValueMapping::
  physicalDataType (const physicalDataType_type& x)
  {
    this->physicalDataType_.set (x);
  }

  void ValueMapping::
  physicalDataType (const physicalDataType_optional& x)
  {
    this->physicalDataType_ = x;
  }

  void ValueMapping::
  physicalDataType (::std::unique_ptr< physicalDataType_type > x)
  {
    this->physicalDataType_.set (std::move (x));
  }

  const ValueMapping::scale_optional& ValueMapping::
  scale () const
  {
    return this->scale_;
  }

  ValueMapping::scale_optional& ValueMapping::
  scale ()
  {
    return this->scale_;
  }

  void ValueMapping::
  scale (const scale_type& x)
  {
    this->scale_.set (x);
  }

  void ValueMapping::
  scale (const scale_optional& x)
  {
    this->scale_ = x;
  }

  const ValueMapping::ValueMapping_formats_DataPoint_sequence& ValueMapping::
  ValueMapping_formats_DataPoint () const
  {
    return this->ValueMapping_formats_DataPoint_;
  }

  ValueMapping::ValueMapping_formats_DataPoint_sequence& ValueMapping::
  ValueMapping_formats_DataPoint ()
  {
    return this->ValueMapping_formats_DataPoint_;
  }

  void ValueMapping::
  ValueMapping_formats_DataPoint (const ValueMapping_formats_DataPoint_sequence& s)
  {
    this->ValueMapping_formats_DataPoint_ = s;
  }

  const ValueMapping::ValueMapping_uses_PhysicalSegmentLocation_optional& ValueMapping::
  ValueMapping_uses_PhysicalSegmentLocation () const
  {
    return this->ValueMapping_uses_PhysicalSegmentLocation_;
  }

  ValueMapping::ValueMapping_uses_PhysicalSegmentLocation_optional& ValueMapping::
  ValueMapping_uses_PhysicalSegmentLocation ()
  {
    return this->ValueMapping_uses_PhysicalSegmentLocation_;
  }

  void ValueMapping::
  ValueMapping_uses_PhysicalSegmentLocation (const ValueMapping_uses_PhysicalSegmentLocation_type& x)
  {
    this->ValueMapping_uses_PhysicalSegmentLocation_.set (x);
  }

  void ValueMapping::
  ValueMapping_uses_PhysicalSegmentLocation (const ValueMapping_uses_PhysicalSegmentLocation_optional& x)
  {
    this->ValueMapping_uses_PhysicalSegmentLocation_ = x;
  }

  void ValueMapping::
  ValueMapping_uses_PhysicalSegmentLocation (::std::unique_ptr< ValueMapping_uses_PhysicalSegmentLocation_type > x)
  {
    this->ValueMapping_uses_PhysicalSegmentLocation_.set (std::move (x));
  }


  // ValueMappingPosition
  //

  const ValueMappingPosition::identifier_optional& ValueMappingPosition::
  identifier () const
  {
    return this->identifier_;
  }

  ValueMappingPosition::identifier_optional& ValueMappingPosition::
  identifier ()
  {
    return this->identifier_;
  }

  void ValueMappingPosition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ValueMappingPosition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ValueMappingPosition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ValueMappingPosition::value_type& ValueMappingPosition::
  value () const
  {
    return this->value_.get ();
  }

  ValueMappingPosition::value_type& ValueMappingPosition::
  value ()
  {
    return this->value_.get ();
  }

  void ValueMappingPosition::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  const ValueMappingPosition::ValueMappingPosition_indexes_ValueMapping_type& ValueMappingPosition::
  ValueMappingPosition_indexes_ValueMapping () const
  {
    return this->ValueMappingPosition_indexes_ValueMapping_.get ();
  }

  ValueMappingPosition::ValueMappingPosition_indexes_ValueMapping_type& ValueMappingPosition::
  ValueMappingPosition_indexes_ValueMapping ()
  {
    return this->ValueMappingPosition_indexes_ValueMapping_.get ();
  }

  void ValueMappingPosition::
  ValueMappingPosition_indexes_ValueMapping (const ValueMappingPosition_indexes_ValueMapping_type& x)
  {
    this->ValueMappingPosition_indexes_ValueMapping_.set (x);
  }

  void ValueMappingPosition::
  ValueMappingPosition_indexes_ValueMapping (::std::unique_ptr< ValueMappingPosition_indexes_ValueMapping_type > x)
  {
    this->ValueMappingPosition_indexes_ValueMapping_.set (std::move (x));
  }


  // ValueMappingRelationship
  //

  const ValueMappingRelationship::identifier_optional& ValueMappingRelationship::
  identifier () const
  {
    return this->identifier_;
  }

  ValueMappingRelationship::identifier_optional& ValueMappingRelationship::
  identifier ()
  {
    return this->identifier_;
  }

  void ValueMappingRelationship::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void ValueMappingRelationship::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void ValueMappingRelationship::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const ValueMappingRelationship::semantics_optional& ValueMappingRelationship::
  semantics () const
  {
    return this->semantics_;
  }

  ValueMappingRelationship::semantics_optional& ValueMappingRelationship::
  semantics ()
  {
    return this->semantics_;
  }

  void ValueMappingRelationship::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void ValueMappingRelationship::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void ValueMappingRelationship::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const ValueMappingRelationship::ValueMappingRelationship_hasTarget_ValueMapping_sequence& ValueMappingRelationship::
  ValueMappingRelationship_hasTarget_ValueMapping () const
  {
    return this->ValueMappingRelationship_hasTarget_ValueMapping_;
  }

  ValueMappingRelationship::ValueMappingRelationship_hasTarget_ValueMapping_sequence& ValueMappingRelationship::
  ValueMappingRelationship_hasTarget_ValueMapping ()
  {
    return this->ValueMappingRelationship_hasTarget_ValueMapping_;
  }

  void ValueMappingRelationship::
  ValueMappingRelationship_hasTarget_ValueMapping (const ValueMappingRelationship_hasTarget_ValueMapping_sequence& s)
  {
    this->ValueMappingRelationship_hasTarget_ValueMapping_ = s;
  }

  const ValueMappingRelationship::ValueMappingRelationship_hasSource_ValueMapping_sequence& ValueMappingRelationship::
  ValueMappingRelationship_hasSource_ValueMapping () const
  {
    return this->ValueMappingRelationship_hasSource_ValueMapping_;
  }

  ValueMappingRelationship::ValueMappingRelationship_hasSource_ValueMapping_sequence& ValueMappingRelationship::
  ValueMappingRelationship_hasSource_ValueMapping ()
  {
    return this->ValueMappingRelationship_hasSource_ValueMapping_;
  }

  void ValueMappingRelationship::
  ValueMappingRelationship_hasSource_ValueMapping (const ValueMappingRelationship_hasSource_ValueMapping_sequence& s)
  {
    this->ValueMappingRelationship_hasSource_ValueMapping_ = s;
  }


  // VariableCollection
  //

  const VariableCollection::allowsDuplicates_type& VariableCollection::
  allowsDuplicates () const
  {
    return this->allowsDuplicates_.get ();
  }

  VariableCollection::allowsDuplicates_type& VariableCollection::
  allowsDuplicates ()
  {
    return this->allowsDuplicates_.get ();
  }

  void VariableCollection::
  allowsDuplicates (const allowsDuplicates_type& x)
  {
    this->allowsDuplicates_.set (x);
  }

  const VariableCollection::displayLabel_sequence& VariableCollection::
  displayLabel () const
  {
    return this->displayLabel_;
  }

  VariableCollection::displayLabel_sequence& VariableCollection::
  displayLabel ()
  {
    return this->displayLabel_;
  }

  void VariableCollection::
  displayLabel (const displayLabel_sequence& s)
  {
    this->displayLabel_ = s;
  }

  const VariableCollection::groupingSemantic_optional& VariableCollection::
  groupingSemantic () const
  {
    return this->groupingSemantic_;
  }

  VariableCollection::groupingSemantic_optional& VariableCollection::
  groupingSemantic ()
  {
    return this->groupingSemantic_;
  }

  void VariableCollection::
  groupingSemantic (const groupingSemantic_type& x)
  {
    this->groupingSemantic_.set (x);
  }

  void VariableCollection::
  groupingSemantic (const groupingSemantic_optional& x)
  {
    this->groupingSemantic_ = x;
  }

  void VariableCollection::
  groupingSemantic (::std::unique_ptr< groupingSemantic_type > x)
  {
    this->groupingSemantic_.set (std::move (x));
  }

  const VariableCollection::identifier_optional& VariableCollection::
  identifier () const
  {
    return this->identifier_;
  }

  VariableCollection::identifier_optional& VariableCollection::
  identifier ()
  {
    return this->identifier_;
  }

  void VariableCollection::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void VariableCollection::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void VariableCollection::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const VariableCollection::name_sequence& VariableCollection::
  name () const
  {
    return this->name_;
  }

  VariableCollection::name_sequence& VariableCollection::
  name ()
  {
    return this->name_;
  }

  void VariableCollection::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const VariableCollection::purpose_optional& VariableCollection::
  purpose () const
  {
    return this->purpose_;
  }

  VariableCollection::purpose_optional& VariableCollection::
  purpose ()
  {
    return this->purpose_;
  }

  void VariableCollection::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void VariableCollection::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void VariableCollection::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const VariableCollection::usage_optional& VariableCollection::
  usage () const
  {
    return this->usage_;
  }

  VariableCollection::usage_optional& VariableCollection::
  usage ()
  {
    return this->usage_;
  }

  void VariableCollection::
  usage (const usage_type& x)
  {
    this->usage_.set (x);
  }

  void VariableCollection::
  usage (const usage_optional& x)
  {
    this->usage_ = x;
  }

  void VariableCollection::
  usage (::std::unique_ptr< usage_type > x)
  {
    this->usage_.set (std::move (x));
  }

  const VariableCollection::VariableCollection_isDefinedBy_Concept_sequence& VariableCollection::
  VariableCollection_isDefinedBy_Concept () const
  {
    return this->VariableCollection_isDefinedBy_Concept_;
  }

  VariableCollection::VariableCollection_isDefinedBy_Concept_sequence& VariableCollection::
  VariableCollection_isDefinedBy_Concept ()
  {
    return this->VariableCollection_isDefinedBy_Concept_;
  }

  void VariableCollection::
  VariableCollection_isDefinedBy_Concept (const VariableCollection_isDefinedBy_Concept_sequence& s)
  {
    this->VariableCollection_isDefinedBy_Concept_ = s;
  }

  const VariableCollection::VariableCollection_has_ConceptualVariable_sequence& VariableCollection::
  VariableCollection_has_ConceptualVariable () const
  {
    return this->VariableCollection_has_ConceptualVariable_;
  }

  VariableCollection::VariableCollection_has_ConceptualVariable_sequence& VariableCollection::
  VariableCollection_has_ConceptualVariable ()
  {
    return this->VariableCollection_has_ConceptualVariable_;
  }

  void VariableCollection::
  VariableCollection_has_ConceptualVariable (const VariableCollection_has_ConceptualVariable_sequence& s)
  {
    this->VariableCollection_has_ConceptualVariable_ = s;
  }

  const VariableCollection::VariableCollection_has_VariablePosition_sequence& VariableCollection::
  VariableCollection_has_VariablePosition () const
  {
    return this->VariableCollection_has_VariablePosition_;
  }

  VariableCollection::VariableCollection_has_VariablePosition_sequence& VariableCollection::
  VariableCollection_has_VariablePosition ()
  {
    return this->VariableCollection_has_VariablePosition_;
  }

  void VariableCollection::
  VariableCollection_has_VariablePosition (const VariableCollection_has_VariablePosition_sequence& s)
  {
    this->VariableCollection_has_VariablePosition_ = s;
  }


  // VariableDescriptorComponent
  //

  const VariableDescriptorComponent::VariableDescriptorComponent_isDefinedBy_DescriptorVariable_optional& VariableDescriptorComponent::
  VariableDescriptorComponent_isDefinedBy_DescriptorVariable () const
  {
    return this->VariableDescriptorComponent_isDefinedBy_DescriptorVariable_;
  }

  VariableDescriptorComponent::VariableDescriptorComponent_isDefinedBy_DescriptorVariable_optional& VariableDescriptorComponent::
  VariableDescriptorComponent_isDefinedBy_DescriptorVariable ()
  {
    return this->VariableDescriptorComponent_isDefinedBy_DescriptorVariable_;
  }

  void VariableDescriptorComponent::
  VariableDescriptorComponent_isDefinedBy_DescriptorVariable (const VariableDescriptorComponent_isDefinedBy_DescriptorVariable_type& x)
  {
    this->VariableDescriptorComponent_isDefinedBy_DescriptorVariable_.set (x);
  }

  void VariableDescriptorComponent::
  VariableDescriptorComponent_isDefinedBy_DescriptorVariable (const VariableDescriptorComponent_isDefinedBy_DescriptorVariable_optional& x)
  {
    this->VariableDescriptorComponent_isDefinedBy_DescriptorVariable_ = x;
  }

  void VariableDescriptorComponent::
  VariableDescriptorComponent_isDefinedBy_DescriptorVariable (::std::unique_ptr< VariableDescriptorComponent_isDefinedBy_DescriptorVariable_type > x)
  {
    this->VariableDescriptorComponent_isDefinedBy_DescriptorVariable_.set (std::move (x));
  }

  const VariableDescriptorComponent::VariableDescriptorComponent_refersTo_VariableValueComponent_type& VariableDescriptorComponent::
  VariableDescriptorComponent_refersTo_VariableValueComponent () const
  {
    return this->VariableDescriptorComponent_refersTo_VariableValueComponent_.get ();
  }

  VariableDescriptorComponent::VariableDescriptorComponent_refersTo_VariableValueComponent_type& VariableDescriptorComponent::
  VariableDescriptorComponent_refersTo_VariableValueComponent ()
  {
    return this->VariableDescriptorComponent_refersTo_VariableValueComponent_.get ();
  }

  void VariableDescriptorComponent::
  VariableDescriptorComponent_refersTo_VariableValueComponent (const VariableDescriptorComponent_refersTo_VariableValueComponent_type& x)
  {
    this->VariableDescriptorComponent_refersTo_VariableValueComponent_.set (x);
  }

  void VariableDescriptorComponent::
  VariableDescriptorComponent_refersTo_VariableValueComponent (::std::unique_ptr< VariableDescriptorComponent_refersTo_VariableValueComponent_type > x)
  {
    this->VariableDescriptorComponent_refersTo_VariableValueComponent_.set (std::move (x));
  }


  // VariablePosition
  //

  const VariablePosition::identifier_optional& VariablePosition::
  identifier () const
  {
    return this->identifier_;
  }

  VariablePosition::identifier_optional& VariablePosition::
  identifier ()
  {
    return this->identifier_;
  }

  void VariablePosition::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void VariablePosition::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void VariablePosition::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const VariablePosition::value_type& VariablePosition::
  value () const
  {
    return this->value_.get ();
  }

  VariablePosition::value_type& VariablePosition::
  value ()
  {
    return this->value_.get ();
  }

  void VariablePosition::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  const VariablePosition::VariablePosition_indexes_ConceptualVariable_type& VariablePosition::
  VariablePosition_indexes_ConceptualVariable () const
  {
    return this->VariablePosition_indexes_ConceptualVariable_.get ();
  }

  VariablePosition::VariablePosition_indexes_ConceptualVariable_type& VariablePosition::
  VariablePosition_indexes_ConceptualVariable ()
  {
    return this->VariablePosition_indexes_ConceptualVariable_.get ();
  }

  void VariablePosition::
  VariablePosition_indexes_ConceptualVariable (const VariablePosition_indexes_ConceptualVariable_type& x)
  {
    this->VariablePosition_indexes_ConceptualVariable_.set (x);
  }

  void VariablePosition::
  VariablePosition_indexes_ConceptualVariable (::std::unique_ptr< VariablePosition_indexes_ConceptualVariable_type > x)
  {
    this->VariablePosition_indexes_ConceptualVariable_.set (std::move (x));
  }


  // VariableRelationship
  //

  const VariableRelationship::identifier_optional& VariableRelationship::
  identifier () const
  {
    return this->identifier_;
  }

  VariableRelationship::identifier_optional& VariableRelationship::
  identifier ()
  {
    return this->identifier_;
  }

  void VariableRelationship::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void VariableRelationship::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void VariableRelationship::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const VariableRelationship::semantics_optional& VariableRelationship::
  semantics () const
  {
    return this->semantics_;
  }

  VariableRelationship::semantics_optional& VariableRelationship::
  semantics ()
  {
    return this->semantics_;
  }

  void VariableRelationship::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void VariableRelationship::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void VariableRelationship::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const VariableRelationship::VariableRelationship_hasTarget_ConceptualVariable_sequence& VariableRelationship::
  VariableRelationship_hasTarget_ConceptualVariable () const
  {
    return this->VariableRelationship_hasTarget_ConceptualVariable_;
  }

  VariableRelationship::VariableRelationship_hasTarget_ConceptualVariable_sequence& VariableRelationship::
  VariableRelationship_hasTarget_ConceptualVariable ()
  {
    return this->VariableRelationship_hasTarget_ConceptualVariable_;
  }

  void VariableRelationship::
  VariableRelationship_hasTarget_ConceptualVariable (const VariableRelationship_hasTarget_ConceptualVariable_sequence& s)
  {
    this->VariableRelationship_hasTarget_ConceptualVariable_ = s;
  }

  const VariableRelationship::VariableRelationship_hasSource_ConceptualVariable_sequence& VariableRelationship::
  VariableRelationship_hasSource_ConceptualVariable () const
  {
    return this->VariableRelationship_hasSource_ConceptualVariable_;
  }

  VariableRelationship::VariableRelationship_hasSource_ConceptualVariable_sequence& VariableRelationship::
  VariableRelationship_hasSource_ConceptualVariable ()
  {
    return this->VariableRelationship_hasSource_ConceptualVariable_;
  }

  void VariableRelationship::
  VariableRelationship_hasSource_ConceptualVariable (const VariableRelationship_hasSource_ConceptualVariable_sequence& s)
  {
    this->VariableRelationship_hasSource_ConceptualVariable_ = s;
  }


  // VariableStructure
  //

  const VariableStructure::identifier_optional& VariableStructure::
  identifier () const
  {
    return this->identifier_;
  }

  VariableStructure::identifier_optional& VariableStructure::
  identifier ()
  {
    return this->identifier_;
  }

  void VariableStructure::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void VariableStructure::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void VariableStructure::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const VariableStructure::name_sequence& VariableStructure::
  name () const
  {
    return this->name_;
  }

  VariableStructure::name_sequence& VariableStructure::
  name ()
  {
    return this->name_;
  }

  void VariableStructure::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const VariableStructure::purpose_optional& VariableStructure::
  purpose () const
  {
    return this->purpose_;
  }

  VariableStructure::purpose_optional& VariableStructure::
  purpose ()
  {
    return this->purpose_;
  }

  void VariableStructure::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void VariableStructure::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void VariableStructure::
  purpose (::std::unique_ptr< purpose_type > x)
  {
    this->purpose_.set (std::move (x));
  }

  const VariableStructure::semantics_optional& VariableStructure::
  semantics () const
  {
    return this->semantics_;
  }

  VariableStructure::semantics_optional& VariableStructure::
  semantics ()
  {
    return this->semantics_;
  }

  void VariableStructure::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void VariableStructure::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void VariableStructure::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }

  const VariableStructure::specification_optional& VariableStructure::
  specification () const
  {
    return this->specification_;
  }

  VariableStructure::specification_optional& VariableStructure::
  specification ()
  {
    return this->specification_;
  }

  void VariableStructure::
  specification (const specification_type& x)
  {
    this->specification_.set (x);
  }

  void VariableStructure::
  specification (const specification_optional& x)
  {
    this->specification_ = x;
  }

  void VariableStructure::
  specification (::std::unique_ptr< specification_type > x)
  {
    this->specification_.set (std::move (x));
  }

  const VariableStructure::topology_optional& VariableStructure::
  topology () const
  {
    return this->topology_;
  }

  VariableStructure::topology_optional& VariableStructure::
  topology ()
  {
    return this->topology_;
  }

  void VariableStructure::
  topology (const topology_type& x)
  {
    this->topology_.set (x);
  }

  void VariableStructure::
  topology (const topology_optional& x)
  {
    this->topology_ = x;
  }

  void VariableStructure::
  topology (::std::unique_ptr< topology_type > x)
  {
    this->topology_.set (std::move (x));
  }

  const VariableStructure::totality_optional& VariableStructure::
  totality () const
  {
    return this->totality_;
  }

  VariableStructure::totality_optional& VariableStructure::
  totality ()
  {
    return this->totality_;
  }

  void VariableStructure::
  totality (const totality_type& x)
  {
    this->totality_.set (x);
  }

  void VariableStructure::
  totality (const totality_optional& x)
  {
    this->totality_ = x;
  }

  void VariableStructure::
  totality (::std::unique_ptr< totality_type > x)
  {
    this->totality_.set (std::move (x));
  }

  const VariableStructure::VariableStructure_structures_VariableCollection_optional& VariableStructure::
  VariableStructure_structures_VariableCollection () const
  {
    return this->VariableStructure_structures_VariableCollection_;
  }

  VariableStructure::VariableStructure_structures_VariableCollection_optional& VariableStructure::
  VariableStructure_structures_VariableCollection ()
  {
    return this->VariableStructure_structures_VariableCollection_;
  }

  void VariableStructure::
  VariableStructure_structures_VariableCollection (const VariableStructure_structures_VariableCollection_type& x)
  {
    this->VariableStructure_structures_VariableCollection_.set (x);
  }

  void VariableStructure::
  VariableStructure_structures_VariableCollection (const VariableStructure_structures_VariableCollection_optional& x)
  {
    this->VariableStructure_structures_VariableCollection_ = x;
  }

  void VariableStructure::
  VariableStructure_structures_VariableCollection (::std::unique_ptr< VariableStructure_structures_VariableCollection_type > x)
  {
    this->VariableStructure_structures_VariableCollection_.set (std::move (x));
  }

  const VariableStructure::VariableStructure_has_VariableRelationship_sequence& VariableStructure::
  VariableStructure_has_VariableRelationship () const
  {
    return this->VariableStructure_has_VariableRelationship_;
  }

  VariableStructure::VariableStructure_has_VariableRelationship_sequence& VariableStructure::
  VariableStructure_has_VariableRelationship ()
  {
    return this->VariableStructure_has_VariableRelationship_;
  }

  void VariableStructure::
  VariableStructure_has_VariableRelationship (const VariableStructure_has_VariableRelationship_sequence& s)
  {
    this->VariableStructure_has_VariableRelationship_ = s;
  }


  // VariableValueComponent
  //


  // WideDataSet
  //


  // WideDataStructure
  //


  // WideKey
  //


  // WideKeyMember
  //


  // CategoryRelationCode
  //

  CategoryRelationCode::
  CategoryRelationCode (value v)
  : ::xml_schema::nmtoken (_xsd_CategoryRelationCode_literals_[v])
  {
  }

  CategoryRelationCode::
  CategoryRelationCode (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  CategoryRelationCode::
  CategoryRelationCode (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  CategoryRelationCode::
  CategoryRelationCode (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  CategoryRelationCode::
  CategoryRelationCode (const CategoryRelationCode& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  CategoryRelationCode& CategoryRelationCode::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_CategoryRelationCode_literals_[v]);

    return *this;
  }


  // ComparisonOperator
  //

  ComparisonOperator::
  ComparisonOperator (value v)
  : ::xml_schema::nmtoken (_xsd_ComparisonOperator_literals_[v])
  {
  }

  ComparisonOperator::
  ComparisonOperator (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  ComparisonOperator::
  ComparisonOperator (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  ComparisonOperator::
  ComparisonOperator (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  ComparisonOperator::
  ComparisonOperator (const ComparisonOperator& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  ComparisonOperator& ComparisonOperator::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_ComparisonOperator_literals_[v]);

    return *this;
  }


  // ComputationBaseList
  //

  ComputationBaseList::
  ComputationBaseList (value v)
  : ::xml_schema::nmtoken (_xsd_ComputationBaseList_literals_[v])
  {
  }

  ComputationBaseList::
  ComputationBaseList (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  ComputationBaseList::
  ComputationBaseList (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  ComputationBaseList::
  ComputationBaseList (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  ComputationBaseList::
  ComputationBaseList (const ComputationBaseList& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  ComputationBaseList& ComputationBaseList::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_ComputationBaseList_literals_[v]);

    return *this;
  }


  // ControlConstruct
  //

  ControlConstruct::
  ControlConstruct (value v)
  : ::xml_schema::nmtoken (_xsd_ControlConstruct_literals_[v])
  {
  }

  ControlConstruct::
  ControlConstruct (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  ControlConstruct::
  ControlConstruct (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  ControlConstruct::
  ControlConstruct (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  ControlConstruct::
  ControlConstruct (const ControlConstruct& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  ControlConstruct& ControlConstruct::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_ControlConstruct_literals_[v]);

    return *this;
  }


  // MatchingCriterion
  //

  MatchingCriterion::
  MatchingCriterion (value v)
  : ::xml_schema::nmtoken (_xsd_MatchingCriterion_literals_[v])
  {
  }

  MatchingCriterion::
  MatchingCriterion (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  MatchingCriterion::
  MatchingCriterion (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  MatchingCriterion::
  MatchingCriterion (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  MatchingCriterion::
  MatchingCriterion (const MatchingCriterion& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  MatchingCriterion& MatchingCriterion::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_MatchingCriterion_literals_[v]);

    return *this;
  }


  // MemberRelationshipScope
  //

  MemberRelationshipScope::
  MemberRelationshipScope (value v)
  : ::xml_schema::nmtoken (_xsd_MemberRelationshipScope_literals_[v])
  {
  }

  MemberRelationshipScope::
  MemberRelationshipScope (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  MemberRelationshipScope::
  MemberRelationshipScope (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  MemberRelationshipScope::
  MemberRelationshipScope (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  MemberRelationshipScope::
  MemberRelationshipScope (const MemberRelationshipScope& v,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  MemberRelationshipScope& MemberRelationshipScope::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_MemberRelationshipScope_literals_[v]);

    return *this;
  }


  // PointFormat
  //

  PointFormat::
  PointFormat (value v)
  : ::xml_schema::nmtoken (_xsd_PointFormat_literals_[v])
  {
  }

  PointFormat::
  PointFormat (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  PointFormat::
  PointFormat (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  PointFormat::
  PointFormat (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  PointFormat::
  PointFormat (const PointFormat& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  PointFormat& PointFormat::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_PointFormat_literals_[v]);

    return *this;
  }


  // SchedulingStrategy
  //

  SchedulingStrategy::
  SchedulingStrategy (value v)
  : ::xml_schema::nmtoken (_xsd_SchedulingStrategy_literals_[v])
  {
  }

  SchedulingStrategy::
  SchedulingStrategy (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  SchedulingStrategy::
  SchedulingStrategy (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  SchedulingStrategy::
  SchedulingStrategy (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  SchedulingStrategy::
  SchedulingStrategy (const SchedulingStrategy& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  SchedulingStrategy& SchedulingStrategy::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_SchedulingStrategy_literals_[v]);

    return *this;
  }


  // SexSpecification
  //

  SexSpecification::
  SexSpecification (value v)
  : ::xml_schema::nmtoken (_xsd_SexSpecification_literals_[v])
  {
  }

  SexSpecification::
  SexSpecification (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  SexSpecification::
  SexSpecification (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  SexSpecification::
  SexSpecification (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  SexSpecification::
  SexSpecification (const SexSpecification& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  SexSpecification& SexSpecification::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_SexSpecification_literals_[v]);

    return *this;
  }


  // StructureExtent
  //

  StructureExtent::
  StructureExtent (value v)
  : ::xml_schema::nmtoken (_xsd_StructureExtent_literals_[v])
  {
  }

  StructureExtent::
  StructureExtent (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  StructureExtent::
  StructureExtent (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  StructureExtent::
  StructureExtent (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  StructureExtent::
  StructureExtent (const StructureExtent& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  StructureExtent& StructureExtent::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_StructureExtent_literals_[v]);

    return *this;
  }


  // TableDirectionValues
  //

  TableDirectionValues::
  TableDirectionValues (value v)
  : ::xml_schema::nmtoken (_xsd_TableDirectionValues_literals_[v])
  {
  }

  TableDirectionValues::
  TableDirectionValues (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TableDirectionValues::
  TableDirectionValues (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TableDirectionValues::
  TableDirectionValues (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TableDirectionValues::
  TableDirectionValues (const TableDirectionValues& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  TableDirectionValues& TableDirectionValues::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_TableDirectionValues_literals_[v]);

    return *this;
  }


  // TemporalOperator
  //

  TemporalOperator::
  TemporalOperator (value v)
  : ::xml_schema::nmtoken (_xsd_TemporalOperator_literals_[v])
  {
  }

  TemporalOperator::
  TemporalOperator (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TemporalOperator::
  TemporalOperator (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TemporalOperator::
  TemporalOperator (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TemporalOperator::
  TemporalOperator (const TemporalOperator& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  TemporalOperator& TemporalOperator::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_TemporalOperator_literals_[v]);

    return *this;
  }


  // TemporalRelation
  //

  TemporalRelation::
  TemporalRelation (value v)
  : ::xml_schema::nmtoken (_xsd_TemporalRelation_literals_[v])
  {
  }

  TemporalRelation::
  TemporalRelation (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TemporalRelation::
  TemporalRelation (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TemporalRelation::
  TemporalRelation (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TemporalRelation::
  TemporalRelation (const TemporalRelation& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  TemporalRelation& TemporalRelation::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_TemporalRelation_literals_[v]);

    return *this;
  }


  // TextDirectionValues
  //

  TextDirectionValues::
  TextDirectionValues (value v)
  : ::xml_schema::nmtoken (_xsd_TextDirectionValues_literals_[v])
  {
  }

  TextDirectionValues::
  TextDirectionValues (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TextDirectionValues::
  TextDirectionValues (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TextDirectionValues::
  TextDirectionValues (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TextDirectionValues::
  TextDirectionValues (const TextDirectionValues& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  TextDirectionValues& TextDirectionValues::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_TextDirectionValues_literals_[v]);

    return *this;
  }


  // TrimValues
  //

  TrimValues::
  TrimValues (value v)
  : ::xml_schema::nmtoken (_xsd_TrimValues_literals_[v])
  {
  }

  TrimValues::
  TrimValues (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TrimValues::
  TrimValues (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TrimValues::
  TrimValues (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  TrimValues::
  TrimValues (const TrimValues& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  TrimValues& TrimValues::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_TrimValues_literals_[v]);

    return *this;
  }


  // WhiteSpaceRule
  //

  WhiteSpaceRule::
  WhiteSpaceRule (value v)
  : ::xml_schema::nmtoken (_xsd_WhiteSpaceRule_literals_[v])
  {
  }

  WhiteSpaceRule::
  WhiteSpaceRule (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  WhiteSpaceRule::
  WhiteSpaceRule (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  WhiteSpaceRule::
  WhiteSpaceRule (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  WhiteSpaceRule::
  WhiteSpaceRule (const WhiteSpaceRule& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  WhiteSpaceRule& WhiteSpaceRule::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_WhiteSpaceRule_literals_[v]);

    return *this;
  }


  // AccessInformation
  //

  const AccessInformation::copyright_sequence& AccessInformation::
  copyright () const
  {
    return this->copyright_;
  }

  AccessInformation::copyright_sequence& AccessInformation::
  copyright ()
  {
    return this->copyright_;
  }

  void AccessInformation::
  copyright (const copyright_sequence& s)
  {
    this->copyright_ = s;
  }

  const AccessInformation::embargo_sequence& AccessInformation::
  embargo () const
  {
    return this->embargo_;
  }

  AccessInformation::embargo_sequence& AccessInformation::
  embargo ()
  {
    return this->embargo_;
  }

  void AccessInformation::
  embargo (const embargo_sequence& s)
  {
    this->embargo_ = s;
  }

  const AccessInformation::license_sequence& AccessInformation::
  license () const
  {
    return this->license_;
  }

  AccessInformation::license_sequence& AccessInformation::
  license ()
  {
    return this->license_;
  }

  void AccessInformation::
  license (const license_sequence& s)
  {
    this->license_ = s;
  }

  const AccessInformation::rights_sequence& AccessInformation::
  rights () const
  {
    return this->rights_;
  }

  AccessInformation::rights_sequence& AccessInformation::
  rights ()
  {
    return this->rights_;
  }

  void AccessInformation::
  rights (const rights_sequence& s)
  {
    this->rights_ = s;
  }


  // AccessLocation
  //

  const AccessLocation::mimeType_optional& AccessLocation::
  mimeType () const
  {
    return this->mimeType_;
  }

  AccessLocation::mimeType_optional& AccessLocation::
  mimeType ()
  {
    return this->mimeType_;
  }

  void AccessLocation::
  mimeType (const mimeType_type& x)
  {
    this->mimeType_.set (x);
  }

  void AccessLocation::
  mimeType (const mimeType_optional& x)
  {
    this->mimeType_ = x;
  }

  void AccessLocation::
  mimeType (::std::unique_ptr< mimeType_type > x)
  {
    this->mimeType_.set (std::move (x));
  }

  const AccessLocation::physicalLocation_sequence& AccessLocation::
  physicalLocation () const
  {
    return this->physicalLocation_;
  }

  AccessLocation::physicalLocation_sequence& AccessLocation::
  physicalLocation ()
  {
    return this->physicalLocation_;
  }

  void AccessLocation::
  physicalLocation (const physicalLocation_sequence& s)
  {
    this->physicalLocation_ = s;
  }

  const AccessLocation::uri_sequence& AccessLocation::
  uri () const
  {
    return this->uri_;
  }

  AccessLocation::uri_sequence& AccessLocation::
  uri ()
  {
    return this->uri_;
  }

  void AccessLocation::
  uri (const uri_sequence& s)
  {
    this->uri_ = s;
  }


  // Address
  //

  const Address::cityPlaceLocal_optional& Address::
  cityPlaceLocal () const
  {
    return this->cityPlaceLocal_;
  }

  Address::cityPlaceLocal_optional& Address::
  cityPlaceLocal ()
  {
    return this->cityPlaceLocal_;
  }

  void Address::
  cityPlaceLocal (const cityPlaceLocal_type& x)
  {
    this->cityPlaceLocal_.set (x);
  }

  void Address::
  cityPlaceLocal (const cityPlaceLocal_optional& x)
  {
    this->cityPlaceLocal_ = x;
  }

  void Address::
  cityPlaceLocal (::std::unique_ptr< cityPlaceLocal_type > x)
  {
    this->cityPlaceLocal_.set (std::move (x));
  }

  const Address::countryCode_optional& Address::
  countryCode () const
  {
    return this->countryCode_;
  }

  Address::countryCode_optional& Address::
  countryCode ()
  {
    return this->countryCode_;
  }

  void Address::
  countryCode (const countryCode_type& x)
  {
    this->countryCode_.set (x);
  }

  void Address::
  countryCode (const countryCode_optional& x)
  {
    this->countryCode_ = x;
  }

  void Address::
  countryCode (::std::unique_ptr< countryCode_type > x)
  {
    this->countryCode_.set (std::move (x));
  }

  const Address::effectiveDates_optional& Address::
  effectiveDates () const
  {
    return this->effectiveDates_;
  }

  Address::effectiveDates_optional& Address::
  effectiveDates ()
  {
    return this->effectiveDates_;
  }

  void Address::
  effectiveDates (const effectiveDates_type& x)
  {
    this->effectiveDates_.set (x);
  }

  void Address::
  effectiveDates (const effectiveDates_optional& x)
  {
    this->effectiveDates_ = x;
  }

  void Address::
  effectiveDates (::std::unique_ptr< effectiveDates_type > x)
  {
    this->effectiveDates_.set (std::move (x));
  }

  const Address::geographicPoint_optional& Address::
  geographicPoint () const
  {
    return this->geographicPoint_;
  }

  Address::geographicPoint_optional& Address::
  geographicPoint ()
  {
    return this->geographicPoint_;
  }

  void Address::
  geographicPoint (const geographicPoint_type& x)
  {
    this->geographicPoint_.set (x);
  }

  void Address::
  geographicPoint (const geographicPoint_optional& x)
  {
    this->geographicPoint_ = x;
  }

  void Address::
  geographicPoint (::std::unique_ptr< geographicPoint_type > x)
  {
    this->geographicPoint_.set (std::move (x));
  }

  const Address::isPreferred_optional& Address::
  isPreferred () const
  {
    return this->isPreferred_;
  }

  Address::isPreferred_optional& Address::
  isPreferred ()
  {
    return this->isPreferred_;
  }

  void Address::
  isPreferred (const isPreferred_type& x)
  {
    this->isPreferred_.set (x);
  }

  void Address::
  isPreferred (const isPreferred_optional& x)
  {
    this->isPreferred_ = x;
  }

  const Address::line_sequence& Address::
  line () const
  {
    return this->line_;
  }

  Address::line_sequence& Address::
  line ()
  {
    return this->line_;
  }

  void Address::
  line (const line_sequence& s)
  {
    this->line_ = s;
  }

  const Address::locationName_optional& Address::
  locationName () const
  {
    return this->locationName_;
  }

  Address::locationName_optional& Address::
  locationName ()
  {
    return this->locationName_;
  }

  void Address::
  locationName (const locationName_type& x)
  {
    this->locationName_.set (x);
  }

  void Address::
  locationName (const locationName_optional& x)
  {
    this->locationName_ = x;
  }

  void Address::
  locationName (::std::unique_ptr< locationName_type > x)
  {
    this->locationName_.set (std::move (x));
  }

  const Address::postalCode_optional& Address::
  postalCode () const
  {
    return this->postalCode_;
  }

  Address::postalCode_optional& Address::
  postalCode ()
  {
    return this->postalCode_;
  }

  void Address::
  postalCode (const postalCode_type& x)
  {
    this->postalCode_.set (x);
  }

  void Address::
  postalCode (const postalCode_optional& x)
  {
    this->postalCode_ = x;
  }

  void Address::
  postalCode (::std::unique_ptr< postalCode_type > x)
  {
    this->postalCode_.set (std::move (x));
  }

  const Address::privacy_optional& Address::
  privacy () const
  {
    return this->privacy_;
  }

  Address::privacy_optional& Address::
  privacy ()
  {
    return this->privacy_;
  }

  void Address::
  privacy (const privacy_type& x)
  {
    this->privacy_.set (x);
  }

  void Address::
  privacy (const privacy_optional& x)
  {
    this->privacy_ = x;
  }

  void Address::
  privacy (::std::unique_ptr< privacy_type > x)
  {
    this->privacy_.set (std::move (x));
  }

  const Address::regionalCoverage_optional& Address::
  regionalCoverage () const
  {
    return this->regionalCoverage_;
  }

  Address::regionalCoverage_optional& Address::
  regionalCoverage ()
  {
    return this->regionalCoverage_;
  }

  void Address::
  regionalCoverage (const regionalCoverage_type& x)
  {
    this->regionalCoverage_.set (x);
  }

  void Address::
  regionalCoverage (const regionalCoverage_optional& x)
  {
    this->regionalCoverage_ = x;
  }

  void Address::
  regionalCoverage (::std::unique_ptr< regionalCoverage_type > x)
  {
    this->regionalCoverage_.set (std::move (x));
  }

  const Address::stateProvince_optional& Address::
  stateProvince () const
  {
    return this->stateProvince_;
  }

  Address::stateProvince_optional& Address::
  stateProvince ()
  {
    return this->stateProvince_;
  }

  void Address::
  stateProvince (const stateProvince_type& x)
  {
    this->stateProvince_.set (x);
  }

  void Address::
  stateProvince (const stateProvince_optional& x)
  {
    this->stateProvince_ = x;
  }

  void Address::
  stateProvince (::std::unique_ptr< stateProvince_type > x)
  {
    this->stateProvince_.set (std::move (x));
  }

  const Address::timeZone_optional& Address::
  timeZone () const
  {
    return this->timeZone_;
  }

  Address::timeZone_optional& Address::
  timeZone ()
  {
    return this->timeZone_;
  }

  void Address::
  timeZone (const timeZone_type& x)
  {
    this->timeZone_.set (x);
  }

  void Address::
  timeZone (const timeZone_optional& x)
  {
    this->timeZone_ = x;
  }

  void Address::
  timeZone (::std::unique_ptr< timeZone_type > x)
  {
    this->timeZone_.set (std::move (x));
  }

  const Address::typeOfAddress_optional& Address::
  typeOfAddress () const
  {
    return this->typeOfAddress_;
  }

  Address::typeOfAddress_optional& Address::
  typeOfAddress ()
  {
    return this->typeOfAddress_;
  }

  void Address::
  typeOfAddress (const typeOfAddress_type& x)
  {
    this->typeOfAddress_.set (x);
  }

  void Address::
  typeOfAddress (const typeOfAddress_optional& x)
  {
    this->typeOfAddress_ = x;
  }

  void Address::
  typeOfAddress (::std::unique_ptr< typeOfAddress_type > x)
  {
    this->typeOfAddress_.set (std::move (x));
  }

  const Address::typeOfLocation_optional& Address::
  typeOfLocation () const
  {
    return this->typeOfLocation_;
  }

  Address::typeOfLocation_optional& Address::
  typeOfLocation ()
  {
    return this->typeOfLocation_;
  }

  void Address::
  typeOfLocation (const typeOfLocation_type& x)
  {
    this->typeOfLocation_.set (x);
  }

  void Address::
  typeOfLocation (const typeOfLocation_optional& x)
  {
    this->typeOfLocation_ = x;
  }

  void Address::
  typeOfLocation (::std::unique_ptr< typeOfLocation_type > x)
  {
    this->typeOfLocation_.set (std::move (x));
  }


  // AgentInRole
  //

  const AgentInRole::agentName_optional& AgentInRole::
  agentName () const
  {
    return this->agentName_;
  }

  AgentInRole::agentName_optional& AgentInRole::
  agentName ()
  {
    return this->agentName_;
  }

  void AgentInRole::
  agentName (const agentName_type& x)
  {
    this->agentName_.set (x);
  }

  void AgentInRole::
  agentName (const agentName_optional& x)
  {
    this->agentName_ = x;
  }

  void AgentInRole::
  agentName (::std::unique_ptr< agentName_type > x)
  {
    this->agentName_.set (std::move (x));
  }

  const AgentInRole::reference_optional& AgentInRole::
  reference () const
  {
    return this->reference_;
  }

  AgentInRole::reference_optional& AgentInRole::
  reference ()
  {
    return this->reference_;
  }

  void AgentInRole::
  reference (const reference_type& x)
  {
    this->reference_.set (x);
  }

  void AgentInRole::
  reference (const reference_optional& x)
  {
    this->reference_ = x;
  }

  void AgentInRole::
  reference (::std::unique_ptr< reference_type > x)
  {
    this->reference_.set (std::move (x));
  }

  const AgentInRole::role_sequence& AgentInRole::
  role () const
  {
    return this->role_;
  }

  AgentInRole::role_sequence& AgentInRole::
  role ()
  {
    return this->role_;
  }

  void AgentInRole::
  role (const role_sequence& s)
  {
    this->role_ = s;
  }


  // InternationalString
  //

  const InternationalString::languageSpecificString_sequence& InternationalString::
  languageSpecificString () const
  {
    return this->languageSpecificString_;
  }

  InternationalString::languageSpecificString_sequence& InternationalString::
  languageSpecificString ()
  {
    return this->languageSpecificString_;
  }

  void InternationalString::
  languageSpecificString (const languageSpecificString_sequence& s)
  {
    this->languageSpecificString_ = s;
  }


  // BibliographicName
  //

  const BibliographicName::affiliation_optional& BibliographicName::
  affiliation () const
  {
    return this->affiliation_;
  }

  BibliographicName::affiliation_optional& BibliographicName::
  affiliation ()
  {
    return this->affiliation_;
  }

  void BibliographicName::
  affiliation (const affiliation_type& x)
  {
    this->affiliation_.set (x);
  }

  void BibliographicName::
  affiliation (const affiliation_optional& x)
  {
    this->affiliation_ = x;
  }

  void BibliographicName::
  affiliation (::std::unique_ptr< affiliation_type > x)
  {
    this->affiliation_.set (std::move (x));
  }


  // CatalogDetails
  //

  const CatalogDetails::access_sequence& CatalogDetails::
  access () const
  {
    return this->access_;
  }

  CatalogDetails::access_sequence& CatalogDetails::
  access ()
  {
    return this->access_;
  }

  void CatalogDetails::
  access (const access_sequence& s)
  {
    this->access_ = s;
  }

  const CatalogDetails::alternativeTitle_sequence& CatalogDetails::
  alternativeTitle () const
  {
    return this->alternativeTitle_;
  }

  CatalogDetails::alternativeTitle_sequence& CatalogDetails::
  alternativeTitle ()
  {
    return this->alternativeTitle_;
  }

  void CatalogDetails::
  alternativeTitle (const alternativeTitle_sequence& s)
  {
    this->alternativeTitle_ = s;
  }

  const CatalogDetails::contributor_sequence& CatalogDetails::
  contributor () const
  {
    return this->contributor_;
  }

  CatalogDetails::contributor_sequence& CatalogDetails::
  contributor ()
  {
    return this->contributor_;
  }

  void CatalogDetails::
  contributor (const contributor_sequence& s)
  {
    this->contributor_ = s;
  }

  const CatalogDetails::creator_sequence& CatalogDetails::
  creator () const
  {
    return this->creator_;
  }

  CatalogDetails::creator_sequence& CatalogDetails::
  creator ()
  {
    return this->creator_;
  }

  void CatalogDetails::
  creator (const creator_sequence& s)
  {
    this->creator_ = s;
  }

  const CatalogDetails::date_sequence& CatalogDetails::
  date () const
  {
    return this->date_;
  }

  CatalogDetails::date_sequence& CatalogDetails::
  date ()
  {
    return this->date_;
  }

  void CatalogDetails::
  date (const date_sequence& s)
  {
    this->date_ = s;
  }

  const CatalogDetails::identifier_optional& CatalogDetails::
  identifier () const
  {
    return this->identifier_;
  }

  CatalogDetails::identifier_optional& CatalogDetails::
  identifier ()
  {
    return this->identifier_;
  }

  void CatalogDetails::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void CatalogDetails::
  identifier (const identifier_optional& x)
  {
    this->identifier_ = x;
  }

  void CatalogDetails::
  identifier (::std::unique_ptr< identifier_type > x)
  {
    this->identifier_.set (std::move (x));
  }

  const CatalogDetails::informationSource_sequence& CatalogDetails::
  informationSource () const
  {
    return this->informationSource_;
  }

  CatalogDetails::informationSource_sequence& CatalogDetails::
  informationSource ()
  {
    return this->informationSource_;
  }

  void CatalogDetails::
  informationSource (const informationSource_sequence& s)
  {
    this->informationSource_ = s;
  }

  const CatalogDetails::languageOfObject_sequence& CatalogDetails::
  languageOfObject () const
  {
    return this->languageOfObject_;
  }

  CatalogDetails::languageOfObject_sequence& CatalogDetails::
  languageOfObject ()
  {
    return this->languageOfObject_;
  }

  void CatalogDetails::
  languageOfObject (const languageOfObject_sequence& s)
  {
    this->languageOfObject_ = s;
  }

  const CatalogDetails::provenance_optional& CatalogDetails::
  provenance () const
  {
    return this->provenance_;
  }

  CatalogDetails::provenance_optional& CatalogDetails::
  provenance ()
  {
    return this->provenance_;
  }

  void CatalogDetails::
  provenance (const provenance_type& x)
  {
    this->provenance_.set (x);
  }

  void CatalogDetails::
  provenance (const provenance_optional& x)
  {
    this->provenance_ = x;
  }

  void CatalogDetails::
  provenance (::std::unique_ptr< provenance_type > x)
  {
    this->provenance_.set (std::move (x));
  }

  const CatalogDetails::publisher_sequence& CatalogDetails::
  publisher () const
  {
    return this->publisher_;
  }

  CatalogDetails::publisher_sequence& CatalogDetails::
  publisher ()
  {
    return this->publisher_;
  }

  void CatalogDetails::
  publisher (const publisher_sequence& s)
  {
    this->publisher_ = s;
  }

  const CatalogDetails::relatedResource_sequence& CatalogDetails::
  relatedResource () const
  {
    return this->relatedResource_;
  }

  CatalogDetails::relatedResource_sequence& CatalogDetails::
  relatedResource ()
  {
    return this->relatedResource_;
  }

  void CatalogDetails::
  relatedResource (const relatedResource_sequence& s)
  {
    this->relatedResource_ = s;
  }

  const CatalogDetails::subTitle_sequence& CatalogDetails::
  subTitle () const
  {
    return this->subTitle_;
  }

  CatalogDetails::subTitle_sequence& CatalogDetails::
  subTitle ()
  {
    return this->subTitle_;
  }

  void CatalogDetails::
  subTitle (const subTitle_sequence& s)
  {
    this->subTitle_ = s;
  }

  const CatalogDetails::summary_optional& CatalogDetails::
  summary () const
  {
    return this->summary_;
  }

  CatalogDetails::summary_optional& CatalogDetails::
  summary ()
  {
    return this->summary_;
  }

  void CatalogDetails::
  summary (const summary_type& x)
  {
    this->summary_.set (x);
  }

  void CatalogDetails::
  summary (const summary_optional& x)
  {
    this->summary_ = x;
  }

  void CatalogDetails::
  summary (::std::unique_ptr< summary_type > x)
  {
    this->summary_.set (std::move (x));
  }

  const CatalogDetails::title_optional& CatalogDetails::
  title () const
  {
    return this->title_;
  }

  CatalogDetails::title_optional& CatalogDetails::
  title ()
  {
    return this->title_;
  }

  void CatalogDetails::
  title (const title_type& x)
  {
    this->title_.set (x);
  }

  void CatalogDetails::
  title (const title_optional& x)
  {
    this->title_ = x;
  }

  void CatalogDetails::
  title (::std::unique_ptr< title_type > x)
  {
    this->title_.set (std::move (x));
  }

  const CatalogDetails::typeOfResource_sequence& CatalogDetails::
  typeOfResource () const
  {
    return this->typeOfResource_;
  }

  CatalogDetails::typeOfResource_sequence& CatalogDetails::
  typeOfResource ()
  {
    return this->typeOfResource_;
  }

  void CatalogDetails::
  typeOfResource (const typeOfResource_sequence& s)
  {
    this->typeOfResource_ = s;
  }


  // CombinedDate
  //

  const CombinedDate::isoDate_optional& CombinedDate::
  isoDate () const
  {
    return this->isoDate_;
  }

  CombinedDate::isoDate_optional& CombinedDate::
  isoDate ()
  {
    return this->isoDate_;
  }

  void CombinedDate::
  isoDate (const isoDate_type& x)
  {
    this->isoDate_.set (x);
  }

  void CombinedDate::
  isoDate (const isoDate_optional& x)
  {
    this->isoDate_ = x;
  }

  void CombinedDate::
  isoDate (::std::unique_ptr< isoDate_type > x)
  {
    this->isoDate_.set (std::move (x));
  }

  const CombinedDate::nonIsoDate_sequence& CombinedDate::
  nonIsoDate () const
  {
    return this->nonIsoDate_;
  }

  CombinedDate::nonIsoDate_sequence& CombinedDate::
  nonIsoDate ()
  {
    return this->nonIsoDate_;
  }

  void CombinedDate::
  nonIsoDate (const nonIsoDate_sequence& s)
  {
    this->nonIsoDate_ = s;
  }

  const CombinedDate::semantics_optional& CombinedDate::
  semantics () const
  {
    return this->semantics_;
  }

  CombinedDate::semantics_optional& CombinedDate::
  semantics ()
  {
    return this->semantics_;
  }

  void CombinedDate::
  semantics (const semantics_type& x)
  {
    this->semantics_.set (x);
  }

  void CombinedDate::
  semantics (const semantics_optional& x)
  {
    this->semantics_ = x;
  }

  void CombinedDate::
  semantics (::std::unique_ptr< semantics_type > x)
  {
    this->semantics_.set (std::move (x));
  }


  // Command
  //

  const Command::commandContent_optional& Command::
  commandContent () const
  {
    return this->commandContent_;
  }

  Command::commandContent_optional& Command::
  commandContent ()
  {
    return this->commandContent_;
  }

  void Command::
  commandContent (const commandContent_type& x)
  {
    this->commandContent_.set (x);
  }

  void Command::
  commandContent (const commandContent_optional& x)
  {
    this->commandContent_ = x;
  }

  void Command::
  commandContent (::std::unique_ptr< commandContent_type > x)
  {
    this->commandContent_.set (std::move (x));
  }

  const Command::programLanguage_optional& Command::
  programLanguage () const
  {
    return this->programLanguage_;
  }

  Command::programLanguage_optional& Command::
  programLanguage ()
  {
    return this->programLanguage_;
  }

  void Command::
  programLanguage (const programLanguage_type& x)
  {
    this->programLanguage_.set (x);
  }

  void Command::
  programLanguage (const programLanguage_optional& x)
  {
    this->programLanguage_ = x;
  }

  void Command::
  programLanguage (::std::unique_ptr< programLanguage_type > x)
  {
    this->programLanguage_.set (std::move (x));
  }


  // CommandCode
  //

  const CommandCode::command_sequence& CommandCode::
  command () const
  {
    return this->command_;
  }

  CommandCode::command_sequence& CommandCode::
  command ()
  {
    return this->command_;
  }

  void CommandCode::
  command (const command_sequence& s)
  {
    this->command_ = s;
  }

  const CommandCode::commandFile_sequence& CommandCode::
  commandFile () const
  {
    return this->commandFile_;
  }

  CommandCode::commandFile_sequence& CommandCode::
  commandFile ()
  {
    return this->commandFile_;
  }

  void CommandCode::
  commandFile (const commandFile_sequence& s)
  {
    this->commandFile_ = s;
  }

  const CommandCode::description_optional& CommandCode::
  description () const
  {
    return this->description_;
  }

  CommandCode::description_optional& CommandCode::
  description ()
  {
    return this->description_;
  }

  void CommandCode::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void CommandCode::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void CommandCode::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }


  // CommandFile
  //

  const CommandFile::location_optional& CommandFile::
  location () const
  {
    return this->location_;
  }

  CommandFile::location_optional& CommandFile::
  location ()
  {
    return this->location_;
  }

  void CommandFile::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  void CommandFile::
  location (const location_optional& x)
  {
    this->location_ = x;
  }

  void CommandFile::
  location (::std::unique_ptr< location_type > x)
  {
    this->location_.set (std::move (x));
  }

  const CommandFile::uri_optional& CommandFile::
  uri () const
  {
    return this->uri_;
  }

  CommandFile::uri_optional& CommandFile::
  uri ()
  {
    return this->uri_;
  }

  void CommandFile::
  uri (const uri_type& x)
  {
    this->uri_.set (x);
  }

  void CommandFile::
  uri (const uri_optional& x)
  {
    this->uri_ = x;
  }

  void CommandFile::
  uri (::std::unique_ptr< uri_type > x)
  {
    this->uri_.set (std::move (x));
  }


  // ContactInformation
  //

  const ContactInformation::address_sequence& ContactInformation::
  address () const
  {
    return this->address_;
  }

  ContactInformation::address_sequence& ContactInformation::
  address ()
  {
    return this->address_;
  }

  void ContactInformation::
  address (const address_sequence& s)
  {
    this->address_ = s;
  }

  const ContactInformation::email_sequence& ContactInformation::
  email () const
  {
    return this->email_;
  }

  ContactInformation::email_sequence& ContactInformation::
  email ()
  {
    return this->email_;
  }

  void ContactInformation::
  email (const email_sequence& s)
  {
    this->email_ = s;
  }

  const ContactInformation::emessaging_sequence& ContactInformation::
  emessaging () const
  {
    return this->emessaging_;
  }

  ContactInformation::emessaging_sequence& ContactInformation::
  emessaging ()
  {
    return this->emessaging_;
  }

  void ContactInformation::
  emessaging (const emessaging_sequence& s)
  {
    this->emessaging_ = s;
  }

  const ContactInformation::telephone_sequence& ContactInformation::
  telephone () const
  {
    return this->telephone_;
  }

  ContactInformation::telephone_sequence& ContactInformation::
  telephone ()
  {
    return this->telephone_;
  }

  void ContactInformation::
  telephone (const telephone_sequence& s)
  {
    this->telephone_ = s;
  }

  const ContactInformation::website_sequence& ContactInformation::
  website () const
  {
    return this->website_;
  }

  ContactInformation::website_sequence& ContactInformation::
  website ()
  {
    return this->website_;
  }

  void ContactInformation::
  website (const website_sequence& s)
  {
    this->website_ = s;
  }


  // ControlledVocabularyEntry
  //

  const ControlledVocabularyEntry::entryReference_sequence& ControlledVocabularyEntry::
  entryReference () const
  {
    return this->entryReference_;
  }

  ControlledVocabularyEntry::entryReference_sequence& ControlledVocabularyEntry::
  entryReference ()
  {
    return this->entryReference_;
  }

  void ControlledVocabularyEntry::
  entryReference (const entryReference_sequence& s)
  {
    this->entryReference_ = s;
  }

  const ControlledVocabularyEntry::entryValue_sequence& ControlledVocabularyEntry::
  entryValue () const
  {
    return this->entryValue_;
  }

  ControlledVocabularyEntry::entryValue_sequence& ControlledVocabularyEntry::
  entryValue ()
  {
    return this->entryValue_;
  }

  void ControlledVocabularyEntry::
  entryValue (const entryValue_sequence& s)
  {
    this->entryValue_ = s;
  }

  const ControlledVocabularyEntry::name_optional& ControlledVocabularyEntry::
  name () const
  {
    return this->name_;
  }

  ControlledVocabularyEntry::name_optional& ControlledVocabularyEntry::
  name ()
  {
    return this->name_;
  }

  void ControlledVocabularyEntry::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void ControlledVocabularyEntry::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void ControlledVocabularyEntry::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const ControlledVocabularyEntry::valueForOther_optional& ControlledVocabularyEntry::
  valueForOther () const
  {
    return this->valueForOther_;
  }

  ControlledVocabularyEntry::valueForOther_optional& ControlledVocabularyEntry::
  valueForOther ()
  {
    return this->valueForOther_;
  }

  void ControlledVocabularyEntry::
  valueForOther (const valueForOther_type& x)
  {
    this->valueForOther_.set (x);
  }

  void ControlledVocabularyEntry::
  valueForOther (const valueForOther_optional& x)
  {
    this->valueForOther_ = x;
  }

  void ControlledVocabularyEntry::
  valueForOther (::std::unique_ptr< valueForOther_type > x)
  {
    this->valueForOther_.set (std::move (x));
  }

  const ControlledVocabularyEntry::vocabulary_optional& ControlledVocabularyEntry::
  vocabulary () const
  {
    return this->vocabulary_;
  }

  ControlledVocabularyEntry::vocabulary_optional& ControlledVocabularyEntry::
  vocabulary ()
  {
    return this->vocabulary_;
  }

  void ControlledVocabularyEntry::
  vocabulary (const vocabulary_type& x)
  {
    this->vocabulary_.set (x);
  }

  void ControlledVocabularyEntry::
  vocabulary (const vocabulary_optional& x)
  {
    this->vocabulary_ = x;
  }

  void ControlledVocabularyEntry::
  vocabulary (::std::unique_ptr< vocabulary_type > x)
  {
    this->vocabulary_.set (std::move (x));
  }


  // CorrespondenceDefinition
  //

  const CorrespondenceDefinition::commonality_optional& CorrespondenceDefinition::
  commonality () const
  {
    return this->commonality_;
  }

  CorrespondenceDefinition::commonality_optional& CorrespondenceDefinition::
  commonality ()
  {
    return this->commonality_;
  }

  void CorrespondenceDefinition::
  commonality (const commonality_type& x)
  {
    this->commonality_.set (x);
  }

  void CorrespondenceDefinition::
  commonality (const commonality_optional& x)
  {
    this->commonality_ = x;
  }

  void CorrespondenceDefinition::
  commonality (::std::unique_ptr< commonality_type > x)
  {
    this->commonality_.set (std::move (x));
  }

  const CorrespondenceDefinition::commonalityCode_sequence& CorrespondenceDefinition::
  commonalityCode () const
  {
    return this->commonalityCode_;
  }

  CorrespondenceDefinition::commonalityCode_sequence& CorrespondenceDefinition::
  commonalityCode ()
  {
    return this->commonalityCode_;
  }

  void CorrespondenceDefinition::
  commonalityCode (const commonalityCode_sequence& s)
  {
    this->commonalityCode_ = s;
  }

  const CorrespondenceDefinition::difference_optional& CorrespondenceDefinition::
  difference () const
  {
    return this->difference_;
  }

  CorrespondenceDefinition::difference_optional& CorrespondenceDefinition::
  difference ()
  {
    return this->difference_;
  }

  void CorrespondenceDefinition::
  difference (const difference_type& x)
  {
    this->difference_.set (x);
  }

  void CorrespondenceDefinition::
  difference (const difference_optional& x)
  {
    this->difference_ = x;
  }

  void CorrespondenceDefinition::
  difference (::std::unique_ptr< difference_type > x)
  {
    this->difference_.set (std::move (x));
  }

  const CorrespondenceDefinition::matching_optional& CorrespondenceDefinition::
  matching () const
  {
    return this->matching_;
  }

  CorrespondenceDefinition::matching_optional& CorrespondenceDefinition::
  matching ()
  {
    return this->matching_;
  }

  void CorrespondenceDefinition::
  matching (const matching_type& x)
  {
    this->matching_.set (x);
  }

  void CorrespondenceDefinition::
  matching (const matching_optional& x)
  {
    this->matching_ = x;
  }

  void CorrespondenceDefinition::
  matching (::std::unique_ptr< matching_type > x)
  {
    this->matching_.set (std::move (x));
  }


  // DateRange
  //

  const DateRange::endDate_optional& DateRange::
  endDate () const
  {
    return this->endDate_;
  }

  DateRange::endDate_optional& DateRange::
  endDate ()
  {
    return this->endDate_;
  }

  void DateRange::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void DateRange::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void DateRange::
  endDate (::std::unique_ptr< endDate_type > x)
  {
    this->endDate_.set (std::move (x));
  }

  const DateRange::startDate_optional& DateRange::
  startDate () const
  {
    return this->startDate_;
  }

  DateRange::startDate_optional& DateRange::
  startDate ()
  {
    return this->startDate_;
  }

  void DateRange::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void DateRange::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void DateRange::
  startDate (::std::unique_ptr< startDate_type > x)
  {
    this->startDate_.set (std::move (x));
  }


  // ElectronicMessageSystem
  //

  const ElectronicMessageSystem::contactAddress_optional& ElectronicMessageSystem::
  contactAddress () const
  {
    return this->contactAddress_;
  }

  ElectronicMessageSystem::contactAddress_optional& ElectronicMessageSystem::
  contactAddress ()
  {
    return this->contactAddress_;
  }

  void ElectronicMessageSystem::
  contactAddress (const contactAddress_type& x)
  {
    this->contactAddress_.set (x);
  }

  void ElectronicMessageSystem::
  contactAddress (const contactAddress_optional& x)
  {
    this->contactAddress_ = x;
  }

  void ElectronicMessageSystem::
  contactAddress (::std::unique_ptr< contactAddress_type > x)
  {
    this->contactAddress_.set (std::move (x));
  }

  const ElectronicMessageSystem::effectiveDates_optional& ElectronicMessageSystem::
  effectiveDates () const
  {
    return this->effectiveDates_;
  }

  ElectronicMessageSystem::effectiveDates_optional& ElectronicMessageSystem::
  effectiveDates ()
  {
    return this->effectiveDates_;
  }

  void ElectronicMessageSystem::
  effectiveDates (const effectiveDates_type& x)
  {
    this->effectiveDates_.set (x);
  }

  void ElectronicMessageSystem::
  effectiveDates (const effectiveDates_optional& x)
  {
    this->effectiveDates_ = x;
  }

  void ElectronicMessageSystem::
  effectiveDates (::std::unique_ptr< effectiveDates_type > x)
  {
    this->effectiveDates_.set (std::move (x));
  }

  const ElectronicMessageSystem::isPreferred_optional& ElectronicMessageSystem::
  isPreferred () const
  {
    return this->isPreferred_;
  }

  ElectronicMessageSystem::isPreferred_optional& ElectronicMessageSystem::
  isPreferred ()
  {
    return this->isPreferred_;
  }

  void ElectronicMessageSystem::
  isPreferred (const isPreferred_type& x)
  {
    this->isPreferred_.set (x);
  }

  void ElectronicMessageSystem::
  isPreferred (const isPreferred_optional& x)
  {
    this->isPreferred_ = x;
  }

  const ElectronicMessageSystem::privacy_optional& ElectronicMessageSystem::
  privacy () const
  {
    return this->privacy_;
  }

  ElectronicMessageSystem::privacy_optional& ElectronicMessageSystem::
  privacy ()
  {
    return this->privacy_;
  }

  void ElectronicMessageSystem::
  privacy (const privacy_type& x)
  {
    this->privacy_.set (x);
  }

  void ElectronicMessageSystem::
  privacy (const privacy_optional& x)
  {
    this->privacy_ = x;
  }

  void ElectronicMessageSystem::
  privacy (::std::unique_ptr< privacy_type > x)
  {
    this->privacy_.set (std::move (x));
  }

  const ElectronicMessageSystem::typeOfService_optional& ElectronicMessageSystem::
  typeOfService () const
  {
    return this->typeOfService_;
  }

  ElectronicMessageSystem::typeOfService_optional& ElectronicMessageSystem::
  typeOfService ()
  {
    return this->typeOfService_;
  }

  void ElectronicMessageSystem::
  typeOfService (const typeOfService_type& x)
  {
    this->typeOfService_.set (x);
  }

  void ElectronicMessageSystem::
  typeOfService (const typeOfService_optional& x)
  {
    this->typeOfService_ = x;
  }

  void ElectronicMessageSystem::
  typeOfService (::std::unique_ptr< typeOfService_type > x)
  {
    this->typeOfService_.set (std::move (x));
  }


  // Email
  //

  const Email::effectiveDates_optional& Email::
  effectiveDates () const
  {
    return this->effectiveDates_;
  }

  Email::effectiveDates_optional& Email::
  effectiveDates ()
  {
    return this->effectiveDates_;
  }

  void Email::
  effectiveDates (const effectiveDates_type& x)
  {
    this->effectiveDates_.set (x);
  }

  void Email::
  effectiveDates (const effectiveDates_optional& x)
  {
    this->effectiveDates_ = x;
  }

  void Email::
  effectiveDates (::std::unique_ptr< effectiveDates_type > x)
  {
    this->effectiveDates_.set (std::move (x));
  }

  const Email::internetEmail_optional& Email::
  internetEmail () const
  {
    return this->internetEmail_;
  }

  Email::internetEmail_optional& Email::
  internetEmail ()
  {
    return this->internetEmail_;
  }

  void Email::
  internetEmail (const internetEmail_type& x)
  {
    this->internetEmail_.set (x);
  }

  void Email::
  internetEmail (const internetEmail_optional& x)
  {
    this->internetEmail_ = x;
  }

  void Email::
  internetEmail (::std::unique_ptr< internetEmail_type > x)
  {
    this->internetEmail_.set (std::move (x));
  }

  const Email::isPreferred_optional& Email::
  isPreferred () const
  {
    return this->isPreferred_;
  }

  Email::isPreferred_optional& Email::
  isPreferred ()
  {
    return this->isPreferred_;
  }

  void Email::
  isPreferred (const isPreferred_type& x)
  {
    this->isPreferred_.set (x);
  }

  void Email::
  isPreferred (const isPreferred_optional& x)
  {
    this->isPreferred_ = x;
  }

  const Email::privacy_optional& Email::
  privacy () const
  {
    return this->privacy_;
  }

  Email::privacy_optional& Email::
  privacy ()
  {
    return this->privacy_;
  }

  void Email::
  privacy (const privacy_type& x)
  {
    this->privacy_.set (x);
  }

  void Email::
  privacy (const privacy_optional& x)
  {
    this->privacy_ = x;
  }

  void Email::
  privacy (::std::unique_ptr< privacy_type > x)
  {
    this->privacy_.set (std::move (x));
  }

  const Email::typeOfEmail_optional& Email::
  typeOfEmail () const
  {
    return this->typeOfEmail_;
  }

  Email::typeOfEmail_optional& Email::
  typeOfEmail ()
  {
    return this->typeOfEmail_;
  }

  void Email::
  typeOfEmail (const typeOfEmail_type& x)
  {
    this->typeOfEmail_.set (x);
  }

  void Email::
  typeOfEmail (const typeOfEmail_optional& x)
  {
    this->typeOfEmail_ = x;
  }

  void Email::
  typeOfEmail (::std::unique_ptr< typeOfEmail_type > x)
  {
    this->typeOfEmail_.set (std::move (x));
  }


  // EmbargoInformation
  //

  const EmbargoInformation::description_optional& EmbargoInformation::
  description () const
  {
    return this->description_;
  }

  EmbargoInformation::description_optional& EmbargoInformation::
  description ()
  {
    return this->description_;
  }

  void EmbargoInformation::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void EmbargoInformation::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void EmbargoInformation::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }

  const EmbargoInformation::period_sequence& EmbargoInformation::
  period () const
  {
    return this->period_;
  }

  EmbargoInformation::period_sequence& EmbargoInformation::
  period ()
  {
    return this->period_;
  }

  void EmbargoInformation::
  period (const period_sequence& s)
  {
    this->period_ = s;
  }


  // FundingInformation
  //

  const FundingInformation::fundingAgent_sequence& FundingInformation::
  fundingAgent () const
  {
    return this->fundingAgent_;
  }

  FundingInformation::fundingAgent_sequence& FundingInformation::
  fundingAgent ()
  {
    return this->fundingAgent_;
  }

  void FundingInformation::
  fundingAgent (const fundingAgent_sequence& s)
  {
    this->fundingAgent_ = s;
  }

  const FundingInformation::grantNumber_optional& FundingInformation::
  grantNumber () const
  {
    return this->grantNumber_;
  }

  FundingInformation::grantNumber_optional& FundingInformation::
  grantNumber ()
  {
    return this->grantNumber_;
  }

  void FundingInformation::
  grantNumber (const grantNumber_type& x)
  {
    this->grantNumber_.set (x);
  }

  void FundingInformation::
  grantNumber (const grantNumber_optional& x)
  {
    this->grantNumber_ = x;
  }

  void FundingInformation::
  grantNumber (::std::unique_ptr< grantNumber_type > x)
  {
    this->grantNumber_.set (std::move (x));
  }


  // SpecializationRole
  //


  // GeoRole
  //

  const GeoRole::geography_optional& GeoRole::
  geography () const
  {
    return this->geography_;
  }

  GeoRole::geography_optional& GeoRole::
  geography ()
  {
    return this->geography_;
  }

  void GeoRole::
  geography (const geography_type& x)
  {
    this->geography_.set (x);
  }

  void GeoRole::
  geography (const geography_optional& x)
  {
    this->geography_ = x;
  }

  void GeoRole::
  geography (::std::unique_ptr< geography_type > x)
  {
    this->geography_.set (std::move (x));
  }


  // Identifier
  //

  const Identifier::ddiIdentifier_optional& Identifier::
  ddiIdentifier () const
  {
    return this->ddiIdentifier_;
  }

  Identifier::ddiIdentifier_optional& Identifier::
  ddiIdentifier ()
  {
    return this->ddiIdentifier_;
  }

  void Identifier::
  ddiIdentifier (const ddiIdentifier_type& x)
  {
    this->ddiIdentifier_.set (x);
  }

  void Identifier::
  ddiIdentifier (const ddiIdentifier_optional& x)
  {
    this->ddiIdentifier_ = x;
  }

  void Identifier::
  ddiIdentifier (::std::unique_ptr< ddiIdentifier_type > x)
  {
    this->ddiIdentifier_.set (std::move (x));
  }

  const Identifier::isDdiIdentifierPersistent_optional& Identifier::
  isDdiIdentifierPersistent () const
  {
    return this->isDdiIdentifierPersistent_;
  }

  Identifier::isDdiIdentifierPersistent_optional& Identifier::
  isDdiIdentifierPersistent ()
  {
    return this->isDdiIdentifierPersistent_;
  }

  void Identifier::
  isDdiIdentifierPersistent (const isDdiIdentifierPersistent_type& x)
  {
    this->isDdiIdentifierPersistent_.set (x);
  }

  void Identifier::
  isDdiIdentifierPersistent (const isDdiIdentifierPersistent_optional& x)
  {
    this->isDdiIdentifierPersistent_ = x;
  }

  const Identifier::isDdiIdentifierUniversallyUnique_optional& Identifier::
  isDdiIdentifierUniversallyUnique () const
  {
    return this->isDdiIdentifierUniversallyUnique_;
  }

  Identifier::isDdiIdentifierUniversallyUnique_optional& Identifier::
  isDdiIdentifierUniversallyUnique ()
  {
    return this->isDdiIdentifierUniversallyUnique_;
  }

  void Identifier::
  isDdiIdentifierUniversallyUnique (const isDdiIdentifierUniversallyUnique_type& x)
  {
    this->isDdiIdentifierUniversallyUnique_.set (x);
  }

  void Identifier::
  isDdiIdentifierUniversallyUnique (const isDdiIdentifierUniversallyUnique_optional& x)
  {
    this->isDdiIdentifierUniversallyUnique_ = x;
  }

  const Identifier::nonDdiIdentifier_sequence& Identifier::
  nonDdiIdentifier () const
  {
    return this->nonDdiIdentifier_;
  }

  Identifier::nonDdiIdentifier_sequence& Identifier::
  nonDdiIdentifier ()
  {
    return this->nonDdiIdentifier_;
  }

  void Identifier::
  nonDdiIdentifier (const nonDdiIdentifier_sequence& s)
  {
    this->nonDdiIdentifier_ = s;
  }

  const Identifier::uri_optional& Identifier::
  uri () const
  {
    return this->uri_;
  }

  Identifier::uri_optional& Identifier::
  uri ()
  {
    return this->uri_;
  }

  void Identifier::
  uri (const uri_type& x)
  {
    this->uri_.set (x);
  }

  void Identifier::
  uri (const uri_optional& x)
  {
    this->uri_ = x;
  }

  void Identifier::
  uri (::std::unique_ptr< uri_type > x)
  {
    this->uri_.set (std::move (x));
  }

  const Identifier::versionDate_optional& Identifier::
  versionDate () const
  {
    return this->versionDate_;
  }

  Identifier::versionDate_optional& Identifier::
  versionDate ()
  {
    return this->versionDate_;
  }

  void Identifier::
  versionDate (const versionDate_type& x)
  {
    this->versionDate_.set (x);
  }

  void Identifier::
  versionDate (const versionDate_optional& x)
  {
    this->versionDate_ = x;
  }

  void Identifier::
  versionDate (::std::unique_ptr< versionDate_type > x)
  {
    this->versionDate_.set (std::move (x));
  }

  const Identifier::versionRationale_optional& Identifier::
  versionRationale () const
  {
    return this->versionRationale_;
  }

  Identifier::versionRationale_optional& Identifier::
  versionRationale ()
  {
    return this->versionRationale_;
  }

  void Identifier::
  versionRationale (const versionRationale_type& x)
  {
    this->versionRationale_.set (x);
  }

  void Identifier::
  versionRationale (const versionRationale_optional& x)
  {
    this->versionRationale_ = x;
  }

  void Identifier::
  versionRationale (::std::unique_ptr< versionRationale_type > x)
  {
    this->versionRationale_.set (std::move (x));
  }

  const Identifier::versionResponsibility_optional& Identifier::
  versionResponsibility () const
  {
    return this->versionResponsibility_;
  }

  Identifier::versionResponsibility_optional& Identifier::
  versionResponsibility ()
  {
    return this->versionResponsibility_;
  }

  void Identifier::
  versionResponsibility (const versionResponsibility_type& x)
  {
    this->versionResponsibility_.set (x);
  }

  void Identifier::
  versionResponsibility (const versionResponsibility_optional& x)
  {
    this->versionResponsibility_ = x;
  }

  void Identifier::
  versionResponsibility (::std::unique_ptr< versionResponsibility_type > x)
  {
    this->versionResponsibility_.set (std::move (x));
  }


  // IndividualName
  //

  const IndividualName::abbreviation_optional& IndividualName::
  abbreviation () const
  {
    return this->abbreviation_;
  }

  IndividualName::abbreviation_optional& IndividualName::
  abbreviation ()
  {
    return this->abbreviation_;
  }

  void IndividualName::
  abbreviation (const abbreviation_type& x)
  {
    this->abbreviation_.set (x);
  }

  void IndividualName::
  abbreviation (const abbreviation_optional& x)
  {
    this->abbreviation_ = x;
  }

  void IndividualName::
  abbreviation (::std::unique_ptr< abbreviation_type > x)
  {
    this->abbreviation_.set (std::move (x));
  }

  const IndividualName::context_optional& IndividualName::
  context () const
  {
    return this->context_;
  }

  IndividualName::context_optional& IndividualName::
  context ()
  {
    return this->context_;
  }

  void IndividualName::
  context (const context_type& x)
  {
    this->context_.set (x);
  }

  void IndividualName::
  context (const context_optional& x)
  {
    this->context_ = x;
  }

  void IndividualName::
  context (::std::unique_ptr< context_type > x)
  {
    this->context_.set (std::move (x));
  }

  const IndividualName::effectiveDates_optional& IndividualName::
  effectiveDates () const
  {
    return this->effectiveDates_;
  }

  IndividualName::effectiveDates_optional& IndividualName::
  effectiveDates ()
  {
    return this->effectiveDates_;
  }

  void IndividualName::
  effectiveDates (const effectiveDates_type& x)
  {
    this->effectiveDates_.set (x);
  }

  void IndividualName::
  effectiveDates (const effectiveDates_optional& x)
  {
    this->effectiveDates_ = x;
  }

  void IndividualName::
  effectiveDates (::std::unique_ptr< effectiveDates_type > x)
  {
    this->effectiveDates_.set (std::move (x));
  }

  const IndividualName::firstGiven_optional& IndividualName::
  firstGiven () const
  {
    return this->firstGiven_;
  }

  IndividualName::firstGiven_optional& IndividualName::
  firstGiven ()
  {
    return this->firstGiven_;
  }

  void IndividualName::
  firstGiven (const firstGiven_type& x)
  {
    this->firstGiven_.set (x);
  }

  void IndividualName::
  firstGiven (const firstGiven_optional& x)
  {
    this->firstGiven_ = x;
  }

  void IndividualName::
  firstGiven (::std::unique_ptr< firstGiven_type > x)
  {
    this->firstGiven_.set (std::move (x));
  }

  const IndividualName::fullName_optional& IndividualName::
  fullName () const
  {
    return this->fullName_;
  }

  IndividualName::fullName_optional& IndividualName::
  fullName ()
  {
    return this->fullName_;
  }

  void IndividualName::
  fullName (const fullName_type& x)
  {
    this->fullName_.set (x);
  }

  void IndividualName::
  fullName (const fullName_optional& x)
  {
    this->fullName_ = x;
  }

  void IndividualName::
  fullName (::std::unique_ptr< fullName_type > x)
  {
    this->fullName_.set (std::move (x));
  }

  const IndividualName::isFormal_optional& IndividualName::
  isFormal () const
  {
    return this->isFormal_;
  }

  IndividualName::isFormal_optional& IndividualName::
  isFormal ()
  {
    return this->isFormal_;
  }

  void IndividualName::
  isFormal (const isFormal_type& x)
  {
    this->isFormal_.set (x);
  }

  void IndividualName::
  isFormal (const isFormal_optional& x)
  {
    this->isFormal_ = x;
  }

  const IndividualName::isPreferred_optional& IndividualName::
  isPreferred () const
  {
    return this->isPreferred_;
  }

  IndividualName::isPreferred_optional& IndividualName::
  isPreferred ()
  {
    return this->isPreferred_;
  }

  void IndividualName::
  isPreferred (const isPreferred_type& x)
  {
    this->isPreferred_.set (x);
  }

  void IndividualName::
  isPreferred (const isPreferred_optional& x)
  {
    this->isPreferred_ = x;
  }

  const IndividualName::lastFamily_optional& IndividualName::
  lastFamily () const
  {
    return this->lastFamily_;
  }

  IndividualName::lastFamily_optional& IndividualName::
  lastFamily ()
  {
    return this->lastFamily_;
  }

  void IndividualName::
  lastFamily (const lastFamily_type& x)
  {
    this->lastFamily_.set (x);
  }

  void IndividualName::
  lastFamily (const lastFamily_optional& x)
  {
    this->lastFamily_ = x;
  }

  void IndividualName::
  lastFamily (::std::unique_ptr< lastFamily_type > x)
  {
    this->lastFamily_.set (std::move (x));
  }

  const IndividualName::middle_sequence& IndividualName::
  middle () const
  {
    return this->middle_;
  }

  IndividualName::middle_sequence& IndividualName::
  middle ()
  {
    return this->middle_;
  }

  void IndividualName::
  middle (const middle_sequence& s)
  {
    this->middle_ = s;
  }

  const IndividualName::prefix_optional& IndividualName::
  prefix () const
  {
    return this->prefix_;
  }

  IndividualName::prefix_optional& IndividualName::
  prefix ()
  {
    return this->prefix_;
  }

  void IndividualName::
  prefix (const prefix_type& x)
  {
    this->prefix_.set (x);
  }

  void IndividualName::
  prefix (const prefix_optional& x)
  {
    this->prefix_ = x;
  }

  void IndividualName::
  prefix (::std::unique_ptr< prefix_type > x)
  {
    this->prefix_.set (std::move (x));
  }

  const IndividualName::sex_optional& IndividualName::
  sex () const
  {
    return this->sex_;
  }

  IndividualName::sex_optional& IndividualName::
  sex ()
  {
    return this->sex_;
  }

  void IndividualName::
  sex (const sex_type& x)
  {
    this->sex_.set (x);
  }

  void IndividualName::
  sex (const sex_optional& x)
  {
    this->sex_ = x;
  }

  void IndividualName::
  sex (::std::unique_ptr< sex_type > x)
  {
    this->sex_.set (std::move (x));
  }

  const IndividualName::suffix_optional& IndividualName::
  suffix () const
  {
    return this->suffix_;
  }

  IndividualName::suffix_optional& IndividualName::
  suffix ()
  {
    return this->suffix_;
  }

  void IndividualName::
  suffix (const suffix_type& x)
  {
    this->suffix_.set (x);
  }

  void IndividualName::
  suffix (const suffix_optional& x)
  {
    this->suffix_ = x;
  }

  void IndividualName::
  suffix (::std::unique_ptr< suffix_type > x)
  {
    this->suffix_.set (std::move (x));
  }

  const IndividualName::typeOfIndividualName_optional& IndividualName::
  typeOfIndividualName () const
  {
    return this->typeOfIndividualName_;
  }

  IndividualName::typeOfIndividualName_optional& IndividualName::
  typeOfIndividualName ()
  {
    return this->typeOfIndividualName_;
  }

  void IndividualName::
  typeOfIndividualName (const typeOfIndividualName_type& x)
  {
    this->typeOfIndividualName_.set (x);
  }

  void IndividualName::
  typeOfIndividualName (const typeOfIndividualName_optional& x)
  {
    this->typeOfIndividualName_ = x;
  }

  void IndividualName::
  typeOfIndividualName (::std::unique_ptr< typeOfIndividualName_type > x)
  {
    this->typeOfIndividualName_.set (std::move (x));
  }


  // InternationalIdentifier
  //

  const InternationalIdentifier::identifierContent_optional& InternationalIdentifier::
  identifierContent () const
  {
    return this->identifierContent_;
  }

  InternationalIdentifier::identifierContent_optional& InternationalIdentifier::
  identifierContent ()
  {
    return this->identifierContent_;
  }

  void InternationalIdentifier::
  identifierContent (const identifierContent_type& x)
  {
    this->identifierContent_.set (x);
  }

  void InternationalIdentifier::
  identifierContent (const identifierContent_optional& x)
  {
    this->identifierContent_ = x;
  }

  void InternationalIdentifier::
  identifierContent (::std::unique_ptr< identifierContent_type > x)
  {
    this->identifierContent_.set (std::move (x));
  }

  const InternationalIdentifier::isURI_optional& InternationalIdentifier::
  isURI () const
  {
    return this->isURI_;
  }

  InternationalIdentifier::isURI_optional& InternationalIdentifier::
  isURI ()
  {
    return this->isURI_;
  }

  void InternationalIdentifier::
  isURI (const isURI_type& x)
  {
    this->isURI_.set (x);
  }

  void InternationalIdentifier::
  isURI (const isURI_optional& x)
  {
    this->isURI_ = x;
  }

  const InternationalIdentifier::managingAgency_optional& InternationalIdentifier::
  managingAgency () const
  {
    return this->managingAgency_;
  }

  InternationalIdentifier::managingAgency_optional& InternationalIdentifier::
  managingAgency ()
  {
    return this->managingAgency_;
  }

  void InternationalIdentifier::
  managingAgency (const managingAgency_type& x)
  {
    this->managingAgency_.set (x);
  }

  void InternationalIdentifier::
  managingAgency (const managingAgency_optional& x)
  {
    this->managingAgency_ = x;
  }

  void InternationalIdentifier::
  managingAgency (::std::unique_ptr< managingAgency_type > x)
  {
    this->managingAgency_.set (std::move (x));
  }


  // InternationalRegistrationDataIdentifier
  //

  const InternationalRegistrationDataIdentifier::dataIdentifier_type& InternationalRegistrationDataIdentifier::
  dataIdentifier () const
  {
    return this->dataIdentifier_.get ();
  }

  InternationalRegistrationDataIdentifier::dataIdentifier_type& InternationalRegistrationDataIdentifier::
  dataIdentifier ()
  {
    return this->dataIdentifier_.get ();
  }

  void InternationalRegistrationDataIdentifier::
  dataIdentifier (const dataIdentifier_type& x)
  {
    this->dataIdentifier_.set (x);
  }

  void InternationalRegistrationDataIdentifier::
  dataIdentifier (::std::unique_ptr< dataIdentifier_type > x)
  {
    this->dataIdentifier_.set (std::move (x));
  }

  const InternationalRegistrationDataIdentifier::registrationAuthorityIdentifier_type& InternationalRegistrationDataIdentifier::
  registrationAuthorityIdentifier () const
  {
    return this->registrationAuthorityIdentifier_.get ();
  }

  InternationalRegistrationDataIdentifier::registrationAuthorityIdentifier_type& InternationalRegistrationDataIdentifier::
  registrationAuthorityIdentifier ()
  {
    return this->registrationAuthorityIdentifier_.get ();
  }

  void InternationalRegistrationDataIdentifier::
  registrationAuthorityIdentifier (const registrationAuthorityIdentifier_type& x)
  {
    this->registrationAuthorityIdentifier_.set (x);
  }

  void InternationalRegistrationDataIdentifier::
  registrationAuthorityIdentifier (::std::unique_ptr< registrationAuthorityIdentifier_type > x)
  {
    this->registrationAuthorityIdentifier_.set (std::move (x));
  }

  const InternationalRegistrationDataIdentifier::versionIdentifier_type& InternationalRegistrationDataIdentifier::
  versionIdentifier () const
  {
    return this->versionIdentifier_.get ();
  }

  InternationalRegistrationDataIdentifier::versionIdentifier_type& InternationalRegistrationDataIdentifier::
  versionIdentifier ()
  {
    return this->versionIdentifier_.get ();
  }

  void InternationalRegistrationDataIdentifier::
  versionIdentifier (const versionIdentifier_type& x)
  {
    this->versionIdentifier_.set (x);
  }

  void InternationalRegistrationDataIdentifier::
  versionIdentifier (::std::unique_ptr< versionIdentifier_type > x)
  {
    this->versionIdentifier_.set (std::move (x));
  }


  // LabelForDisplay
  //

  const LabelForDisplay::locationVariant_optional& LabelForDisplay::
  locationVariant () const
  {
    return this->locationVariant_;
  }

  LabelForDisplay::locationVariant_optional& LabelForDisplay::
  locationVariant ()
  {
    return this->locationVariant_;
  }

  void LabelForDisplay::
  locationVariant (const locationVariant_type& x)
  {
    this->locationVariant_.set (x);
  }

  void LabelForDisplay::
  locationVariant (const locationVariant_optional& x)
  {
    this->locationVariant_ = x;
  }

  void LabelForDisplay::
  locationVariant (::std::unique_ptr< locationVariant_type > x)
  {
    this->locationVariant_.set (std::move (x));
  }

  const LabelForDisplay::maxLength_optional& LabelForDisplay::
  maxLength () const
  {
    return this->maxLength_;
  }

  LabelForDisplay::maxLength_optional& LabelForDisplay::
  maxLength ()
  {
    return this->maxLength_;
  }

  void LabelForDisplay::
  maxLength (const maxLength_type& x)
  {
    this->maxLength_.set (x);
  }

  void LabelForDisplay::
  maxLength (const maxLength_optional& x)
  {
    this->maxLength_ = x;
  }

  const LabelForDisplay::validDates_optional& LabelForDisplay::
  validDates () const
  {
    return this->validDates_;
  }

  LabelForDisplay::validDates_optional& LabelForDisplay::
  validDates ()
  {
    return this->validDates_;
  }

  void LabelForDisplay::
  validDates (const validDates_type& x)
  {
    this->validDates_.set (x);
  }

  void LabelForDisplay::
  validDates (const validDates_optional& x)
  {
    this->validDates_ = x;
  }

  void LabelForDisplay::
  validDates (::std::unique_ptr< validDates_type > x)
  {
    this->validDates_.set (std::move (x));
  }


  // LanguageString
  //

  const LanguageString::content_type& LanguageString::
  content () const
  {
    return this->content_.get ();
  }

  LanguageString::content_type& LanguageString::
  content ()
  {
    return this->content_.get ();
  }

  void LanguageString::
  content (const content_type& x)
  {
    this->content_.set (x);
  }

  void LanguageString::
  content (::std::unique_ptr< content_type > x)
  {
    this->content_.set (std::move (x));
  }

  const LanguageString::isTranslatable_optional& LanguageString::
  isTranslatable () const
  {
    return this->isTranslatable_;
  }

  LanguageString::isTranslatable_optional& LanguageString::
  isTranslatable ()
  {
    return this->isTranslatable_;
  }

  void LanguageString::
  isTranslatable (const isTranslatable_type& x)
  {
    this->isTranslatable_.set (x);
  }

  void LanguageString::
  isTranslatable (const isTranslatable_optional& x)
  {
    this->isTranslatable_ = x;
  }

  const LanguageString::isTranslated_optional& LanguageString::
  isTranslated () const
  {
    return this->isTranslated_;
  }

  LanguageString::isTranslated_optional& LanguageString::
  isTranslated ()
  {
    return this->isTranslated_;
  }

  void LanguageString::
  isTranslated (const isTranslated_type& x)
  {
    this->isTranslated_.set (x);
  }

  void LanguageString::
  isTranslated (const isTranslated_optional& x)
  {
    this->isTranslated_ = x;
  }

  const LanguageString::scope_optional& LanguageString::
  scope () const
  {
    return this->scope_;
  }

  LanguageString::scope_optional& LanguageString::
  scope ()
  {
    return this->scope_;
  }

  void LanguageString::
  scope (const scope_type& x)
  {
    this->scope_.set (x);
  }

  void LanguageString::
  scope (const scope_optional& x)
  {
    this->scope_ = x;
  }

  void LanguageString::
  scope (::std::unique_ptr< scope_type > x)
  {
    this->scope_.set (std::move (x));
  }

  const LanguageString::structureUsed_optional& LanguageString::
  structureUsed () const
  {
    return this->structureUsed_;
  }

  LanguageString::structureUsed_optional& LanguageString::
  structureUsed ()
  {
    return this->structureUsed_;
  }

  void LanguageString::
  structureUsed (const structureUsed_type& x)
  {
    this->structureUsed_.set (x);
  }

  void LanguageString::
  structureUsed (const structureUsed_optional& x)
  {
    this->structureUsed_ = x;
  }

  void LanguageString::
  structureUsed (::std::unique_ptr< structureUsed_type > x)
  {
    this->structureUsed_.set (std::move (x));
  }

  const LanguageString::translationDate_optional& LanguageString::
  translationDate () const
  {
    return this->translationDate_;
  }

  LanguageString::translationDate_optional& LanguageString::
  translationDate ()
  {
    return this->translationDate_;
  }

  void LanguageString::
  translationDate (const translationDate_type& x)
  {
    this->translationDate_.set (x);
  }

  void LanguageString::
  translationDate (const translationDate_optional& x)
  {
    this->translationDate_ = x;
  }

  void LanguageString::
  translationDate (::std::unique_ptr< translationDate_type > x)
  {
    this->translationDate_.set (std::move (x));
  }

  const LanguageString::translationSourceLanguage_sequence& LanguageString::
  translationSourceLanguage () const
  {
    return this->translationSourceLanguage_;
  }

  LanguageString::translationSourceLanguage_sequence& LanguageString::
  translationSourceLanguage ()
  {
    return this->translationSourceLanguage_;
  }

  void LanguageString::
  translationSourceLanguage (const translationSourceLanguage_sequence& s)
  {
    this->translationSourceLanguage_ = s;
  }


  // LicenseInformation
  //

  const LicenseInformation::contact_sequence& LicenseInformation::
  contact () const
  {
    return this->contact_;
  }

  LicenseInformation::contact_sequence& LicenseInformation::
  contact ()
  {
    return this->contact_;
  }

  void LicenseInformation::
  contact (const contact_sequence& s)
  {
    this->contact_ = s;
  }

  const LicenseInformation::description_sequence& LicenseInformation::
  description () const
  {
    return this->description_;
  }

  LicenseInformation::description_sequence& LicenseInformation::
  description ()
  {
    return this->description_;
  }

  void LicenseInformation::
  description (const description_sequence& s)
  {
    this->description_ = s;
  }

  const LicenseInformation::licenseAgent_sequence& LicenseInformation::
  licenseAgent () const
  {
    return this->licenseAgent_;
  }

  LicenseInformation::licenseAgent_sequence& LicenseInformation::
  licenseAgent ()
  {
    return this->licenseAgent_;
  }

  void LicenseInformation::
  licenseAgent (const licenseAgent_sequence& s)
  {
    this->licenseAgent_ = s;
  }

  const LicenseInformation::licenseReference_sequence& LicenseInformation::
  licenseReference () const
  {
    return this->licenseReference_;
  }

  LicenseInformation::licenseReference_sequence& LicenseInformation::
  licenseReference ()
  {
    return this->licenseReference_;
  }

  void LicenseInformation::
  licenseReference (const licenseReference_sequence& s)
  {
    this->licenseReference_ = s;
  }


  // ModelIdentification
  //

  const ModelIdentification::acronym_type& ModelIdentification::
  acronym () const
  {
    return this->acronym_.get ();
  }

  ModelIdentification::acronym_type& ModelIdentification::
  acronym ()
  {
    return this->acronym_.get ();
  }

  void ModelIdentification::
  acronym (const acronym_type& x)
  {
    this->acronym_.set (x);
  }

  void ModelIdentification::
  acronym (::std::unique_ptr< acronym_type > x)
  {
    this->acronym_.set (std::move (x));
  }

  const ModelIdentification::language_type& ModelIdentification::
  language () const
  {
    return this->language_.get ();
  }

  ModelIdentification::language_type& ModelIdentification::
  language ()
  {
    return this->language_.get ();
  }

  void ModelIdentification::
  language (const language_type& x)
  {
    this->language_.set (x);
  }

  void ModelIdentification::
  language (::std::unique_ptr< language_type > x)
  {
    this->language_.set (std::move (x));
  }

  const ModelIdentification::majorVersion_type& ModelIdentification::
  majorVersion () const
  {
    return this->majorVersion_.get ();
  }

  ModelIdentification::majorVersion_type& ModelIdentification::
  majorVersion ()
  {
    return this->majorVersion_.get ();
  }

  void ModelIdentification::
  majorVersion (const majorVersion_type& x)
  {
    this->majorVersion_.set (x);
  }

  const ModelIdentification::minorVersion_type& ModelIdentification::
  minorVersion () const
  {
    return this->minorVersion_.get ();
  }

  ModelIdentification::minorVersion_type& ModelIdentification::
  minorVersion ()
  {
    return this->minorVersion_.get ();
  }

  void ModelIdentification::
  minorVersion (const minorVersion_type& x)
  {
    this->minorVersion_.set (x);
  }

  const ModelIdentification::subtitle_type& ModelIdentification::
  subtitle () const
  {
    return this->subtitle_.get ();
  }

  ModelIdentification::subtitle_type& ModelIdentification::
  subtitle ()
  {
    return this->subtitle_.get ();
  }

  void ModelIdentification::
  subtitle (const subtitle_type& x)
  {
    this->subtitle_.set (x);
  }

  void ModelIdentification::
  subtitle (::std::unique_ptr< subtitle_type > x)
  {
    this->subtitle_.set (std::move (x));
  }

  const ModelIdentification::title_type& ModelIdentification::
  title () const
  {
    return this->title_.get ();
  }

  ModelIdentification::title_type& ModelIdentification::
  title ()
  {
    return this->title_.get ();
  }

  void ModelIdentification::
  title (const title_type& x)
  {
    this->title_.set (x);
  }

  void ModelIdentification::
  title (::std::unique_ptr< title_type > x)
  {
    this->title_.set (std::move (x));
  }

  const ModelIdentification::uri_type& ModelIdentification::
  uri () const
  {
    return this->uri_.get ();
  }

  ModelIdentification::uri_type& ModelIdentification::
  uri ()
  {
    return this->uri_.get ();
  }

  void ModelIdentification::
  uri (const uri_type& x)
  {
    this->uri_.set (x);
  }

  void ModelIdentification::
  uri (::std::unique_ptr< uri_type > x)
  {
    this->uri_.set (std::move (x));
  }


  // NonDdiIdentifier
  //

  const NonDdiIdentifier::managingAgency_optional& NonDdiIdentifier::
  managingAgency () const
  {
    return this->managingAgency_;
  }

  NonDdiIdentifier::managingAgency_optional& NonDdiIdentifier::
  managingAgency ()
  {
    return this->managingAgency_;
  }

  void NonDdiIdentifier::
  managingAgency (const managingAgency_type& x)
  {
    this->managingAgency_.set (x);
  }

  void NonDdiIdentifier::
  managingAgency (const managingAgency_optional& x)
  {
    this->managingAgency_ = x;
  }

  void NonDdiIdentifier::
  managingAgency (::std::unique_ptr< managingAgency_type > x)
  {
    this->managingAgency_.set (std::move (x));
  }

  const NonDdiIdentifier::type_type& NonDdiIdentifier::
  type () const
  {
    return this->type_.get ();
  }

  NonDdiIdentifier::type_type& NonDdiIdentifier::
  type ()
  {
    return this->type_.get ();
  }

  void NonDdiIdentifier::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void NonDdiIdentifier::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const NonDdiIdentifier::value_type& NonDdiIdentifier::
  value () const
  {
    return this->value_.get ();
  }

  NonDdiIdentifier::value_type& NonDdiIdentifier::
  value ()
  {
    return this->value_.get ();
  }

  void NonDdiIdentifier::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void NonDdiIdentifier::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }

  const NonDdiIdentifier::version_optional& NonDdiIdentifier::
  version () const
  {
    return this->version_;
  }

  NonDdiIdentifier::version_optional& NonDdiIdentifier::
  version ()
  {
    return this->version_;
  }

  void NonDdiIdentifier::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void NonDdiIdentifier::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void NonDdiIdentifier::
  version (::std::unique_ptr< version_type > x)
  {
    this->version_.set (std::move (x));
  }


  // NonIsoDate
  //

  const NonIsoDate::calendar_optional& NonIsoDate::
  calendar () const
  {
    return this->calendar_;
  }

  NonIsoDate::calendar_optional& NonIsoDate::
  calendar ()
  {
    return this->calendar_;
  }

  void NonIsoDate::
  calendar (const calendar_type& x)
  {
    this->calendar_.set (x);
  }

  void NonIsoDate::
  calendar (const calendar_optional& x)
  {
    this->calendar_ = x;
  }

  void NonIsoDate::
  calendar (::std::unique_ptr< calendar_type > x)
  {
    this->calendar_.set (std::move (x));
  }

  const NonIsoDate::dateContent_type& NonIsoDate::
  dateContent () const
  {
    return this->dateContent_.get ();
  }

  NonIsoDate::dateContent_type& NonIsoDate::
  dateContent ()
  {
    return this->dateContent_.get ();
  }

  void NonIsoDate::
  dateContent (const dateContent_type& x)
  {
    this->dateContent_.set (x);
  }

  void NonIsoDate::
  dateContent (::std::unique_ptr< dateContent_type > x)
  {
    this->dateContent_.set (std::move (x));
  }

  const NonIsoDate::nonIsoDateFormat_optional& NonIsoDate::
  nonIsoDateFormat () const
  {
    return this->nonIsoDateFormat_;
  }

  NonIsoDate::nonIsoDateFormat_optional& NonIsoDate::
  nonIsoDateFormat ()
  {
    return this->nonIsoDateFormat_;
  }

  void NonIsoDate::
  nonIsoDateFormat (const nonIsoDateFormat_type& x)
  {
    this->nonIsoDateFormat_.set (x);
  }

  void NonIsoDate::
  nonIsoDateFormat (const nonIsoDateFormat_optional& x)
  {
    this->nonIsoDateFormat_ = x;
  }

  void NonIsoDate::
  nonIsoDateFormat (::std::unique_ptr< nonIsoDateFormat_type > x)
  {
    this->nonIsoDateFormat_.set (std::move (x));
  }


  // Selector
  //


  // ObjectAttributeSelector
  //

  const ObjectAttributeSelector::refinedBy_optional& ObjectAttributeSelector::
  refinedBy () const
  {
    return this->refinedBy_;
  }

  ObjectAttributeSelector::refinedBy_optional& ObjectAttributeSelector::
  refinedBy ()
  {
    return this->refinedBy_;
  }

  void ObjectAttributeSelector::
  refinedBy (const refinedBy_type& x)
  {
    this->refinedBy_.set (x);
  }

  void ObjectAttributeSelector::
  refinedBy (const refinedBy_optional& x)
  {
    this->refinedBy_ = x;
  }

  void ObjectAttributeSelector::
  refinedBy (::std::unique_ptr< refinedBy_type > x)
  {
    this->refinedBy_.set (std::move (x));
  }

  const ObjectAttributeSelector::refinedByOrderNumber_optional& ObjectAttributeSelector::
  refinedByOrderNumber () const
  {
    return this->refinedByOrderNumber_;
  }

  ObjectAttributeSelector::refinedByOrderNumber_optional& ObjectAttributeSelector::
  refinedByOrderNumber ()
  {
    return this->refinedByOrderNumber_;
  }

  void ObjectAttributeSelector::
  refinedByOrderNumber (const refinedByOrderNumber_type& x)
  {
    this->refinedByOrderNumber_.set (x);
  }

  void ObjectAttributeSelector::
  refinedByOrderNumber (const refinedByOrderNumber_optional& x)
  {
    this->refinedByOrderNumber_ = x;
  }

  const ObjectAttributeSelector::value_optional& ObjectAttributeSelector::
  value () const
  {
    return this->value_;
  }

  ObjectAttributeSelector::value_optional& ObjectAttributeSelector::
  value ()
  {
    return this->value_;
  }

  void ObjectAttributeSelector::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void ObjectAttributeSelector::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void ObjectAttributeSelector::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }


  // ObjectName
  //

  const ObjectName::context_optional& ObjectName::
  context () const
  {
    return this->context_;
  }

  ObjectName::context_optional& ObjectName::
  context ()
  {
    return this->context_;
  }

  void ObjectName::
  context (const context_type& x)
  {
    this->context_.set (x);
  }

  void ObjectName::
  context (const context_optional& x)
  {
    this->context_ = x;
  }

  void ObjectName::
  context (::std::unique_ptr< context_type > x)
  {
    this->context_.set (std::move (x));
  }

  const ObjectName::name_optional& ObjectName::
  name () const
  {
    return this->name_;
  }

  ObjectName::name_optional& ObjectName::
  name ()
  {
    return this->name_;
  }

  void ObjectName::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void ObjectName::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void ObjectName::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // OrganizationName
  //

  const OrganizationName::abbreviation_optional& OrganizationName::
  abbreviation () const
  {
    return this->abbreviation_;
  }

  OrganizationName::abbreviation_optional& OrganizationName::
  abbreviation ()
  {
    return this->abbreviation_;
  }

  void OrganizationName::
  abbreviation (const abbreviation_type& x)
  {
    this->abbreviation_.set (x);
  }

  void OrganizationName::
  abbreviation (const abbreviation_optional& x)
  {
    this->abbreviation_ = x;
  }

  void OrganizationName::
  abbreviation (::std::unique_ptr< abbreviation_type > x)
  {
    this->abbreviation_.set (std::move (x));
  }

  const OrganizationName::effectiveDates_optional& OrganizationName::
  effectiveDates () const
  {
    return this->effectiveDates_;
  }

  OrganizationName::effectiveDates_optional& OrganizationName::
  effectiveDates ()
  {
    return this->effectiveDates_;
  }

  void OrganizationName::
  effectiveDates (const effectiveDates_type& x)
  {
    this->effectiveDates_.set (x);
  }

  void OrganizationName::
  effectiveDates (const effectiveDates_optional& x)
  {
    this->effectiveDates_ = x;
  }

  void OrganizationName::
  effectiveDates (::std::unique_ptr< effectiveDates_type > x)
  {
    this->effectiveDates_.set (std::move (x));
  }

  const OrganizationName::isFormal_optional& OrganizationName::
  isFormal () const
  {
    return this->isFormal_;
  }

  OrganizationName::isFormal_optional& OrganizationName::
  isFormal ()
  {
    return this->isFormal_;
  }

  void OrganizationName::
  isFormal (const isFormal_type& x)
  {
    this->isFormal_.set (x);
  }

  void OrganizationName::
  isFormal (const isFormal_optional& x)
  {
    this->isFormal_ = x;
  }

  const OrganizationName::typeOfOrganizationName_optional& OrganizationName::
  typeOfOrganizationName () const
  {
    return this->typeOfOrganizationName_;
  }

  OrganizationName::typeOfOrganizationName_optional& OrganizationName::
  typeOfOrganizationName ()
  {
    return this->typeOfOrganizationName_;
  }

  void OrganizationName::
  typeOfOrganizationName (const typeOfOrganizationName_type& x)
  {
    this->typeOfOrganizationName_.set (x);
  }

  void OrganizationName::
  typeOfOrganizationName (const typeOfOrganizationName_optional& x)
  {
    this->typeOfOrganizationName_ = x;
  }

  void OrganizationName::
  typeOfOrganizationName (::std::unique_ptr< typeOfOrganizationName_type > x)
  {
    this->typeOfOrganizationName_.set (std::move (x));
  }


  // PairedControlledVocabularyEntry
  //

  const PairedControlledVocabularyEntry::extent_optional& PairedControlledVocabularyEntry::
  extent () const
  {
    return this->extent_;
  }

  PairedControlledVocabularyEntry::extent_optional& PairedControlledVocabularyEntry::
  extent ()
  {
    return this->extent_;
  }

  void PairedControlledVocabularyEntry::
  extent (const extent_type& x)
  {
    this->extent_.set (x);
  }

  void PairedControlledVocabularyEntry::
  extent (const extent_optional& x)
  {
    this->extent_ = x;
  }

  void PairedControlledVocabularyEntry::
  extent (::std::unique_ptr< extent_type > x)
  {
    this->extent_.set (std::move (x));
  }

  const PairedControlledVocabularyEntry::term_type& PairedControlledVocabularyEntry::
  term () const
  {
    return this->term_.get ();
  }

  PairedControlledVocabularyEntry::term_type& PairedControlledVocabularyEntry::
  term ()
  {
    return this->term_.get ();
  }

  void PairedControlledVocabularyEntry::
  term (const term_type& x)
  {
    this->term_.set (x);
  }

  void PairedControlledVocabularyEntry::
  term (::std::unique_ptr< term_type > x)
  {
    this->term_.set (std::move (x));
  }


  // PrivateImage
  //

  const PrivateImage::effectiveDates_optional& PrivateImage::
  effectiveDates () const
  {
    return this->effectiveDates_;
  }

  PrivateImage::effectiveDates_optional& PrivateImage::
  effectiveDates ()
  {
    return this->effectiveDates_;
  }

  void PrivateImage::
  effectiveDates (const effectiveDates_type& x)
  {
    this->effectiveDates_.set (x);
  }

  void PrivateImage::
  effectiveDates (const effectiveDates_optional& x)
  {
    this->effectiveDates_ = x;
  }

  void PrivateImage::
  effectiveDates (::std::unique_ptr< effectiveDates_type > x)
  {
    this->effectiveDates_.set (std::move (x));
  }

  const PrivateImage::privacy_optional& PrivateImage::
  privacy () const
  {
    return this->privacy_;
  }

  PrivateImage::privacy_optional& PrivateImage::
  privacy ()
  {
    return this->privacy_;
  }

  void PrivateImage::
  privacy (const privacy_type& x)
  {
    this->privacy_.set (x);
  }

  void PrivateImage::
  privacy (const privacy_optional& x)
  {
    this->privacy_ = x;
  }

  void PrivateImage::
  privacy (::std::unique_ptr< privacy_type > x)
  {
    this->privacy_.set (std::move (x));
  }


  // ProvenanceInformation
  //

  const ProvenanceInformation::funding_sequence& ProvenanceInformation::
  funding () const
  {
    return this->funding_;
  }

  ProvenanceInformation::funding_sequence& ProvenanceInformation::
  funding ()
  {
    return this->funding_;
  }

  void ProvenanceInformation::
  funding (const funding_sequence& s)
  {
    this->funding_ = s;
  }

  const ProvenanceInformation::provenanceStatement_sequence& ProvenanceInformation::
  provenanceStatement () const
  {
    return this->provenanceStatement_;
  }

  ProvenanceInformation::provenanceStatement_sequence& ProvenanceInformation::
  provenanceStatement ()
  {
    return this->provenanceStatement_;
  }

  void ProvenanceInformation::
  provenanceStatement (const provenanceStatement_sequence& s)
  {
    this->provenanceStatement_ = s;
  }

  const ProvenanceInformation::recordCreationDate_optional& ProvenanceInformation::
  recordCreationDate () const
  {
    return this->recordCreationDate_;
  }

  ProvenanceInformation::recordCreationDate_optional& ProvenanceInformation::
  recordCreationDate ()
  {
    return this->recordCreationDate_;
  }

  void ProvenanceInformation::
  recordCreationDate (const recordCreationDate_type& x)
  {
    this->recordCreationDate_.set (x);
  }

  void ProvenanceInformation::
  recordCreationDate (const recordCreationDate_optional& x)
  {
    this->recordCreationDate_ = x;
  }

  void ProvenanceInformation::
  recordCreationDate (::std::unique_ptr< recordCreationDate_type > x)
  {
    this->recordCreationDate_.set (std::move (x));
  }

  const ProvenanceInformation::recordLastRevisionDate_optional& ProvenanceInformation::
  recordLastRevisionDate () const
  {
    return this->recordLastRevisionDate_;
  }

  ProvenanceInformation::recordLastRevisionDate_optional& ProvenanceInformation::
  recordLastRevisionDate ()
  {
    return this->recordLastRevisionDate_;
  }

  void ProvenanceInformation::
  recordLastRevisionDate (const recordLastRevisionDate_type& x)
  {
    this->recordLastRevisionDate_.set (x);
  }

  void ProvenanceInformation::
  recordLastRevisionDate (const recordLastRevisionDate_optional& x)
  {
    this->recordLastRevisionDate_ = x;
  }

  void ProvenanceInformation::
  recordLastRevisionDate (::std::unique_ptr< recordLastRevisionDate_type > x)
  {
    this->recordLastRevisionDate_.set (std::move (x));
  }


  // RationaleDefinition
  //

  const RationaleDefinition::rationaleCode_optional& RationaleDefinition::
  rationaleCode () const
  {
    return this->rationaleCode_;
  }

  RationaleDefinition::rationaleCode_optional& RationaleDefinition::
  rationaleCode ()
  {
    return this->rationaleCode_;
  }

  void RationaleDefinition::
  rationaleCode (const rationaleCode_type& x)
  {
    this->rationaleCode_.set (x);
  }

  void RationaleDefinition::
  rationaleCode (const rationaleCode_optional& x)
  {
    this->rationaleCode_ = x;
  }

  void RationaleDefinition::
  rationaleCode (::std::unique_ptr< rationaleCode_type > x)
  {
    this->rationaleCode_.set (std::move (x));
  }

  const RationaleDefinition::rationaleDescription_optional& RationaleDefinition::
  rationaleDescription () const
  {
    return this->rationaleDescription_;
  }

  RationaleDefinition::rationaleDescription_optional& RationaleDefinition::
  rationaleDescription ()
  {
    return this->rationaleDescription_;
  }

  void RationaleDefinition::
  rationaleDescription (const rationaleDescription_type& x)
  {
    this->rationaleDescription_.set (x);
  }

  void RationaleDefinition::
  rationaleDescription (const rationaleDescription_optional& x)
  {
    this->rationaleDescription_ = x;
  }

  void RationaleDefinition::
  rationaleDescription (::std::unique_ptr< rationaleDescription_type > x)
  {
    this->rationaleDescription_.set (std::move (x));
  }


  // Reference
  //

  const Reference::ddiReference_optional& Reference::
  ddiReference () const
  {
    return this->ddiReference_;
  }

  Reference::ddiReference_optional& Reference::
  ddiReference ()
  {
    return this->ddiReference_;
  }

  void Reference::
  ddiReference (const ddiReference_type& x)
  {
    this->ddiReference_.set (x);
  }

  void Reference::
  ddiReference (const ddiReference_optional& x)
  {
    this->ddiReference_ = x;
  }

  void Reference::
  ddiReference (::std::unique_ptr< ddiReference_type > x)
  {
    this->ddiReference_.set (std::move (x));
  }

  const Reference::deepLink_optional& Reference::
  deepLink () const
  {
    return this->deepLink_;
  }

  Reference::deepLink_optional& Reference::
  deepLink ()
  {
    return this->deepLink_;
  }

  void Reference::
  deepLink (const deepLink_type& x)
  {
    this->deepLink_.set (x);
  }

  void Reference::
  deepLink (const deepLink_optional& x)
  {
    this->deepLink_ = x;
  }

  void Reference::
  deepLink (::std::unique_ptr< deepLink_type > x)
  {
    this->deepLink_.set (std::move (x));
  }

  const Reference::description_optional& Reference::
  description () const
  {
    return this->description_;
  }

  Reference::description_optional& Reference::
  description ()
  {
    return this->description_;
  }

  void Reference::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void Reference::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void Reference::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }

  const Reference::location_optional& Reference::
  location () const
  {
    return this->location_;
  }

  Reference::location_optional& Reference::
  location ()
  {
    return this->location_;
  }

  void Reference::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  void Reference::
  location (const location_optional& x)
  {
    this->location_ = x;
  }

  void Reference::
  location (::std::unique_ptr< location_type > x)
  {
    this->location_.set (std::move (x));
  }

  const Reference::nonDdiReference_sequence& Reference::
  nonDdiReference () const
  {
    return this->nonDdiReference_;
  }

  Reference::nonDdiReference_sequence& Reference::
  nonDdiReference ()
  {
    return this->nonDdiReference_;
  }

  void Reference::
  nonDdiReference (const nonDdiReference_sequence& s)
  {
    this->nonDdiReference_ = s;
  }

  const Reference::semantic_optional& Reference::
  semantic () const
  {
    return this->semantic_;
  }

  Reference::semantic_optional& Reference::
  semantic ()
  {
    return this->semantic_;
  }

  void Reference::
  semantic (const semantic_type& x)
  {
    this->semantic_.set (x);
  }

  void Reference::
  semantic (const semantic_optional& x)
  {
    this->semantic_ = x;
  }

  void Reference::
  semantic (::std::unique_ptr< semantic_type > x)
  {
    this->semantic_.set (std::move (x));
  }

  const Reference::uri_optional& Reference::
  uri () const
  {
    return this->uri_;
  }

  Reference::uri_optional& Reference::
  uri ()
  {
    return this->uri_;
  }

  void Reference::
  uri (const uri_type& x)
  {
    this->uri_.set (x);
  }

  void Reference::
  uri (const uri_optional& x)
  {
    this->uri_ = x;
  }

  void Reference::
  uri (::std::unique_ptr< uri_type > x)
  {
    this->uri_.set (std::move (x));
  }

  const Reference::validType_sequence& Reference::
  validType () const
  {
    return this->validType_;
  }

  Reference::validType_sequence& Reference::
  validType ()
  {
    return this->validType_;
  }

  void Reference::
  validType (const validType_sequence& s)
  {
    this->validType_ = s;
  }

  const Reference::isAssociationReference_optional& Reference::
  isAssociationReference () const
  {
    return this->isAssociationReference_;
  }

  Reference::isAssociationReference_optional& Reference::
  isAssociationReference ()
  {
    return this->isAssociationReference_;
  }

  void Reference::
  isAssociationReference (const isAssociationReference_type& x)
  {
    this->isAssociationReference_.set (x);
  }

  void Reference::
  isAssociationReference (const isAssociationReference_optional& x)
  {
    this->isAssociationReference_ = x;
  }


  // SpatialCoordinate
  //

  const SpatialCoordinate::content_optional& SpatialCoordinate::
  content () const
  {
    return this->content_;
  }

  SpatialCoordinate::content_optional& SpatialCoordinate::
  content ()
  {
    return this->content_;
  }

  void SpatialCoordinate::
  content (const content_type& x)
  {
    this->content_.set (x);
  }

  void SpatialCoordinate::
  content (const content_optional& x)
  {
    this->content_ = x;
  }

  void SpatialCoordinate::
  content (::std::unique_ptr< content_type > x)
  {
    this->content_.set (std::move (x));
  }

  const SpatialCoordinate::coordinateType_optional& SpatialCoordinate::
  coordinateType () const
  {
    return this->coordinateType_;
  }

  SpatialCoordinate::coordinateType_optional& SpatialCoordinate::
  coordinateType ()
  {
    return this->coordinateType_;
  }

  void SpatialCoordinate::
  coordinateType (const coordinateType_type& x)
  {
    this->coordinateType_.set (x);
  }

  void SpatialCoordinate::
  coordinateType (const coordinateType_optional& x)
  {
    this->coordinateType_ = x;
  }

  void SpatialCoordinate::
  coordinateType (::std::unique_ptr< coordinateType_type > x)
  {
    this->coordinateType_.set (std::move (x));
  }


  // SpatialPoint
  //

  const SpatialPoint::xCoordinate_optional& SpatialPoint::
  xCoordinate () const
  {
    return this->xCoordinate_;
  }

  SpatialPoint::xCoordinate_optional& SpatialPoint::
  xCoordinate ()
  {
    return this->xCoordinate_;
  }

  void SpatialPoint::
  xCoordinate (const xCoordinate_type& x)
  {
    this->xCoordinate_.set (x);
  }

  void SpatialPoint::
  xCoordinate (const xCoordinate_optional& x)
  {
    this->xCoordinate_ = x;
  }

  void SpatialPoint::
  xCoordinate (::std::unique_ptr< xCoordinate_type > x)
  {
    this->xCoordinate_.set (std::move (x));
  }

  const SpatialPoint::yCoordinate_optional& SpatialPoint::
  yCoordinate () const
  {
    return this->yCoordinate_;
  }

  SpatialPoint::yCoordinate_optional& SpatialPoint::
  yCoordinate ()
  {
    return this->yCoordinate_;
  }

  void SpatialPoint::
  yCoordinate (const yCoordinate_type& x)
  {
    this->yCoordinate_.set (x);
  }

  void SpatialPoint::
  yCoordinate (const yCoordinate_optional& x)
  {
    this->yCoordinate_ = x;
  }

  void SpatialPoint::
  yCoordinate (::std::unique_ptr< yCoordinate_type > x)
  {
    this->yCoordinate_.set (std::move (x));
  }


  // Statistic
  //

  const Statistic::computationBase_optional& Statistic::
  computationBase () const
  {
    return this->computationBase_;
  }

  Statistic::computationBase_optional& Statistic::
  computationBase ()
  {
    return this->computationBase_;
  }

  void Statistic::
  computationBase (const computationBase_type& x)
  {
    this->computationBase_.set (x);
  }

  void Statistic::
  computationBase (const computationBase_optional& x)
  {
    this->computationBase_ = x;
  }

  void Statistic::
  computationBase (::std::unique_ptr< computationBase_type > x)
  {
    this->computationBase_.set (std::move (x));
  }

  const Statistic::content_optional& Statistic::
  content () const
  {
    return this->content_;
  }

  Statistic::content_optional& Statistic::
  content ()
  {
    return this->content_;
  }

  void Statistic::
  content (const content_type& x)
  {
    this->content_.set (x);
  }

  void Statistic::
  content (const content_optional& x)
  {
    this->content_ = x;
  }

  const Statistic::isWeighted_optional& Statistic::
  isWeighted () const
  {
    return this->isWeighted_;
  }

  Statistic::isWeighted_optional& Statistic::
  isWeighted ()
  {
    return this->isWeighted_;
  }

  void Statistic::
  isWeighted (const isWeighted_type& x)
  {
    this->isWeighted_.set (x);
  }

  void Statistic::
  isWeighted (const isWeighted_optional& x)
  {
    this->isWeighted_ = x;
  }

  const Statistic::typeOfNumericValue_optional& Statistic::
  typeOfNumericValue () const
  {
    return this->typeOfNumericValue_;
  }

  Statistic::typeOfNumericValue_optional& Statistic::
  typeOfNumericValue ()
  {
    return this->typeOfNumericValue_;
  }

  void Statistic::
  typeOfNumericValue (const typeOfNumericValue_type& x)
  {
    this->typeOfNumericValue_.set (x);
  }

  void Statistic::
  typeOfNumericValue (const typeOfNumericValue_optional& x)
  {
    this->typeOfNumericValue_ = x;
  }

  void Statistic::
  typeOfNumericValue (::std::unique_ptr< typeOfNumericValue_type > x)
  {
    this->typeOfNumericValue_.set (std::move (x));
  }


  // StructureSpecification
  //

  const StructureSpecification::reflexive_optional& StructureSpecification::
  reflexive () const
  {
    return this->reflexive_;
  }

  StructureSpecification::reflexive_optional& StructureSpecification::
  reflexive ()
  {
    return this->reflexive_;
  }

  void StructureSpecification::
  reflexive (const reflexive_type& x)
  {
    this->reflexive_.set (x);
  }

  void StructureSpecification::
  reflexive (const reflexive_optional& x)
  {
    this->reflexive_ = x;
  }

  void StructureSpecification::
  reflexive (::std::unique_ptr< reflexive_type > x)
  {
    this->reflexive_.set (std::move (x));
  }

  const StructureSpecification::symmetric_optional& StructureSpecification::
  symmetric () const
  {
    return this->symmetric_;
  }

  StructureSpecification::symmetric_optional& StructureSpecification::
  symmetric ()
  {
    return this->symmetric_;
  }

  void StructureSpecification::
  symmetric (const symmetric_type& x)
  {
    this->symmetric_.set (x);
  }

  void StructureSpecification::
  symmetric (const symmetric_optional& x)
  {
    this->symmetric_ = x;
  }

  void StructureSpecification::
  symmetric (::std::unique_ptr< symmetric_type > x)
  {
    this->symmetric_.set (std::move (x));
  }

  const StructureSpecification::transitive_optional& StructureSpecification::
  transitive () const
  {
    return this->transitive_;
  }

  StructureSpecification::transitive_optional& StructureSpecification::
  transitive ()
  {
    return this->transitive_;
  }

  void StructureSpecification::
  transitive (const transitive_type& x)
  {
    this->transitive_.set (x);
  }

  void StructureSpecification::
  transitive (const transitive_optional& x)
  {
    this->transitive_ = x;
  }

  void StructureSpecification::
  transitive (::std::unique_ptr< transitive_type > x)
  {
    this->transitive_.set (std::move (x));
  }


  // Telephone
  //

  const Telephone::effectiveDates_optional& Telephone::
  effectiveDates () const
  {
    return this->effectiveDates_;
  }

  Telephone::effectiveDates_optional& Telephone::
  effectiveDates ()
  {
    return this->effectiveDates_;
  }

  void Telephone::
  effectiveDates (const effectiveDates_type& x)
  {
    this->effectiveDates_.set (x);
  }

  void Telephone::
  effectiveDates (const effectiveDates_optional& x)
  {
    this->effectiveDates_ = x;
  }

  void Telephone::
  effectiveDates (::std::unique_ptr< effectiveDates_type > x)
  {
    this->effectiveDates_.set (std::move (x));
  }

  const Telephone::isPreferred_optional& Telephone::
  isPreferred () const
  {
    return this->isPreferred_;
  }

  Telephone::isPreferred_optional& Telephone::
  isPreferred ()
  {
    return this->isPreferred_;
  }

  void Telephone::
  isPreferred (const isPreferred_type& x)
  {
    this->isPreferred_.set (x);
  }

  void Telephone::
  isPreferred (const isPreferred_optional& x)
  {
    this->isPreferred_ = x;
  }

  const Telephone::privacy_optional& Telephone::
  privacy () const
  {
    return this->privacy_;
  }

  Telephone::privacy_optional& Telephone::
  privacy ()
  {
    return this->privacy_;
  }

  void Telephone::
  privacy (const privacy_type& x)
  {
    this->privacy_.set (x);
  }

  void Telephone::
  privacy (const privacy_optional& x)
  {
    this->privacy_ = x;
  }

  void Telephone::
  privacy (::std::unique_ptr< privacy_type > x)
  {
    this->privacy_.set (std::move (x));
  }

  const Telephone::telephoneNumber_optional& Telephone::
  telephoneNumber () const
  {
    return this->telephoneNumber_;
  }

  Telephone::telephoneNumber_optional& Telephone::
  telephoneNumber ()
  {
    return this->telephoneNumber_;
  }

  void Telephone::
  telephoneNumber (const telephoneNumber_type& x)
  {
    this->telephoneNumber_.set (x);
  }

  void Telephone::
  telephoneNumber (const telephoneNumber_optional& x)
  {
    this->telephoneNumber_ = x;
  }

  void Telephone::
  telephoneNumber (::std::unique_ptr< telephoneNumber_type > x)
  {
    this->telephoneNumber_.set (std::move (x));
  }

  const Telephone::typeOfTelephone_optional& Telephone::
  typeOfTelephone () const
  {
    return this->typeOfTelephone_;
  }

  Telephone::typeOfTelephone_optional& Telephone::
  typeOfTelephone ()
  {
    return this->typeOfTelephone_;
  }

  void Telephone::
  typeOfTelephone (const typeOfTelephone_type& x)
  {
    this->typeOfTelephone_.set (x);
  }

  void Telephone::
  typeOfTelephone (const typeOfTelephone_optional& x)
  {
    this->typeOfTelephone_ = x;
  }

  void Telephone::
  typeOfTelephone (::std::unique_ptr< typeOfTelephone_type > x)
  {
    this->typeOfTelephone_.set (std::move (x));
  }


  // TextPositionSelector
  //

  const TextPositionSelector::end_type& TextPositionSelector::
  end () const
  {
    return this->end_.get ();
  }

  TextPositionSelector::end_type& TextPositionSelector::
  end ()
  {
    return this->end_.get ();
  }

  void TextPositionSelector::
  end (const end_type& x)
  {
    this->end_.set (x);
  }

  const TextPositionSelector::start_type& TextPositionSelector::
  start () const
  {
    return this->start_.get ();
  }

  TextPositionSelector::start_type& TextPositionSelector::
  start ()
  {
    return this->start_.get ();
  }

  void TextPositionSelector::
  start (const start_type& x)
  {
    this->start_.set (x);
  }


  // TimeRole
  //

  const TimeRole::time_optional& TimeRole::
  time () const
  {
    return this->time_;
  }

  TimeRole::time_optional& TimeRole::
  time ()
  {
    return this->time_;
  }

  void TimeRole::
  time (const time_type& x)
  {
    this->time_.set (x);
  }

  void TimeRole::
  time (const time_optional& x)
  {
    this->time_ = x;
  }

  void TimeRole::
  time (::std::unique_ptr< time_type > x)
  {
    this->time_.set (std::move (x));
  }


  // TypedString
  //

  const TypedString::content_type& TypedString::
  content () const
  {
    return this->content_.get ();
  }

  TypedString::content_type& TypedString::
  content ()
  {
    return this->content_.get ();
  }

  void TypedString::
  content (const content_type& x)
  {
    this->content_.set (x);
  }

  void TypedString::
  content (::std::unique_ptr< content_type > x)
  {
    this->content_.set (std::move (x));
  }

  const TypedString::typeOfContent_optional& TypedString::
  typeOfContent () const
  {
    return this->typeOfContent_;
  }

  TypedString::typeOfContent_optional& TypedString::
  typeOfContent ()
  {
    return this->typeOfContent_;
  }

  void TypedString::
  typeOfContent (const typeOfContent_type& x)
  {
    this->typeOfContent_.set (x);
  }

  void TypedString::
  typeOfContent (const typeOfContent_optional& x)
  {
    this->typeOfContent_ = x;
  }

  void TypedString::
  typeOfContent (::std::unique_ptr< typeOfContent_type > x)
  {
    this->typeOfContent_.set (std::move (x));
  }


  // WebLink
  //

  const WebLink::effectiveDates_optional& WebLink::
  effectiveDates () const
  {
    return this->effectiveDates_;
  }

  WebLink::effectiveDates_optional& WebLink::
  effectiveDates ()
  {
    return this->effectiveDates_;
  }

  void WebLink::
  effectiveDates (const effectiveDates_type& x)
  {
    this->effectiveDates_.set (x);
  }

  void WebLink::
  effectiveDates (const effectiveDates_optional& x)
  {
    this->effectiveDates_ = x;
  }

  void WebLink::
  effectiveDates (::std::unique_ptr< effectiveDates_type > x)
  {
    this->effectiveDates_.set (std::move (x));
  }

  const WebLink::isPreferred_optional& WebLink::
  isPreferred () const
  {
    return this->isPreferred_;
  }

  WebLink::isPreferred_optional& WebLink::
  isPreferred ()
  {
    return this->isPreferred_;
  }

  void WebLink::
  isPreferred (const isPreferred_type& x)
  {
    this->isPreferred_.set (x);
  }

  void WebLink::
  isPreferred (const isPreferred_optional& x)
  {
    this->isPreferred_ = x;
  }

  const WebLink::privacy_optional& WebLink::
  privacy () const
  {
    return this->privacy_;
  }

  WebLink::privacy_optional& WebLink::
  privacy ()
  {
    return this->privacy_;
  }

  void WebLink::
  privacy (const privacy_type& x)
  {
    this->privacy_.set (x);
  }

  void WebLink::
  privacy (const privacy_optional& x)
  {
    this->privacy_ = x;
  }

  void WebLink::
  privacy (::std::unique_ptr< privacy_type > x)
  {
    this->privacy_.set (std::move (x));
  }

  const WebLink::typeOfWebsite_optional& WebLink::
  typeOfWebsite () const
  {
    return this->typeOfWebsite_;
  }

  WebLink::typeOfWebsite_optional& WebLink::
  typeOfWebsite ()
  {
    return this->typeOfWebsite_;
  }

  void WebLink::
  typeOfWebsite (const typeOfWebsite_type& x)
  {
    this->typeOfWebsite_.set (x);
  }

  void WebLink::
  typeOfWebsite (const typeOfWebsite_optional& x)
  {
    this->typeOfWebsite_ = x;
  }

  void WebLink::
  typeOfWebsite (::std::unique_ptr< typeOfWebsite_type > x)
  {
    this->typeOfWebsite_.set (std::move (x));
  }

  const WebLink::uri_optional& WebLink::
  uri () const
  {
    return this->uri_;
  }

  WebLink::uri_optional& WebLink::
  uri ()
  {
    return this->uri_;
  }

  void WebLink::
  uri (const uri_type& x)
  {
    this->uri_.set (x);
  }

  void WebLink::
  uri (const uri_optional& x)
  {
    this->uri_ = x;
  }

  void WebLink::
  uri (::std::unique_ptr< uri_type > x)
  {
    this->uri_.set (std::move (x));
  }


  // entityProduced
  //


  // entityUsed
  //


  // standardModelMapping
  //


  // Activity_hasInternal_ControlLogic
  //


  // Activity_hasSubActivity_Activity
  //


  // Activity_has_Step
  //


  // AgentListing_isDefinedBy_Concept
  //


  // AgentListing_isMaintainedBy_Agent
  //


  // AgentListing_has_AgentPosition
  //


  // AgentListing_has_Agent
  //


  // AgentPosition_indexes_Agent
  //


  // AgentRelationship_hasSource_Agent
  //


  // AgentRelationship_hasTarget_Agent
  //


  // AgentStructure_structures_AgentListing
  //


  // AgentStructure_has_AgentRelationship
  //


  // AttributeComponent_qualifies_DataStructureComponent
  //


  // AuthorizationSource_has_Agent
  //


  // CategoryPosition_indexes_Category
  //


  // CategoryRelationStructure_structures_CategorySet
  //


  // CategoryRelationStructure_has_CategoryRelationship
  //


  // CategoryRelationship_hasSource_Category
  //


  // CategoryRelationship_hasTarget_Category
  //


  // CategorySet_has_Category
  //


  // CategorySet_has_CategoryPosition
  //


  // CategoryStatistic_appliesTo_InstanceVariable
  //


  // CategoryStatistic_for_Category
  //


  // ClassificationFamily_uses_ClassificationIndex
  //


  // ClassificationFamily_isDefinedBy_Concept
  //


  // ClassificationFamily_groups_ClassificationSeries
  //


  // ClassificationIndex_isMaintainedBy_Agent
  //


  // ClassificationIndex_hasContact_Agent
  //


  // ClassificationIndex_isDefinedBy_Concept
  //


  // ClassificationIndex_has_ClassificationIndexEntryPosition
  //


  // ClassificationIndex_has_ClassificationIndexEntry
  //


  // ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry
  //


  // ClassificationItem_excludes_ClassificationItem
  //


  // ClassificationItem_denotes_Category
  //


  // ClassificationItem_uses_Notation
  //


  // ClassificationItem_hasRulingBy_AuthorizationSource
  //


  // ClassificationItemPosition_indexes_ClassificationItem
  //


  // ClassificationItemRelationship_hasSource_ClassificationItem
  //


  // ClassificationItemRelationship_hasTarget_ClassificationItem
  //


  // ClassificationItemStructure_structures_StatisticalClassification
  //


  // ClassificationItemStructure_has_ClassificationItemRelationship
  //


  // ClassificationPosition_indexes_StatisticalClassification
  //


  // ClassificationSeries_isOwnedBy_Agent
  //


  // ClassificationSeries_isDefinedBy_Concept
  //


  // ClassificationSeries_has_StatisticalClassification
  //


  // ClassificationSeries_has_ClassificationPosition
  //


  // ClassificationSeriesStructure_structures_ClassificationSeries
  //


  // ClassificationSeriesStructure_has_StatisticalClassificationRelationship
  //


  // Code_denotes_Category
  //


  // Code_uses_Notation
  //


  // CodeList_has_CodePosition
  //


  // CodeList_has_Code
  //


  // CodeListStructure_structures_CodeList
  //


  // CodeListStructure_has_CodeRelationship
  //


  // CodePosition_indexes_Code
  //


  // CodeRelationship_hasTarget_Code
  //


  // CodeRelationship_hasSource_Code
  //


  // ComponentPosition_indexes_DataStructureComponent
  //


  // externalDefinition
  //


  // Concept_uses_Concept
  //


  // ConceptMap_hasSource_Concept
  //


  // ConceptMap_hasTarget_Concept
  //


  // ConceptRelationship_hasSource_Concept
  //


  // ConceptRelationship_hasTarget_Concept
  //


  // ConceptStructure_structures_ConceptSystem
  //


  // ConceptStructure_has_ConceptRelationship
  //


  // ConceptSystem_isDefinedBy_Concept
  //


  // ConceptSystem_has_Concept
  //


  // ConceptSystemCorrespondence_maps_ConceptSystem
  //


  // ConceptSystemCorrespondence_has_ConceptMap
  //


  // ConceptualDomain_isDescribedBy_ValueAndConceptDescription
  //


  // ConceptualDomain_takesConceptsFrom_ConceptSystem
  //


  // ConceptualValue_hasConceptFrom_ConceptualDomain
  //


  // ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain
  //


  // ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain
  //


  // ConceptualVariable_measures_UnitType
  //


  // ControlLogic_informs_ProcessingAgent
  //


  // ControlLogic_invokes_Activity
  //


  // ControlLogic_hasSubControlLogic_ControlLogic
  //


  // ControlLogic_has_InformationFlowDefinition
  //


  // CorrespondenceTable_hasSource_Level
  //


  // CorrespondenceTable_hasTarget_Level
  //


  // CorrespondenceTable_isOwnedBy_Agent
  //


  // CorrespondenceTable_mapsTo_StatisticalClassification
  //


  // CorrespondenceTable_hasContact_Agent
  //


  // CorrespondenceTable_isMaintainedBy_Agent
  //


  // CorrespondenceTable_has_ConceptMap
  //


  // DataPoint_correspondsTo_DataStructureComponent
  //


  // DataPoint_isDescribedBy_InstanceVariable
  //


  // DataPointPosition_indexes_DataPoint
  //


  // DataPointRelationship_hasTarget_DataPoint
  //


  // DataPointRelationship_hasSource_DataPoint
  //


  // DataSet_isStructuredBy_DataStructure
  //


  // DataSet_has_DataPoint
  //


  // DataSet_has_Key
  //


  // DataStore_isDefinedBy_Concept
  //


  // DataStore_has_LogicalRecordPosition
  //


  // DataStore_has_LogicalRecord
  //


  // DataStore_has_RecordRelation
  //


  // DataStructure_has_ForeignKey
  //


  // DataStructure_has_DataStructureComponent
  //


  // DataStructure_has_ComponentPosition
  //


  // DataStructure_has_PrimaryKey
  //


  // DataStructureComponent_isDefinedBy_RepresentedVariable
  //


  // Datum_uses_Notation
  //


  // Datum_denotes_ConceptualValue
  //


  // Datum_uses_InstanceValue
  //


  // Datum_isBoundedBy_InstanceVariable
  //


  // Descriptor_refersTo_ReferenceValue
  //


  // Descriptor_identifies_ReferenceVariable
  //


  // Descriptor_hasValueFrom_DescriptorValueDomain
  //


  // DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain
  //


  // DimensionComponent_isStructuredBy_ValueDomain
  //


  // DimensionGroup_has_DimensionComponent
  //


  // DimensionalDataSet_represents_ScopedMeasure
  //


  // DimensionalDataStructure_uses_DimensionGroup
  //


  // DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember
  //


  // DimensionalKeyMember_hasValueFrom_CodeList
  //


  // EnumerationDomain_uses_LevelStructure
  //


  // EnumerationDomain_references_CategorySet
  //


  // EnumerationDomain_isDefinedBy_Concept
  //


  // ForeignKey_isComposedOf_ForeignKeyComponent
  //


  // ForeignKeyComponent_references_PrimaryKeyComponent
  //


  // ForeignKeyComponent_correspondsTo_DataStructureComponent
  //


  // InformationFlowDefinition_from_Parameter
  //


  // InformationFlowDefinition_to_Parameter
  //


  // InstanceKey_has_InstanceValue
  //


  // InstanceKey_refersTo_ReferenceValue
  //


  // InstanceValue_hasValueFrom_ValueDomain
  //


  // InstanceValue_isStoredIn_DataPoint
  //


  // InstanceValue_represents_ConceptualValue
  //


  // source
  //


  // InstanceVariableMap_hasTarget_InstanceVariable
  //


  // InstanceVariableMap_hasSource_InstanceVariable
  //


  // Key_correspondsTo_Unit
  //


  // Key_represents_KeyDefinition
  //


  // Key_identifies_DataPoint
  //


  // Key_correspondsTo_Universe
  //


  // Key_has_KeyMember
  //


  // KeyDefinition_correspondsTo_Universe
  //


  // KeyDefinition_correspondsTo_Unit
  //


  // KeyDefinition_has_KeyDefinitionMember
  //


  // KeyMember_isBasedOn_DataStructureComponent
  //


  // Level_isDefinedBy_Concept
  //


  // Level_groups_ClassificationItem
  //


  // LevelStructure_has_Level
  //


  // LogicalRecord_organizes_DataSet
  //


  // LogicalRecord_isDefinedBy_Concept
  //


  // LogicalRecord_has_InstanceVariable
  //


  // LogicalRecordPosition_indexes_LogicalRecord
  //


  // LogicalRecordRelationStructure_structures_DataStore
  //


  // LogicalRecordRelationStructure_has_LogicalRecordRelationship
  //


  // LogicalRecordRelationship_hasTarget_LogicalRecord
  //


  // LogicalRecordRelationship_hasSource_LogicalRecord
  //


  // MainKeyMember_hasValueFrom_SubstantiveValueDomain
  //


  // Notation_represents_Category
  //


  // entityBound
  //


  // PhysicalDataSet_isDefinedBy_Concept
  //


  // PhysicalDataSet_formats_DataStore
  //


  // PhysicalDataSet_has_InstanceVariable
  //


  // PhysicalDataSet_has_PhysicalRecordSegment
  //


  // PhysicalDataSet_has_PhysicalRecordSegmentPosition
  //


  // PhysicalDataSetStructure_structures_PhysicalDataSet
  //


  // PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship
  //


  // PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout
  //


  // PhysicalLayoutRelationStructure_has_ValueMappingRelationship
  //


  // PhysicalRecordSegment_represents_Population
  //


  // PhysicalRecordSegment_isDefinedBy_Concept
  //


  // PhysicalRecordSegment_has_PhysicalSegmentLayout
  //


  // PhysicalRecordSegment_mapsTo_LogicalRecord
  //


  // PhysicalRecordSegment_has_DataPointPosition
  //


  // PhysicalRecordSegment_has_DataPoint
  //


  // PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment
  //


  // PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment
  //


  // PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment
  //


  // PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment
  //


  // PhysicalRecordSegmentStructure_has_DataPointRelationship
  //


  // PhysicalSegmentLayout_isDefinedBy_Concept
  //


  // PhysicalSegmentLayout_formats_LogicalRecord
  //


  // PhysicalSegmentLayout_has_ValueMapping
  //


  // PhysicalSegmentLayout_has_ValueMappingPosition
  //


  // Population_isComposedOf_Unit
  //


  // PrimaryKey_isComposedOf_PrimaryKeyComponent
  //


  // PrimaryKeyComponent_correspondsTo_DataStructureComponent
  //


  // ProcessingAgent_performs_Activity
  //


  // ProcessingAgent_operatesOn_ProductionEnvironment
  //


  // QualifiedMeasure_refines_MeasureComponent
  //


  // RecordRelation_maps_LogicalRecord
  //


  // RecordRelation_has_InstanceVariableMap
  //


  // ReferenceValue_correspondsTo_VariableValueComponent
  //


  // ReferenceValue_hasValueFrom_ReferenceValueDomain
  //


  // ReferenceVariable_takesValuesFrom_ReferenceValueDomain
  //


  // RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain
  //


  // RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain
  //


  // RevisableDatum_correspondsTo_Revision
  //


  // Rule_hasPrecondition_ConditionalControlLogic
  //


  // RuleBasedScheduling_has_RuleSet
  //


  // RuleBasedScheduling_has_Curator
  //


  // RuleSet_has_Rule
  //


  // ScopedMeasure_circumscribes_DimensionalKeyDefinition
  //


  // ScopedMeasure_restricts_QualifiedMeasure
  //


  // ScopedMeasure_generates_RevisableDatum
  //


  // SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain
  //


  // SentinelValueDomain_takesValuesFrom_EnumerationDomain
  //


  // SentinelValueDomain_isDescribedBy_ValueAndConceptDescription
  //


  // Sequence_has_SequencePosition
  //


  // StatisticalClassification_isMaintainedBy_Organization
  //


  // StatisticalClassification_isIndexedBy_ClassificationIndex
  //


  // StatisticalClassification_isVariantOf_StatisticalClassification
  //


  // StatisticalClassification_isSuccessorOf_StatisticalClassification
  //


  // StatisticalClassification_isPredecessorOf_StatisticalClassification
  //


  // StatisticalClassification_has_ClassificationItemPosition
  //


  // StatisticalClassification_has_ClassificationItem
  //


  // StatisticalClassification_has_LevelStructure
  //


  // StatisticalClassificationRelationship_hasTarget_StatisticalClassification
  //


  // StatisticalClassificationRelationship_hasSource_StatisticalClassification
  //


  // Step_produces_Parameter
  //


  // Step_receives_Parameter
  //


  // Step_hasSubStep_Step
  //


  // SubstantiveValueDomain_takesValuesFrom_EnumerationDomain
  //


  // SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription
  //


  // SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain
  //


  // Unit_has_UnitType
  //


  // ValueMapping_formats_DataPoint
  //


  // ValueMapping_uses_PhysicalSegmentLocation
  //


  // ValueMappingPosition_indexes_ValueMapping
  //


  // ValueMappingRelationship_hasTarget_ValueMapping
  //


  // ValueMappingRelationship_hasSource_ValueMapping
  //


  // VariableCollection_isDefinedBy_Concept
  //


  // VariableCollection_has_ConceptualVariable
  //


  // VariableCollection_has_VariablePosition
  //


  // VariableDescriptorComponent_isDefinedBy_DescriptorVariable
  //


  // VariableDescriptorComponent_refersTo_VariableValueComponent
  //


  // VariablePosition_indexes_ConceptualVariable
  //


  // VariableRelationship_hasTarget_ConceptualVariable
  //


  // VariableRelationship_hasSource_ConceptualVariable
  //


  // VariableStructure_structures_VariableCollection
  //


  // VariableStructure_has_VariableRelationship
  //


  // reference
  //


  // relatedResource
  //


  // entryReference
  //


  // vocabulary
  //


  // licenseReference
  //
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace XMLSchema
{
  // DDICDIModels
  //

  DDICDIModels::
  DDICDIModels ()
  : ::xml_schema::type (),
    Activity_ (this),
    Agent_ (this),
    AgentListing_ (this),
    AgentPosition_ (this),
    AgentRelationship_ (this),
    AgentStructure_ (this),
    AllenIntervalAlgebra_ (this),
    AttributeComponent_ (this),
    AuthorizationSource_ (this),
    Category_ (this),
    CategoryPosition_ (this),
    CategoryRelationStructure_ (this),
    CategoryRelationship_ (this),
    CategorySet_ (this),
    CategoryStatistic_ (this),
    ClassificationFamily_ (this),
    ClassificationIndex_ (this),
    ClassificationIndexEntry_ (this),
    ClassificationIndexEntryPosition_ (this),
    ClassificationItem_ (this),
    ClassificationItemPosition_ (this),
    ClassificationItemRelationship_ (this),
    ClassificationItemStructure_ (this),
    ClassificationPosition_ (this),
    ClassificationSeries_ (this),
    ClassificationSeriesStructure_ (this),
    Code_ (this),
    CodeList_ (this),
    CodeListStructure_ (this),
    CodePosition_ (this),
    CodeRelationship_ (this),
    ComponentPosition_ (this),
    Concept_ (this),
    ConceptMap_ (this),
    ConceptRelationship_ (this),
    ConceptStructure_ (this),
    ConceptSystem_ (this),
    ConceptSystemCorrespondence_ (this),
    ConceptualDomain_ (this),
    ConceptualValue_ (this),
    ConceptualVariable_ (this),
    ConditionalControlLogic_ (this),
    ContextualComponent_ (this),
    ControlLogic_ (this),
    CorrespondenceTable_ (this),
    Curator_ (this),
    DataPoint_ (this),
    DataPointPosition_ (this),
    DataPointRelationship_ (this),
    DataSet_ (this),
    DataStore_ (this),
    DataStructure_ (this),
    DataStructureComponent_ (this),
    Datum_ (this),
    Descriptor_ (this),
    DescriptorValueDomain_ (this),
    DescriptorVariable_ (this),
    DeterministicImperative_ (this),
    DimensionComponent_ (this),
    DimensionGroup_ (this),
    DimensionalDataSet_ (this),
    DimensionalDataStructure_ (this),
    DimensionalKey_ (this),
    DimensionalKeyDefinition_ (this),
    DimensionalKeyDefinitionMember_ (this),
    DimensionalKeyMember_ (this),
    EnumerationDomain_ (this),
    ForeignKey_ (this),
    ForeignKeyComponent_ (this),
    IdentifierComponent_ (this),
    Individual_ (this),
    InformationFlowDefinition_ (this),
    InstanceKey_ (this),
    InstanceValue_ (this),
    InstanceVariable_ (this),
    InstanceVariableMap_ (this),
    Key_ (this),
    KeyDefinition_ (this),
    KeyDefinitionMember_ (this),
    KeyMember_ (this),
    KeyValueDataStore_ (this),
    KeyValueStructure_ (this),
    Level_ (this),
    LevelStructure_ (this),
    LogicalRecord_ (this),
    LogicalRecordPosition_ (this),
    LogicalRecordRelationStructure_ (this),
    LogicalRecordRelationship_ (this),
    LongDataSet_ (this),
    LongDataStructure_ (this),
    LongKey_ (this),
    LongMainKeyMember_ (this),
    Machine_ (this),
    MainKeyMember_ (this),
    MeasureComponent_ (this),
    NonDeterministicDeclarative_ (this),
    Notation_ (this),
    Organization_ (this),
    Parameter_ (this),
    PhysicalDataSet_ (this),
    PhysicalDataSetStructure_ (this),
    PhysicalLayoutRelationStructure_ (this),
    PhysicalRecordSegment_ (this),
    PhysicalRecordSegmentPosition_ (this),
    PhysicalRecordSegmentRelationship_ (this),
    PhysicalRecordSegmentStructure_ (this),
    PhysicalSegmentLayout_ (this),
    PhysicalSegmentLocation_ (this),
    Population_ (this),
    PrimaryKey_ (this),
    PrimaryKeyComponent_ (this),
    ProcessingAgent_ (this),
    ProductionEnvironment_ (this),
    QualifiedMeasure_ (this),
    RecordRelation_ (this),
    ReferenceValue_ (this),
    ReferenceValueDomain_ (this),
    ReferenceVariable_ (this),
    RepresentedVariable_ (this),
    RevisableDatum_ (this),
    Revision_ (this),
    Rule_ (this),
    RuleBasedScheduling_ (this),
    RuleSet_ (this),
    ScopedMeasure_ (this),
    SegmentByText_ (this),
    SentinelConceptualDomain_ (this),
    SentinelValueDomain_ (this),
    Sequence_ (this),
    SequencePosition_ (this),
    Service_ (this),
    StatisticalClassification_ (this),
    StatisticalClassificationRelationship_ (this),
    Step_ (this),
    SubstantiveConceptualDomain_ (this),
    SubstantiveValueDomain_ (this),
    SyntheticIdComponent_ (this),
    TemporalConstraints_ (this),
    TemporalControlConstruct_ (this),
    Unit_ (this),
    UnitSegmentLayout_ (this),
    UnitType_ (this),
    Universe_ (this),
    ValueAndConceptDescription_ (this),
    ValueDomain_ (this),
    ValueMapping_ (this),
    ValueMappingPosition_ (this),
    ValueMappingRelationship_ (this),
    VariableCollection_ (this),
    VariableDescriptorComponent_ (this),
    VariablePosition_ (this),
    VariableRelationship_ (this),
    VariableStructure_ (this),
    VariableValueComponent_ (this),
    WideDataSet_ (this),
    WideDataStructure_ (this),
    WideKey_ (this),
    WideKeyMember_ (this),
    Wrapper_ (this)
  {
  }

  DDICDIModels::
  DDICDIModels (const DDICDIModels& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Activity_ (x.Activity_, f, this),
    Agent_ (x.Agent_, f, this),
    AgentListing_ (x.AgentListing_, f, this),
    AgentPosition_ (x.AgentPosition_, f, this),
    AgentRelationship_ (x.AgentRelationship_, f, this),
    AgentStructure_ (x.AgentStructure_, f, this),
    AllenIntervalAlgebra_ (x.AllenIntervalAlgebra_, f, this),
    AttributeComponent_ (x.AttributeComponent_, f, this),
    AuthorizationSource_ (x.AuthorizationSource_, f, this),
    Category_ (x.Category_, f, this),
    CategoryPosition_ (x.CategoryPosition_, f, this),
    CategoryRelationStructure_ (x.CategoryRelationStructure_, f, this),
    CategoryRelationship_ (x.CategoryRelationship_, f, this),
    CategorySet_ (x.CategorySet_, f, this),
    CategoryStatistic_ (x.CategoryStatistic_, f, this),
    ClassificationFamily_ (x.ClassificationFamily_, f, this),
    ClassificationIndex_ (x.ClassificationIndex_, f, this),
    ClassificationIndexEntry_ (x.ClassificationIndexEntry_, f, this),
    ClassificationIndexEntryPosition_ (x.ClassificationIndexEntryPosition_, f, this),
    ClassificationItem_ (x.ClassificationItem_, f, this),
    ClassificationItemPosition_ (x.ClassificationItemPosition_, f, this),
    ClassificationItemRelationship_ (x.ClassificationItemRelationship_, f, this),
    ClassificationItemStructure_ (x.ClassificationItemStructure_, f, this),
    ClassificationPosition_ (x.ClassificationPosition_, f, this),
    ClassificationSeries_ (x.ClassificationSeries_, f, this),
    ClassificationSeriesStructure_ (x.ClassificationSeriesStructure_, f, this),
    Code_ (x.Code_, f, this),
    CodeList_ (x.CodeList_, f, this),
    CodeListStructure_ (x.CodeListStructure_, f, this),
    CodePosition_ (x.CodePosition_, f, this),
    CodeRelationship_ (x.CodeRelationship_, f, this),
    ComponentPosition_ (x.ComponentPosition_, f, this),
    Concept_ (x.Concept_, f, this),
    ConceptMap_ (x.ConceptMap_, f, this),
    ConceptRelationship_ (x.ConceptRelationship_, f, this),
    ConceptStructure_ (x.ConceptStructure_, f, this),
    ConceptSystem_ (x.ConceptSystem_, f, this),
    ConceptSystemCorrespondence_ (x.ConceptSystemCorrespondence_, f, this),
    ConceptualDomain_ (x.ConceptualDomain_, f, this),
    ConceptualValue_ (x.ConceptualValue_, f, this),
    ConceptualVariable_ (x.ConceptualVariable_, f, this),
    ConditionalControlLogic_ (x.ConditionalControlLogic_, f, this),
    ContextualComponent_ (x.ContextualComponent_, f, this),
    ControlLogic_ (x.ControlLogic_, f, this),
    CorrespondenceTable_ (x.CorrespondenceTable_, f, this),
    Curator_ (x.Curator_, f, this),
    DataPoint_ (x.DataPoint_, f, this),
    DataPointPosition_ (x.DataPointPosition_, f, this),
    DataPointRelationship_ (x.DataPointRelationship_, f, this),
    DataSet_ (x.DataSet_, f, this),
    DataStore_ (x.DataStore_, f, this),
    DataStructure_ (x.DataStructure_, f, this),
    DataStructureComponent_ (x.DataStructureComponent_, f, this),
    Datum_ (x.Datum_, f, this),
    Descriptor_ (x.Descriptor_, f, this),
    DescriptorValueDomain_ (x.DescriptorValueDomain_, f, this),
    DescriptorVariable_ (x.DescriptorVariable_, f, this),
    DeterministicImperative_ (x.DeterministicImperative_, f, this),
    DimensionComponent_ (x.DimensionComponent_, f, this),
    DimensionGroup_ (x.DimensionGroup_, f, this),
    DimensionalDataSet_ (x.DimensionalDataSet_, f, this),
    DimensionalDataStructure_ (x.DimensionalDataStructure_, f, this),
    DimensionalKey_ (x.DimensionalKey_, f, this),
    DimensionalKeyDefinition_ (x.DimensionalKeyDefinition_, f, this),
    DimensionalKeyDefinitionMember_ (x.DimensionalKeyDefinitionMember_, f, this),
    DimensionalKeyMember_ (x.DimensionalKeyMember_, f, this),
    EnumerationDomain_ (x.EnumerationDomain_, f, this),
    ForeignKey_ (x.ForeignKey_, f, this),
    ForeignKeyComponent_ (x.ForeignKeyComponent_, f, this),
    IdentifierComponent_ (x.IdentifierComponent_, f, this),
    Individual_ (x.Individual_, f, this),
    InformationFlowDefinition_ (x.InformationFlowDefinition_, f, this),
    InstanceKey_ (x.InstanceKey_, f, this),
    InstanceValue_ (x.InstanceValue_, f, this),
    InstanceVariable_ (x.InstanceVariable_, f, this),
    InstanceVariableMap_ (x.InstanceVariableMap_, f, this),
    Key_ (x.Key_, f, this),
    KeyDefinition_ (x.KeyDefinition_, f, this),
    KeyDefinitionMember_ (x.KeyDefinitionMember_, f, this),
    KeyMember_ (x.KeyMember_, f, this),
    KeyValueDataStore_ (x.KeyValueDataStore_, f, this),
    KeyValueStructure_ (x.KeyValueStructure_, f, this),
    Level_ (x.Level_, f, this),
    LevelStructure_ (x.LevelStructure_, f, this),
    LogicalRecord_ (x.LogicalRecord_, f, this),
    LogicalRecordPosition_ (x.LogicalRecordPosition_, f, this),
    LogicalRecordRelationStructure_ (x.LogicalRecordRelationStructure_, f, this),
    LogicalRecordRelationship_ (x.LogicalRecordRelationship_, f, this),
    LongDataSet_ (x.LongDataSet_, f, this),
    LongDataStructure_ (x.LongDataStructure_, f, this),
    LongKey_ (x.LongKey_, f, this),
    LongMainKeyMember_ (x.LongMainKeyMember_, f, this),
    Machine_ (x.Machine_, f, this),
    MainKeyMember_ (x.MainKeyMember_, f, this),
    MeasureComponent_ (x.MeasureComponent_, f, this),
    NonDeterministicDeclarative_ (x.NonDeterministicDeclarative_, f, this),
    Notation_ (x.Notation_, f, this),
    Organization_ (x.Organization_, f, this),
    Parameter_ (x.Parameter_, f, this),
    PhysicalDataSet_ (x.PhysicalDataSet_, f, this),
    PhysicalDataSetStructure_ (x.PhysicalDataSetStructure_, f, this),
    PhysicalLayoutRelationStructure_ (x.PhysicalLayoutRelationStructure_, f, this),
    PhysicalRecordSegment_ (x.PhysicalRecordSegment_, f, this),
    PhysicalRecordSegmentPosition_ (x.PhysicalRecordSegmentPosition_, f, this),
    PhysicalRecordSegmentRelationship_ (x.PhysicalRecordSegmentRelationship_, f, this),
    PhysicalRecordSegmentStructure_ (x.PhysicalRecordSegmentStructure_, f, this),
    PhysicalSegmentLayout_ (x.PhysicalSegmentLayout_, f, this),
    PhysicalSegmentLocation_ (x.PhysicalSegmentLocation_, f, this),
    Population_ (x.Population_, f, this),
    PrimaryKey_ (x.PrimaryKey_, f, this),
    PrimaryKeyComponent_ (x.PrimaryKeyComponent_, f, this),
    ProcessingAgent_ (x.ProcessingAgent_, f, this),
    ProductionEnvironment_ (x.ProductionEnvironment_, f, this),
    QualifiedMeasure_ (x.QualifiedMeasure_, f, this),
    RecordRelation_ (x.RecordRelation_, f, this),
    ReferenceValue_ (x.ReferenceValue_, f, this),
    ReferenceValueDomain_ (x.ReferenceValueDomain_, f, this),
    ReferenceVariable_ (x.ReferenceVariable_, f, this),
    RepresentedVariable_ (x.RepresentedVariable_, f, this),
    RevisableDatum_ (x.RevisableDatum_, f, this),
    Revision_ (x.Revision_, f, this),
    Rule_ (x.Rule_, f, this),
    RuleBasedScheduling_ (x.RuleBasedScheduling_, f, this),
    RuleSet_ (x.RuleSet_, f, this),
    ScopedMeasure_ (x.ScopedMeasure_, f, this),
    SegmentByText_ (x.SegmentByText_, f, this),
    SentinelConceptualDomain_ (x.SentinelConceptualDomain_, f, this),
    SentinelValueDomain_ (x.SentinelValueDomain_, f, this),
    Sequence_ (x.Sequence_, f, this),
    SequencePosition_ (x.SequencePosition_, f, this),
    Service_ (x.Service_, f, this),
    StatisticalClassification_ (x.StatisticalClassification_, f, this),
    StatisticalClassificationRelationship_ (x.StatisticalClassificationRelationship_, f, this),
    Step_ (x.Step_, f, this),
    SubstantiveConceptualDomain_ (x.SubstantiveConceptualDomain_, f, this),
    SubstantiveValueDomain_ (x.SubstantiveValueDomain_, f, this),
    SyntheticIdComponent_ (x.SyntheticIdComponent_, f, this),
    TemporalConstraints_ (x.TemporalConstraints_, f, this),
    TemporalControlConstruct_ (x.TemporalControlConstruct_, f, this),
    Unit_ (x.Unit_, f, this),
    UnitSegmentLayout_ (x.UnitSegmentLayout_, f, this),
    UnitType_ (x.UnitType_, f, this),
    Universe_ (x.Universe_, f, this),
    ValueAndConceptDescription_ (x.ValueAndConceptDescription_, f, this),
    ValueDomain_ (x.ValueDomain_, f, this),
    ValueMapping_ (x.ValueMapping_, f, this),
    ValueMappingPosition_ (x.ValueMappingPosition_, f, this),
    ValueMappingRelationship_ (x.ValueMappingRelationship_, f, this),
    VariableCollection_ (x.VariableCollection_, f, this),
    VariableDescriptorComponent_ (x.VariableDescriptorComponent_, f, this),
    VariablePosition_ (x.VariablePosition_, f, this),
    VariableRelationship_ (x.VariableRelationship_, f, this),
    VariableStructure_ (x.VariableStructure_, f, this),
    VariableValueComponent_ (x.VariableValueComponent_, f, this),
    WideDataSet_ (x.WideDataSet_, f, this),
    WideDataStructure_ (x.WideDataStructure_, f, this),
    WideKey_ (x.WideKey_, f, this),
    WideKeyMember_ (x.WideKeyMember_, f, this),
    Wrapper_ (x.Wrapper_, f, this)
  {
  }

  DDICDIModels::
  DDICDIModels (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Activity_ (this),
    Agent_ (this),
    AgentListing_ (this),
    AgentPosition_ (this),
    AgentRelationship_ (this),
    AgentStructure_ (this),
    AllenIntervalAlgebra_ (this),
    AttributeComponent_ (this),
    AuthorizationSource_ (this),
    Category_ (this),
    CategoryPosition_ (this),
    CategoryRelationStructure_ (this),
    CategoryRelationship_ (this),
    CategorySet_ (this),
    CategoryStatistic_ (this),
    ClassificationFamily_ (this),
    ClassificationIndex_ (this),
    ClassificationIndexEntry_ (this),
    ClassificationIndexEntryPosition_ (this),
    ClassificationItem_ (this),
    ClassificationItemPosition_ (this),
    ClassificationItemRelationship_ (this),
    ClassificationItemStructure_ (this),
    ClassificationPosition_ (this),
    ClassificationSeries_ (this),
    ClassificationSeriesStructure_ (this),
    Code_ (this),
    CodeList_ (this),
    CodeListStructure_ (this),
    CodePosition_ (this),
    CodeRelationship_ (this),
    ComponentPosition_ (this),
    Concept_ (this),
    ConceptMap_ (this),
    ConceptRelationship_ (this),
    ConceptStructure_ (this),
    ConceptSystem_ (this),
    ConceptSystemCorrespondence_ (this),
    ConceptualDomain_ (this),
    ConceptualValue_ (this),
    ConceptualVariable_ (this),
    ConditionalControlLogic_ (this),
    ContextualComponent_ (this),
    ControlLogic_ (this),
    CorrespondenceTable_ (this),
    Curator_ (this),
    DataPoint_ (this),
    DataPointPosition_ (this),
    DataPointRelationship_ (this),
    DataSet_ (this),
    DataStore_ (this),
    DataStructure_ (this),
    DataStructureComponent_ (this),
    Datum_ (this),
    Descriptor_ (this),
    DescriptorValueDomain_ (this),
    DescriptorVariable_ (this),
    DeterministicImperative_ (this),
    DimensionComponent_ (this),
    DimensionGroup_ (this),
    DimensionalDataSet_ (this),
    DimensionalDataStructure_ (this),
    DimensionalKey_ (this),
    DimensionalKeyDefinition_ (this),
    DimensionalKeyDefinitionMember_ (this),
    DimensionalKeyMember_ (this),
    EnumerationDomain_ (this),
    ForeignKey_ (this),
    ForeignKeyComponent_ (this),
    IdentifierComponent_ (this),
    Individual_ (this),
    InformationFlowDefinition_ (this),
    InstanceKey_ (this),
    InstanceValue_ (this),
    InstanceVariable_ (this),
    InstanceVariableMap_ (this),
    Key_ (this),
    KeyDefinition_ (this),
    KeyDefinitionMember_ (this),
    KeyMember_ (this),
    KeyValueDataStore_ (this),
    KeyValueStructure_ (this),
    Level_ (this),
    LevelStructure_ (this),
    LogicalRecord_ (this),
    LogicalRecordPosition_ (this),
    LogicalRecordRelationStructure_ (this),
    LogicalRecordRelationship_ (this),
    LongDataSet_ (this),
    LongDataStructure_ (this),
    LongKey_ (this),
    LongMainKeyMember_ (this),
    Machine_ (this),
    MainKeyMember_ (this),
    MeasureComponent_ (this),
    NonDeterministicDeclarative_ (this),
    Notation_ (this),
    Organization_ (this),
    Parameter_ (this),
    PhysicalDataSet_ (this),
    PhysicalDataSetStructure_ (this),
    PhysicalLayoutRelationStructure_ (this),
    PhysicalRecordSegment_ (this),
    PhysicalRecordSegmentPosition_ (this),
    PhysicalRecordSegmentRelationship_ (this),
    PhysicalRecordSegmentStructure_ (this),
    PhysicalSegmentLayout_ (this),
    PhysicalSegmentLocation_ (this),
    Population_ (this),
    PrimaryKey_ (this),
    PrimaryKeyComponent_ (this),
    ProcessingAgent_ (this),
    ProductionEnvironment_ (this),
    QualifiedMeasure_ (this),
    RecordRelation_ (this),
    ReferenceValue_ (this),
    ReferenceValueDomain_ (this),
    ReferenceVariable_ (this),
    RepresentedVariable_ (this),
    RevisableDatum_ (this),
    Revision_ (this),
    Rule_ (this),
    RuleBasedScheduling_ (this),
    RuleSet_ (this),
    ScopedMeasure_ (this),
    SegmentByText_ (this),
    SentinelConceptualDomain_ (this),
    SentinelValueDomain_ (this),
    Sequence_ (this),
    SequencePosition_ (this),
    Service_ (this),
    StatisticalClassification_ (this),
    StatisticalClassificationRelationship_ (this),
    Step_ (this),
    SubstantiveConceptualDomain_ (this),
    SubstantiveValueDomain_ (this),
    SyntheticIdComponent_ (this),
    TemporalConstraints_ (this),
    TemporalControlConstruct_ (this),
    Unit_ (this),
    UnitSegmentLayout_ (this),
    UnitType_ (this),
    Universe_ (this),
    ValueAndConceptDescription_ (this),
    ValueDomain_ (this),
    ValueMapping_ (this),
    ValueMappingPosition_ (this),
    ValueMappingRelationship_ (this),
    VariableCollection_ (this),
    VariableDescriptorComponent_ (this),
    VariablePosition_ (this),
    VariableRelationship_ (this),
    VariableStructure_ (this),
    VariableValueComponent_ (this),
    WideDataSet_ (this),
    WideDataStructure_ (this),
    WideKey_ (this),
    WideKeyMember_ (this),
    Wrapper_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DDICDIModels::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Activity
      //
      if (n.name () == "Activity" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Activity_type > r (
          Activity_traits::create (i, f, this));

        this->Activity_.push_back (::std::move (r));
        continue;
      }

      // Agent
      //
      if (n.name () == "Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Agent_type > r (
          Agent_traits::create (i, f, this));

        this->Agent_.push_back (::std::move (r));
        continue;
      }

      // AgentListing
      //
      if (n.name () == "AgentListing" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentListing_type > r (
          AgentListing_traits::create (i, f, this));

        this->AgentListing_.push_back (::std::move (r));
        continue;
      }

      // AgentPosition
      //
      if (n.name () == "AgentPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentPosition_type > r (
          AgentPosition_traits::create (i, f, this));

        this->AgentPosition_.push_back (::std::move (r));
        continue;
      }

      // AgentRelationship
      //
      if (n.name () == "AgentRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentRelationship_type > r (
          AgentRelationship_traits::create (i, f, this));

        this->AgentRelationship_.push_back (::std::move (r));
        continue;
      }

      // AgentStructure
      //
      if (n.name () == "AgentStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentStructure_type > r (
          AgentStructure_traits::create (i, f, this));

        this->AgentStructure_.push_back (::std::move (r));
        continue;
      }

      // AllenIntervalAlgebra
      //
      if (n.name () == "AllenIntervalAlgebra" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AllenIntervalAlgebra_type > r (
          AllenIntervalAlgebra_traits::create (i, f, this));

        this->AllenIntervalAlgebra_.push_back (::std::move (r));
        continue;
      }

      // AttributeComponent
      //
      if (n.name () == "AttributeComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AttributeComponent_type > r (
          AttributeComponent_traits::create (i, f, this));

        this->AttributeComponent_.push_back (::std::move (r));
        continue;
      }

      // AuthorizationSource
      //
      if (n.name () == "AuthorizationSource" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AuthorizationSource_type > r (
          AuthorizationSource_traits::create (i, f, this));

        this->AuthorizationSource_.push_back (::std::move (r));
        continue;
      }

      // Category
      //
      if (n.name () == "Category" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Category_type > r (
          Category_traits::create (i, f, this));

        this->Category_.push_back (::std::move (r));
        continue;
      }

      // CategoryPosition
      //
      if (n.name () == "CategoryPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryPosition_type > r (
          CategoryPosition_traits::create (i, f, this));

        this->CategoryPosition_.push_back (::std::move (r));
        continue;
      }

      // CategoryRelationStructure
      //
      if (n.name () == "CategoryRelationStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryRelationStructure_type > r (
          CategoryRelationStructure_traits::create (i, f, this));

        this->CategoryRelationStructure_.push_back (::std::move (r));
        continue;
      }

      // CategoryRelationship
      //
      if (n.name () == "CategoryRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryRelationship_type > r (
          CategoryRelationship_traits::create (i, f, this));

        this->CategoryRelationship_.push_back (::std::move (r));
        continue;
      }

      // CategorySet
      //
      if (n.name () == "CategorySet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategorySet_type > r (
          CategorySet_traits::create (i, f, this));

        this->CategorySet_.push_back (::std::move (r));
        continue;
      }

      // CategoryStatistic
      //
      if (n.name () == "CategoryStatistic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryStatistic_type > r (
          CategoryStatistic_traits::create (i, f, this));

        this->CategoryStatistic_.push_back (::std::move (r));
        continue;
      }

      // ClassificationFamily
      //
      if (n.name () == "ClassificationFamily" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationFamily_type > r (
          ClassificationFamily_traits::create (i, f, this));

        this->ClassificationFamily_.push_back (::std::move (r));
        continue;
      }

      // ClassificationIndex
      //
      if (n.name () == "ClassificationIndex" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationIndex_type > r (
          ClassificationIndex_traits::create (i, f, this));

        this->ClassificationIndex_.push_back (::std::move (r));
        continue;
      }

      // ClassificationIndexEntry
      //
      if (n.name () == "ClassificationIndexEntry" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationIndexEntry_type > r (
          ClassificationIndexEntry_traits::create (i, f, this));

        this->ClassificationIndexEntry_.push_back (::std::move (r));
        continue;
      }

      // ClassificationIndexEntryPosition
      //
      if (n.name () == "ClassificationIndexEntryPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationIndexEntryPosition_type > r (
          ClassificationIndexEntryPosition_traits::create (i, f, this));

        this->ClassificationIndexEntryPosition_.push_back (::std::move (r));
        continue;
      }

      // ClassificationItem
      //
      if (n.name () == "ClassificationItem" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItem_type > r (
          ClassificationItem_traits::create (i, f, this));

        this->ClassificationItem_.push_back (::std::move (r));
        continue;
      }

      // ClassificationItemPosition
      //
      if (n.name () == "ClassificationItemPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItemPosition_type > r (
          ClassificationItemPosition_traits::create (i, f, this));

        this->ClassificationItemPosition_.push_back (::std::move (r));
        continue;
      }

      // ClassificationItemRelationship
      //
      if (n.name () == "ClassificationItemRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItemRelationship_type > r (
          ClassificationItemRelationship_traits::create (i, f, this));

        this->ClassificationItemRelationship_.push_back (::std::move (r));
        continue;
      }

      // ClassificationItemStructure
      //
      if (n.name () == "ClassificationItemStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItemStructure_type > r (
          ClassificationItemStructure_traits::create (i, f, this));

        this->ClassificationItemStructure_.push_back (::std::move (r));
        continue;
      }

      // ClassificationPosition
      //
      if (n.name () == "ClassificationPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationPosition_type > r (
          ClassificationPosition_traits::create (i, f, this));

        this->ClassificationPosition_.push_back (::std::move (r));
        continue;
      }

      // ClassificationSeries
      //
      if (n.name () == "ClassificationSeries" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationSeries_type > r (
          ClassificationSeries_traits::create (i, f, this));

        this->ClassificationSeries_.push_back (::std::move (r));
        continue;
      }

      // ClassificationSeriesStructure
      //
      if (n.name () == "ClassificationSeriesStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationSeriesStructure_type > r (
          ClassificationSeriesStructure_traits::create (i, f, this));

        this->ClassificationSeriesStructure_.push_back (::std::move (r));
        continue;
      }

      // Code
      //
      if (n.name () == "Code" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Code_type > r (
          Code_traits::create (i, f, this));

        this->Code_.push_back (::std::move (r));
        continue;
      }

      // CodeList
      //
      if (n.name () == "CodeList" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodeList_type > r (
          CodeList_traits::create (i, f, this));

        this->CodeList_.push_back (::std::move (r));
        continue;
      }

      // CodeListStructure
      //
      if (n.name () == "CodeListStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodeListStructure_type > r (
          CodeListStructure_traits::create (i, f, this));

        this->CodeListStructure_.push_back (::std::move (r));
        continue;
      }

      // CodePosition
      //
      if (n.name () == "CodePosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodePosition_type > r (
          CodePosition_traits::create (i, f, this));

        this->CodePosition_.push_back (::std::move (r));
        continue;
      }

      // CodeRelationship
      //
      if (n.name () == "CodeRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodeRelationship_type > r (
          CodeRelationship_traits::create (i, f, this));

        this->CodeRelationship_.push_back (::std::move (r));
        continue;
      }

      // ComponentPosition
      //
      if (n.name () == "ComponentPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ComponentPosition_type > r (
          ComponentPosition_traits::create (i, f, this));

        this->ComponentPosition_.push_back (::std::move (r));
        continue;
      }

      // Concept
      //
      if (n.name () == "Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Concept_type > r (
          Concept_traits::create (i, f, this));

        this->Concept_.push_back (::std::move (r));
        continue;
      }

      // ConceptMap
      //
      if (n.name () == "ConceptMap" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptMap_type > r (
          ConceptMap_traits::create (i, f, this));

        this->ConceptMap_.push_back (::std::move (r));
        continue;
      }

      // ConceptRelationship
      //
      if (n.name () == "ConceptRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptRelationship_type > r (
          ConceptRelationship_traits::create (i, f, this));

        this->ConceptRelationship_.push_back (::std::move (r));
        continue;
      }

      // ConceptStructure
      //
      if (n.name () == "ConceptStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptStructure_type > r (
          ConceptStructure_traits::create (i, f, this));

        this->ConceptStructure_.push_back (::std::move (r));
        continue;
      }

      // ConceptSystem
      //
      if (n.name () == "ConceptSystem" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptSystem_type > r (
          ConceptSystem_traits::create (i, f, this));

        this->ConceptSystem_.push_back (::std::move (r));
        continue;
      }

      // ConceptSystemCorrespondence
      //
      if (n.name () == "ConceptSystemCorrespondence" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptSystemCorrespondence_type > r (
          ConceptSystemCorrespondence_traits::create (i, f, this));

        this->ConceptSystemCorrespondence_.push_back (::std::move (r));
        continue;
      }

      // ConceptualDomain
      //
      if (n.name () == "ConceptualDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptualDomain_type > r (
          ConceptualDomain_traits::create (i, f, this));

        this->ConceptualDomain_.push_back (::std::move (r));
        continue;
      }

      // ConceptualValue
      //
      if (n.name () == "ConceptualValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptualValue_type > r (
          ConceptualValue_traits::create (i, f, this));

        this->ConceptualValue_.push_back (::std::move (r));
        continue;
      }

      // ConceptualVariable
      //
      if (n.name () == "ConceptualVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptualVariable_type > r (
          ConceptualVariable_traits::create (i, f, this));

        this->ConceptualVariable_.push_back (::std::move (r));
        continue;
      }

      // ConditionalControlLogic
      //
      if (n.name () == "ConditionalControlLogic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConditionalControlLogic_type > r (
          ConditionalControlLogic_traits::create (i, f, this));

        this->ConditionalControlLogic_.push_back (::std::move (r));
        continue;
      }

      // ContextualComponent
      //
      if (n.name () == "ContextualComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ContextualComponent_type > r (
          ContextualComponent_traits::create (i, f, this));

        this->ContextualComponent_.push_back (::std::move (r));
        continue;
      }

      // ControlLogic
      //
      if (n.name () == "ControlLogic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ControlLogic_type > r (
          ControlLogic_traits::create (i, f, this));

        this->ControlLogic_.push_back (::std::move (r));
        continue;
      }

      // CorrespondenceTable
      //
      if (n.name () == "CorrespondenceTable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CorrespondenceTable_type > r (
          CorrespondenceTable_traits::create (i, f, this));

        this->CorrespondenceTable_.push_back (::std::move (r));
        continue;
      }

      // Curator
      //
      if (n.name () == "Curator" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Curator_type > r (
          Curator_traits::create (i, f, this));

        this->Curator_.push_back (::std::move (r));
        continue;
      }

      // DataPoint
      //
      if (n.name () == "DataPoint" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataPoint_type > r (
          DataPoint_traits::create (i, f, this));

        this->DataPoint_.push_back (::std::move (r));
        continue;
      }

      // DataPointPosition
      //
      if (n.name () == "DataPointPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataPointPosition_type > r (
          DataPointPosition_traits::create (i, f, this));

        this->DataPointPosition_.push_back (::std::move (r));
        continue;
      }

      // DataPointRelationship
      //
      if (n.name () == "DataPointRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataPointRelationship_type > r (
          DataPointRelationship_traits::create (i, f, this));

        this->DataPointRelationship_.push_back (::std::move (r));
        continue;
      }

      // DataSet
      //
      if (n.name () == "DataSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataSet_type > r (
          DataSet_traits::create (i, f, this));

        this->DataSet_.push_back (::std::move (r));
        continue;
      }

      // DataStore
      //
      if (n.name () == "DataStore" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStore_type > r (
          DataStore_traits::create (i, f, this));

        this->DataStore_.push_back (::std::move (r));
        continue;
      }

      // DataStructure
      //
      if (n.name () == "DataStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStructure_type > r (
          DataStructure_traits::create (i, f, this));

        this->DataStructure_.push_back (::std::move (r));
        continue;
      }

      // DataStructureComponent
      //
      if (n.name () == "DataStructureComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStructureComponent_type > r (
          DataStructureComponent_traits::create (i, f, this));

        this->DataStructureComponent_.push_back (::std::move (r));
        continue;
      }

      // Datum
      //
      if (n.name () == "Datum" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Datum_type > r (
          Datum_traits::create (i, f, this));

        this->Datum_.push_back (::std::move (r));
        continue;
      }

      // Descriptor
      //
      if (n.name () == "Descriptor" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Descriptor_type > r (
          Descriptor_traits::create (i, f, this));

        this->Descriptor_.push_back (::std::move (r));
        continue;
      }

      // DescriptorValueDomain
      //
      if (n.name () == "DescriptorValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DescriptorValueDomain_type > r (
          DescriptorValueDomain_traits::create (i, f, this));

        this->DescriptorValueDomain_.push_back (::std::move (r));
        continue;
      }

      // DescriptorVariable
      //
      if (n.name () == "DescriptorVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DescriptorVariable_type > r (
          DescriptorVariable_traits::create (i, f, this));

        this->DescriptorVariable_.push_back (::std::move (r));
        continue;
      }

      // DeterministicImperative
      //
      if (n.name () == "DeterministicImperative" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DeterministicImperative_type > r (
          DeterministicImperative_traits::create (i, f, this));

        this->DeterministicImperative_.push_back (::std::move (r));
        continue;
      }

      // DimensionComponent
      //
      if (n.name () == "DimensionComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionComponent_type > r (
          DimensionComponent_traits::create (i, f, this));

        this->DimensionComponent_.push_back (::std::move (r));
        continue;
      }

      // DimensionGroup
      //
      if (n.name () == "DimensionGroup" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionGroup_type > r (
          DimensionGroup_traits::create (i, f, this));

        this->DimensionGroup_.push_back (::std::move (r));
        continue;
      }

      // DimensionalDataSet
      //
      if (n.name () == "DimensionalDataSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalDataSet_type > r (
          DimensionalDataSet_traits::create (i, f, this));

        this->DimensionalDataSet_.push_back (::std::move (r));
        continue;
      }

      // DimensionalDataStructure
      //
      if (n.name () == "DimensionalDataStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalDataStructure_type > r (
          DimensionalDataStructure_traits::create (i, f, this));

        this->DimensionalDataStructure_.push_back (::std::move (r));
        continue;
      }

      // DimensionalKey
      //
      if (n.name () == "DimensionalKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalKey_type > r (
          DimensionalKey_traits::create (i, f, this));

        this->DimensionalKey_.push_back (::std::move (r));
        continue;
      }

      // DimensionalKeyDefinition
      //
      if (n.name () == "DimensionalKeyDefinition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalKeyDefinition_type > r (
          DimensionalKeyDefinition_traits::create (i, f, this));

        this->DimensionalKeyDefinition_.push_back (::std::move (r));
        continue;
      }

      // DimensionalKeyDefinitionMember
      //
      if (n.name () == "DimensionalKeyDefinitionMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalKeyDefinitionMember_type > r (
          DimensionalKeyDefinitionMember_traits::create (i, f, this));

        this->DimensionalKeyDefinitionMember_.push_back (::std::move (r));
        continue;
      }

      // DimensionalKeyMember
      //
      if (n.name () == "DimensionalKeyMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalKeyMember_type > r (
          DimensionalKeyMember_traits::create (i, f, this));

        this->DimensionalKeyMember_.push_back (::std::move (r));
        continue;
      }

      // EnumerationDomain
      //
      if (n.name () == "EnumerationDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< EnumerationDomain_type > r (
          EnumerationDomain_traits::create (i, f, this));

        this->EnumerationDomain_.push_back (::std::move (r));
        continue;
      }

      // ForeignKey
      //
      if (n.name () == "ForeignKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ForeignKey_type > r (
          ForeignKey_traits::create (i, f, this));

        this->ForeignKey_.push_back (::std::move (r));
        continue;
      }

      // ForeignKeyComponent
      //
      if (n.name () == "ForeignKeyComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ForeignKeyComponent_type > r (
          ForeignKeyComponent_traits::create (i, f, this));

        this->ForeignKeyComponent_.push_back (::std::move (r));
        continue;
      }

      // IdentifierComponent
      //
      if (n.name () == "IdentifierComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< IdentifierComponent_type > r (
          IdentifierComponent_traits::create (i, f, this));

        this->IdentifierComponent_.push_back (::std::move (r));
        continue;
      }

      // Individual
      //
      if (n.name () == "Individual" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Individual_type > r (
          Individual_traits::create (i, f, this));

        this->Individual_.push_back (::std::move (r));
        continue;
      }

      // InformationFlowDefinition
      //
      if (n.name () == "InformationFlowDefinition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InformationFlowDefinition_type > r (
          InformationFlowDefinition_traits::create (i, f, this));

        this->InformationFlowDefinition_.push_back (::std::move (r));
        continue;
      }

      // InstanceKey
      //
      if (n.name () == "InstanceKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceKey_type > r (
          InstanceKey_traits::create (i, f, this));

        this->InstanceKey_.push_back (::std::move (r));
        continue;
      }

      // InstanceValue
      //
      if (n.name () == "InstanceValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceValue_type > r (
          InstanceValue_traits::create (i, f, this));

        this->InstanceValue_.push_back (::std::move (r));
        continue;
      }

      // InstanceVariable
      //
      if (n.name () == "InstanceVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceVariable_type > r (
          InstanceVariable_traits::create (i, f, this));

        this->InstanceVariable_.push_back (::std::move (r));
        continue;
      }

      // InstanceVariableMap
      //
      if (n.name () == "InstanceVariableMap" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceVariableMap_type > r (
          InstanceVariableMap_traits::create (i, f, this));

        this->InstanceVariableMap_.push_back (::std::move (r));
        continue;
      }

      // Key
      //
      if (n.name () == "Key" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Key_type > r (
          Key_traits::create (i, f, this));

        this->Key_.push_back (::std::move (r));
        continue;
      }

      // KeyDefinition
      //
      if (n.name () == "KeyDefinition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyDefinition_type > r (
          KeyDefinition_traits::create (i, f, this));

        this->KeyDefinition_.push_back (::std::move (r));
        continue;
      }

      // KeyDefinitionMember
      //
      if (n.name () == "KeyDefinitionMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyDefinitionMember_type > r (
          KeyDefinitionMember_traits::create (i, f, this));

        this->KeyDefinitionMember_.push_back (::std::move (r));
        continue;
      }

      // KeyMember
      //
      if (n.name () == "KeyMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyMember_type > r (
          KeyMember_traits::create (i, f, this));

        this->KeyMember_.push_back (::std::move (r));
        continue;
      }

      // KeyValueDataStore
      //
      if (n.name () == "KeyValueDataStore" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyValueDataStore_type > r (
          KeyValueDataStore_traits::create (i, f, this));

        this->KeyValueDataStore_.push_back (::std::move (r));
        continue;
      }

      // KeyValueStructure
      //
      if (n.name () == "KeyValueStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyValueStructure_type > r (
          KeyValueStructure_traits::create (i, f, this));

        this->KeyValueStructure_.push_back (::std::move (r));
        continue;
      }

      // Level
      //
      if (n.name () == "Level" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Level_type > r (
          Level_traits::create (i, f, this));

        this->Level_.push_back (::std::move (r));
        continue;
      }

      // LevelStructure
      //
      if (n.name () == "LevelStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LevelStructure_type > r (
          LevelStructure_traits::create (i, f, this));

        this->LevelStructure_.push_back (::std::move (r));
        continue;
      }

      // LogicalRecord
      //
      if (n.name () == "LogicalRecord" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecord_type > r (
          LogicalRecord_traits::create (i, f, this));

        this->LogicalRecord_.push_back (::std::move (r));
        continue;
      }

      // LogicalRecordPosition
      //
      if (n.name () == "LogicalRecordPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecordPosition_type > r (
          LogicalRecordPosition_traits::create (i, f, this));

        this->LogicalRecordPosition_.push_back (::std::move (r));
        continue;
      }

      // LogicalRecordRelationStructure
      //
      if (n.name () == "LogicalRecordRelationStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecordRelationStructure_type > r (
          LogicalRecordRelationStructure_traits::create (i, f, this));

        this->LogicalRecordRelationStructure_.push_back (::std::move (r));
        continue;
      }

      // LogicalRecordRelationship
      //
      if (n.name () == "LogicalRecordRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecordRelationship_type > r (
          LogicalRecordRelationship_traits::create (i, f, this));

        this->LogicalRecordRelationship_.push_back (::std::move (r));
        continue;
      }

      // LongDataSet
      //
      if (n.name () == "LongDataSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LongDataSet_type > r (
          LongDataSet_traits::create (i, f, this));

        this->LongDataSet_.push_back (::std::move (r));
        continue;
      }

      // LongDataStructure
      //
      if (n.name () == "LongDataStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LongDataStructure_type > r (
          LongDataStructure_traits::create (i, f, this));

        this->LongDataStructure_.push_back (::std::move (r));
        continue;
      }

      // LongKey
      //
      if (n.name () == "LongKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LongKey_type > r (
          LongKey_traits::create (i, f, this));

        this->LongKey_.push_back (::std::move (r));
        continue;
      }

      // LongMainKeyMember
      //
      if (n.name () == "LongMainKeyMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LongMainKeyMember_type > r (
          LongMainKeyMember_traits::create (i, f, this));

        this->LongMainKeyMember_.push_back (::std::move (r));
        continue;
      }

      // Machine
      //
      if (n.name () == "Machine" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Machine_type > r (
          Machine_traits::create (i, f, this));

        this->Machine_.push_back (::std::move (r));
        continue;
      }

      // MainKeyMember
      //
      if (n.name () == "MainKeyMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< MainKeyMember_type > r (
          MainKeyMember_traits::create (i, f, this));

        this->MainKeyMember_.push_back (::std::move (r));
        continue;
      }

      // MeasureComponent
      //
      if (n.name () == "MeasureComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< MeasureComponent_type > r (
          MeasureComponent_traits::create (i, f, this));

        this->MeasureComponent_.push_back (::std::move (r));
        continue;
      }

      // NonDeterministicDeclarative
      //
      if (n.name () == "NonDeterministicDeclarative" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< NonDeterministicDeclarative_type > r (
          NonDeterministicDeclarative_traits::create (i, f, this));

        this->NonDeterministicDeclarative_.push_back (::std::move (r));
        continue;
      }

      // Notation
      //
      if (n.name () == "Notation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Notation_type > r (
          Notation_traits::create (i, f, this));

        this->Notation_.push_back (::std::move (r));
        continue;
      }

      // Organization
      //
      if (n.name () == "Organization" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Organization_type > r (
          Organization_traits::create (i, f, this));

        this->Organization_.push_back (::std::move (r));
        continue;
      }

      // Parameter
      //
      if (n.name () == "Parameter" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Parameter_type > r (
          Parameter_traits::create (i, f, this));

        this->Parameter_.push_back (::std::move (r));
        continue;
      }

      // PhysicalDataSet
      //
      if (n.name () == "PhysicalDataSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalDataSet_type > r (
          PhysicalDataSet_traits::create (i, f, this));

        this->PhysicalDataSet_.push_back (::std::move (r));
        continue;
      }

      // PhysicalDataSetStructure
      //
      if (n.name () == "PhysicalDataSetStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalDataSetStructure_type > r (
          PhysicalDataSetStructure_traits::create (i, f, this));

        this->PhysicalDataSetStructure_.push_back (::std::move (r));
        continue;
      }

      // PhysicalLayoutRelationStructure
      //
      if (n.name () == "PhysicalLayoutRelationStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalLayoutRelationStructure_type > r (
          PhysicalLayoutRelationStructure_traits::create (i, f, this));

        this->PhysicalLayoutRelationStructure_.push_back (::std::move (r));
        continue;
      }

      // PhysicalRecordSegment
      //
      if (n.name () == "PhysicalRecordSegment" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegment_type > r (
          PhysicalRecordSegment_traits::create (i, f, this));

        this->PhysicalRecordSegment_.push_back (::std::move (r));
        continue;
      }

      // PhysicalRecordSegmentPosition
      //
      if (n.name () == "PhysicalRecordSegmentPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegmentPosition_type > r (
          PhysicalRecordSegmentPosition_traits::create (i, f, this));

        this->PhysicalRecordSegmentPosition_.push_back (::std::move (r));
        continue;
      }

      // PhysicalRecordSegmentRelationship
      //
      if (n.name () == "PhysicalRecordSegmentRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegmentRelationship_type > r (
          PhysicalRecordSegmentRelationship_traits::create (i, f, this));

        this->PhysicalRecordSegmentRelationship_.push_back (::std::move (r));
        continue;
      }

      // PhysicalRecordSegmentStructure
      //
      if (n.name () == "PhysicalRecordSegmentStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegmentStructure_type > r (
          PhysicalRecordSegmentStructure_traits::create (i, f, this));

        this->PhysicalRecordSegmentStructure_.push_back (::std::move (r));
        continue;
      }

      // PhysicalSegmentLayout
      //
      if (n.name () == "PhysicalSegmentLayout" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalSegmentLayout_type > r (
          PhysicalSegmentLayout_traits::create (i, f, this));

        this->PhysicalSegmentLayout_.push_back (::std::move (r));
        continue;
      }

      // PhysicalSegmentLocation
      //
      if (n.name () == "PhysicalSegmentLocation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalSegmentLocation_type > r (
          PhysicalSegmentLocation_traits::create (i, f, this));

        this->PhysicalSegmentLocation_.push_back (::std::move (r));
        continue;
      }

      // Population
      //
      if (n.name () == "Population" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Population_type > r (
          Population_traits::create (i, f, this));

        this->Population_.push_back (::std::move (r));
        continue;
      }

      // PrimaryKey
      //
      if (n.name () == "PrimaryKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PrimaryKey_type > r (
          PrimaryKey_traits::create (i, f, this));

        this->PrimaryKey_.push_back (::std::move (r));
        continue;
      }

      // PrimaryKeyComponent
      //
      if (n.name () == "PrimaryKeyComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PrimaryKeyComponent_type > r (
          PrimaryKeyComponent_traits::create (i, f, this));

        this->PrimaryKeyComponent_.push_back (::std::move (r));
        continue;
      }

      // ProcessingAgent
      //
      if (n.name () == "ProcessingAgent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ProcessingAgent_type > r (
          ProcessingAgent_traits::create (i, f, this));

        this->ProcessingAgent_.push_back (::std::move (r));
        continue;
      }

      // ProductionEnvironment
      //
      if (n.name () == "ProductionEnvironment" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ProductionEnvironment_type > r (
          ProductionEnvironment_traits::create (i, f, this));

        this->ProductionEnvironment_.push_back (::std::move (r));
        continue;
      }

      // QualifiedMeasure
      //
      if (n.name () == "QualifiedMeasure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< QualifiedMeasure_type > r (
          QualifiedMeasure_traits::create (i, f, this));

        this->QualifiedMeasure_.push_back (::std::move (r));
        continue;
      }

      // RecordRelation
      //
      if (n.name () == "RecordRelation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RecordRelation_type > r (
          RecordRelation_traits::create (i, f, this));

        this->RecordRelation_.push_back (::std::move (r));
        continue;
      }

      // ReferenceValue
      //
      if (n.name () == "ReferenceValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ReferenceValue_type > r (
          ReferenceValue_traits::create (i, f, this));

        this->ReferenceValue_.push_back (::std::move (r));
        continue;
      }

      // ReferenceValueDomain
      //
      if (n.name () == "ReferenceValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ReferenceValueDomain_type > r (
          ReferenceValueDomain_traits::create (i, f, this));

        this->ReferenceValueDomain_.push_back (::std::move (r));
        continue;
      }

      // ReferenceVariable
      //
      if (n.name () == "ReferenceVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ReferenceVariable_type > r (
          ReferenceVariable_traits::create (i, f, this));

        this->ReferenceVariable_.push_back (::std::move (r));
        continue;
      }

      // RepresentedVariable
      //
      if (n.name () == "RepresentedVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RepresentedVariable_type > r (
          RepresentedVariable_traits::create (i, f, this));

        this->RepresentedVariable_.push_back (::std::move (r));
        continue;
      }

      // RevisableDatum
      //
      if (n.name () == "RevisableDatum" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RevisableDatum_type > r (
          RevisableDatum_traits::create (i, f, this));

        this->RevisableDatum_.push_back (::std::move (r));
        continue;
      }

      // Revision
      //
      if (n.name () == "Revision" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Revision_type > r (
          Revision_traits::create (i, f, this));

        this->Revision_.push_back (::std::move (r));
        continue;
      }

      // Rule
      //
      if (n.name () == "Rule" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Rule_type > r (
          Rule_traits::create (i, f, this));

        this->Rule_.push_back (::std::move (r));
        continue;
      }

      // RuleBasedScheduling
      //
      if (n.name () == "RuleBasedScheduling" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RuleBasedScheduling_type > r (
          RuleBasedScheduling_traits::create (i, f, this));

        this->RuleBasedScheduling_.push_back (::std::move (r));
        continue;
      }

      // RuleSet
      //
      if (n.name () == "RuleSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RuleSet_type > r (
          RuleSet_traits::create (i, f, this));

        this->RuleSet_.push_back (::std::move (r));
        continue;
      }

      // ScopedMeasure
      //
      if (n.name () == "ScopedMeasure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ScopedMeasure_type > r (
          ScopedMeasure_traits::create (i, f, this));

        this->ScopedMeasure_.push_back (::std::move (r));
        continue;
      }

      // SegmentByText
      //
      if (n.name () == "SegmentByText" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SegmentByText_type > r (
          SegmentByText_traits::create (i, f, this));

        this->SegmentByText_.push_back (::std::move (r));
        continue;
      }

      // SentinelConceptualDomain
      //
      if (n.name () == "SentinelConceptualDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SentinelConceptualDomain_type > r (
          SentinelConceptualDomain_traits::create (i, f, this));

        this->SentinelConceptualDomain_.push_back (::std::move (r));
        continue;
      }

      // SentinelValueDomain
      //
      if (n.name () == "SentinelValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SentinelValueDomain_type > r (
          SentinelValueDomain_traits::create (i, f, this));

        this->SentinelValueDomain_.push_back (::std::move (r));
        continue;
      }

      // Sequence
      //
      if (n.name () == "Sequence" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Sequence_type > r (
          Sequence_traits::create (i, f, this));

        this->Sequence_.push_back (::std::move (r));
        continue;
      }

      // SequencePosition
      //
      if (n.name () == "SequencePosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SequencePosition_type > r (
          SequencePosition_traits::create (i, f, this));

        this->SequencePosition_.push_back (::std::move (r));
        continue;
      }

      // Service
      //
      if (n.name () == "Service" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Service_type > r (
          Service_traits::create (i, f, this));

        this->Service_.push_back (::std::move (r));
        continue;
      }

      // StatisticalClassification
      //
      if (n.name () == "StatisticalClassification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassification_type > r (
          StatisticalClassification_traits::create (i, f, this));

        this->StatisticalClassification_.push_back (::std::move (r));
        continue;
      }

      // StatisticalClassificationRelationship
      //
      if (n.name () == "StatisticalClassificationRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassificationRelationship_type > r (
          StatisticalClassificationRelationship_traits::create (i, f, this));

        this->StatisticalClassificationRelationship_.push_back (::std::move (r));
        continue;
      }

      // Step
      //
      if (n.name () == "Step" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Step_type > r (
          Step_traits::create (i, f, this));

        this->Step_.push_back (::std::move (r));
        continue;
      }

      // SubstantiveConceptualDomain
      //
      if (n.name () == "SubstantiveConceptualDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SubstantiveConceptualDomain_type > r (
          SubstantiveConceptualDomain_traits::create (i, f, this));

        this->SubstantiveConceptualDomain_.push_back (::std::move (r));
        continue;
      }

      // SubstantiveValueDomain
      //
      if (n.name () == "SubstantiveValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SubstantiveValueDomain_type > r (
          SubstantiveValueDomain_traits::create (i, f, this));

        this->SubstantiveValueDomain_.push_back (::std::move (r));
        continue;
      }

      // SyntheticIdComponent
      //
      if (n.name () == "SyntheticIdComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SyntheticIdComponent_type > r (
          SyntheticIdComponent_traits::create (i, f, this));

        this->SyntheticIdComponent_.push_back (::std::move (r));
        continue;
      }

      // TemporalConstraints
      //
      if (n.name () == "TemporalConstraints" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< TemporalConstraints_type > r (
          TemporalConstraints_traits::create (i, f, this));

        this->TemporalConstraints_.push_back (::std::move (r));
        continue;
      }

      // TemporalControlConstruct
      //
      if (n.name () == "TemporalControlConstruct" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< TemporalControlConstruct_type > r (
          TemporalControlConstruct_traits::create (i, f, this));

        this->TemporalControlConstruct_.push_back (::std::move (r));
        continue;
      }

      // Unit
      //
      if (n.name () == "Unit" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Unit_type > r (
          Unit_traits::create (i, f, this));

        this->Unit_.push_back (::std::move (r));
        continue;
      }

      // UnitSegmentLayout
      //
      if (n.name () == "UnitSegmentLayout" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< UnitSegmentLayout_type > r (
          UnitSegmentLayout_traits::create (i, f, this));

        this->UnitSegmentLayout_.push_back (::std::move (r));
        continue;
      }

      // UnitType
      //
      if (n.name () == "UnitType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< UnitType_type > r (
          UnitType_traits::create (i, f, this));

        this->UnitType_.push_back (::std::move (r));
        continue;
      }

      // Universe
      //
      if (n.name () == "Universe" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Universe_type > r (
          Universe_traits::create (i, f, this));

        this->Universe_.push_back (::std::move (r));
        continue;
      }

      // ValueAndConceptDescription
      //
      if (n.name () == "ValueAndConceptDescription" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueAndConceptDescription_type > r (
          ValueAndConceptDescription_traits::create (i, f, this));

        this->ValueAndConceptDescription_.push_back (::std::move (r));
        continue;
      }

      // ValueDomain
      //
      if (n.name () == "ValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueDomain_type > r (
          ValueDomain_traits::create (i, f, this));

        this->ValueDomain_.push_back (::std::move (r));
        continue;
      }

      // ValueMapping
      //
      if (n.name () == "ValueMapping" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueMapping_type > r (
          ValueMapping_traits::create (i, f, this));

        this->ValueMapping_.push_back (::std::move (r));
        continue;
      }

      // ValueMappingPosition
      //
      if (n.name () == "ValueMappingPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueMappingPosition_type > r (
          ValueMappingPosition_traits::create (i, f, this));

        this->ValueMappingPosition_.push_back (::std::move (r));
        continue;
      }

      // ValueMappingRelationship
      //
      if (n.name () == "ValueMappingRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueMappingRelationship_type > r (
          ValueMappingRelationship_traits::create (i, f, this));

        this->ValueMappingRelationship_.push_back (::std::move (r));
        continue;
      }

      // VariableCollection
      //
      if (n.name () == "VariableCollection" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableCollection_type > r (
          VariableCollection_traits::create (i, f, this));

        this->VariableCollection_.push_back (::std::move (r));
        continue;
      }

      // VariableDescriptorComponent
      //
      if (n.name () == "VariableDescriptorComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableDescriptorComponent_type > r (
          VariableDescriptorComponent_traits::create (i, f, this));

        this->VariableDescriptorComponent_.push_back (::std::move (r));
        continue;
      }

      // VariablePosition
      //
      if (n.name () == "VariablePosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariablePosition_type > r (
          VariablePosition_traits::create (i, f, this));

        this->VariablePosition_.push_back (::std::move (r));
        continue;
      }

      // VariableRelationship
      //
      if (n.name () == "VariableRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableRelationship_type > r (
          VariableRelationship_traits::create (i, f, this));

        this->VariableRelationship_.push_back (::std::move (r));
        continue;
      }

      // VariableStructure
      //
      if (n.name () == "VariableStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableStructure_type > r (
          VariableStructure_traits::create (i, f, this));

        this->VariableStructure_.push_back (::std::move (r));
        continue;
      }

      // VariableValueComponent
      //
      if (n.name () == "VariableValueComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableValueComponent_type > r (
          VariableValueComponent_traits::create (i, f, this));

        this->VariableValueComponent_.push_back (::std::move (r));
        continue;
      }

      // WideDataSet
      //
      if (n.name () == "WideDataSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< WideDataSet_type > r (
          WideDataSet_traits::create (i, f, this));

        this->WideDataSet_.push_back (::std::move (r));
        continue;
      }

      // WideDataStructure
      //
      if (n.name () == "WideDataStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< WideDataStructure_type > r (
          WideDataStructure_traits::create (i, f, this));

        this->WideDataStructure_.push_back (::std::move (r));
        continue;
      }

      // WideKey
      //
      if (n.name () == "WideKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< WideKey_type > r (
          WideKey_traits::create (i, f, this));

        this->WideKey_.push_back (::std::move (r));
        continue;
      }

      // WideKeyMember
      //
      if (n.name () == "WideKeyMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< WideKeyMember_type > r (
          WideKeyMember_traits::create (i, f, this));

        this->WideKeyMember_.push_back (::std::move (r));
        continue;
      }

      // Wrapper
      //
      if (n.name () == "Wrapper" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Wrapper_type > r (
          Wrapper_traits::create (i, f, this));

        this->Wrapper_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DDICDIModels* DDICDIModels::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DDICDIModels (*this, f, c);
  }

  DDICDIModels& DDICDIModels::
  operator= (const DDICDIModels& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Activity_ = x.Activity_;
      this->Agent_ = x.Agent_;
      this->AgentListing_ = x.AgentListing_;
      this->AgentPosition_ = x.AgentPosition_;
      this->AgentRelationship_ = x.AgentRelationship_;
      this->AgentStructure_ = x.AgentStructure_;
      this->AllenIntervalAlgebra_ = x.AllenIntervalAlgebra_;
      this->AttributeComponent_ = x.AttributeComponent_;
      this->AuthorizationSource_ = x.AuthorizationSource_;
      this->Category_ = x.Category_;
      this->CategoryPosition_ = x.CategoryPosition_;
      this->CategoryRelationStructure_ = x.CategoryRelationStructure_;
      this->CategoryRelationship_ = x.CategoryRelationship_;
      this->CategorySet_ = x.CategorySet_;
      this->CategoryStatistic_ = x.CategoryStatistic_;
      this->ClassificationFamily_ = x.ClassificationFamily_;
      this->ClassificationIndex_ = x.ClassificationIndex_;
      this->ClassificationIndexEntry_ = x.ClassificationIndexEntry_;
      this->ClassificationIndexEntryPosition_ = x.ClassificationIndexEntryPosition_;
      this->ClassificationItem_ = x.ClassificationItem_;
      this->ClassificationItemPosition_ = x.ClassificationItemPosition_;
      this->ClassificationItemRelationship_ = x.ClassificationItemRelationship_;
      this->ClassificationItemStructure_ = x.ClassificationItemStructure_;
      this->ClassificationPosition_ = x.ClassificationPosition_;
      this->ClassificationSeries_ = x.ClassificationSeries_;
      this->ClassificationSeriesStructure_ = x.ClassificationSeriesStructure_;
      this->Code_ = x.Code_;
      this->CodeList_ = x.CodeList_;
      this->CodeListStructure_ = x.CodeListStructure_;
      this->CodePosition_ = x.CodePosition_;
      this->CodeRelationship_ = x.CodeRelationship_;
      this->ComponentPosition_ = x.ComponentPosition_;
      this->Concept_ = x.Concept_;
      this->ConceptMap_ = x.ConceptMap_;
      this->ConceptRelationship_ = x.ConceptRelationship_;
      this->ConceptStructure_ = x.ConceptStructure_;
      this->ConceptSystem_ = x.ConceptSystem_;
      this->ConceptSystemCorrespondence_ = x.ConceptSystemCorrespondence_;
      this->ConceptualDomain_ = x.ConceptualDomain_;
      this->ConceptualValue_ = x.ConceptualValue_;
      this->ConceptualVariable_ = x.ConceptualVariable_;
      this->ConditionalControlLogic_ = x.ConditionalControlLogic_;
      this->ContextualComponent_ = x.ContextualComponent_;
      this->ControlLogic_ = x.ControlLogic_;
      this->CorrespondenceTable_ = x.CorrespondenceTable_;
      this->Curator_ = x.Curator_;
      this->DataPoint_ = x.DataPoint_;
      this->DataPointPosition_ = x.DataPointPosition_;
      this->DataPointRelationship_ = x.DataPointRelationship_;
      this->DataSet_ = x.DataSet_;
      this->DataStore_ = x.DataStore_;
      this->DataStructure_ = x.DataStructure_;
      this->DataStructureComponent_ = x.DataStructureComponent_;
      this->Datum_ = x.Datum_;
      this->Descriptor_ = x.Descriptor_;
      this->DescriptorValueDomain_ = x.DescriptorValueDomain_;
      this->DescriptorVariable_ = x.DescriptorVariable_;
      this->DeterministicImperative_ = x.DeterministicImperative_;
      this->DimensionComponent_ = x.DimensionComponent_;
      this->DimensionGroup_ = x.DimensionGroup_;
      this->DimensionalDataSet_ = x.DimensionalDataSet_;
      this->DimensionalDataStructure_ = x.DimensionalDataStructure_;
      this->DimensionalKey_ = x.DimensionalKey_;
      this->DimensionalKeyDefinition_ = x.DimensionalKeyDefinition_;
      this->DimensionalKeyDefinitionMember_ = x.DimensionalKeyDefinitionMember_;
      this->DimensionalKeyMember_ = x.DimensionalKeyMember_;
      this->EnumerationDomain_ = x.EnumerationDomain_;
      this->ForeignKey_ = x.ForeignKey_;
      this->ForeignKeyComponent_ = x.ForeignKeyComponent_;
      this->IdentifierComponent_ = x.IdentifierComponent_;
      this->Individual_ = x.Individual_;
      this->InformationFlowDefinition_ = x.InformationFlowDefinition_;
      this->InstanceKey_ = x.InstanceKey_;
      this->InstanceValue_ = x.InstanceValue_;
      this->InstanceVariable_ = x.InstanceVariable_;
      this->InstanceVariableMap_ = x.InstanceVariableMap_;
      this->Key_ = x.Key_;
      this->KeyDefinition_ = x.KeyDefinition_;
      this->KeyDefinitionMember_ = x.KeyDefinitionMember_;
      this->KeyMember_ = x.KeyMember_;
      this->KeyValueDataStore_ = x.KeyValueDataStore_;
      this->KeyValueStructure_ = x.KeyValueStructure_;
      this->Level_ = x.Level_;
      this->LevelStructure_ = x.LevelStructure_;
      this->LogicalRecord_ = x.LogicalRecord_;
      this->LogicalRecordPosition_ = x.LogicalRecordPosition_;
      this->LogicalRecordRelationStructure_ = x.LogicalRecordRelationStructure_;
      this->LogicalRecordRelationship_ = x.LogicalRecordRelationship_;
      this->LongDataSet_ = x.LongDataSet_;
      this->LongDataStructure_ = x.LongDataStructure_;
      this->LongKey_ = x.LongKey_;
      this->LongMainKeyMember_ = x.LongMainKeyMember_;
      this->Machine_ = x.Machine_;
      this->MainKeyMember_ = x.MainKeyMember_;
      this->MeasureComponent_ = x.MeasureComponent_;
      this->NonDeterministicDeclarative_ = x.NonDeterministicDeclarative_;
      this->Notation_ = x.Notation_;
      this->Organization_ = x.Organization_;
      this->Parameter_ = x.Parameter_;
      this->PhysicalDataSet_ = x.PhysicalDataSet_;
      this->PhysicalDataSetStructure_ = x.PhysicalDataSetStructure_;
      this->PhysicalLayoutRelationStructure_ = x.PhysicalLayoutRelationStructure_;
      this->PhysicalRecordSegment_ = x.PhysicalRecordSegment_;
      this->PhysicalRecordSegmentPosition_ = x.PhysicalRecordSegmentPosition_;
      this->PhysicalRecordSegmentRelationship_ = x.PhysicalRecordSegmentRelationship_;
      this->PhysicalRecordSegmentStructure_ = x.PhysicalRecordSegmentStructure_;
      this->PhysicalSegmentLayout_ = x.PhysicalSegmentLayout_;
      this->PhysicalSegmentLocation_ = x.PhysicalSegmentLocation_;
      this->Population_ = x.Population_;
      this->PrimaryKey_ = x.PrimaryKey_;
      this->PrimaryKeyComponent_ = x.PrimaryKeyComponent_;
      this->ProcessingAgent_ = x.ProcessingAgent_;
      this->ProductionEnvironment_ = x.ProductionEnvironment_;
      this->QualifiedMeasure_ = x.QualifiedMeasure_;
      this->RecordRelation_ = x.RecordRelation_;
      this->ReferenceValue_ = x.ReferenceValue_;
      this->ReferenceValueDomain_ = x.ReferenceValueDomain_;
      this->ReferenceVariable_ = x.ReferenceVariable_;
      this->RepresentedVariable_ = x.RepresentedVariable_;
      this->RevisableDatum_ = x.RevisableDatum_;
      this->Revision_ = x.Revision_;
      this->Rule_ = x.Rule_;
      this->RuleBasedScheduling_ = x.RuleBasedScheduling_;
      this->RuleSet_ = x.RuleSet_;
      this->ScopedMeasure_ = x.ScopedMeasure_;
      this->SegmentByText_ = x.SegmentByText_;
      this->SentinelConceptualDomain_ = x.SentinelConceptualDomain_;
      this->SentinelValueDomain_ = x.SentinelValueDomain_;
      this->Sequence_ = x.Sequence_;
      this->SequencePosition_ = x.SequencePosition_;
      this->Service_ = x.Service_;
      this->StatisticalClassification_ = x.StatisticalClassification_;
      this->StatisticalClassificationRelationship_ = x.StatisticalClassificationRelationship_;
      this->Step_ = x.Step_;
      this->SubstantiveConceptualDomain_ = x.SubstantiveConceptualDomain_;
      this->SubstantiveValueDomain_ = x.SubstantiveValueDomain_;
      this->SyntheticIdComponent_ = x.SyntheticIdComponent_;
      this->TemporalConstraints_ = x.TemporalConstraints_;
      this->TemporalControlConstruct_ = x.TemporalControlConstruct_;
      this->Unit_ = x.Unit_;
      this->UnitSegmentLayout_ = x.UnitSegmentLayout_;
      this->UnitType_ = x.UnitType_;
      this->Universe_ = x.Universe_;
      this->ValueAndConceptDescription_ = x.ValueAndConceptDescription_;
      this->ValueDomain_ = x.ValueDomain_;
      this->ValueMapping_ = x.ValueMapping_;
      this->ValueMappingPosition_ = x.ValueMappingPosition_;
      this->ValueMappingRelationship_ = x.ValueMappingRelationship_;
      this->VariableCollection_ = x.VariableCollection_;
      this->VariableDescriptorComponent_ = x.VariableDescriptorComponent_;
      this->VariablePosition_ = x.VariablePosition_;
      this->VariableRelationship_ = x.VariableRelationship_;
      this->VariableStructure_ = x.VariableStructure_;
      this->VariableValueComponent_ = x.VariableValueComponent_;
      this->WideDataSet_ = x.WideDataSet_;
      this->WideDataStructure_ = x.WideDataStructure_;
      this->WideKey_ = x.WideKey_;
      this->WideKeyMember_ = x.WideKeyMember_;
      this->Wrapper_ = x.Wrapper_;
    }

    return *this;
  }

  DDICDIModels::
  ~DDICDIModels ()
  {
  }

  // Wrapper
  //

  Wrapper::
  Wrapper ()
  : ::xml_schema::type (),
    identifier_ (this),
    supportingInformation_ (this),
    Activity_ (this),
    Agent_ (this),
    AgentListing_ (this),
    AgentPosition_ (this),
    AgentRelationship_ (this),
    AgentStructure_ (this),
    AllenIntervalAlgebra_ (this),
    AttributeComponent_ (this),
    AuthorizationSource_ (this),
    Category_ (this),
    CategoryPosition_ (this),
    CategoryRelationStructure_ (this),
    CategoryRelationship_ (this),
    CategorySet_ (this),
    CategoryStatistic_ (this),
    ClassificationFamily_ (this),
    ClassificationIndex_ (this),
    ClassificationIndexEntry_ (this),
    ClassificationIndexEntryPosition_ (this),
    ClassificationItem_ (this),
    ClassificationItemPosition_ (this),
    ClassificationItemRelationship_ (this),
    ClassificationItemStructure_ (this),
    ClassificationPosition_ (this),
    ClassificationSeries_ (this),
    ClassificationSeriesStructure_ (this),
    Code_ (this),
    CodeList_ (this),
    CodeListStructure_ (this),
    CodePosition_ (this),
    CodeRelationship_ (this),
    ComponentPosition_ (this),
    Concept_ (this),
    ConceptMap_ (this),
    ConceptRelationship_ (this),
    ConceptStructure_ (this),
    ConceptSystem_ (this),
    ConceptSystemCorrespondence_ (this),
    ConceptualDomain_ (this),
    ConceptualValue_ (this),
    ConceptualVariable_ (this),
    ConditionalControlLogic_ (this),
    ContextualComponent_ (this),
    ControlLogic_ (this),
    CorrespondenceTable_ (this),
    Curator_ (this),
    DataPoint_ (this),
    DataPointPosition_ (this),
    DataPointRelationship_ (this),
    DataSet_ (this),
    DataStore_ (this),
    DataStructure_ (this),
    DataStructureComponent_ (this),
    Datum_ (this),
    Descriptor_ (this),
    DescriptorValueDomain_ (this),
    DescriptorVariable_ (this),
    DeterministicImperative_ (this),
    DimensionComponent_ (this),
    DimensionGroup_ (this),
    DimensionalDataSet_ (this),
    DimensionalDataStructure_ (this),
    DimensionalKey_ (this),
    DimensionalKeyDefinition_ (this),
    DimensionalKeyDefinitionMember_ (this),
    DimensionalKeyMember_ (this),
    EnumerationDomain_ (this),
    ForeignKey_ (this),
    ForeignKeyComponent_ (this),
    IdentifierComponent_ (this),
    Individual_ (this),
    InformationFlowDefinition_ (this),
    InstanceKey_ (this),
    InstanceValue_ (this),
    InstanceVariable_ (this),
    InstanceVariableMap_ (this),
    Key_ (this),
    KeyDefinition_ (this),
    KeyDefinitionMember_ (this),
    KeyMember_ (this),
    KeyValueDataStore_ (this),
    KeyValueStructure_ (this),
    Level_ (this),
    LevelStructure_ (this),
    LogicalRecord_ (this),
    LogicalRecordPosition_ (this),
    LogicalRecordRelationStructure_ (this),
    LogicalRecordRelationship_ (this),
    LongDataSet_ (this),
    LongDataStructure_ (this),
    LongKey_ (this),
    LongMainKeyMember_ (this),
    Machine_ (this),
    MainKeyMember_ (this),
    MeasureComponent_ (this),
    NonDeterministicDeclarative_ (this),
    Notation_ (this),
    Organization_ (this),
    Parameter_ (this),
    PhysicalDataSet_ (this),
    PhysicalDataSetStructure_ (this),
    PhysicalLayoutRelationStructure_ (this),
    PhysicalRecordSegment_ (this),
    PhysicalRecordSegmentPosition_ (this),
    PhysicalRecordSegmentRelationship_ (this),
    PhysicalRecordSegmentStructure_ (this),
    PhysicalSegmentLayout_ (this),
    PhysicalSegmentLocation_ (this),
    Population_ (this),
    PrimaryKey_ (this),
    PrimaryKeyComponent_ (this),
    ProcessingAgent_ (this),
    ProductionEnvironment_ (this),
    QualifiedMeasure_ (this),
    RecordRelation_ (this),
    ReferenceValue_ (this),
    ReferenceValueDomain_ (this),
    ReferenceVariable_ (this),
    RepresentedVariable_ (this),
    RevisableDatum_ (this),
    Revision_ (this),
    Rule_ (this),
    RuleBasedScheduling_ (this),
    RuleSet_ (this),
    ScopedMeasure_ (this),
    SegmentByText_ (this),
    SentinelConceptualDomain_ (this),
    SentinelValueDomain_ (this),
    Sequence_ (this),
    SequencePosition_ (this),
    Service_ (this),
    StatisticalClassification_ (this),
    StatisticalClassificationRelationship_ (this),
    Step_ (this),
    SubstantiveConceptualDomain_ (this),
    SubstantiveValueDomain_ (this),
    SyntheticIdComponent_ (this),
    TemporalConstraints_ (this),
    TemporalControlConstruct_ (this),
    Unit_ (this),
    UnitSegmentLayout_ (this),
    UnitType_ (this),
    Universe_ (this),
    ValueAndConceptDescription_ (this),
    ValueDomain_ (this),
    ValueMapping_ (this),
    ValueMappingPosition_ (this),
    ValueMappingRelationship_ (this),
    VariableCollection_ (this),
    VariableDescriptorComponent_ (this),
    VariablePosition_ (this),
    VariableRelationship_ (this),
    VariableStructure_ (this),
    VariableValueComponent_ (this),
    WideDataSet_ (this),
    WideDataStructure_ (this),
    WideKey_ (this),
    WideKeyMember_ (this)
  {
  }

  Wrapper::
  Wrapper (const Wrapper& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    supportingInformation_ (x.supportingInformation_, f, this),
    Activity_ (x.Activity_, f, this),
    Agent_ (x.Agent_, f, this),
    AgentListing_ (x.AgentListing_, f, this),
    AgentPosition_ (x.AgentPosition_, f, this),
    AgentRelationship_ (x.AgentRelationship_, f, this),
    AgentStructure_ (x.AgentStructure_, f, this),
    AllenIntervalAlgebra_ (x.AllenIntervalAlgebra_, f, this),
    AttributeComponent_ (x.AttributeComponent_, f, this),
    AuthorizationSource_ (x.AuthorizationSource_, f, this),
    Category_ (x.Category_, f, this),
    CategoryPosition_ (x.CategoryPosition_, f, this),
    CategoryRelationStructure_ (x.CategoryRelationStructure_, f, this),
    CategoryRelationship_ (x.CategoryRelationship_, f, this),
    CategorySet_ (x.CategorySet_, f, this),
    CategoryStatistic_ (x.CategoryStatistic_, f, this),
    ClassificationFamily_ (x.ClassificationFamily_, f, this),
    ClassificationIndex_ (x.ClassificationIndex_, f, this),
    ClassificationIndexEntry_ (x.ClassificationIndexEntry_, f, this),
    ClassificationIndexEntryPosition_ (x.ClassificationIndexEntryPosition_, f, this),
    ClassificationItem_ (x.ClassificationItem_, f, this),
    ClassificationItemPosition_ (x.ClassificationItemPosition_, f, this),
    ClassificationItemRelationship_ (x.ClassificationItemRelationship_, f, this),
    ClassificationItemStructure_ (x.ClassificationItemStructure_, f, this),
    ClassificationPosition_ (x.ClassificationPosition_, f, this),
    ClassificationSeries_ (x.ClassificationSeries_, f, this),
    ClassificationSeriesStructure_ (x.ClassificationSeriesStructure_, f, this),
    Code_ (x.Code_, f, this),
    CodeList_ (x.CodeList_, f, this),
    CodeListStructure_ (x.CodeListStructure_, f, this),
    CodePosition_ (x.CodePosition_, f, this),
    CodeRelationship_ (x.CodeRelationship_, f, this),
    ComponentPosition_ (x.ComponentPosition_, f, this),
    Concept_ (x.Concept_, f, this),
    ConceptMap_ (x.ConceptMap_, f, this),
    ConceptRelationship_ (x.ConceptRelationship_, f, this),
    ConceptStructure_ (x.ConceptStructure_, f, this),
    ConceptSystem_ (x.ConceptSystem_, f, this),
    ConceptSystemCorrespondence_ (x.ConceptSystemCorrespondence_, f, this),
    ConceptualDomain_ (x.ConceptualDomain_, f, this),
    ConceptualValue_ (x.ConceptualValue_, f, this),
    ConceptualVariable_ (x.ConceptualVariable_, f, this),
    ConditionalControlLogic_ (x.ConditionalControlLogic_, f, this),
    ContextualComponent_ (x.ContextualComponent_, f, this),
    ControlLogic_ (x.ControlLogic_, f, this),
    CorrespondenceTable_ (x.CorrespondenceTable_, f, this),
    Curator_ (x.Curator_, f, this),
    DataPoint_ (x.DataPoint_, f, this),
    DataPointPosition_ (x.DataPointPosition_, f, this),
    DataPointRelationship_ (x.DataPointRelationship_, f, this),
    DataSet_ (x.DataSet_, f, this),
    DataStore_ (x.DataStore_, f, this),
    DataStructure_ (x.DataStructure_, f, this),
    DataStructureComponent_ (x.DataStructureComponent_, f, this),
    Datum_ (x.Datum_, f, this),
    Descriptor_ (x.Descriptor_, f, this),
    DescriptorValueDomain_ (x.DescriptorValueDomain_, f, this),
    DescriptorVariable_ (x.DescriptorVariable_, f, this),
    DeterministicImperative_ (x.DeterministicImperative_, f, this),
    DimensionComponent_ (x.DimensionComponent_, f, this),
    DimensionGroup_ (x.DimensionGroup_, f, this),
    DimensionalDataSet_ (x.DimensionalDataSet_, f, this),
    DimensionalDataStructure_ (x.DimensionalDataStructure_, f, this),
    DimensionalKey_ (x.DimensionalKey_, f, this),
    DimensionalKeyDefinition_ (x.DimensionalKeyDefinition_, f, this),
    DimensionalKeyDefinitionMember_ (x.DimensionalKeyDefinitionMember_, f, this),
    DimensionalKeyMember_ (x.DimensionalKeyMember_, f, this),
    EnumerationDomain_ (x.EnumerationDomain_, f, this),
    ForeignKey_ (x.ForeignKey_, f, this),
    ForeignKeyComponent_ (x.ForeignKeyComponent_, f, this),
    IdentifierComponent_ (x.IdentifierComponent_, f, this),
    Individual_ (x.Individual_, f, this),
    InformationFlowDefinition_ (x.InformationFlowDefinition_, f, this),
    InstanceKey_ (x.InstanceKey_, f, this),
    InstanceValue_ (x.InstanceValue_, f, this),
    InstanceVariable_ (x.InstanceVariable_, f, this),
    InstanceVariableMap_ (x.InstanceVariableMap_, f, this),
    Key_ (x.Key_, f, this),
    KeyDefinition_ (x.KeyDefinition_, f, this),
    KeyDefinitionMember_ (x.KeyDefinitionMember_, f, this),
    KeyMember_ (x.KeyMember_, f, this),
    KeyValueDataStore_ (x.KeyValueDataStore_, f, this),
    KeyValueStructure_ (x.KeyValueStructure_, f, this),
    Level_ (x.Level_, f, this),
    LevelStructure_ (x.LevelStructure_, f, this),
    LogicalRecord_ (x.LogicalRecord_, f, this),
    LogicalRecordPosition_ (x.LogicalRecordPosition_, f, this),
    LogicalRecordRelationStructure_ (x.LogicalRecordRelationStructure_, f, this),
    LogicalRecordRelationship_ (x.LogicalRecordRelationship_, f, this),
    LongDataSet_ (x.LongDataSet_, f, this),
    LongDataStructure_ (x.LongDataStructure_, f, this),
    LongKey_ (x.LongKey_, f, this),
    LongMainKeyMember_ (x.LongMainKeyMember_, f, this),
    Machine_ (x.Machine_, f, this),
    MainKeyMember_ (x.MainKeyMember_, f, this),
    MeasureComponent_ (x.MeasureComponent_, f, this),
    NonDeterministicDeclarative_ (x.NonDeterministicDeclarative_, f, this),
    Notation_ (x.Notation_, f, this),
    Organization_ (x.Organization_, f, this),
    Parameter_ (x.Parameter_, f, this),
    PhysicalDataSet_ (x.PhysicalDataSet_, f, this),
    PhysicalDataSetStructure_ (x.PhysicalDataSetStructure_, f, this),
    PhysicalLayoutRelationStructure_ (x.PhysicalLayoutRelationStructure_, f, this),
    PhysicalRecordSegment_ (x.PhysicalRecordSegment_, f, this),
    PhysicalRecordSegmentPosition_ (x.PhysicalRecordSegmentPosition_, f, this),
    PhysicalRecordSegmentRelationship_ (x.PhysicalRecordSegmentRelationship_, f, this),
    PhysicalRecordSegmentStructure_ (x.PhysicalRecordSegmentStructure_, f, this),
    PhysicalSegmentLayout_ (x.PhysicalSegmentLayout_, f, this),
    PhysicalSegmentLocation_ (x.PhysicalSegmentLocation_, f, this),
    Population_ (x.Population_, f, this),
    PrimaryKey_ (x.PrimaryKey_, f, this),
    PrimaryKeyComponent_ (x.PrimaryKeyComponent_, f, this),
    ProcessingAgent_ (x.ProcessingAgent_, f, this),
    ProductionEnvironment_ (x.ProductionEnvironment_, f, this),
    QualifiedMeasure_ (x.QualifiedMeasure_, f, this),
    RecordRelation_ (x.RecordRelation_, f, this),
    ReferenceValue_ (x.ReferenceValue_, f, this),
    ReferenceValueDomain_ (x.ReferenceValueDomain_, f, this),
    ReferenceVariable_ (x.ReferenceVariable_, f, this),
    RepresentedVariable_ (x.RepresentedVariable_, f, this),
    RevisableDatum_ (x.RevisableDatum_, f, this),
    Revision_ (x.Revision_, f, this),
    Rule_ (x.Rule_, f, this),
    RuleBasedScheduling_ (x.RuleBasedScheduling_, f, this),
    RuleSet_ (x.RuleSet_, f, this),
    ScopedMeasure_ (x.ScopedMeasure_, f, this),
    SegmentByText_ (x.SegmentByText_, f, this),
    SentinelConceptualDomain_ (x.SentinelConceptualDomain_, f, this),
    SentinelValueDomain_ (x.SentinelValueDomain_, f, this),
    Sequence_ (x.Sequence_, f, this),
    SequencePosition_ (x.SequencePosition_, f, this),
    Service_ (x.Service_, f, this),
    StatisticalClassification_ (x.StatisticalClassification_, f, this),
    StatisticalClassificationRelationship_ (x.StatisticalClassificationRelationship_, f, this),
    Step_ (x.Step_, f, this),
    SubstantiveConceptualDomain_ (x.SubstantiveConceptualDomain_, f, this),
    SubstantiveValueDomain_ (x.SubstantiveValueDomain_, f, this),
    SyntheticIdComponent_ (x.SyntheticIdComponent_, f, this),
    TemporalConstraints_ (x.TemporalConstraints_, f, this),
    TemporalControlConstruct_ (x.TemporalControlConstruct_, f, this),
    Unit_ (x.Unit_, f, this),
    UnitSegmentLayout_ (x.UnitSegmentLayout_, f, this),
    UnitType_ (x.UnitType_, f, this),
    Universe_ (x.Universe_, f, this),
    ValueAndConceptDescription_ (x.ValueAndConceptDescription_, f, this),
    ValueDomain_ (x.ValueDomain_, f, this),
    ValueMapping_ (x.ValueMapping_, f, this),
    ValueMappingPosition_ (x.ValueMappingPosition_, f, this),
    ValueMappingRelationship_ (x.ValueMappingRelationship_, f, this),
    VariableCollection_ (x.VariableCollection_, f, this),
    VariableDescriptorComponent_ (x.VariableDescriptorComponent_, f, this),
    VariablePosition_ (x.VariablePosition_, f, this),
    VariableRelationship_ (x.VariableRelationship_, f, this),
    VariableStructure_ (x.VariableStructure_, f, this),
    VariableValueComponent_ (x.VariableValueComponent_, f, this),
    WideDataSet_ (x.WideDataSet_, f, this),
    WideDataStructure_ (x.WideDataStructure_, f, this),
    WideKey_ (x.WideKey_, f, this),
    WideKeyMember_ (x.WideKeyMember_, f, this)
  {
  }

  Wrapper::
  Wrapper (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    supportingInformation_ (this),
    Activity_ (this),
    Agent_ (this),
    AgentListing_ (this),
    AgentPosition_ (this),
    AgentRelationship_ (this),
    AgentStructure_ (this),
    AllenIntervalAlgebra_ (this),
    AttributeComponent_ (this),
    AuthorizationSource_ (this),
    Category_ (this),
    CategoryPosition_ (this),
    CategoryRelationStructure_ (this),
    CategoryRelationship_ (this),
    CategorySet_ (this),
    CategoryStatistic_ (this),
    ClassificationFamily_ (this),
    ClassificationIndex_ (this),
    ClassificationIndexEntry_ (this),
    ClassificationIndexEntryPosition_ (this),
    ClassificationItem_ (this),
    ClassificationItemPosition_ (this),
    ClassificationItemRelationship_ (this),
    ClassificationItemStructure_ (this),
    ClassificationPosition_ (this),
    ClassificationSeries_ (this),
    ClassificationSeriesStructure_ (this),
    Code_ (this),
    CodeList_ (this),
    CodeListStructure_ (this),
    CodePosition_ (this),
    CodeRelationship_ (this),
    ComponentPosition_ (this),
    Concept_ (this),
    ConceptMap_ (this),
    ConceptRelationship_ (this),
    ConceptStructure_ (this),
    ConceptSystem_ (this),
    ConceptSystemCorrespondence_ (this),
    ConceptualDomain_ (this),
    ConceptualValue_ (this),
    ConceptualVariable_ (this),
    ConditionalControlLogic_ (this),
    ContextualComponent_ (this),
    ControlLogic_ (this),
    CorrespondenceTable_ (this),
    Curator_ (this),
    DataPoint_ (this),
    DataPointPosition_ (this),
    DataPointRelationship_ (this),
    DataSet_ (this),
    DataStore_ (this),
    DataStructure_ (this),
    DataStructureComponent_ (this),
    Datum_ (this),
    Descriptor_ (this),
    DescriptorValueDomain_ (this),
    DescriptorVariable_ (this),
    DeterministicImperative_ (this),
    DimensionComponent_ (this),
    DimensionGroup_ (this),
    DimensionalDataSet_ (this),
    DimensionalDataStructure_ (this),
    DimensionalKey_ (this),
    DimensionalKeyDefinition_ (this),
    DimensionalKeyDefinitionMember_ (this),
    DimensionalKeyMember_ (this),
    EnumerationDomain_ (this),
    ForeignKey_ (this),
    ForeignKeyComponent_ (this),
    IdentifierComponent_ (this),
    Individual_ (this),
    InformationFlowDefinition_ (this),
    InstanceKey_ (this),
    InstanceValue_ (this),
    InstanceVariable_ (this),
    InstanceVariableMap_ (this),
    Key_ (this),
    KeyDefinition_ (this),
    KeyDefinitionMember_ (this),
    KeyMember_ (this),
    KeyValueDataStore_ (this),
    KeyValueStructure_ (this),
    Level_ (this),
    LevelStructure_ (this),
    LogicalRecord_ (this),
    LogicalRecordPosition_ (this),
    LogicalRecordRelationStructure_ (this),
    LogicalRecordRelationship_ (this),
    LongDataSet_ (this),
    LongDataStructure_ (this),
    LongKey_ (this),
    LongMainKeyMember_ (this),
    Machine_ (this),
    MainKeyMember_ (this),
    MeasureComponent_ (this),
    NonDeterministicDeclarative_ (this),
    Notation_ (this),
    Organization_ (this),
    Parameter_ (this),
    PhysicalDataSet_ (this),
    PhysicalDataSetStructure_ (this),
    PhysicalLayoutRelationStructure_ (this),
    PhysicalRecordSegment_ (this),
    PhysicalRecordSegmentPosition_ (this),
    PhysicalRecordSegmentRelationship_ (this),
    PhysicalRecordSegmentStructure_ (this),
    PhysicalSegmentLayout_ (this),
    PhysicalSegmentLocation_ (this),
    Population_ (this),
    PrimaryKey_ (this),
    PrimaryKeyComponent_ (this),
    ProcessingAgent_ (this),
    ProductionEnvironment_ (this),
    QualifiedMeasure_ (this),
    RecordRelation_ (this),
    ReferenceValue_ (this),
    ReferenceValueDomain_ (this),
    ReferenceVariable_ (this),
    RepresentedVariable_ (this),
    RevisableDatum_ (this),
    Revision_ (this),
    Rule_ (this),
    RuleBasedScheduling_ (this),
    RuleSet_ (this),
    ScopedMeasure_ (this),
    SegmentByText_ (this),
    SentinelConceptualDomain_ (this),
    SentinelValueDomain_ (this),
    Sequence_ (this),
    SequencePosition_ (this),
    Service_ (this),
    StatisticalClassification_ (this),
    StatisticalClassificationRelationship_ (this),
    Step_ (this),
    SubstantiveConceptualDomain_ (this),
    SubstantiveValueDomain_ (this),
    SyntheticIdComponent_ (this),
    TemporalConstraints_ (this),
    TemporalControlConstruct_ (this),
    Unit_ (this),
    UnitSegmentLayout_ (this),
    UnitType_ (this),
    Universe_ (this),
    ValueAndConceptDescription_ (this),
    ValueDomain_ (this),
    ValueMapping_ (this),
    ValueMappingPosition_ (this),
    ValueMappingRelationship_ (this),
    VariableCollection_ (this),
    VariableDescriptorComponent_ (this),
    VariablePosition_ (this),
    VariableRelationship_ (this),
    VariableStructure_ (this),
    VariableValueComponent_ (this),
    WideDataSet_ (this),
    WideDataStructure_ (this),
    WideKey_ (this),
    WideKeyMember_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Wrapper::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // supportingInformation
      //
      if (n.name () == "supportingInformation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< supportingInformation_type > r (
          supportingInformation_traits::create (i, f, this));

        this->supportingInformation_.push_back (::std::move (r));
        continue;
      }

      // Activity
      //
      if (n.name () == "Activity" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Activity_type > r (
          Activity_traits::create (i, f, this));

        this->Activity_.push_back (::std::move (r));
        continue;
      }

      // Agent
      //
      if (n.name () == "Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Agent_type > r (
          Agent_traits::create (i, f, this));

        this->Agent_.push_back (::std::move (r));
        continue;
      }

      // AgentListing
      //
      if (n.name () == "AgentListing" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentListing_type > r (
          AgentListing_traits::create (i, f, this));

        this->AgentListing_.push_back (::std::move (r));
        continue;
      }

      // AgentPosition
      //
      if (n.name () == "AgentPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentPosition_type > r (
          AgentPosition_traits::create (i, f, this));

        this->AgentPosition_.push_back (::std::move (r));
        continue;
      }

      // AgentRelationship
      //
      if (n.name () == "AgentRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentRelationship_type > r (
          AgentRelationship_traits::create (i, f, this));

        this->AgentRelationship_.push_back (::std::move (r));
        continue;
      }

      // AgentStructure
      //
      if (n.name () == "AgentStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentStructure_type > r (
          AgentStructure_traits::create (i, f, this));

        this->AgentStructure_.push_back (::std::move (r));
        continue;
      }

      // AllenIntervalAlgebra
      //
      if (n.name () == "AllenIntervalAlgebra" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AllenIntervalAlgebra_type > r (
          AllenIntervalAlgebra_traits::create (i, f, this));

        this->AllenIntervalAlgebra_.push_back (::std::move (r));
        continue;
      }

      // AttributeComponent
      //
      if (n.name () == "AttributeComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AttributeComponent_type > r (
          AttributeComponent_traits::create (i, f, this));

        this->AttributeComponent_.push_back (::std::move (r));
        continue;
      }

      // AuthorizationSource
      //
      if (n.name () == "AuthorizationSource" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AuthorizationSource_type > r (
          AuthorizationSource_traits::create (i, f, this));

        this->AuthorizationSource_.push_back (::std::move (r));
        continue;
      }

      // Category
      //
      if (n.name () == "Category" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Category_type > r (
          Category_traits::create (i, f, this));

        this->Category_.push_back (::std::move (r));
        continue;
      }

      // CategoryPosition
      //
      if (n.name () == "CategoryPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryPosition_type > r (
          CategoryPosition_traits::create (i, f, this));

        this->CategoryPosition_.push_back (::std::move (r));
        continue;
      }

      // CategoryRelationStructure
      //
      if (n.name () == "CategoryRelationStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryRelationStructure_type > r (
          CategoryRelationStructure_traits::create (i, f, this));

        this->CategoryRelationStructure_.push_back (::std::move (r));
        continue;
      }

      // CategoryRelationship
      //
      if (n.name () == "CategoryRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryRelationship_type > r (
          CategoryRelationship_traits::create (i, f, this));

        this->CategoryRelationship_.push_back (::std::move (r));
        continue;
      }

      // CategorySet
      //
      if (n.name () == "CategorySet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategorySet_type > r (
          CategorySet_traits::create (i, f, this));

        this->CategorySet_.push_back (::std::move (r));
        continue;
      }

      // CategoryStatistic
      //
      if (n.name () == "CategoryStatistic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryStatistic_type > r (
          CategoryStatistic_traits::create (i, f, this));

        this->CategoryStatistic_.push_back (::std::move (r));
        continue;
      }

      // ClassificationFamily
      //
      if (n.name () == "ClassificationFamily" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationFamily_type > r (
          ClassificationFamily_traits::create (i, f, this));

        this->ClassificationFamily_.push_back (::std::move (r));
        continue;
      }

      // ClassificationIndex
      //
      if (n.name () == "ClassificationIndex" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationIndex_type > r (
          ClassificationIndex_traits::create (i, f, this));

        this->ClassificationIndex_.push_back (::std::move (r));
        continue;
      }

      // ClassificationIndexEntry
      //
      if (n.name () == "ClassificationIndexEntry" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationIndexEntry_type > r (
          ClassificationIndexEntry_traits::create (i, f, this));

        this->ClassificationIndexEntry_.push_back (::std::move (r));
        continue;
      }

      // ClassificationIndexEntryPosition
      //
      if (n.name () == "ClassificationIndexEntryPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationIndexEntryPosition_type > r (
          ClassificationIndexEntryPosition_traits::create (i, f, this));

        this->ClassificationIndexEntryPosition_.push_back (::std::move (r));
        continue;
      }

      // ClassificationItem
      //
      if (n.name () == "ClassificationItem" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItem_type > r (
          ClassificationItem_traits::create (i, f, this));

        this->ClassificationItem_.push_back (::std::move (r));
        continue;
      }

      // ClassificationItemPosition
      //
      if (n.name () == "ClassificationItemPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItemPosition_type > r (
          ClassificationItemPosition_traits::create (i, f, this));

        this->ClassificationItemPosition_.push_back (::std::move (r));
        continue;
      }

      // ClassificationItemRelationship
      //
      if (n.name () == "ClassificationItemRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItemRelationship_type > r (
          ClassificationItemRelationship_traits::create (i, f, this));

        this->ClassificationItemRelationship_.push_back (::std::move (r));
        continue;
      }

      // ClassificationItemStructure
      //
      if (n.name () == "ClassificationItemStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItemStructure_type > r (
          ClassificationItemStructure_traits::create (i, f, this));

        this->ClassificationItemStructure_.push_back (::std::move (r));
        continue;
      }

      // ClassificationPosition
      //
      if (n.name () == "ClassificationPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationPosition_type > r (
          ClassificationPosition_traits::create (i, f, this));

        this->ClassificationPosition_.push_back (::std::move (r));
        continue;
      }

      // ClassificationSeries
      //
      if (n.name () == "ClassificationSeries" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationSeries_type > r (
          ClassificationSeries_traits::create (i, f, this));

        this->ClassificationSeries_.push_back (::std::move (r));
        continue;
      }

      // ClassificationSeriesStructure
      //
      if (n.name () == "ClassificationSeriesStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationSeriesStructure_type > r (
          ClassificationSeriesStructure_traits::create (i, f, this));

        this->ClassificationSeriesStructure_.push_back (::std::move (r));
        continue;
      }

      // Code
      //
      if (n.name () == "Code" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Code_type > r (
          Code_traits::create (i, f, this));

        this->Code_.push_back (::std::move (r));
        continue;
      }

      // CodeList
      //
      if (n.name () == "CodeList" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodeList_type > r (
          CodeList_traits::create (i, f, this));

        this->CodeList_.push_back (::std::move (r));
        continue;
      }

      // CodeListStructure
      //
      if (n.name () == "CodeListStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodeListStructure_type > r (
          CodeListStructure_traits::create (i, f, this));

        this->CodeListStructure_.push_back (::std::move (r));
        continue;
      }

      // CodePosition
      //
      if (n.name () == "CodePosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodePosition_type > r (
          CodePosition_traits::create (i, f, this));

        this->CodePosition_.push_back (::std::move (r));
        continue;
      }

      // CodeRelationship
      //
      if (n.name () == "CodeRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodeRelationship_type > r (
          CodeRelationship_traits::create (i, f, this));

        this->CodeRelationship_.push_back (::std::move (r));
        continue;
      }

      // ComponentPosition
      //
      if (n.name () == "ComponentPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ComponentPosition_type > r (
          ComponentPosition_traits::create (i, f, this));

        this->ComponentPosition_.push_back (::std::move (r));
        continue;
      }

      // Concept
      //
      if (n.name () == "Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Concept_type > r (
          Concept_traits::create (i, f, this));

        this->Concept_.push_back (::std::move (r));
        continue;
      }

      // ConceptMap
      //
      if (n.name () == "ConceptMap" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptMap_type > r (
          ConceptMap_traits::create (i, f, this));

        this->ConceptMap_.push_back (::std::move (r));
        continue;
      }

      // ConceptRelationship
      //
      if (n.name () == "ConceptRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptRelationship_type > r (
          ConceptRelationship_traits::create (i, f, this));

        this->ConceptRelationship_.push_back (::std::move (r));
        continue;
      }

      // ConceptStructure
      //
      if (n.name () == "ConceptStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptStructure_type > r (
          ConceptStructure_traits::create (i, f, this));

        this->ConceptStructure_.push_back (::std::move (r));
        continue;
      }

      // ConceptSystem
      //
      if (n.name () == "ConceptSystem" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptSystem_type > r (
          ConceptSystem_traits::create (i, f, this));

        this->ConceptSystem_.push_back (::std::move (r));
        continue;
      }

      // ConceptSystemCorrespondence
      //
      if (n.name () == "ConceptSystemCorrespondence" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptSystemCorrespondence_type > r (
          ConceptSystemCorrespondence_traits::create (i, f, this));

        this->ConceptSystemCorrespondence_.push_back (::std::move (r));
        continue;
      }

      // ConceptualDomain
      //
      if (n.name () == "ConceptualDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptualDomain_type > r (
          ConceptualDomain_traits::create (i, f, this));

        this->ConceptualDomain_.push_back (::std::move (r));
        continue;
      }

      // ConceptualValue
      //
      if (n.name () == "ConceptualValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptualValue_type > r (
          ConceptualValue_traits::create (i, f, this));

        this->ConceptualValue_.push_back (::std::move (r));
        continue;
      }

      // ConceptualVariable
      //
      if (n.name () == "ConceptualVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptualVariable_type > r (
          ConceptualVariable_traits::create (i, f, this));

        this->ConceptualVariable_.push_back (::std::move (r));
        continue;
      }

      // ConditionalControlLogic
      //
      if (n.name () == "ConditionalControlLogic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConditionalControlLogic_type > r (
          ConditionalControlLogic_traits::create (i, f, this));

        this->ConditionalControlLogic_.push_back (::std::move (r));
        continue;
      }

      // ContextualComponent
      //
      if (n.name () == "ContextualComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ContextualComponent_type > r (
          ContextualComponent_traits::create (i, f, this));

        this->ContextualComponent_.push_back (::std::move (r));
        continue;
      }

      // ControlLogic
      //
      if (n.name () == "ControlLogic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ControlLogic_type > r (
          ControlLogic_traits::create (i, f, this));

        this->ControlLogic_.push_back (::std::move (r));
        continue;
      }

      // CorrespondenceTable
      //
      if (n.name () == "CorrespondenceTable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CorrespondenceTable_type > r (
          CorrespondenceTable_traits::create (i, f, this));

        this->CorrespondenceTable_.push_back (::std::move (r));
        continue;
      }

      // Curator
      //
      if (n.name () == "Curator" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Curator_type > r (
          Curator_traits::create (i, f, this));

        this->Curator_.push_back (::std::move (r));
        continue;
      }

      // DataPoint
      //
      if (n.name () == "DataPoint" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataPoint_type > r (
          DataPoint_traits::create (i, f, this));

        this->DataPoint_.push_back (::std::move (r));
        continue;
      }

      // DataPointPosition
      //
      if (n.name () == "DataPointPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataPointPosition_type > r (
          DataPointPosition_traits::create (i, f, this));

        this->DataPointPosition_.push_back (::std::move (r));
        continue;
      }

      // DataPointRelationship
      //
      if (n.name () == "DataPointRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataPointRelationship_type > r (
          DataPointRelationship_traits::create (i, f, this));

        this->DataPointRelationship_.push_back (::std::move (r));
        continue;
      }

      // DataSet
      //
      if (n.name () == "DataSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataSet_type > r (
          DataSet_traits::create (i, f, this));

        this->DataSet_.push_back (::std::move (r));
        continue;
      }

      // DataStore
      //
      if (n.name () == "DataStore" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStore_type > r (
          DataStore_traits::create (i, f, this));

        this->DataStore_.push_back (::std::move (r));
        continue;
      }

      // DataStructure
      //
      if (n.name () == "DataStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStructure_type > r (
          DataStructure_traits::create (i, f, this));

        this->DataStructure_.push_back (::std::move (r));
        continue;
      }

      // DataStructureComponent
      //
      if (n.name () == "DataStructureComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStructureComponent_type > r (
          DataStructureComponent_traits::create (i, f, this));

        this->DataStructureComponent_.push_back (::std::move (r));
        continue;
      }

      // Datum
      //
      if (n.name () == "Datum" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Datum_type > r (
          Datum_traits::create (i, f, this));

        this->Datum_.push_back (::std::move (r));
        continue;
      }

      // Descriptor
      //
      if (n.name () == "Descriptor" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Descriptor_type > r (
          Descriptor_traits::create (i, f, this));

        this->Descriptor_.push_back (::std::move (r));
        continue;
      }

      // DescriptorValueDomain
      //
      if (n.name () == "DescriptorValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DescriptorValueDomain_type > r (
          DescriptorValueDomain_traits::create (i, f, this));

        this->DescriptorValueDomain_.push_back (::std::move (r));
        continue;
      }

      // DescriptorVariable
      //
      if (n.name () == "DescriptorVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DescriptorVariable_type > r (
          DescriptorVariable_traits::create (i, f, this));

        this->DescriptorVariable_.push_back (::std::move (r));
        continue;
      }

      // DeterministicImperative
      //
      if (n.name () == "DeterministicImperative" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DeterministicImperative_type > r (
          DeterministicImperative_traits::create (i, f, this));

        this->DeterministicImperative_.push_back (::std::move (r));
        continue;
      }

      // DimensionComponent
      //
      if (n.name () == "DimensionComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionComponent_type > r (
          DimensionComponent_traits::create (i, f, this));

        this->DimensionComponent_.push_back (::std::move (r));
        continue;
      }

      // DimensionGroup
      //
      if (n.name () == "DimensionGroup" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionGroup_type > r (
          DimensionGroup_traits::create (i, f, this));

        this->DimensionGroup_.push_back (::std::move (r));
        continue;
      }

      // DimensionalDataSet
      //
      if (n.name () == "DimensionalDataSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalDataSet_type > r (
          DimensionalDataSet_traits::create (i, f, this));

        this->DimensionalDataSet_.push_back (::std::move (r));
        continue;
      }

      // DimensionalDataStructure
      //
      if (n.name () == "DimensionalDataStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalDataStructure_type > r (
          DimensionalDataStructure_traits::create (i, f, this));

        this->DimensionalDataStructure_.push_back (::std::move (r));
        continue;
      }

      // DimensionalKey
      //
      if (n.name () == "DimensionalKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalKey_type > r (
          DimensionalKey_traits::create (i, f, this));

        this->DimensionalKey_.push_back (::std::move (r));
        continue;
      }

      // DimensionalKeyDefinition
      //
      if (n.name () == "DimensionalKeyDefinition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalKeyDefinition_type > r (
          DimensionalKeyDefinition_traits::create (i, f, this));

        this->DimensionalKeyDefinition_.push_back (::std::move (r));
        continue;
      }

      // DimensionalKeyDefinitionMember
      //
      if (n.name () == "DimensionalKeyDefinitionMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalKeyDefinitionMember_type > r (
          DimensionalKeyDefinitionMember_traits::create (i, f, this));

        this->DimensionalKeyDefinitionMember_.push_back (::std::move (r));
        continue;
      }

      // DimensionalKeyMember
      //
      if (n.name () == "DimensionalKeyMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalKeyMember_type > r (
          DimensionalKeyMember_traits::create (i, f, this));

        this->DimensionalKeyMember_.push_back (::std::move (r));
        continue;
      }

      // EnumerationDomain
      //
      if (n.name () == "EnumerationDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< EnumerationDomain_type > r (
          EnumerationDomain_traits::create (i, f, this));

        this->EnumerationDomain_.push_back (::std::move (r));
        continue;
      }

      // ForeignKey
      //
      if (n.name () == "ForeignKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ForeignKey_type > r (
          ForeignKey_traits::create (i, f, this));

        this->ForeignKey_.push_back (::std::move (r));
        continue;
      }

      // ForeignKeyComponent
      //
      if (n.name () == "ForeignKeyComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ForeignKeyComponent_type > r (
          ForeignKeyComponent_traits::create (i, f, this));

        this->ForeignKeyComponent_.push_back (::std::move (r));
        continue;
      }

      // IdentifierComponent
      //
      if (n.name () == "IdentifierComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< IdentifierComponent_type > r (
          IdentifierComponent_traits::create (i, f, this));

        this->IdentifierComponent_.push_back (::std::move (r));
        continue;
      }

      // Individual
      //
      if (n.name () == "Individual" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Individual_type > r (
          Individual_traits::create (i, f, this));

        this->Individual_.push_back (::std::move (r));
        continue;
      }

      // InformationFlowDefinition
      //
      if (n.name () == "InformationFlowDefinition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InformationFlowDefinition_type > r (
          InformationFlowDefinition_traits::create (i, f, this));

        this->InformationFlowDefinition_.push_back (::std::move (r));
        continue;
      }

      // InstanceKey
      //
      if (n.name () == "InstanceKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceKey_type > r (
          InstanceKey_traits::create (i, f, this));

        this->InstanceKey_.push_back (::std::move (r));
        continue;
      }

      // InstanceValue
      //
      if (n.name () == "InstanceValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceValue_type > r (
          InstanceValue_traits::create (i, f, this));

        this->InstanceValue_.push_back (::std::move (r));
        continue;
      }

      // InstanceVariable
      //
      if (n.name () == "InstanceVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceVariable_type > r (
          InstanceVariable_traits::create (i, f, this));

        this->InstanceVariable_.push_back (::std::move (r));
        continue;
      }

      // InstanceVariableMap
      //
      if (n.name () == "InstanceVariableMap" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceVariableMap_type > r (
          InstanceVariableMap_traits::create (i, f, this));

        this->InstanceVariableMap_.push_back (::std::move (r));
        continue;
      }

      // Key
      //
      if (n.name () == "Key" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Key_type > r (
          Key_traits::create (i, f, this));

        this->Key_.push_back (::std::move (r));
        continue;
      }

      // KeyDefinition
      //
      if (n.name () == "KeyDefinition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyDefinition_type > r (
          KeyDefinition_traits::create (i, f, this));

        this->KeyDefinition_.push_back (::std::move (r));
        continue;
      }

      // KeyDefinitionMember
      //
      if (n.name () == "KeyDefinitionMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyDefinitionMember_type > r (
          KeyDefinitionMember_traits::create (i, f, this));

        this->KeyDefinitionMember_.push_back (::std::move (r));
        continue;
      }

      // KeyMember
      //
      if (n.name () == "KeyMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyMember_type > r (
          KeyMember_traits::create (i, f, this));

        this->KeyMember_.push_back (::std::move (r));
        continue;
      }

      // KeyValueDataStore
      //
      if (n.name () == "KeyValueDataStore" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyValueDataStore_type > r (
          KeyValueDataStore_traits::create (i, f, this));

        this->KeyValueDataStore_.push_back (::std::move (r));
        continue;
      }

      // KeyValueStructure
      //
      if (n.name () == "KeyValueStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyValueStructure_type > r (
          KeyValueStructure_traits::create (i, f, this));

        this->KeyValueStructure_.push_back (::std::move (r));
        continue;
      }

      // Level
      //
      if (n.name () == "Level" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Level_type > r (
          Level_traits::create (i, f, this));

        this->Level_.push_back (::std::move (r));
        continue;
      }

      // LevelStructure
      //
      if (n.name () == "LevelStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LevelStructure_type > r (
          LevelStructure_traits::create (i, f, this));

        this->LevelStructure_.push_back (::std::move (r));
        continue;
      }

      // LogicalRecord
      //
      if (n.name () == "LogicalRecord" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecord_type > r (
          LogicalRecord_traits::create (i, f, this));

        this->LogicalRecord_.push_back (::std::move (r));
        continue;
      }

      // LogicalRecordPosition
      //
      if (n.name () == "LogicalRecordPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecordPosition_type > r (
          LogicalRecordPosition_traits::create (i, f, this));

        this->LogicalRecordPosition_.push_back (::std::move (r));
        continue;
      }

      // LogicalRecordRelationStructure
      //
      if (n.name () == "LogicalRecordRelationStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecordRelationStructure_type > r (
          LogicalRecordRelationStructure_traits::create (i, f, this));

        this->LogicalRecordRelationStructure_.push_back (::std::move (r));
        continue;
      }

      // LogicalRecordRelationship
      //
      if (n.name () == "LogicalRecordRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecordRelationship_type > r (
          LogicalRecordRelationship_traits::create (i, f, this));

        this->LogicalRecordRelationship_.push_back (::std::move (r));
        continue;
      }

      // LongDataSet
      //
      if (n.name () == "LongDataSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LongDataSet_type > r (
          LongDataSet_traits::create (i, f, this));

        this->LongDataSet_.push_back (::std::move (r));
        continue;
      }

      // LongDataStructure
      //
      if (n.name () == "LongDataStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LongDataStructure_type > r (
          LongDataStructure_traits::create (i, f, this));

        this->LongDataStructure_.push_back (::std::move (r));
        continue;
      }

      // LongKey
      //
      if (n.name () == "LongKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LongKey_type > r (
          LongKey_traits::create (i, f, this));

        this->LongKey_.push_back (::std::move (r));
        continue;
      }

      // LongMainKeyMember
      //
      if (n.name () == "LongMainKeyMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LongMainKeyMember_type > r (
          LongMainKeyMember_traits::create (i, f, this));

        this->LongMainKeyMember_.push_back (::std::move (r));
        continue;
      }

      // Machine
      //
      if (n.name () == "Machine" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Machine_type > r (
          Machine_traits::create (i, f, this));

        this->Machine_.push_back (::std::move (r));
        continue;
      }

      // MainKeyMember
      //
      if (n.name () == "MainKeyMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< MainKeyMember_type > r (
          MainKeyMember_traits::create (i, f, this));

        this->MainKeyMember_.push_back (::std::move (r));
        continue;
      }

      // MeasureComponent
      //
      if (n.name () == "MeasureComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< MeasureComponent_type > r (
          MeasureComponent_traits::create (i, f, this));

        this->MeasureComponent_.push_back (::std::move (r));
        continue;
      }

      // NonDeterministicDeclarative
      //
      if (n.name () == "NonDeterministicDeclarative" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< NonDeterministicDeclarative_type > r (
          NonDeterministicDeclarative_traits::create (i, f, this));

        this->NonDeterministicDeclarative_.push_back (::std::move (r));
        continue;
      }

      // Notation
      //
      if (n.name () == "Notation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Notation_type > r (
          Notation_traits::create (i, f, this));

        this->Notation_.push_back (::std::move (r));
        continue;
      }

      // Organization
      //
      if (n.name () == "Organization" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Organization_type > r (
          Organization_traits::create (i, f, this));

        this->Organization_.push_back (::std::move (r));
        continue;
      }

      // Parameter
      //
      if (n.name () == "Parameter" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Parameter_type > r (
          Parameter_traits::create (i, f, this));

        this->Parameter_.push_back (::std::move (r));
        continue;
      }

      // PhysicalDataSet
      //
      if (n.name () == "PhysicalDataSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalDataSet_type > r (
          PhysicalDataSet_traits::create (i, f, this));

        this->PhysicalDataSet_.push_back (::std::move (r));
        continue;
      }

      // PhysicalDataSetStructure
      //
      if (n.name () == "PhysicalDataSetStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalDataSetStructure_type > r (
          PhysicalDataSetStructure_traits::create (i, f, this));

        this->PhysicalDataSetStructure_.push_back (::std::move (r));
        continue;
      }

      // PhysicalLayoutRelationStructure
      //
      if (n.name () == "PhysicalLayoutRelationStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalLayoutRelationStructure_type > r (
          PhysicalLayoutRelationStructure_traits::create (i, f, this));

        this->PhysicalLayoutRelationStructure_.push_back (::std::move (r));
        continue;
      }

      // PhysicalRecordSegment
      //
      if (n.name () == "PhysicalRecordSegment" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegment_type > r (
          PhysicalRecordSegment_traits::create (i, f, this));

        this->PhysicalRecordSegment_.push_back (::std::move (r));
        continue;
      }

      // PhysicalRecordSegmentPosition
      //
      if (n.name () == "PhysicalRecordSegmentPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegmentPosition_type > r (
          PhysicalRecordSegmentPosition_traits::create (i, f, this));

        this->PhysicalRecordSegmentPosition_.push_back (::std::move (r));
        continue;
      }

      // PhysicalRecordSegmentRelationship
      //
      if (n.name () == "PhysicalRecordSegmentRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegmentRelationship_type > r (
          PhysicalRecordSegmentRelationship_traits::create (i, f, this));

        this->PhysicalRecordSegmentRelationship_.push_back (::std::move (r));
        continue;
      }

      // PhysicalRecordSegmentStructure
      //
      if (n.name () == "PhysicalRecordSegmentStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegmentStructure_type > r (
          PhysicalRecordSegmentStructure_traits::create (i, f, this));

        this->PhysicalRecordSegmentStructure_.push_back (::std::move (r));
        continue;
      }

      // PhysicalSegmentLayout
      //
      if (n.name () == "PhysicalSegmentLayout" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalSegmentLayout_type > r (
          PhysicalSegmentLayout_traits::create (i, f, this));

        this->PhysicalSegmentLayout_.push_back (::std::move (r));
        continue;
      }

      // PhysicalSegmentLocation
      //
      if (n.name () == "PhysicalSegmentLocation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalSegmentLocation_type > r (
          PhysicalSegmentLocation_traits::create (i, f, this));

        this->PhysicalSegmentLocation_.push_back (::std::move (r));
        continue;
      }

      // Population
      //
      if (n.name () == "Population" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Population_type > r (
          Population_traits::create (i, f, this));

        this->Population_.push_back (::std::move (r));
        continue;
      }

      // PrimaryKey
      //
      if (n.name () == "PrimaryKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PrimaryKey_type > r (
          PrimaryKey_traits::create (i, f, this));

        this->PrimaryKey_.push_back (::std::move (r));
        continue;
      }

      // PrimaryKeyComponent
      //
      if (n.name () == "PrimaryKeyComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PrimaryKeyComponent_type > r (
          PrimaryKeyComponent_traits::create (i, f, this));

        this->PrimaryKeyComponent_.push_back (::std::move (r));
        continue;
      }

      // ProcessingAgent
      //
      if (n.name () == "ProcessingAgent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ProcessingAgent_type > r (
          ProcessingAgent_traits::create (i, f, this));

        this->ProcessingAgent_.push_back (::std::move (r));
        continue;
      }

      // ProductionEnvironment
      //
      if (n.name () == "ProductionEnvironment" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ProductionEnvironment_type > r (
          ProductionEnvironment_traits::create (i, f, this));

        this->ProductionEnvironment_.push_back (::std::move (r));
        continue;
      }

      // QualifiedMeasure
      //
      if (n.name () == "QualifiedMeasure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< QualifiedMeasure_type > r (
          QualifiedMeasure_traits::create (i, f, this));

        this->QualifiedMeasure_.push_back (::std::move (r));
        continue;
      }

      // RecordRelation
      //
      if (n.name () == "RecordRelation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RecordRelation_type > r (
          RecordRelation_traits::create (i, f, this));

        this->RecordRelation_.push_back (::std::move (r));
        continue;
      }

      // ReferenceValue
      //
      if (n.name () == "ReferenceValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ReferenceValue_type > r (
          ReferenceValue_traits::create (i, f, this));

        this->ReferenceValue_.push_back (::std::move (r));
        continue;
      }

      // ReferenceValueDomain
      //
      if (n.name () == "ReferenceValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ReferenceValueDomain_type > r (
          ReferenceValueDomain_traits::create (i, f, this));

        this->ReferenceValueDomain_.push_back (::std::move (r));
        continue;
      }

      // ReferenceVariable
      //
      if (n.name () == "ReferenceVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ReferenceVariable_type > r (
          ReferenceVariable_traits::create (i, f, this));

        this->ReferenceVariable_.push_back (::std::move (r));
        continue;
      }

      // RepresentedVariable
      //
      if (n.name () == "RepresentedVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RepresentedVariable_type > r (
          RepresentedVariable_traits::create (i, f, this));

        this->RepresentedVariable_.push_back (::std::move (r));
        continue;
      }

      // RevisableDatum
      //
      if (n.name () == "RevisableDatum" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RevisableDatum_type > r (
          RevisableDatum_traits::create (i, f, this));

        this->RevisableDatum_.push_back (::std::move (r));
        continue;
      }

      // Revision
      //
      if (n.name () == "Revision" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Revision_type > r (
          Revision_traits::create (i, f, this));

        this->Revision_.push_back (::std::move (r));
        continue;
      }

      // Rule
      //
      if (n.name () == "Rule" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Rule_type > r (
          Rule_traits::create (i, f, this));

        this->Rule_.push_back (::std::move (r));
        continue;
      }

      // RuleBasedScheduling
      //
      if (n.name () == "RuleBasedScheduling" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RuleBasedScheduling_type > r (
          RuleBasedScheduling_traits::create (i, f, this));

        this->RuleBasedScheduling_.push_back (::std::move (r));
        continue;
      }

      // RuleSet
      //
      if (n.name () == "RuleSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RuleSet_type > r (
          RuleSet_traits::create (i, f, this));

        this->RuleSet_.push_back (::std::move (r));
        continue;
      }

      // ScopedMeasure
      //
      if (n.name () == "ScopedMeasure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ScopedMeasure_type > r (
          ScopedMeasure_traits::create (i, f, this));

        this->ScopedMeasure_.push_back (::std::move (r));
        continue;
      }

      // SegmentByText
      //
      if (n.name () == "SegmentByText" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SegmentByText_type > r (
          SegmentByText_traits::create (i, f, this));

        this->SegmentByText_.push_back (::std::move (r));
        continue;
      }

      // SentinelConceptualDomain
      //
      if (n.name () == "SentinelConceptualDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SentinelConceptualDomain_type > r (
          SentinelConceptualDomain_traits::create (i, f, this));

        this->SentinelConceptualDomain_.push_back (::std::move (r));
        continue;
      }

      // SentinelValueDomain
      //
      if (n.name () == "SentinelValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SentinelValueDomain_type > r (
          SentinelValueDomain_traits::create (i, f, this));

        this->SentinelValueDomain_.push_back (::std::move (r));
        continue;
      }

      // Sequence
      //
      if (n.name () == "Sequence" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Sequence_type > r (
          Sequence_traits::create (i, f, this));

        this->Sequence_.push_back (::std::move (r));
        continue;
      }

      // SequencePosition
      //
      if (n.name () == "SequencePosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SequencePosition_type > r (
          SequencePosition_traits::create (i, f, this));

        this->SequencePosition_.push_back (::std::move (r));
        continue;
      }

      // Service
      //
      if (n.name () == "Service" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Service_type > r (
          Service_traits::create (i, f, this));

        this->Service_.push_back (::std::move (r));
        continue;
      }

      // StatisticalClassification
      //
      if (n.name () == "StatisticalClassification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassification_type > r (
          StatisticalClassification_traits::create (i, f, this));

        this->StatisticalClassification_.push_back (::std::move (r));
        continue;
      }

      // StatisticalClassificationRelationship
      //
      if (n.name () == "StatisticalClassificationRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassificationRelationship_type > r (
          StatisticalClassificationRelationship_traits::create (i, f, this));

        this->StatisticalClassificationRelationship_.push_back (::std::move (r));
        continue;
      }

      // Step
      //
      if (n.name () == "Step" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Step_type > r (
          Step_traits::create (i, f, this));

        this->Step_.push_back (::std::move (r));
        continue;
      }

      // SubstantiveConceptualDomain
      //
      if (n.name () == "SubstantiveConceptualDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SubstantiveConceptualDomain_type > r (
          SubstantiveConceptualDomain_traits::create (i, f, this));

        this->SubstantiveConceptualDomain_.push_back (::std::move (r));
        continue;
      }

      // SubstantiveValueDomain
      //
      if (n.name () == "SubstantiveValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SubstantiveValueDomain_type > r (
          SubstantiveValueDomain_traits::create (i, f, this));

        this->SubstantiveValueDomain_.push_back (::std::move (r));
        continue;
      }

      // SyntheticIdComponent
      //
      if (n.name () == "SyntheticIdComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SyntheticIdComponent_type > r (
          SyntheticIdComponent_traits::create (i, f, this));

        this->SyntheticIdComponent_.push_back (::std::move (r));
        continue;
      }

      // TemporalConstraints
      //
      if (n.name () == "TemporalConstraints" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< TemporalConstraints_type > r (
          TemporalConstraints_traits::create (i, f, this));

        this->TemporalConstraints_.push_back (::std::move (r));
        continue;
      }

      // TemporalControlConstruct
      //
      if (n.name () == "TemporalControlConstruct" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< TemporalControlConstruct_type > r (
          TemporalControlConstruct_traits::create (i, f, this));

        this->TemporalControlConstruct_.push_back (::std::move (r));
        continue;
      }

      // Unit
      //
      if (n.name () == "Unit" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Unit_type > r (
          Unit_traits::create (i, f, this));

        this->Unit_.push_back (::std::move (r));
        continue;
      }

      // UnitSegmentLayout
      //
      if (n.name () == "UnitSegmentLayout" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< UnitSegmentLayout_type > r (
          UnitSegmentLayout_traits::create (i, f, this));

        this->UnitSegmentLayout_.push_back (::std::move (r));
        continue;
      }

      // UnitType
      //
      if (n.name () == "UnitType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< UnitType_type > r (
          UnitType_traits::create (i, f, this));

        this->UnitType_.push_back (::std::move (r));
        continue;
      }

      // Universe
      //
      if (n.name () == "Universe" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Universe_type > r (
          Universe_traits::create (i, f, this));

        this->Universe_.push_back (::std::move (r));
        continue;
      }

      // ValueAndConceptDescription
      //
      if (n.name () == "ValueAndConceptDescription" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueAndConceptDescription_type > r (
          ValueAndConceptDescription_traits::create (i, f, this));

        this->ValueAndConceptDescription_.push_back (::std::move (r));
        continue;
      }

      // ValueDomain
      //
      if (n.name () == "ValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueDomain_type > r (
          ValueDomain_traits::create (i, f, this));

        this->ValueDomain_.push_back (::std::move (r));
        continue;
      }

      // ValueMapping
      //
      if (n.name () == "ValueMapping" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueMapping_type > r (
          ValueMapping_traits::create (i, f, this));

        this->ValueMapping_.push_back (::std::move (r));
        continue;
      }

      // ValueMappingPosition
      //
      if (n.name () == "ValueMappingPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueMappingPosition_type > r (
          ValueMappingPosition_traits::create (i, f, this));

        this->ValueMappingPosition_.push_back (::std::move (r));
        continue;
      }

      // ValueMappingRelationship
      //
      if (n.name () == "ValueMappingRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueMappingRelationship_type > r (
          ValueMappingRelationship_traits::create (i, f, this));

        this->ValueMappingRelationship_.push_back (::std::move (r));
        continue;
      }

      // VariableCollection
      //
      if (n.name () == "VariableCollection" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableCollection_type > r (
          VariableCollection_traits::create (i, f, this));

        this->VariableCollection_.push_back (::std::move (r));
        continue;
      }

      // VariableDescriptorComponent
      //
      if (n.name () == "VariableDescriptorComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableDescriptorComponent_type > r (
          VariableDescriptorComponent_traits::create (i, f, this));

        this->VariableDescriptorComponent_.push_back (::std::move (r));
        continue;
      }

      // VariablePosition
      //
      if (n.name () == "VariablePosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariablePosition_type > r (
          VariablePosition_traits::create (i, f, this));

        this->VariablePosition_.push_back (::std::move (r));
        continue;
      }

      // VariableRelationship
      //
      if (n.name () == "VariableRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableRelationship_type > r (
          VariableRelationship_traits::create (i, f, this));

        this->VariableRelationship_.push_back (::std::move (r));
        continue;
      }

      // VariableStructure
      //
      if (n.name () == "VariableStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableStructure_type > r (
          VariableStructure_traits::create (i, f, this));

        this->VariableStructure_.push_back (::std::move (r));
        continue;
      }

      // VariableValueComponent
      //
      if (n.name () == "VariableValueComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableValueComponent_type > r (
          VariableValueComponent_traits::create (i, f, this));

        this->VariableValueComponent_.push_back (::std::move (r));
        continue;
      }

      // WideDataSet
      //
      if (n.name () == "WideDataSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< WideDataSet_type > r (
          WideDataSet_traits::create (i, f, this));

        this->WideDataSet_.push_back (::std::move (r));
        continue;
      }

      // WideDataStructure
      //
      if (n.name () == "WideDataStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< WideDataStructure_type > r (
          WideDataStructure_traits::create (i, f, this));

        this->WideDataStructure_.push_back (::std::move (r));
        continue;
      }

      // WideKey
      //
      if (n.name () == "WideKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< WideKey_type > r (
          WideKey_traits::create (i, f, this));

        this->WideKey_.push_back (::std::move (r));
        continue;
      }

      // WideKeyMember
      //
      if (n.name () == "WideKeyMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< WideKeyMember_type > r (
          WideKeyMember_traits::create (i, f, this));

        this->WideKeyMember_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Wrapper* Wrapper::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Wrapper (*this, f, c);
  }

  Wrapper& Wrapper::
  operator= (const Wrapper& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->supportingInformation_ = x.supportingInformation_;
      this->Activity_ = x.Activity_;
      this->Agent_ = x.Agent_;
      this->AgentListing_ = x.AgentListing_;
      this->AgentPosition_ = x.AgentPosition_;
      this->AgentRelationship_ = x.AgentRelationship_;
      this->AgentStructure_ = x.AgentStructure_;
      this->AllenIntervalAlgebra_ = x.AllenIntervalAlgebra_;
      this->AttributeComponent_ = x.AttributeComponent_;
      this->AuthorizationSource_ = x.AuthorizationSource_;
      this->Category_ = x.Category_;
      this->CategoryPosition_ = x.CategoryPosition_;
      this->CategoryRelationStructure_ = x.CategoryRelationStructure_;
      this->CategoryRelationship_ = x.CategoryRelationship_;
      this->CategorySet_ = x.CategorySet_;
      this->CategoryStatistic_ = x.CategoryStatistic_;
      this->ClassificationFamily_ = x.ClassificationFamily_;
      this->ClassificationIndex_ = x.ClassificationIndex_;
      this->ClassificationIndexEntry_ = x.ClassificationIndexEntry_;
      this->ClassificationIndexEntryPosition_ = x.ClassificationIndexEntryPosition_;
      this->ClassificationItem_ = x.ClassificationItem_;
      this->ClassificationItemPosition_ = x.ClassificationItemPosition_;
      this->ClassificationItemRelationship_ = x.ClassificationItemRelationship_;
      this->ClassificationItemStructure_ = x.ClassificationItemStructure_;
      this->ClassificationPosition_ = x.ClassificationPosition_;
      this->ClassificationSeries_ = x.ClassificationSeries_;
      this->ClassificationSeriesStructure_ = x.ClassificationSeriesStructure_;
      this->Code_ = x.Code_;
      this->CodeList_ = x.CodeList_;
      this->CodeListStructure_ = x.CodeListStructure_;
      this->CodePosition_ = x.CodePosition_;
      this->CodeRelationship_ = x.CodeRelationship_;
      this->ComponentPosition_ = x.ComponentPosition_;
      this->Concept_ = x.Concept_;
      this->ConceptMap_ = x.ConceptMap_;
      this->ConceptRelationship_ = x.ConceptRelationship_;
      this->ConceptStructure_ = x.ConceptStructure_;
      this->ConceptSystem_ = x.ConceptSystem_;
      this->ConceptSystemCorrespondence_ = x.ConceptSystemCorrespondence_;
      this->ConceptualDomain_ = x.ConceptualDomain_;
      this->ConceptualValue_ = x.ConceptualValue_;
      this->ConceptualVariable_ = x.ConceptualVariable_;
      this->ConditionalControlLogic_ = x.ConditionalControlLogic_;
      this->ContextualComponent_ = x.ContextualComponent_;
      this->ControlLogic_ = x.ControlLogic_;
      this->CorrespondenceTable_ = x.CorrespondenceTable_;
      this->Curator_ = x.Curator_;
      this->DataPoint_ = x.DataPoint_;
      this->DataPointPosition_ = x.DataPointPosition_;
      this->DataPointRelationship_ = x.DataPointRelationship_;
      this->DataSet_ = x.DataSet_;
      this->DataStore_ = x.DataStore_;
      this->DataStructure_ = x.DataStructure_;
      this->DataStructureComponent_ = x.DataStructureComponent_;
      this->Datum_ = x.Datum_;
      this->Descriptor_ = x.Descriptor_;
      this->DescriptorValueDomain_ = x.DescriptorValueDomain_;
      this->DescriptorVariable_ = x.DescriptorVariable_;
      this->DeterministicImperative_ = x.DeterministicImperative_;
      this->DimensionComponent_ = x.DimensionComponent_;
      this->DimensionGroup_ = x.DimensionGroup_;
      this->DimensionalDataSet_ = x.DimensionalDataSet_;
      this->DimensionalDataStructure_ = x.DimensionalDataStructure_;
      this->DimensionalKey_ = x.DimensionalKey_;
      this->DimensionalKeyDefinition_ = x.DimensionalKeyDefinition_;
      this->DimensionalKeyDefinitionMember_ = x.DimensionalKeyDefinitionMember_;
      this->DimensionalKeyMember_ = x.DimensionalKeyMember_;
      this->EnumerationDomain_ = x.EnumerationDomain_;
      this->ForeignKey_ = x.ForeignKey_;
      this->ForeignKeyComponent_ = x.ForeignKeyComponent_;
      this->IdentifierComponent_ = x.IdentifierComponent_;
      this->Individual_ = x.Individual_;
      this->InformationFlowDefinition_ = x.InformationFlowDefinition_;
      this->InstanceKey_ = x.InstanceKey_;
      this->InstanceValue_ = x.InstanceValue_;
      this->InstanceVariable_ = x.InstanceVariable_;
      this->InstanceVariableMap_ = x.InstanceVariableMap_;
      this->Key_ = x.Key_;
      this->KeyDefinition_ = x.KeyDefinition_;
      this->KeyDefinitionMember_ = x.KeyDefinitionMember_;
      this->KeyMember_ = x.KeyMember_;
      this->KeyValueDataStore_ = x.KeyValueDataStore_;
      this->KeyValueStructure_ = x.KeyValueStructure_;
      this->Level_ = x.Level_;
      this->LevelStructure_ = x.LevelStructure_;
      this->LogicalRecord_ = x.LogicalRecord_;
      this->LogicalRecordPosition_ = x.LogicalRecordPosition_;
      this->LogicalRecordRelationStructure_ = x.LogicalRecordRelationStructure_;
      this->LogicalRecordRelationship_ = x.LogicalRecordRelationship_;
      this->LongDataSet_ = x.LongDataSet_;
      this->LongDataStructure_ = x.LongDataStructure_;
      this->LongKey_ = x.LongKey_;
      this->LongMainKeyMember_ = x.LongMainKeyMember_;
      this->Machine_ = x.Machine_;
      this->MainKeyMember_ = x.MainKeyMember_;
      this->MeasureComponent_ = x.MeasureComponent_;
      this->NonDeterministicDeclarative_ = x.NonDeterministicDeclarative_;
      this->Notation_ = x.Notation_;
      this->Organization_ = x.Organization_;
      this->Parameter_ = x.Parameter_;
      this->PhysicalDataSet_ = x.PhysicalDataSet_;
      this->PhysicalDataSetStructure_ = x.PhysicalDataSetStructure_;
      this->PhysicalLayoutRelationStructure_ = x.PhysicalLayoutRelationStructure_;
      this->PhysicalRecordSegment_ = x.PhysicalRecordSegment_;
      this->PhysicalRecordSegmentPosition_ = x.PhysicalRecordSegmentPosition_;
      this->PhysicalRecordSegmentRelationship_ = x.PhysicalRecordSegmentRelationship_;
      this->PhysicalRecordSegmentStructure_ = x.PhysicalRecordSegmentStructure_;
      this->PhysicalSegmentLayout_ = x.PhysicalSegmentLayout_;
      this->PhysicalSegmentLocation_ = x.PhysicalSegmentLocation_;
      this->Population_ = x.Population_;
      this->PrimaryKey_ = x.PrimaryKey_;
      this->PrimaryKeyComponent_ = x.PrimaryKeyComponent_;
      this->ProcessingAgent_ = x.ProcessingAgent_;
      this->ProductionEnvironment_ = x.ProductionEnvironment_;
      this->QualifiedMeasure_ = x.QualifiedMeasure_;
      this->RecordRelation_ = x.RecordRelation_;
      this->ReferenceValue_ = x.ReferenceValue_;
      this->ReferenceValueDomain_ = x.ReferenceValueDomain_;
      this->ReferenceVariable_ = x.ReferenceVariable_;
      this->RepresentedVariable_ = x.RepresentedVariable_;
      this->RevisableDatum_ = x.RevisableDatum_;
      this->Revision_ = x.Revision_;
      this->Rule_ = x.Rule_;
      this->RuleBasedScheduling_ = x.RuleBasedScheduling_;
      this->RuleSet_ = x.RuleSet_;
      this->ScopedMeasure_ = x.ScopedMeasure_;
      this->SegmentByText_ = x.SegmentByText_;
      this->SentinelConceptualDomain_ = x.SentinelConceptualDomain_;
      this->SentinelValueDomain_ = x.SentinelValueDomain_;
      this->Sequence_ = x.Sequence_;
      this->SequencePosition_ = x.SequencePosition_;
      this->Service_ = x.Service_;
      this->StatisticalClassification_ = x.StatisticalClassification_;
      this->StatisticalClassificationRelationship_ = x.StatisticalClassificationRelationship_;
      this->Step_ = x.Step_;
      this->SubstantiveConceptualDomain_ = x.SubstantiveConceptualDomain_;
      this->SubstantiveValueDomain_ = x.SubstantiveValueDomain_;
      this->SyntheticIdComponent_ = x.SyntheticIdComponent_;
      this->TemporalConstraints_ = x.TemporalConstraints_;
      this->TemporalControlConstruct_ = x.TemporalControlConstruct_;
      this->Unit_ = x.Unit_;
      this->UnitSegmentLayout_ = x.UnitSegmentLayout_;
      this->UnitType_ = x.UnitType_;
      this->Universe_ = x.Universe_;
      this->ValueAndConceptDescription_ = x.ValueAndConceptDescription_;
      this->ValueDomain_ = x.ValueDomain_;
      this->ValueMapping_ = x.ValueMapping_;
      this->ValueMappingPosition_ = x.ValueMappingPosition_;
      this->ValueMappingRelationship_ = x.ValueMappingRelationship_;
      this->VariableCollection_ = x.VariableCollection_;
      this->VariableDescriptorComponent_ = x.VariableDescriptorComponent_;
      this->VariablePosition_ = x.VariablePosition_;
      this->VariableRelationship_ = x.VariableRelationship_;
      this->VariableStructure_ = x.VariableStructure_;
      this->VariableValueComponent_ = x.VariableValueComponent_;
      this->WideDataSet_ = x.WideDataSet_;
      this->WideDataStructure_ = x.WideDataStructure_;
      this->WideKey_ = x.WideKey_;
      this->WideKeyMember_ = x.WideKeyMember_;
    }

    return *this;
  }

  Wrapper::
  ~Wrapper ()
  {
  }

  // Activity
  //

  Activity::
  Activity ()
  : ::xml_schema::type (),
    definition_ (this),
    description_ (this),
    displayLabel_ (this),
    entityProduced_ (this),
    entityUsed_ (this),
    identifier_ (this),
    name_ (this),
    standardModelMapping_ (this),
    Activity_hasInternal_ControlLogic_ (this),
    Activity_hasSubActivity_Activity_ (this),
    Activity_has_Step_ (this)
  {
  }

  Activity::
  Activity (const Activity& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    definition_ (x.definition_, f, this),
    description_ (x.description_, f, this),
    displayLabel_ (x.displayLabel_, f, this),
    entityProduced_ (x.entityProduced_, f, this),
    entityUsed_ (x.entityUsed_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    standardModelMapping_ (x.standardModelMapping_, f, this),
    Activity_hasInternal_ControlLogic_ (x.Activity_hasInternal_ControlLogic_, f, this),
    Activity_hasSubActivity_Activity_ (x.Activity_hasSubActivity_Activity_, f, this),
    Activity_has_Step_ (x.Activity_has_Step_, f, this)
  {
  }

  Activity::
  Activity (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    definition_ (this),
    description_ (this),
    displayLabel_ (this),
    entityProduced_ (this),
    entityUsed_ (this),
    identifier_ (this),
    name_ (this),
    standardModelMapping_ (this),
    Activity_hasInternal_ControlLogic_ (this),
    Activity_hasSubActivity_Activity_ (this),
    Activity_has_Step_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Activity::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // definition
      //
      if (n.name () == "definition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< definition_type > r (
          definition_traits::create (i, f, this));

        if (!this->definition_)
        {
          this->definition_.set (::std::move (r));
          continue;
        }
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!this->description_)
        {
          this->description_.set (::std::move (r));
          continue;
        }
      }

      // displayLabel
      //
      if (n.name () == "displayLabel" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< displayLabel_type > r (
          displayLabel_traits::create (i, f, this));

        this->displayLabel_.push_back (::std::move (r));
        continue;
      }

      // entityProduced
      //
      if (n.name () == "entityProduced" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< entityProduced_type > r (
          entityProduced_traits::create (i, f, this));

        this->entityProduced_.push_back (::std::move (r));
        continue;
      }

      // entityUsed
      //
      if (n.name () == "entityUsed" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< entityUsed_type > r (
          entityUsed_traits::create (i, f, this));

        this->entityUsed_.push_back (::std::move (r));
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // standardModelMapping
      //
      if (n.name () == "standardModelMapping" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< standardModelMapping_type > r (
          standardModelMapping_traits::create (i, f, this));

        this->standardModelMapping_.push_back (::std::move (r));
        continue;
      }

      // Activity_hasInternal_ControlLogic
      //
      if (n.name () == "Activity_hasInternal_ControlLogic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Activity_hasInternal_ControlLogic_type > r (
          Activity_hasInternal_ControlLogic_traits::create (i, f, this));

        this->Activity_hasInternal_ControlLogic_.push_back (::std::move (r));
        continue;
      }

      // Activity_hasSubActivity_Activity
      //
      if (n.name () == "Activity_hasSubActivity_Activity" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Activity_hasSubActivity_Activity_type > r (
          Activity_hasSubActivity_Activity_traits::create (i, f, this));

        this->Activity_hasSubActivity_Activity_.push_back (::std::move (r));
        continue;
      }

      // Activity_has_Step
      //
      if (n.name () == "Activity_has_Step" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Activity_has_Step_type > r (
          Activity_has_Step_traits::create (i, f, this));

        this->Activity_has_Step_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Activity* Activity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Activity (*this, f, c);
  }

  Activity& Activity::
  operator= (const Activity& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->definition_ = x.definition_;
      this->description_ = x.description_;
      this->displayLabel_ = x.displayLabel_;
      this->entityProduced_ = x.entityProduced_;
      this->entityUsed_ = x.entityUsed_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->standardModelMapping_ = x.standardModelMapping_;
      this->Activity_hasInternal_ControlLogic_ = x.Activity_hasInternal_ControlLogic_;
      this->Activity_hasSubActivity_Activity_ = x.Activity_hasSubActivity_Activity_;
      this->Activity_has_Step_ = x.Activity_has_Step_;
    }

    return *this;
  }

  Activity::
  ~Activity ()
  {
  }

  // Agent
  //

  Agent::
  Agent ()
  : ::xml_schema::type (),
    catalogDetails_ (this),
    identifier_ (this),
    image_ (this),
    purpose_ (this)
  {
  }

  Agent::
  Agent (const Agent& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    identifier_ (x.identifier_, f, this),
    image_ (x.image_, f, this),
    purpose_ (x.purpose_, f, this)
  {
  }

  Agent::
  Agent (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    identifier_ (this),
    image_ (this),
    purpose_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Agent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // image
      //
      if (n.name () == "image" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< image_type > r (
          image_traits::create (i, f, this));

        this->image_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Agent* Agent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Agent (*this, f, c);
  }

  Agent& Agent::
  operator= (const Agent& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->identifier_ = x.identifier_;
      this->image_ = x.image_;
      this->purpose_ = x.purpose_;
    }

    return *this;
  }

  Agent::
  ~Agent ()
  {
  }

  // AgentListing
  //

  AgentListing::
  AgentListing (const allowsDuplicates_type& allowsDuplicates)
  : ::xml_schema::type (),
    allowsDuplicates_ (allowsDuplicates, this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    AgentListing_isDefinedBy_Concept_ (this),
    AgentListing_isMaintainedBy_Agent_ (this),
    AgentListing_has_AgentPosition_ (this),
    AgentListing_has_Agent_ (this)
  {
  }

  AgentListing::
  AgentListing (const AgentListing& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    allowsDuplicates_ (x.allowsDuplicates_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    AgentListing_isDefinedBy_Concept_ (x.AgentListing_isDefinedBy_Concept_, f, this),
    AgentListing_isMaintainedBy_Agent_ (x.AgentListing_isMaintainedBy_Agent_, f, this),
    AgentListing_has_AgentPosition_ (x.AgentListing_has_AgentPosition_, f, this),
    AgentListing_has_Agent_ (x.AgentListing_has_Agent_, f, this)
  {
  }

  AgentListing::
  AgentListing (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    allowsDuplicates_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    AgentListing_isDefinedBy_Concept_ (this),
    AgentListing_isMaintainedBy_Agent_ (this),
    AgentListing_has_AgentPosition_ (this),
    AgentListing_has_Agent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AgentListing::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // allowsDuplicates
      //
      if (n.name () == "allowsDuplicates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!allowsDuplicates_.present ())
        {
          this->allowsDuplicates_.set (allowsDuplicates_traits::create (i, f, this));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // AgentListing_isDefinedBy_Concept
      //
      if (n.name () == "AgentListing_isDefinedBy_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentListing_isDefinedBy_Concept_type > r (
          AgentListing_isDefinedBy_Concept_traits::create (i, f, this));

        this->AgentListing_isDefinedBy_Concept_.push_back (::std::move (r));
        continue;
      }

      // AgentListing_isMaintainedBy_Agent
      //
      if (n.name () == "AgentListing_isMaintainedBy_Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentListing_isMaintainedBy_Agent_type > r (
          AgentListing_isMaintainedBy_Agent_traits::create (i, f, this));

        if (!this->AgentListing_isMaintainedBy_Agent_)
        {
          this->AgentListing_isMaintainedBy_Agent_.set (::std::move (r));
          continue;
        }
      }

      // AgentListing_has_AgentPosition
      //
      if (n.name () == "AgentListing_has_AgentPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentListing_has_AgentPosition_type > r (
          AgentListing_has_AgentPosition_traits::create (i, f, this));

        this->AgentListing_has_AgentPosition_.push_back (::std::move (r));
        continue;
      }

      // AgentListing_has_Agent
      //
      if (n.name () == "AgentListing_has_Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentListing_has_Agent_type > r (
          AgentListing_has_Agent_traits::create (i, f, this));

        this->AgentListing_has_Agent_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!allowsDuplicates_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "allowsDuplicates",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  AgentListing* AgentListing::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentListing (*this, f, c);
  }

  AgentListing& AgentListing::
  operator= (const AgentListing& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->allowsDuplicates_ = x.allowsDuplicates_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->AgentListing_isDefinedBy_Concept_ = x.AgentListing_isDefinedBy_Concept_;
      this->AgentListing_isMaintainedBy_Agent_ = x.AgentListing_isMaintainedBy_Agent_;
      this->AgentListing_has_AgentPosition_ = x.AgentListing_has_AgentPosition_;
      this->AgentListing_has_Agent_ = x.AgentListing_has_Agent_;
    }

    return *this;
  }

  AgentListing::
  ~AgentListing ()
  {
  }

  // AgentPosition
  //

  AgentPosition::
  AgentPosition (const value_type& value)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    AgentPosition_indexes_Agent_ (this)
  {
  }

  AgentPosition::
  AgentPosition (const AgentPosition& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    value_ (x.value_, f, this),
    AgentPosition_indexes_Agent_ (x.AgentPosition_indexes_Agent_, f, this)
  {
  }

  AgentPosition::
  AgentPosition (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    value_ (this),
    AgentPosition_indexes_Agent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AgentPosition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      // AgentPosition_indexes_Agent
      //
      if (n.name () == "AgentPosition_indexes_Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentPosition_indexes_Agent_type > r (
          AgentPosition_indexes_Agent_traits::create (i, f, this));

        if (!this->AgentPosition_indexes_Agent_)
        {
          this->AgentPosition_indexes_Agent_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  AgentPosition* AgentPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentPosition (*this, f, c);
  }

  AgentPosition& AgentPosition::
  operator= (const AgentPosition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->value_ = x.value_;
      this->AgentPosition_indexes_Agent_ = x.AgentPosition_indexes_Agent_;
    }

    return *this;
  }

  AgentPosition::
  ~AgentPosition ()
  {
  }

  // AgentRelationship
  //

  AgentRelationship::
  AgentRelationship (const AgentRelationship_hasSource_Agent_type& AgentRelationship_hasSource_Agent,
                     const AgentRelationship_hasTarget_Agent_type& AgentRelationship_hasTarget_Agent)
  : ::xml_schema::type (),
    effectiveDates_ (this),
    identifier_ (this),
    semantics_ (this),
    AgentRelationship_hasSource_Agent_ (AgentRelationship_hasSource_Agent, this),
    AgentRelationship_hasTarget_Agent_ (AgentRelationship_hasTarget_Agent, this)
  {
  }

  AgentRelationship::
  AgentRelationship (::std::unique_ptr< AgentRelationship_hasSource_Agent_type > AgentRelationship_hasSource_Agent,
                     ::std::unique_ptr< AgentRelationship_hasTarget_Agent_type > AgentRelationship_hasTarget_Agent)
  : ::xml_schema::type (),
    effectiveDates_ (this),
    identifier_ (this),
    semantics_ (this),
    AgentRelationship_hasSource_Agent_ (std::move (AgentRelationship_hasSource_Agent), this),
    AgentRelationship_hasTarget_Agent_ (std::move (AgentRelationship_hasTarget_Agent), this)
  {
  }

  AgentRelationship::
  AgentRelationship (const AgentRelationship& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    effectiveDates_ (x.effectiveDates_, f, this),
    identifier_ (x.identifier_, f, this),
    semantics_ (x.semantics_, f, this),
    AgentRelationship_hasSource_Agent_ (x.AgentRelationship_hasSource_Agent_, f, this),
    AgentRelationship_hasTarget_Agent_ (x.AgentRelationship_hasTarget_Agent_, f, this)
  {
  }

  AgentRelationship::
  AgentRelationship (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    effectiveDates_ (this),
    identifier_ (this),
    semantics_ (this),
    AgentRelationship_hasSource_Agent_ (this),
    AgentRelationship_hasTarget_Agent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AgentRelationship::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // effectiveDates
      //
      if (n.name () == "effectiveDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< effectiveDates_type > r (
          effectiveDates_traits::create (i, f, this));

        if (!this->effectiveDates_)
        {
          this->effectiveDates_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // AgentRelationship_hasSource_Agent
      //
      if (n.name () == "AgentRelationship_hasSource_Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentRelationship_hasSource_Agent_type > r (
          AgentRelationship_hasSource_Agent_traits::create (i, f, this));

        if (!AgentRelationship_hasSource_Agent_.present ())
        {
          this->AgentRelationship_hasSource_Agent_.set (::std::move (r));
          continue;
        }
      }

      // AgentRelationship_hasTarget_Agent
      //
      if (n.name () == "AgentRelationship_hasTarget_Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentRelationship_hasTarget_Agent_type > r (
          AgentRelationship_hasTarget_Agent_traits::create (i, f, this));

        if (!AgentRelationship_hasTarget_Agent_.present ())
        {
          this->AgentRelationship_hasTarget_Agent_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!AgentRelationship_hasSource_Agent_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AgentRelationship_hasSource_Agent",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!AgentRelationship_hasTarget_Agent_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AgentRelationship_hasTarget_Agent",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  AgentRelationship* AgentRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentRelationship (*this, f, c);
  }

  AgentRelationship& AgentRelationship::
  operator= (const AgentRelationship& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->effectiveDates_ = x.effectiveDates_;
      this->identifier_ = x.identifier_;
      this->semantics_ = x.semantics_;
      this->AgentRelationship_hasSource_Agent_ = x.AgentRelationship_hasSource_Agent_;
      this->AgentRelationship_hasTarget_Agent_ = x.AgentRelationship_hasTarget_Agent_;
    }

    return *this;
  }

  AgentRelationship::
  ~AgentRelationship ()
  {
  }

  // AgentStructure
  //

  AgentStructure::
  AgentStructure ()
  : ::xml_schema::type (),
    effectiveDates_ (this),
    identifier_ (this),
    name_ (this),
    privacy_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    AgentStructure_structures_AgentListing_ (this),
    AgentStructure_has_AgentRelationship_ (this)
  {
  }

  AgentStructure::
  AgentStructure (const AgentStructure& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    effectiveDates_ (x.effectiveDates_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    privacy_ (x.privacy_, f, this),
    purpose_ (x.purpose_, f, this),
    semantics_ (x.semantics_, f, this),
    specification_ (x.specification_, f, this),
    topology_ (x.topology_, f, this),
    totality_ (x.totality_, f, this),
    AgentStructure_structures_AgentListing_ (x.AgentStructure_structures_AgentListing_, f, this),
    AgentStructure_has_AgentRelationship_ (x.AgentStructure_has_AgentRelationship_, f, this)
  {
  }

  AgentStructure::
  AgentStructure (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    effectiveDates_ (this),
    identifier_ (this),
    name_ (this),
    privacy_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    AgentStructure_structures_AgentListing_ (this),
    AgentStructure_has_AgentRelationship_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AgentStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // effectiveDates
      //
      if (n.name () == "effectiveDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< effectiveDates_type > r (
          effectiveDates_traits::create (i, f, this));

        if (!this->effectiveDates_)
        {
          this->effectiveDates_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // privacy
      //
      if (n.name () == "privacy" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< privacy_type > r (
          privacy_traits::create (i, f, this));

        if (!this->privacy_)
        {
          this->privacy_.set (::std::move (r));
          continue;
        }
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // specification
      //
      if (n.name () == "specification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< specification_type > r (
          specification_traits::create (i, f, this));

        if (!this->specification_)
        {
          this->specification_.set (::std::move (r));
          continue;
        }
      }

      // topology
      //
      if (n.name () == "topology" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< topology_type > r (
          topology_traits::create (i, f, this));

        if (!this->topology_)
        {
          this->topology_.set (::std::move (r));
          continue;
        }
      }

      // totality
      //
      if (n.name () == "totality" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< totality_type > r (
          totality_traits::create (i, f, this));

        if (!this->totality_)
        {
          this->totality_.set (::std::move (r));
          continue;
        }
      }

      // AgentStructure_structures_AgentListing
      //
      if (n.name () == "AgentStructure_structures_AgentListing" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentStructure_structures_AgentListing_type > r (
          AgentStructure_structures_AgentListing_traits::create (i, f, this));

        if (!this->AgentStructure_structures_AgentListing_)
        {
          this->AgentStructure_structures_AgentListing_.set (::std::move (r));
          continue;
        }
      }

      // AgentStructure_has_AgentRelationship
      //
      if (n.name () == "AgentStructure_has_AgentRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AgentStructure_has_AgentRelationship_type > r (
          AgentStructure_has_AgentRelationship_traits::create (i, f, this));

        this->AgentStructure_has_AgentRelationship_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AgentStructure* AgentStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentStructure (*this, f, c);
  }

  AgentStructure& AgentStructure::
  operator= (const AgentStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->effectiveDates_ = x.effectiveDates_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->privacy_ = x.privacy_;
      this->purpose_ = x.purpose_;
      this->semantics_ = x.semantics_;
      this->specification_ = x.specification_;
      this->topology_ = x.topology_;
      this->totality_ = x.totality_;
      this->AgentStructure_structures_AgentListing_ = x.AgentStructure_structures_AgentListing_;
      this->AgentStructure_has_AgentRelationship_ = x.AgentStructure_has_AgentRelationship_;
    }

    return *this;
  }

  AgentStructure::
  ~AgentStructure ()
  {
  }

  // ControlLogic
  //

  ControlLogic::
  ControlLogic ()
  : ::xml_schema::type (),
    description_ (this),
    identifier_ (this),
    workflow_ (this),
    ControlLogic_informs_ProcessingAgent_ (this),
    ControlLogic_invokes_Activity_ (this),
    ControlLogic_hasSubControlLogic_ControlLogic_ (this),
    ControlLogic_has_InformationFlowDefinition_ (this)
  {
  }

  ControlLogic::
  ControlLogic (const ControlLogic& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    description_ (x.description_, f, this),
    identifier_ (x.identifier_, f, this),
    workflow_ (x.workflow_, f, this),
    ControlLogic_informs_ProcessingAgent_ (x.ControlLogic_informs_ProcessingAgent_, f, this),
    ControlLogic_invokes_Activity_ (x.ControlLogic_invokes_Activity_, f, this),
    ControlLogic_hasSubControlLogic_ControlLogic_ (x.ControlLogic_hasSubControlLogic_ControlLogic_, f, this),
    ControlLogic_has_InformationFlowDefinition_ (x.ControlLogic_has_InformationFlowDefinition_, f, this)
  {
  }

  ControlLogic::
  ControlLogic (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    description_ (this),
    identifier_ (this),
    workflow_ (this),
    ControlLogic_informs_ProcessingAgent_ (this),
    ControlLogic_invokes_Activity_ (this),
    ControlLogic_hasSubControlLogic_ControlLogic_ (this),
    ControlLogic_has_InformationFlowDefinition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ControlLogic::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!this->description_)
        {
          this->description_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // workflow
      //
      if (n.name () == "workflow" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< workflow_type > r (
          workflow_traits::create (i, f, this));

        if (!this->workflow_)
        {
          this->workflow_.set (::std::move (r));
          continue;
        }
      }

      // ControlLogic_informs_ProcessingAgent
      //
      if (n.name () == "ControlLogic_informs_ProcessingAgent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ControlLogic_informs_ProcessingAgent_type > r (
          ControlLogic_informs_ProcessingAgent_traits::create (i, f, this));

        this->ControlLogic_informs_ProcessingAgent_.push_back (::std::move (r));
        continue;
      }

      // ControlLogic_invokes_Activity
      //
      if (n.name () == "ControlLogic_invokes_Activity" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ControlLogic_invokes_Activity_type > r (
          ControlLogic_invokes_Activity_traits::create (i, f, this));

        this->ControlLogic_invokes_Activity_.push_back (::std::move (r));
        continue;
      }

      // ControlLogic_hasSubControlLogic_ControlLogic
      //
      if (n.name () == "ControlLogic_hasSubControlLogic_ControlLogic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ControlLogic_hasSubControlLogic_ControlLogic_type > r (
          ControlLogic_hasSubControlLogic_ControlLogic_traits::create (i, f, this));

        this->ControlLogic_hasSubControlLogic_ControlLogic_.push_back (::std::move (r));
        continue;
      }

      // ControlLogic_has_InformationFlowDefinition
      //
      if (n.name () == "ControlLogic_has_InformationFlowDefinition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ControlLogic_has_InformationFlowDefinition_type > r (
          ControlLogic_has_InformationFlowDefinition_traits::create (i, f, this));

        this->ControlLogic_has_InformationFlowDefinition_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ControlLogic* ControlLogic::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ControlLogic (*this, f, c);
  }

  ControlLogic& ControlLogic::
  operator= (const ControlLogic& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->description_ = x.description_;
      this->identifier_ = x.identifier_;
      this->workflow_ = x.workflow_;
      this->ControlLogic_informs_ProcessingAgent_ = x.ControlLogic_informs_ProcessingAgent_;
      this->ControlLogic_invokes_Activity_ = x.ControlLogic_invokes_Activity_;
      this->ControlLogic_hasSubControlLogic_ControlLogic_ = x.ControlLogic_hasSubControlLogic_ControlLogic_;
      this->ControlLogic_has_InformationFlowDefinition_ = x.ControlLogic_has_InformationFlowDefinition_;
    }

    return *this;
  }

  ControlLogic::
  ~ControlLogic ()
  {
  }

  // NonDeterministicDeclarative
  //

  NonDeterministicDeclarative::
  NonDeterministicDeclarative ()
  : ::XMLSchema::ControlLogic ()
  {
  }

  NonDeterministicDeclarative::
  NonDeterministicDeclarative (const NonDeterministicDeclarative& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::XMLSchema::ControlLogic (x, f, c)
  {
  }

  NonDeterministicDeclarative::
  NonDeterministicDeclarative (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::XMLSchema::ControlLogic (e, f, c)
  {
  }

  NonDeterministicDeclarative* NonDeterministicDeclarative::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NonDeterministicDeclarative (*this, f, c);
  }

  NonDeterministicDeclarative::
  ~NonDeterministicDeclarative ()
  {
  }

  // TemporalConstraints
  //

  TemporalConstraints::
  TemporalConstraints ()
  : ::XMLSchema::NonDeterministicDeclarative ()
  {
  }

  TemporalConstraints::
  TemporalConstraints (const TemporalConstraints& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::NonDeterministicDeclarative (x, f, c)
  {
  }

  TemporalConstraints::
  TemporalConstraints (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::NonDeterministicDeclarative (e, f, c)
  {
  }

  TemporalConstraints* TemporalConstraints::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TemporalConstraints (*this, f, c);
  }

  TemporalConstraints::
  ~TemporalConstraints ()
  {
  }

  // AllenIntervalAlgebra
  //

  AllenIntervalAlgebra::
  AllenIntervalAlgebra (const temporalIntervalRelation_type& temporalIntervalRelation)
  : ::XMLSchema::TemporalConstraints (),
    temporalIntervalRelation_ (temporalIntervalRelation, this)
  {
  }

  AllenIntervalAlgebra::
  AllenIntervalAlgebra (const AllenIntervalAlgebra& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::TemporalConstraints (x, f, c),
    temporalIntervalRelation_ (x.temporalIntervalRelation_, f, this)
  {
  }

  AllenIntervalAlgebra::
  AllenIntervalAlgebra (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::TemporalConstraints (e, f | ::xml_schema::flags::base, c),
    temporalIntervalRelation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AllenIntervalAlgebra::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::TemporalConstraints::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // temporalIntervalRelation
      //
      if (n.name () == "temporalIntervalRelation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< temporalIntervalRelation_type > r (
          temporalIntervalRelation_traits::create (i, f, this));

        if (!temporalIntervalRelation_.present ())
        {
          this->temporalIntervalRelation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!temporalIntervalRelation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "temporalIntervalRelation",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  AllenIntervalAlgebra* AllenIntervalAlgebra::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AllenIntervalAlgebra (*this, f, c);
  }

  AllenIntervalAlgebra& AllenIntervalAlgebra::
  operator= (const AllenIntervalAlgebra& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::TemporalConstraints& > (*this) = x;
      this->temporalIntervalRelation_ = x.temporalIntervalRelation_;
    }

    return *this;
  }

  AllenIntervalAlgebra::
  ~AllenIntervalAlgebra ()
  {
  }

  // DataStructureComponent
  //

  DataStructureComponent::
  DataStructureComponent ()
  : ::xml_schema::type (),
    identifier_ (this),
    semantic_ (this),
    specialization_ (this),
    DataStructureComponent_isDefinedBy_RepresentedVariable_ (this)
  {
  }

  DataStructureComponent::
  DataStructureComponent (const DataStructureComponent& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    semantic_ (x.semantic_, f, this),
    specialization_ (x.specialization_, f, this),
    DataStructureComponent_isDefinedBy_RepresentedVariable_ (x.DataStructureComponent_isDefinedBy_RepresentedVariable_, f, this)
  {
  }

  DataStructureComponent::
  DataStructureComponent (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    semantic_ (this),
    specialization_ (this),
    DataStructureComponent_isDefinedBy_RepresentedVariable_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DataStructureComponent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // semantic
      //
      if (n.name () == "semantic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantic_type > r (
          semantic_traits::create (i, f, this));

        this->semantic_.push_back (::std::move (r));
        continue;
      }

      // specialization
      //
      if (n.name () == "specialization" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< specialization_type > r (
          specialization_traits::create (i, f, this));

        if (!this->specialization_)
        {
          this->specialization_.set (::std::move (r));
          continue;
        }
      }

      // DataStructureComponent_isDefinedBy_RepresentedVariable
      //
      if (n.name () == "DataStructureComponent_isDefinedBy_RepresentedVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStructureComponent_isDefinedBy_RepresentedVariable_type > r (
          DataStructureComponent_isDefinedBy_RepresentedVariable_traits::create (i, f, this));

        if (!this->DataStructureComponent_isDefinedBy_RepresentedVariable_)
        {
          this->DataStructureComponent_isDefinedBy_RepresentedVariable_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  DataStructureComponent* DataStructureComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataStructureComponent (*this, f, c);
  }

  DataStructureComponent& DataStructureComponent::
  operator= (const DataStructureComponent& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->semantic_ = x.semantic_;
      this->specialization_ = x.specialization_;
      this->DataStructureComponent_isDefinedBy_RepresentedVariable_ = x.DataStructureComponent_isDefinedBy_RepresentedVariable_;
    }

    return *this;
  }

  DataStructureComponent::
  ~DataStructureComponent ()
  {
  }

  // AttributeComponent
  //

  AttributeComponent::
  AttributeComponent ()
  : ::XMLSchema::DataStructureComponent (),
    AttributeComponent_qualifies_DataStructureComponent_ (this)
  {
  }

  AttributeComponent::
  AttributeComponent (const AttributeComponent& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (x, f, c),
    AttributeComponent_qualifies_DataStructureComponent_ (x.AttributeComponent_qualifies_DataStructureComponent_, f, this)
  {
  }

  AttributeComponent::
  AttributeComponent (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (e, f | ::xml_schema::flags::base, c),
    AttributeComponent_qualifies_DataStructureComponent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AttributeComponent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::DataStructureComponent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AttributeComponent_qualifies_DataStructureComponent
      //
      if (n.name () == "AttributeComponent_qualifies_DataStructureComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AttributeComponent_qualifies_DataStructureComponent_type > r (
          AttributeComponent_qualifies_DataStructureComponent_traits::create (i, f, this));

        this->AttributeComponent_qualifies_DataStructureComponent_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AttributeComponent* AttributeComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AttributeComponent (*this, f, c);
  }

  AttributeComponent& AttributeComponent::
  operator= (const AttributeComponent& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::DataStructureComponent& > (*this) = x;
      this->AttributeComponent_qualifies_DataStructureComponent_ = x.AttributeComponent_qualifies_DataStructureComponent_;
    }

    return *this;
  }

  AttributeComponent::
  ~AttributeComponent ()
  {
  }

  // AuthorizationSource
  //

  AuthorizationSource::
  AuthorizationSource ()
  : ::xml_schema::type (),
    authorizationDate_ (this),
    catalogDetails_ (this),
    identifier_ (this),
    legalMandate_ (this),
    purpose_ (this),
    statementOfAuthorization_ (this),
    AuthorizationSource_has_Agent_ (this)
  {
  }

  AuthorizationSource::
  AuthorizationSource (const AuthorizationSource& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    authorizationDate_ (x.authorizationDate_, f, this),
    catalogDetails_ (x.catalogDetails_, f, this),
    identifier_ (x.identifier_, f, this),
    legalMandate_ (x.legalMandate_, f, this),
    purpose_ (x.purpose_, f, this),
    statementOfAuthorization_ (x.statementOfAuthorization_, f, this),
    AuthorizationSource_has_Agent_ (x.AuthorizationSource_has_Agent_, f, this)
  {
  }

  AuthorizationSource::
  AuthorizationSource (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    authorizationDate_ (this),
    catalogDetails_ (this),
    identifier_ (this),
    legalMandate_ (this),
    purpose_ (this),
    statementOfAuthorization_ (this),
    AuthorizationSource_has_Agent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AuthorizationSource::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // authorizationDate
      //
      if (n.name () == "authorizationDate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< authorizationDate_type > r (
          authorizationDate_traits::create (i, f, this));

        if (!this->authorizationDate_)
        {
          this->authorizationDate_.set (::std::move (r));
          continue;
        }
      }

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // legalMandate
      //
      if (n.name () == "legalMandate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< legalMandate_type > r (
          legalMandate_traits::create (i, f, this));

        if (!this->legalMandate_)
        {
          this->legalMandate_.set (::std::move (r));
          continue;
        }
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // statementOfAuthorization
      //
      if (n.name () == "statementOfAuthorization" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< statementOfAuthorization_type > r (
          statementOfAuthorization_traits::create (i, f, this));

        if (!this->statementOfAuthorization_)
        {
          this->statementOfAuthorization_.set (::std::move (r));
          continue;
        }
      }

      // AuthorizationSource_has_Agent
      //
      if (n.name () == "AuthorizationSource_has_Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< AuthorizationSource_has_Agent_type > r (
          AuthorizationSource_has_Agent_traits::create (i, f, this));

        this->AuthorizationSource_has_Agent_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AuthorizationSource* AuthorizationSource::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AuthorizationSource (*this, f, c);
  }

  AuthorizationSource& AuthorizationSource::
  operator= (const AuthorizationSource& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->authorizationDate_ = x.authorizationDate_;
      this->catalogDetails_ = x.catalogDetails_;
      this->identifier_ = x.identifier_;
      this->legalMandate_ = x.legalMandate_;
      this->purpose_ = x.purpose_;
      this->statementOfAuthorization_ = x.statementOfAuthorization_;
      this->AuthorizationSource_has_Agent_ = x.AuthorizationSource_has_Agent_;
    }

    return *this;
  }

  AuthorizationSource::
  ~AuthorizationSource ()
  {
  }

  // Concept
  //

  Concept::
  Concept ()
  : ::xml_schema::type (),
    catalogDetails_ (this),
    definition_ (this),
    displayLabel_ (this),
    externalDefinition_ (this),
    identifier_ (this),
    name_ (this),
    Concept_uses_Concept_ (this)
  {
  }

  Concept::
  Concept (const Concept& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    definition_ (x.definition_, f, this),
    displayLabel_ (x.displayLabel_, f, this),
    externalDefinition_ (x.externalDefinition_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    Concept_uses_Concept_ (x.Concept_uses_Concept_, f, this)
  {
  }

  Concept::
  Concept (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    definition_ (this),
    displayLabel_ (this),
    externalDefinition_ (this),
    identifier_ (this),
    name_ (this),
    Concept_uses_Concept_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Concept::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // definition
      //
      if (n.name () == "definition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< definition_type > r (
          definition_traits::create (i, f, this));

        if (!this->definition_)
        {
          this->definition_.set (::std::move (r));
          continue;
        }
      }

      // displayLabel
      //
      if (n.name () == "displayLabel" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< displayLabel_type > r (
          displayLabel_traits::create (i, f, this));

        this->displayLabel_.push_back (::std::move (r));
        continue;
      }

      // externalDefinition
      //
      if (n.name () == "externalDefinition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< externalDefinition_type > r (
          externalDefinition_traits::create (i, f, this));

        if (!this->externalDefinition_)
        {
          this->externalDefinition_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // Concept_uses_Concept
      //
      if (n.name () == "Concept_uses_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Concept_uses_Concept_type > r (
          Concept_uses_Concept_traits::create (i, f, this));

        this->Concept_uses_Concept_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Concept* Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Concept (*this, f, c);
  }

  Concept& Concept::
  operator= (const Concept& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->definition_ = x.definition_;
      this->displayLabel_ = x.displayLabel_;
      this->externalDefinition_ = x.externalDefinition_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->Concept_uses_Concept_ = x.Concept_uses_Concept_;
    }

    return *this;
  }

  Concept::
  ~Concept ()
  {
  }

  // Category
  //

  Category::
  Category ()
  : ::XMLSchema::Concept (),
    descriptiveText_ (this)
  {
  }

  Category::
  Category (const Category& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::XMLSchema::Concept (x, f, c),
    descriptiveText_ (x.descriptiveText_, f, this)
  {
  }

  Category::
  Category (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::XMLSchema::Concept (e, f | ::xml_schema::flags::base, c),
    descriptiveText_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Category::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::Concept::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // descriptiveText
      //
      if (n.name () == "descriptiveText" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< descriptiveText_type > r (
          descriptiveText_traits::create (i, f, this));

        if (!this->descriptiveText_)
        {
          this->descriptiveText_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Category* Category::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Category (*this, f, c);
  }

  Category& Category::
  operator= (const Category& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Concept& > (*this) = x;
      this->descriptiveText_ = x.descriptiveText_;
    }

    return *this;
  }

  Category::
  ~Category ()
  {
  }

  // CategoryPosition
  //

  CategoryPosition::
  CategoryPosition (const value_type& value,
                    const CategoryPosition_indexes_Category_type& CategoryPosition_indexes_Category)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    CategoryPosition_indexes_Category_ (CategoryPosition_indexes_Category, this)
  {
  }

  CategoryPosition::
  CategoryPosition (const value_type& value,
                    ::std::unique_ptr< CategoryPosition_indexes_Category_type > CategoryPosition_indexes_Category)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    CategoryPosition_indexes_Category_ (std::move (CategoryPosition_indexes_Category), this)
  {
  }

  CategoryPosition::
  CategoryPosition (const CategoryPosition& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    value_ (x.value_, f, this),
    CategoryPosition_indexes_Category_ (x.CategoryPosition_indexes_Category_, f, this)
  {
  }

  CategoryPosition::
  CategoryPosition (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    value_ (this),
    CategoryPosition_indexes_Category_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CategoryPosition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      // CategoryPosition_indexes_Category
      //
      if (n.name () == "CategoryPosition_indexes_Category" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryPosition_indexes_Category_type > r (
          CategoryPosition_indexes_Category_traits::create (i, f, this));

        if (!CategoryPosition_indexes_Category_.present ())
        {
          this->CategoryPosition_indexes_Category_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!CategoryPosition_indexes_Category_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CategoryPosition_indexes_Category",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  CategoryPosition* CategoryPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategoryPosition (*this, f, c);
  }

  CategoryPosition& CategoryPosition::
  operator= (const CategoryPosition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->value_ = x.value_;
      this->CategoryPosition_indexes_Category_ = x.CategoryPosition_indexes_Category_;
    }

    return *this;
  }

  CategoryPosition::
  ~CategoryPosition ()
  {
  }

  // CategoryRelationStructure
  //

  CategoryRelationStructure::
  CategoryRelationStructure ()
  : ::xml_schema::type (),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    CategoryRelationStructure_structures_CategorySet_ (this),
    CategoryRelationStructure_has_CategoryRelationship_ (this)
  {
  }

  CategoryRelationStructure::
  CategoryRelationStructure (const CategoryRelationStructure& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    semantics_ (x.semantics_, f, this),
    specification_ (x.specification_, f, this),
    topology_ (x.topology_, f, this),
    totality_ (x.totality_, f, this),
    CategoryRelationStructure_structures_CategorySet_ (x.CategoryRelationStructure_structures_CategorySet_, f, this),
    CategoryRelationStructure_has_CategoryRelationship_ (x.CategoryRelationStructure_has_CategoryRelationship_, f, this)
  {
  }

  CategoryRelationStructure::
  CategoryRelationStructure (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    CategoryRelationStructure_structures_CategorySet_ (this),
    CategoryRelationStructure_has_CategoryRelationship_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CategoryRelationStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // specification
      //
      if (n.name () == "specification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< specification_type > r (
          specification_traits::create (i, f, this));

        if (!this->specification_)
        {
          this->specification_.set (::std::move (r));
          continue;
        }
      }

      // topology
      //
      if (n.name () == "topology" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< topology_type > r (
          topology_traits::create (i, f, this));

        if (!this->topology_)
        {
          this->topology_.set (::std::move (r));
          continue;
        }
      }

      // totality
      //
      if (n.name () == "totality" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< totality_type > r (
          totality_traits::create (i, f, this));

        if (!this->totality_)
        {
          this->totality_.set (::std::move (r));
          continue;
        }
      }

      // CategoryRelationStructure_structures_CategorySet
      //
      if (n.name () == "CategoryRelationStructure_structures_CategorySet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryRelationStructure_structures_CategorySet_type > r (
          CategoryRelationStructure_structures_CategorySet_traits::create (i, f, this));

        if (!this->CategoryRelationStructure_structures_CategorySet_)
        {
          this->CategoryRelationStructure_structures_CategorySet_.set (::std::move (r));
          continue;
        }
      }

      // CategoryRelationStructure_has_CategoryRelationship
      //
      if (n.name () == "CategoryRelationStructure_has_CategoryRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryRelationStructure_has_CategoryRelationship_type > r (
          CategoryRelationStructure_has_CategoryRelationship_traits::create (i, f, this));

        this->CategoryRelationStructure_has_CategoryRelationship_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CategoryRelationStructure* CategoryRelationStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategoryRelationStructure (*this, f, c);
  }

  CategoryRelationStructure& CategoryRelationStructure::
  operator= (const CategoryRelationStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->semantics_ = x.semantics_;
      this->specification_ = x.specification_;
      this->topology_ = x.topology_;
      this->totality_ = x.totality_;
      this->CategoryRelationStructure_structures_CategorySet_ = x.CategoryRelationStructure_structures_CategorySet_;
      this->CategoryRelationStructure_has_CategoryRelationship_ = x.CategoryRelationStructure_has_CategoryRelationship_;
    }

    return *this;
  }

  CategoryRelationStructure::
  ~CategoryRelationStructure ()
  {
  }

  // CategoryRelationship
  //

  CategoryRelationship::
  CategoryRelationship ()
  : ::xml_schema::type (),
    identifier_ (this),
    semantics_ (this),
    CategoryRelationship_hasSource_Category_ (this),
    CategoryRelationship_hasTarget_Category_ (this)
  {
  }

  CategoryRelationship::
  CategoryRelationship (const CategoryRelationship& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    semantics_ (x.semantics_, f, this),
    CategoryRelationship_hasSource_Category_ (x.CategoryRelationship_hasSource_Category_, f, this),
    CategoryRelationship_hasTarget_Category_ (x.CategoryRelationship_hasTarget_Category_, f, this)
  {
  }

  CategoryRelationship::
  CategoryRelationship (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    semantics_ (this),
    CategoryRelationship_hasSource_Category_ (this),
    CategoryRelationship_hasTarget_Category_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CategoryRelationship::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // CategoryRelationship_hasSource_Category
      //
      if (n.name () == "CategoryRelationship_hasSource_Category" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryRelationship_hasSource_Category_type > r (
          CategoryRelationship_hasSource_Category_traits::create (i, f, this));

        this->CategoryRelationship_hasSource_Category_.push_back (::std::move (r));
        continue;
      }

      // CategoryRelationship_hasTarget_Category
      //
      if (n.name () == "CategoryRelationship_hasTarget_Category" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryRelationship_hasTarget_Category_type > r (
          CategoryRelationship_hasTarget_Category_traits::create (i, f, this));

        this->CategoryRelationship_hasTarget_Category_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CategoryRelationship* CategoryRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategoryRelationship (*this, f, c);
  }

  CategoryRelationship& CategoryRelationship::
  operator= (const CategoryRelationship& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->semantics_ = x.semantics_;
      this->CategoryRelationship_hasSource_Category_ = x.CategoryRelationship_hasSource_Category_;
      this->CategoryRelationship_hasTarget_Category_ = x.CategoryRelationship_hasTarget_Category_;
    }

    return *this;
  }

  CategoryRelationship::
  ~CategoryRelationship ()
  {
  }

  // ConceptSystem
  //

  ConceptSystem::
  ConceptSystem (const allowsDuplicates_type& allowsDuplicates)
  : ::xml_schema::type (),
    allowsDuplicates_ (allowsDuplicates, this),
    catalogDetails_ (this),
    externalDefinition_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    ConceptSystem_isDefinedBy_Concept_ (this),
    ConceptSystem_has_Concept_ (this)
  {
  }

  ConceptSystem::
  ConceptSystem (const ConceptSystem& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    allowsDuplicates_ (x.allowsDuplicates_, f, this),
    catalogDetails_ (x.catalogDetails_, f, this),
    externalDefinition_ (x.externalDefinition_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    ConceptSystem_isDefinedBy_Concept_ (x.ConceptSystem_isDefinedBy_Concept_, f, this),
    ConceptSystem_has_Concept_ (x.ConceptSystem_has_Concept_, f, this)
  {
  }

  ConceptSystem::
  ConceptSystem (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    allowsDuplicates_ (this),
    catalogDetails_ (this),
    externalDefinition_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    ConceptSystem_isDefinedBy_Concept_ (this),
    ConceptSystem_has_Concept_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ConceptSystem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // allowsDuplicates
      //
      if (n.name () == "allowsDuplicates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!allowsDuplicates_.present ())
        {
          this->allowsDuplicates_.set (allowsDuplicates_traits::create (i, f, this));
          continue;
        }
      }

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // externalDefinition
      //
      if (n.name () == "externalDefinition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< externalDefinition_type > r (
          externalDefinition_traits::create (i, f, this));

        if (!this->externalDefinition_)
        {
          this->externalDefinition_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // ConceptSystem_isDefinedBy_Concept
      //
      if (n.name () == "ConceptSystem_isDefinedBy_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptSystem_isDefinedBy_Concept_type > r (
          ConceptSystem_isDefinedBy_Concept_traits::create (i, f, this));

        this->ConceptSystem_isDefinedBy_Concept_.push_back (::std::move (r));
        continue;
      }

      // ConceptSystem_has_Concept
      //
      if (n.name () == "ConceptSystem_has_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptSystem_has_Concept_type > r (
          ConceptSystem_has_Concept_traits::create (i, f, this));

        this->ConceptSystem_has_Concept_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!allowsDuplicates_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "allowsDuplicates",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ConceptSystem* ConceptSystem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptSystem (*this, f, c);
  }

  ConceptSystem& ConceptSystem::
  operator= (const ConceptSystem& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->allowsDuplicates_ = x.allowsDuplicates_;
      this->catalogDetails_ = x.catalogDetails_;
      this->externalDefinition_ = x.externalDefinition_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->ConceptSystem_isDefinedBy_Concept_ = x.ConceptSystem_isDefinedBy_Concept_;
      this->ConceptSystem_has_Concept_ = x.ConceptSystem_has_Concept_;
    }

    return *this;
  }

  ConceptSystem::
  ~ConceptSystem ()
  {
  }

  // CategorySet
  //

  CategorySet::
  CategorySet (const allowsDuplicates_type& allowsDuplicates)
  : ::XMLSchema::ConceptSystem (allowsDuplicates),
    CategorySet_has_Category_ (this),
    CategorySet_has_CategoryPosition_ (this)
  {
  }

  CategorySet::
  CategorySet (const CategorySet& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::XMLSchema::ConceptSystem (x, f, c),
    CategorySet_has_Category_ (x.CategorySet_has_Category_, f, this),
    CategorySet_has_CategoryPosition_ (x.CategorySet_has_CategoryPosition_, f, this)
  {
  }

  CategorySet::
  CategorySet (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::XMLSchema::ConceptSystem (e, f | ::xml_schema::flags::base, c),
    CategorySet_has_Category_ (this),
    CategorySet_has_CategoryPosition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CategorySet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::ConceptSystem::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CategorySet_has_Category
      //
      if (n.name () == "CategorySet_has_Category" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategorySet_has_Category_type > r (
          CategorySet_has_Category_traits::create (i, f, this));

        this->CategorySet_has_Category_.push_back (::std::move (r));
        continue;
      }

      // CategorySet_has_CategoryPosition
      //
      if (n.name () == "CategorySet_has_CategoryPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategorySet_has_CategoryPosition_type > r (
          CategorySet_has_CategoryPosition_traits::create (i, f, this));

        this->CategorySet_has_CategoryPosition_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CategorySet* CategorySet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategorySet (*this, f, c);
  }

  CategorySet& CategorySet::
  operator= (const CategorySet& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::ConceptSystem& > (*this) = x;
      this->CategorySet_has_Category_ = x.CategorySet_has_Category_;
      this->CategorySet_has_CategoryPosition_ = x.CategorySet_has_CategoryPosition_;
    }

    return *this;
  }

  CategorySet::
  ~CategorySet ()
  {
  }

  // CategoryStatistic
  //

  CategoryStatistic::
  CategoryStatistic ()
  : ::xml_schema::type (),
    identifier_ (this),
    statistic_ (this),
    typeOfCategoryStatistic_ (this),
    CategoryStatistic_appliesTo_InstanceVariable_ (this),
    CategoryStatistic_for_Category_ (this)
  {
  }

  CategoryStatistic::
  CategoryStatistic (const CategoryStatistic& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    statistic_ (x.statistic_, f, this),
    typeOfCategoryStatistic_ (x.typeOfCategoryStatistic_, f, this),
    CategoryStatistic_appliesTo_InstanceVariable_ (x.CategoryStatistic_appliesTo_InstanceVariable_, f, this),
    CategoryStatistic_for_Category_ (x.CategoryStatistic_for_Category_, f, this)
  {
  }

  CategoryStatistic::
  CategoryStatistic (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    statistic_ (this),
    typeOfCategoryStatistic_ (this),
    CategoryStatistic_appliesTo_InstanceVariable_ (this),
    CategoryStatistic_for_Category_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CategoryStatistic::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // statistic
      //
      if (n.name () == "statistic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< statistic_type > r (
          statistic_traits::create (i, f, this));

        this->statistic_.push_back (::std::move (r));
        continue;
      }

      // typeOfCategoryStatistic
      //
      if (n.name () == "typeOfCategoryStatistic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< typeOfCategoryStatistic_type > r (
          typeOfCategoryStatistic_traits::create (i, f, this));

        if (!this->typeOfCategoryStatistic_)
        {
          this->typeOfCategoryStatistic_.set (::std::move (r));
          continue;
        }
      }

      // CategoryStatistic_appliesTo_InstanceVariable
      //
      if (n.name () == "CategoryStatistic_appliesTo_InstanceVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryStatistic_appliesTo_InstanceVariable_type > r (
          CategoryStatistic_appliesTo_InstanceVariable_traits::create (i, f, this));

        this->CategoryStatistic_appliesTo_InstanceVariable_.push_back (::std::move (r));
        continue;
      }

      // CategoryStatistic_for_Category
      //
      if (n.name () == "CategoryStatistic_for_Category" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CategoryStatistic_for_Category_type > r (
          CategoryStatistic_for_Category_traits::create (i, f, this));

        if (!this->CategoryStatistic_for_Category_)
        {
          this->CategoryStatistic_for_Category_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  CategoryStatistic* CategoryStatistic::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategoryStatistic (*this, f, c);
  }

  CategoryStatistic& CategoryStatistic::
  operator= (const CategoryStatistic& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->statistic_ = x.statistic_;
      this->typeOfCategoryStatistic_ = x.typeOfCategoryStatistic_;
      this->CategoryStatistic_appliesTo_InstanceVariable_ = x.CategoryStatistic_appliesTo_InstanceVariable_;
      this->CategoryStatistic_for_Category_ = x.CategoryStatistic_for_Category_;
    }

    return *this;
  }

  CategoryStatistic::
  ~CategoryStatistic ()
  {
  }

  // ClassificationFamily
  //

  ClassificationFamily::
  ClassificationFamily ()
  : ::xml_schema::type (),
    catalogDetails_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    ClassificationFamily_uses_ClassificationIndex_ (this),
    ClassificationFamily_isDefinedBy_Concept_ (this),
    ClassificationFamily_groups_ClassificationSeries_ (this)
  {
  }

  ClassificationFamily::
  ClassificationFamily (const ClassificationFamily& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    ClassificationFamily_uses_ClassificationIndex_ (x.ClassificationFamily_uses_ClassificationIndex_, f, this),
    ClassificationFamily_isDefinedBy_Concept_ (x.ClassificationFamily_isDefinedBy_Concept_, f, this),
    ClassificationFamily_groups_ClassificationSeries_ (x.ClassificationFamily_groups_ClassificationSeries_, f, this)
  {
  }

  ClassificationFamily::
  ClassificationFamily (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    ClassificationFamily_uses_ClassificationIndex_ (this),
    ClassificationFamily_isDefinedBy_Concept_ (this),
    ClassificationFamily_groups_ClassificationSeries_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClassificationFamily::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // ClassificationFamily_uses_ClassificationIndex
      //
      if (n.name () == "ClassificationFamily_uses_ClassificationIndex" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationFamily_uses_ClassificationIndex_type > r (
          ClassificationFamily_uses_ClassificationIndex_traits::create (i, f, this));

        this->ClassificationFamily_uses_ClassificationIndex_.push_back (::std::move (r));
        continue;
      }

      // ClassificationFamily_isDefinedBy_Concept
      //
      if (n.name () == "ClassificationFamily_isDefinedBy_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationFamily_isDefinedBy_Concept_type > r (
          ClassificationFamily_isDefinedBy_Concept_traits::create (i, f, this));

        this->ClassificationFamily_isDefinedBy_Concept_.push_back (::std::move (r));
        continue;
      }

      // ClassificationFamily_groups_ClassificationSeries
      //
      if (n.name () == "ClassificationFamily_groups_ClassificationSeries" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationFamily_groups_ClassificationSeries_type > r (
          ClassificationFamily_groups_ClassificationSeries_traits::create (i, f, this));

        this->ClassificationFamily_groups_ClassificationSeries_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ClassificationFamily* ClassificationFamily::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationFamily (*this, f, c);
  }

  ClassificationFamily& ClassificationFamily::
  operator= (const ClassificationFamily& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->ClassificationFamily_uses_ClassificationIndex_ = x.ClassificationFamily_uses_ClassificationIndex_;
      this->ClassificationFamily_isDefinedBy_Concept_ = x.ClassificationFamily_isDefinedBy_Concept_;
      this->ClassificationFamily_groups_ClassificationSeries_ = x.ClassificationFamily_groups_ClassificationSeries_;
    }

    return *this;
  }

  ClassificationFamily::
  ~ClassificationFamily ()
  {
  }

  // ClassificationIndex
  //

  ClassificationIndex::
  ClassificationIndex (const allowsDuplicates_type& allowsDuplicates)
  : ::xml_schema::type (),
    allowsDuplicates_ (allowsDuplicates, this),
    availableLanguage_ (this),
    catalogDetails_ (this),
    codingInstruction_ (this),
    corrections_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    releaseDate_ (this),
    ClassificationIndex_isMaintainedBy_Agent_ (this),
    ClassificationIndex_hasContact_Agent_ (this),
    ClassificationIndex_isDefinedBy_Concept_ (this),
    ClassificationIndex_has_ClassificationIndexEntryPosition_ (this),
    ClassificationIndex_has_ClassificationIndexEntry_ (this)
  {
  }

  ClassificationIndex::
  ClassificationIndex (const ClassificationIndex& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    allowsDuplicates_ (x.allowsDuplicates_, f, this),
    availableLanguage_ (x.availableLanguage_, f, this),
    catalogDetails_ (x.catalogDetails_, f, this),
    codingInstruction_ (x.codingInstruction_, f, this),
    corrections_ (x.corrections_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    releaseDate_ (x.releaseDate_, f, this),
    ClassificationIndex_isMaintainedBy_Agent_ (x.ClassificationIndex_isMaintainedBy_Agent_, f, this),
    ClassificationIndex_hasContact_Agent_ (x.ClassificationIndex_hasContact_Agent_, f, this),
    ClassificationIndex_isDefinedBy_Concept_ (x.ClassificationIndex_isDefinedBy_Concept_, f, this),
    ClassificationIndex_has_ClassificationIndexEntryPosition_ (x.ClassificationIndex_has_ClassificationIndexEntryPosition_, f, this),
    ClassificationIndex_has_ClassificationIndexEntry_ (x.ClassificationIndex_has_ClassificationIndexEntry_, f, this)
  {
  }

  ClassificationIndex::
  ClassificationIndex (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    allowsDuplicates_ (this),
    availableLanguage_ (this),
    catalogDetails_ (this),
    codingInstruction_ (this),
    corrections_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    releaseDate_ (this),
    ClassificationIndex_isMaintainedBy_Agent_ (this),
    ClassificationIndex_hasContact_Agent_ (this),
    ClassificationIndex_isDefinedBy_Concept_ (this),
    ClassificationIndex_has_ClassificationIndexEntryPosition_ (this),
    ClassificationIndex_has_ClassificationIndexEntry_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClassificationIndex::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // allowsDuplicates
      //
      if (n.name () == "allowsDuplicates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!allowsDuplicates_.present ())
        {
          this->allowsDuplicates_.set (allowsDuplicates_traits::create (i, f, this));
          continue;
        }
      }

      // availableLanguage
      //
      if (n.name () == "availableLanguage" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< availableLanguage_type > r (
          availableLanguage_traits::create (i, f, this));

        this->availableLanguage_.push_back (::std::move (r));
        continue;
      }

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // codingInstruction
      //
      if (n.name () == "codingInstruction" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< codingInstruction_type > r (
          codingInstruction_traits::create (i, f, this));

        this->codingInstruction_.push_back (::std::move (r));
        continue;
      }

      // corrections
      //
      if (n.name () == "corrections" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< corrections_type > r (
          corrections_traits::create (i, f, this));

        this->corrections_.push_back (::std::move (r));
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // releaseDate
      //
      if (n.name () == "releaseDate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< releaseDate_type > r (
          releaseDate_traits::create (i, f, this));

        if (!this->releaseDate_)
        {
          this->releaseDate_.set (::std::move (r));
          continue;
        }
      }

      // ClassificationIndex_isMaintainedBy_Agent
      //
      if (n.name () == "ClassificationIndex_isMaintainedBy_Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationIndex_isMaintainedBy_Agent_type > r (
          ClassificationIndex_isMaintainedBy_Agent_traits::create (i, f, this));

        if (!this->ClassificationIndex_isMaintainedBy_Agent_)
        {
          this->ClassificationIndex_isMaintainedBy_Agent_.set (::std::move (r));
          continue;
        }
      }

      // ClassificationIndex_hasContact_Agent
      //
      if (n.name () == "ClassificationIndex_hasContact_Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationIndex_hasContact_Agent_type > r (
          ClassificationIndex_hasContact_Agent_traits::create (i, f, this));

        this->ClassificationIndex_hasContact_Agent_.push_back (::std::move (r));
        continue;
      }

      // ClassificationIndex_isDefinedBy_Concept
      //
      if (n.name () == "ClassificationIndex_isDefinedBy_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationIndex_isDefinedBy_Concept_type > r (
          ClassificationIndex_isDefinedBy_Concept_traits::create (i, f, this));

        this->ClassificationIndex_isDefinedBy_Concept_.push_back (::std::move (r));
        continue;
      }

      // ClassificationIndex_has_ClassificationIndexEntryPosition
      //
      if (n.name () == "ClassificationIndex_has_ClassificationIndexEntryPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationIndex_has_ClassificationIndexEntryPosition_type > r (
          ClassificationIndex_has_ClassificationIndexEntryPosition_traits::create (i, f, this));

        this->ClassificationIndex_has_ClassificationIndexEntryPosition_.push_back (::std::move (r));
        continue;
      }

      // ClassificationIndex_has_ClassificationIndexEntry
      //
      if (n.name () == "ClassificationIndex_has_ClassificationIndexEntry" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationIndex_has_ClassificationIndexEntry_type > r (
          ClassificationIndex_has_ClassificationIndexEntry_traits::create (i, f, this));

        this->ClassificationIndex_has_ClassificationIndexEntry_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!allowsDuplicates_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "allowsDuplicates",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ClassificationIndex* ClassificationIndex::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationIndex (*this, f, c);
  }

  ClassificationIndex& ClassificationIndex::
  operator= (const ClassificationIndex& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->allowsDuplicates_ = x.allowsDuplicates_;
      this->availableLanguage_ = x.availableLanguage_;
      this->catalogDetails_ = x.catalogDetails_;
      this->codingInstruction_ = x.codingInstruction_;
      this->corrections_ = x.corrections_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->releaseDate_ = x.releaseDate_;
      this->ClassificationIndex_isMaintainedBy_Agent_ = x.ClassificationIndex_isMaintainedBy_Agent_;
      this->ClassificationIndex_hasContact_Agent_ = x.ClassificationIndex_hasContact_Agent_;
      this->ClassificationIndex_isDefinedBy_Concept_ = x.ClassificationIndex_isDefinedBy_Concept_;
      this->ClassificationIndex_has_ClassificationIndexEntryPosition_ = x.ClassificationIndex_has_ClassificationIndexEntryPosition_;
      this->ClassificationIndex_has_ClassificationIndexEntry_ = x.ClassificationIndex_has_ClassificationIndexEntry_;
    }

    return *this;
  }

  ClassificationIndex::
  ~ClassificationIndex ()
  {
  }

  // ClassificationIndexEntry
  //

  ClassificationIndexEntry::
  ClassificationIndexEntry ()
  : ::xml_schema::type (),
    catalogDetails_ (this),
    codingInstruction_ (this),
    entry_ (this),
    identifier_ (this),
    validDates_ (this)
  {
  }

  ClassificationIndexEntry::
  ClassificationIndexEntry (const ClassificationIndexEntry& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    codingInstruction_ (x.codingInstruction_, f, this),
    entry_ (x.entry_, f, this),
    identifier_ (x.identifier_, f, this),
    validDates_ (x.validDates_, f, this)
  {
  }

  ClassificationIndexEntry::
  ClassificationIndexEntry (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    codingInstruction_ (this),
    entry_ (this),
    identifier_ (this),
    validDates_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClassificationIndexEntry::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // codingInstruction
      //
      if (n.name () == "codingInstruction" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< codingInstruction_type > r (
          codingInstruction_traits::create (i, f, this));

        if (!this->codingInstruction_)
        {
          this->codingInstruction_.set (::std::move (r));
          continue;
        }
      }

      // entry
      //
      if (n.name () == "entry" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< entry_type > r (
          entry_traits::create (i, f, this));

        if (!this->entry_)
        {
          this->entry_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // validDates
      //
      if (n.name () == "validDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< validDates_type > r (
          validDates_traits::create (i, f, this));

        if (!this->validDates_)
        {
          this->validDates_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ClassificationIndexEntry* ClassificationIndexEntry::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationIndexEntry (*this, f, c);
  }

  ClassificationIndexEntry& ClassificationIndexEntry::
  operator= (const ClassificationIndexEntry& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->codingInstruction_ = x.codingInstruction_;
      this->entry_ = x.entry_;
      this->identifier_ = x.identifier_;
      this->validDates_ = x.validDates_;
    }

    return *this;
  }

  ClassificationIndexEntry::
  ~ClassificationIndexEntry ()
  {
  }

  // ClassificationIndexEntryPosition
  //

  ClassificationIndexEntryPosition::
  ClassificationIndexEntryPosition (const value_type& value,
                                    const ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type& ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_ (ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry, this)
  {
  }

  ClassificationIndexEntryPosition::
  ClassificationIndexEntryPosition (const value_type& value,
                                    ::std::unique_ptr< ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type > ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_ (std::move (ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry), this)
  {
  }

  ClassificationIndexEntryPosition::
  ClassificationIndexEntryPosition (const ClassificationIndexEntryPosition& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    value_ (x.value_, f, this),
    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_ (x.ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_, f, this)
  {
  }

  ClassificationIndexEntryPosition::
  ClassificationIndexEntryPosition (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    value_ (this),
    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClassificationIndexEntryPosition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      // ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry
      //
      if (n.name () == "ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type > r (
          ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_traits::create (i, f, this));

        if (!ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_.present ())
        {
          this->ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ClassificationIndexEntryPosition* ClassificationIndexEntryPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationIndexEntryPosition (*this, f, c);
  }

  ClassificationIndexEntryPosition& ClassificationIndexEntryPosition::
  operator= (const ClassificationIndexEntryPosition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->value_ = x.value_;
      this->ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_ = x.ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_;
    }

    return *this;
  }

  ClassificationIndexEntryPosition::
  ~ClassificationIndexEntryPosition ()
  {
  }

  // ClassificationItem
  //

  ClassificationItem::
  ClassificationItem (const ClassificationItem_denotes_Category_type& ClassificationItem_denotes_Category,
                      const ClassificationItem_uses_Notation_type& ClassificationItem_uses_Notation)
  : ::xml_schema::type (),
    changeFromPreviousVersion_ (this),
    changeLog_ (this),
    explanatoryNotes_ (this),
    futureNotes_ (this),
    identifier_ (this),
    isGenerated_ (this),
    isValid_ (this),
    name_ (this),
    validDates_ (this),
    ClassificationItem_excludes_ClassificationItem_ (this),
    ClassificationItem_denotes_Category_ (ClassificationItem_denotes_Category, this),
    ClassificationItem_uses_Notation_ (ClassificationItem_uses_Notation, this),
    ClassificationItem_hasRulingBy_AuthorizationSource_ (this)
  {
  }

  ClassificationItem::
  ClassificationItem (::std::unique_ptr< ClassificationItem_denotes_Category_type > ClassificationItem_denotes_Category,
                      ::std::unique_ptr< ClassificationItem_uses_Notation_type > ClassificationItem_uses_Notation)
  : ::xml_schema::type (),
    changeFromPreviousVersion_ (this),
    changeLog_ (this),
    explanatoryNotes_ (this),
    futureNotes_ (this),
    identifier_ (this),
    isGenerated_ (this),
    isValid_ (this),
    name_ (this),
    validDates_ (this),
    ClassificationItem_excludes_ClassificationItem_ (this),
    ClassificationItem_denotes_Category_ (std::move (ClassificationItem_denotes_Category), this),
    ClassificationItem_uses_Notation_ (std::move (ClassificationItem_uses_Notation), this),
    ClassificationItem_hasRulingBy_AuthorizationSource_ (this)
  {
  }

  ClassificationItem::
  ClassificationItem (const ClassificationItem& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    changeFromPreviousVersion_ (x.changeFromPreviousVersion_, f, this),
    changeLog_ (x.changeLog_, f, this),
    explanatoryNotes_ (x.explanatoryNotes_, f, this),
    futureNotes_ (x.futureNotes_, f, this),
    identifier_ (x.identifier_, f, this),
    isGenerated_ (x.isGenerated_, f, this),
    isValid_ (x.isValid_, f, this),
    name_ (x.name_, f, this),
    validDates_ (x.validDates_, f, this),
    ClassificationItem_excludes_ClassificationItem_ (x.ClassificationItem_excludes_ClassificationItem_, f, this),
    ClassificationItem_denotes_Category_ (x.ClassificationItem_denotes_Category_, f, this),
    ClassificationItem_uses_Notation_ (x.ClassificationItem_uses_Notation_, f, this),
    ClassificationItem_hasRulingBy_AuthorizationSource_ (x.ClassificationItem_hasRulingBy_AuthorizationSource_, f, this)
  {
  }

  ClassificationItem::
  ClassificationItem (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    changeFromPreviousVersion_ (this),
    changeLog_ (this),
    explanatoryNotes_ (this),
    futureNotes_ (this),
    identifier_ (this),
    isGenerated_ (this),
    isValid_ (this),
    name_ (this),
    validDates_ (this),
    ClassificationItem_excludes_ClassificationItem_ (this),
    ClassificationItem_denotes_Category_ (this),
    ClassificationItem_uses_Notation_ (this),
    ClassificationItem_hasRulingBy_AuthorizationSource_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClassificationItem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // changeFromPreviousVersion
      //
      if (n.name () == "changeFromPreviousVersion" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< changeFromPreviousVersion_type > r (
          changeFromPreviousVersion_traits::create (i, f, this));

        if (!this->changeFromPreviousVersion_)
        {
          this->changeFromPreviousVersion_.set (::std::move (r));
          continue;
        }
      }

      // changeLog
      //
      if (n.name () == "changeLog" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< changeLog_type > r (
          changeLog_traits::create (i, f, this));

        if (!this->changeLog_)
        {
          this->changeLog_.set (::std::move (r));
          continue;
        }
      }

      // explanatoryNotes
      //
      if (n.name () == "explanatoryNotes" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< explanatoryNotes_type > r (
          explanatoryNotes_traits::create (i, f, this));

        this->explanatoryNotes_.push_back (::std::move (r));
        continue;
      }

      // futureNotes
      //
      if (n.name () == "futureNotes" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< futureNotes_type > r (
          futureNotes_traits::create (i, f, this));

        this->futureNotes_.push_back (::std::move (r));
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // isGenerated
      //
      if (n.name () == "isGenerated" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isGenerated_)
        {
          this->isGenerated_.set (isGenerated_traits::create (i, f, this));
          continue;
        }
      }

      // isValid
      //
      if (n.name () == "isValid" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isValid_)
        {
          this->isValid_.set (isValid_traits::create (i, f, this));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // validDates
      //
      if (n.name () == "validDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< validDates_type > r (
          validDates_traits::create (i, f, this));

        if (!this->validDates_)
        {
          this->validDates_.set (::std::move (r));
          continue;
        }
      }

      // ClassificationItem_excludes_ClassificationItem
      //
      if (n.name () == "ClassificationItem_excludes_ClassificationItem" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItem_excludes_ClassificationItem_type > r (
          ClassificationItem_excludes_ClassificationItem_traits::create (i, f, this));

        this->ClassificationItem_excludes_ClassificationItem_.push_back (::std::move (r));
        continue;
      }

      // ClassificationItem_denotes_Category
      //
      if (n.name () == "ClassificationItem_denotes_Category" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItem_denotes_Category_type > r (
          ClassificationItem_denotes_Category_traits::create (i, f, this));

        if (!ClassificationItem_denotes_Category_.present ())
        {
          this->ClassificationItem_denotes_Category_.set (::std::move (r));
          continue;
        }
      }

      // ClassificationItem_uses_Notation
      //
      if (n.name () == "ClassificationItem_uses_Notation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItem_uses_Notation_type > r (
          ClassificationItem_uses_Notation_traits::create (i, f, this));

        if (!ClassificationItem_uses_Notation_.present ())
        {
          this->ClassificationItem_uses_Notation_.set (::std::move (r));
          continue;
        }
      }

      // ClassificationItem_hasRulingBy_AuthorizationSource
      //
      if (n.name () == "ClassificationItem_hasRulingBy_AuthorizationSource" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItem_hasRulingBy_AuthorizationSource_type > r (
          ClassificationItem_hasRulingBy_AuthorizationSource_traits::create (i, f, this));

        this->ClassificationItem_hasRulingBy_AuthorizationSource_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!ClassificationItem_denotes_Category_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ClassificationItem_denotes_Category",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!ClassificationItem_uses_Notation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ClassificationItem_uses_Notation",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ClassificationItem* ClassificationItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationItem (*this, f, c);
  }

  ClassificationItem& ClassificationItem::
  operator= (const ClassificationItem& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->changeFromPreviousVersion_ = x.changeFromPreviousVersion_;
      this->changeLog_ = x.changeLog_;
      this->explanatoryNotes_ = x.explanatoryNotes_;
      this->futureNotes_ = x.futureNotes_;
      this->identifier_ = x.identifier_;
      this->isGenerated_ = x.isGenerated_;
      this->isValid_ = x.isValid_;
      this->name_ = x.name_;
      this->validDates_ = x.validDates_;
      this->ClassificationItem_excludes_ClassificationItem_ = x.ClassificationItem_excludes_ClassificationItem_;
      this->ClassificationItem_denotes_Category_ = x.ClassificationItem_denotes_Category_;
      this->ClassificationItem_uses_Notation_ = x.ClassificationItem_uses_Notation_;
      this->ClassificationItem_hasRulingBy_AuthorizationSource_ = x.ClassificationItem_hasRulingBy_AuthorizationSource_;
    }

    return *this;
  }

  ClassificationItem::
  ~ClassificationItem ()
  {
  }

  // ClassificationItemPosition
  //

  ClassificationItemPosition::
  ClassificationItemPosition (const value_type& value)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    ClassificationItemPosition_indexes_ClassificationItem_ (this)
  {
  }

  ClassificationItemPosition::
  ClassificationItemPosition (const ClassificationItemPosition& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    value_ (x.value_, f, this),
    ClassificationItemPosition_indexes_ClassificationItem_ (x.ClassificationItemPosition_indexes_ClassificationItem_, f, this)
  {
  }

  ClassificationItemPosition::
  ClassificationItemPosition (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    value_ (this),
    ClassificationItemPosition_indexes_ClassificationItem_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClassificationItemPosition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      // ClassificationItemPosition_indexes_ClassificationItem
      //
      if (n.name () == "ClassificationItemPosition_indexes_ClassificationItem" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItemPosition_indexes_ClassificationItem_type > r (
          ClassificationItemPosition_indexes_ClassificationItem_traits::create (i, f, this));

        if (!this->ClassificationItemPosition_indexes_ClassificationItem_)
        {
          this->ClassificationItemPosition_indexes_ClassificationItem_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ClassificationItemPosition* ClassificationItemPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationItemPosition (*this, f, c);
  }

  ClassificationItemPosition& ClassificationItemPosition::
  operator= (const ClassificationItemPosition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->value_ = x.value_;
      this->ClassificationItemPosition_indexes_ClassificationItem_ = x.ClassificationItemPosition_indexes_ClassificationItem_;
    }

    return *this;
  }

  ClassificationItemPosition::
  ~ClassificationItemPosition ()
  {
  }

  // ClassificationItemRelationship
  //

  ClassificationItemRelationship::
  ClassificationItemRelationship ()
  : ::xml_schema::type (),
    identifier_ (this),
    semantics_ (this),
    ClassificationItemRelationship_hasSource_ClassificationItem_ (this),
    ClassificationItemRelationship_hasTarget_ClassificationItem_ (this)
  {
  }

  ClassificationItemRelationship::
  ClassificationItemRelationship (const ClassificationItemRelationship& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    semantics_ (x.semantics_, f, this),
    ClassificationItemRelationship_hasSource_ClassificationItem_ (x.ClassificationItemRelationship_hasSource_ClassificationItem_, f, this),
    ClassificationItemRelationship_hasTarget_ClassificationItem_ (x.ClassificationItemRelationship_hasTarget_ClassificationItem_, f, this)
  {
  }

  ClassificationItemRelationship::
  ClassificationItemRelationship (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    semantics_ (this),
    ClassificationItemRelationship_hasSource_ClassificationItem_ (this),
    ClassificationItemRelationship_hasTarget_ClassificationItem_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClassificationItemRelationship::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // ClassificationItemRelationship_hasSource_ClassificationItem
      //
      if (n.name () == "ClassificationItemRelationship_hasSource_ClassificationItem" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItemRelationship_hasSource_ClassificationItem_type > r (
          ClassificationItemRelationship_hasSource_ClassificationItem_traits::create (i, f, this));

        this->ClassificationItemRelationship_hasSource_ClassificationItem_.push_back (::std::move (r));
        continue;
      }

      // ClassificationItemRelationship_hasTarget_ClassificationItem
      //
      if (n.name () == "ClassificationItemRelationship_hasTarget_ClassificationItem" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItemRelationship_hasTarget_ClassificationItem_type > r (
          ClassificationItemRelationship_hasTarget_ClassificationItem_traits::create (i, f, this));

        this->ClassificationItemRelationship_hasTarget_ClassificationItem_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ClassificationItemRelationship* ClassificationItemRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationItemRelationship (*this, f, c);
  }

  ClassificationItemRelationship& ClassificationItemRelationship::
  operator= (const ClassificationItemRelationship& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->semantics_ = x.semantics_;
      this->ClassificationItemRelationship_hasSource_ClassificationItem_ = x.ClassificationItemRelationship_hasSource_ClassificationItem_;
      this->ClassificationItemRelationship_hasTarget_ClassificationItem_ = x.ClassificationItemRelationship_hasTarget_ClassificationItem_;
    }

    return *this;
  }

  ClassificationItemRelationship::
  ~ClassificationItemRelationship ()
  {
  }

  // ClassificationItemStructure
  //

  ClassificationItemStructure::
  ClassificationItemStructure ()
  : ::xml_schema::type (),
    displayLabel_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    ClassificationItemStructure_structures_StatisticalClassification_ (this),
    ClassificationItemStructure_has_ClassificationItemRelationship_ (this)
  {
  }

  ClassificationItemStructure::
  ClassificationItemStructure (const ClassificationItemStructure& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    displayLabel_ (x.displayLabel_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    semantics_ (x.semantics_, f, this),
    specification_ (x.specification_, f, this),
    topology_ (x.topology_, f, this),
    totality_ (x.totality_, f, this),
    ClassificationItemStructure_structures_StatisticalClassification_ (x.ClassificationItemStructure_structures_StatisticalClassification_, f, this),
    ClassificationItemStructure_has_ClassificationItemRelationship_ (x.ClassificationItemStructure_has_ClassificationItemRelationship_, f, this)
  {
  }

  ClassificationItemStructure::
  ClassificationItemStructure (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    displayLabel_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    ClassificationItemStructure_structures_StatisticalClassification_ (this),
    ClassificationItemStructure_has_ClassificationItemRelationship_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClassificationItemStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // displayLabel
      //
      if (n.name () == "displayLabel" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< displayLabel_type > r (
          displayLabel_traits::create (i, f, this));

        this->displayLabel_.push_back (::std::move (r));
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // specification
      //
      if (n.name () == "specification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< specification_type > r (
          specification_traits::create (i, f, this));

        if (!this->specification_)
        {
          this->specification_.set (::std::move (r));
          continue;
        }
      }

      // topology
      //
      if (n.name () == "topology" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< topology_type > r (
          topology_traits::create (i, f, this));

        if (!this->topology_)
        {
          this->topology_.set (::std::move (r));
          continue;
        }
      }

      // totality
      //
      if (n.name () == "totality" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< totality_type > r (
          totality_traits::create (i, f, this));

        if (!this->totality_)
        {
          this->totality_.set (::std::move (r));
          continue;
        }
      }

      // ClassificationItemStructure_structures_StatisticalClassification
      //
      if (n.name () == "ClassificationItemStructure_structures_StatisticalClassification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItemStructure_structures_StatisticalClassification_type > r (
          ClassificationItemStructure_structures_StatisticalClassification_traits::create (i, f, this));

        if (!this->ClassificationItemStructure_structures_StatisticalClassification_)
        {
          this->ClassificationItemStructure_structures_StatisticalClassification_.set (::std::move (r));
          continue;
        }
      }

      // ClassificationItemStructure_has_ClassificationItemRelationship
      //
      if (n.name () == "ClassificationItemStructure_has_ClassificationItemRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationItemStructure_has_ClassificationItemRelationship_type > r (
          ClassificationItemStructure_has_ClassificationItemRelationship_traits::create (i, f, this));

        this->ClassificationItemStructure_has_ClassificationItemRelationship_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ClassificationItemStructure* ClassificationItemStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationItemStructure (*this, f, c);
  }

  ClassificationItemStructure& ClassificationItemStructure::
  operator= (const ClassificationItemStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->displayLabel_ = x.displayLabel_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->semantics_ = x.semantics_;
      this->specification_ = x.specification_;
      this->topology_ = x.topology_;
      this->totality_ = x.totality_;
      this->ClassificationItemStructure_structures_StatisticalClassification_ = x.ClassificationItemStructure_structures_StatisticalClassification_;
      this->ClassificationItemStructure_has_ClassificationItemRelationship_ = x.ClassificationItemStructure_has_ClassificationItemRelationship_;
    }

    return *this;
  }

  ClassificationItemStructure::
  ~ClassificationItemStructure ()
  {
  }

  // ClassificationPosition
  //

  ClassificationPosition::
  ClassificationPosition (const value_type& value)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    ClassificationPosition_indexes_StatisticalClassification_ (this)
  {
  }

  ClassificationPosition::
  ClassificationPosition (const ClassificationPosition& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    value_ (x.value_, f, this),
    ClassificationPosition_indexes_StatisticalClassification_ (x.ClassificationPosition_indexes_StatisticalClassification_, f, this)
  {
  }

  ClassificationPosition::
  ClassificationPosition (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    value_ (this),
    ClassificationPosition_indexes_StatisticalClassification_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClassificationPosition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      // ClassificationPosition_indexes_StatisticalClassification
      //
      if (n.name () == "ClassificationPosition_indexes_StatisticalClassification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationPosition_indexes_StatisticalClassification_type > r (
          ClassificationPosition_indexes_StatisticalClassification_traits::create (i, f, this));

        if (!this->ClassificationPosition_indexes_StatisticalClassification_)
        {
          this->ClassificationPosition_indexes_StatisticalClassification_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ClassificationPosition* ClassificationPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationPosition (*this, f, c);
  }

  ClassificationPosition& ClassificationPosition::
  operator= (const ClassificationPosition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->value_ = x.value_;
      this->ClassificationPosition_indexes_StatisticalClassification_ = x.ClassificationPosition_indexes_StatisticalClassification_;
    }

    return *this;
  }

  ClassificationPosition::
  ~ClassificationPosition ()
  {
  }

  // ClassificationSeries
  //

  ClassificationSeries::
  ClassificationSeries (const allowsDuplicates_type& allowsDuplicates)
  : ::xml_schema::type (),
    allowsDuplicates_ (allowsDuplicates, this),
    catalogDetails_ (this),
    context_ (this),
    identifier_ (this),
    keyword_ (this),
    name_ (this),
    objectsOrUnitsClassified_ (this),
    purpose_ (this),
    subject_ (this),
    ClassificationSeries_isOwnedBy_Agent_ (this),
    ClassificationSeries_isDefinedBy_Concept_ (this),
    ClassificationSeries_has_StatisticalClassification_ (this),
    ClassificationSeries_has_ClassificationPosition_ (this)
  {
  }

  ClassificationSeries::
  ClassificationSeries (const ClassificationSeries& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    allowsDuplicates_ (x.allowsDuplicates_, f, this),
    catalogDetails_ (x.catalogDetails_, f, this),
    context_ (x.context_, f, this),
    identifier_ (x.identifier_, f, this),
    keyword_ (x.keyword_, f, this),
    name_ (x.name_, f, this),
    objectsOrUnitsClassified_ (x.objectsOrUnitsClassified_, f, this),
    purpose_ (x.purpose_, f, this),
    subject_ (x.subject_, f, this),
    ClassificationSeries_isOwnedBy_Agent_ (x.ClassificationSeries_isOwnedBy_Agent_, f, this),
    ClassificationSeries_isDefinedBy_Concept_ (x.ClassificationSeries_isDefinedBy_Concept_, f, this),
    ClassificationSeries_has_StatisticalClassification_ (x.ClassificationSeries_has_StatisticalClassification_, f, this),
    ClassificationSeries_has_ClassificationPosition_ (x.ClassificationSeries_has_ClassificationPosition_, f, this)
  {
  }

  ClassificationSeries::
  ClassificationSeries (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    allowsDuplicates_ (this),
    catalogDetails_ (this),
    context_ (this),
    identifier_ (this),
    keyword_ (this),
    name_ (this),
    objectsOrUnitsClassified_ (this),
    purpose_ (this),
    subject_ (this),
    ClassificationSeries_isOwnedBy_Agent_ (this),
    ClassificationSeries_isDefinedBy_Concept_ (this),
    ClassificationSeries_has_StatisticalClassification_ (this),
    ClassificationSeries_has_ClassificationPosition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClassificationSeries::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // allowsDuplicates
      //
      if (n.name () == "allowsDuplicates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!allowsDuplicates_.present ())
        {
          this->allowsDuplicates_.set (allowsDuplicates_traits::create (i, f, this));
          continue;
        }
      }

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // context
      //
      if (n.name () == "context" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< context_type > r (
          context_traits::create (i, f, this));

        if (!this->context_)
        {
          this->context_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // keyword
      //
      if (n.name () == "keyword" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< keyword_type > r (
          keyword_traits::create (i, f, this));

        this->keyword_.push_back (::std::move (r));
        continue;
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // objectsOrUnitsClassified
      //
      if (n.name () == "objectsOrUnitsClassified" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< objectsOrUnitsClassified_type > r (
          objectsOrUnitsClassified_traits::create (i, f, this));

        if (!this->objectsOrUnitsClassified_)
        {
          this->objectsOrUnitsClassified_.set (::std::move (r));
          continue;
        }
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // subject
      //
      if (n.name () == "subject" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< subject_type > r (
          subject_traits::create (i, f, this));

        this->subject_.push_back (::std::move (r));
        continue;
      }

      // ClassificationSeries_isOwnedBy_Agent
      //
      if (n.name () == "ClassificationSeries_isOwnedBy_Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationSeries_isOwnedBy_Agent_type > r (
          ClassificationSeries_isOwnedBy_Agent_traits::create (i, f, this));

        this->ClassificationSeries_isOwnedBy_Agent_.push_back (::std::move (r));
        continue;
      }

      // ClassificationSeries_isDefinedBy_Concept
      //
      if (n.name () == "ClassificationSeries_isDefinedBy_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationSeries_isDefinedBy_Concept_type > r (
          ClassificationSeries_isDefinedBy_Concept_traits::create (i, f, this));

        this->ClassificationSeries_isDefinedBy_Concept_.push_back (::std::move (r));
        continue;
      }

      // ClassificationSeries_has_StatisticalClassification
      //
      if (n.name () == "ClassificationSeries_has_StatisticalClassification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationSeries_has_StatisticalClassification_type > r (
          ClassificationSeries_has_StatisticalClassification_traits::create (i, f, this));

        this->ClassificationSeries_has_StatisticalClassification_.push_back (::std::move (r));
        continue;
      }

      // ClassificationSeries_has_ClassificationPosition
      //
      if (n.name () == "ClassificationSeries_has_ClassificationPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationSeries_has_ClassificationPosition_type > r (
          ClassificationSeries_has_ClassificationPosition_traits::create (i, f, this));

        this->ClassificationSeries_has_ClassificationPosition_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!allowsDuplicates_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "allowsDuplicates",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ClassificationSeries* ClassificationSeries::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationSeries (*this, f, c);
  }

  ClassificationSeries& ClassificationSeries::
  operator= (const ClassificationSeries& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->allowsDuplicates_ = x.allowsDuplicates_;
      this->catalogDetails_ = x.catalogDetails_;
      this->context_ = x.context_;
      this->identifier_ = x.identifier_;
      this->keyword_ = x.keyword_;
      this->name_ = x.name_;
      this->objectsOrUnitsClassified_ = x.objectsOrUnitsClassified_;
      this->purpose_ = x.purpose_;
      this->subject_ = x.subject_;
      this->ClassificationSeries_isOwnedBy_Agent_ = x.ClassificationSeries_isOwnedBy_Agent_;
      this->ClassificationSeries_isDefinedBy_Concept_ = x.ClassificationSeries_isDefinedBy_Concept_;
      this->ClassificationSeries_has_StatisticalClassification_ = x.ClassificationSeries_has_StatisticalClassification_;
      this->ClassificationSeries_has_ClassificationPosition_ = x.ClassificationSeries_has_ClassificationPosition_;
    }

    return *this;
  }

  ClassificationSeries::
  ~ClassificationSeries ()
  {
  }

  // ClassificationSeriesStructure
  //

  ClassificationSeriesStructure::
  ClassificationSeriesStructure ()
  : ::xml_schema::type (),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    ClassificationSeriesStructure_structures_ClassificationSeries_ (this),
    ClassificationSeriesStructure_has_StatisticalClassificationRelationship_ (this)
  {
  }

  ClassificationSeriesStructure::
  ClassificationSeriesStructure (const ClassificationSeriesStructure& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    semantics_ (x.semantics_, f, this),
    specification_ (x.specification_, f, this),
    topology_ (x.topology_, f, this),
    totality_ (x.totality_, f, this),
    ClassificationSeriesStructure_structures_ClassificationSeries_ (x.ClassificationSeriesStructure_structures_ClassificationSeries_, f, this),
    ClassificationSeriesStructure_has_StatisticalClassificationRelationship_ (x.ClassificationSeriesStructure_has_StatisticalClassificationRelationship_, f, this)
  {
  }

  ClassificationSeriesStructure::
  ClassificationSeriesStructure (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    ClassificationSeriesStructure_structures_ClassificationSeries_ (this),
    ClassificationSeriesStructure_has_StatisticalClassificationRelationship_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClassificationSeriesStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // specification
      //
      if (n.name () == "specification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< specification_type > r (
          specification_traits::create (i, f, this));

        if (!this->specification_)
        {
          this->specification_.set (::std::move (r));
          continue;
        }
      }

      // topology
      //
      if (n.name () == "topology" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< topology_type > r (
          topology_traits::create (i, f, this));

        if (!this->topology_)
        {
          this->topology_.set (::std::move (r));
          continue;
        }
      }

      // totality
      //
      if (n.name () == "totality" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< totality_type > r (
          totality_traits::create (i, f, this));

        if (!this->totality_)
        {
          this->totality_.set (::std::move (r));
          continue;
        }
      }

      // ClassificationSeriesStructure_structures_ClassificationSeries
      //
      if (n.name () == "ClassificationSeriesStructure_structures_ClassificationSeries" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationSeriesStructure_structures_ClassificationSeries_type > r (
          ClassificationSeriesStructure_structures_ClassificationSeries_traits::create (i, f, this));

        if (!this->ClassificationSeriesStructure_structures_ClassificationSeries_)
        {
          this->ClassificationSeriesStructure_structures_ClassificationSeries_.set (::std::move (r));
          continue;
        }
      }

      // ClassificationSeriesStructure_has_StatisticalClassificationRelationship
      //
      if (n.name () == "ClassificationSeriesStructure_has_StatisticalClassificationRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ClassificationSeriesStructure_has_StatisticalClassificationRelationship_type > r (
          ClassificationSeriesStructure_has_StatisticalClassificationRelationship_traits::create (i, f, this));

        this->ClassificationSeriesStructure_has_StatisticalClassificationRelationship_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ClassificationSeriesStructure* ClassificationSeriesStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationSeriesStructure (*this, f, c);
  }

  ClassificationSeriesStructure& ClassificationSeriesStructure::
  operator= (const ClassificationSeriesStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->semantics_ = x.semantics_;
      this->specification_ = x.specification_;
      this->topology_ = x.topology_;
      this->totality_ = x.totality_;
      this->ClassificationSeriesStructure_structures_ClassificationSeries_ = x.ClassificationSeriesStructure_structures_ClassificationSeries_;
      this->ClassificationSeriesStructure_has_StatisticalClassificationRelationship_ = x.ClassificationSeriesStructure_has_StatisticalClassificationRelationship_;
    }

    return *this;
  }

  ClassificationSeriesStructure::
  ~ClassificationSeriesStructure ()
  {
  }

  // Code
  //

  Code::
  Code (const Code_denotes_Category_type& Code_denotes_Category,
        const Code_uses_Notation_type& Code_uses_Notation)
  : ::xml_schema::type (),
    identifier_ (this),
    Code_denotes_Category_ (Code_denotes_Category, this),
    Code_uses_Notation_ (Code_uses_Notation, this)
  {
  }

  Code::
  Code (::std::unique_ptr< Code_denotes_Category_type > Code_denotes_Category,
        ::std::unique_ptr< Code_uses_Notation_type > Code_uses_Notation)
  : ::xml_schema::type (),
    identifier_ (this),
    Code_denotes_Category_ (std::move (Code_denotes_Category), this),
    Code_uses_Notation_ (std::move (Code_uses_Notation), this)
  {
  }

  Code::
  Code (const Code& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    Code_denotes_Category_ (x.Code_denotes_Category_, f, this),
    Code_uses_Notation_ (x.Code_uses_Notation_, f, this)
  {
  }

  Code::
  Code (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    Code_denotes_Category_ (this),
    Code_uses_Notation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Code::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // Code_denotes_Category
      //
      if (n.name () == "Code_denotes_Category" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Code_denotes_Category_type > r (
          Code_denotes_Category_traits::create (i, f, this));

        if (!Code_denotes_Category_.present ())
        {
          this->Code_denotes_Category_.set (::std::move (r));
          continue;
        }
      }

      // Code_uses_Notation
      //
      if (n.name () == "Code_uses_Notation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Code_uses_Notation_type > r (
          Code_uses_Notation_traits::create (i, f, this));

        if (!Code_uses_Notation_.present ())
        {
          this->Code_uses_Notation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Code_denotes_Category_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Code_denotes_Category",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!Code_uses_Notation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Code_uses_Notation",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  Code* Code::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Code (*this, f, c);
  }

  Code& Code::
  operator= (const Code& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->Code_denotes_Category_ = x.Code_denotes_Category_;
      this->Code_uses_Notation_ = x.Code_uses_Notation_;
    }

    return *this;
  }

  Code::
  ~Code ()
  {
  }

  // EnumerationDomain
  //

  EnumerationDomain::
  EnumerationDomain ()
  : ::xml_schema::type (),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    EnumerationDomain_uses_LevelStructure_ (this),
    EnumerationDomain_references_CategorySet_ (this),
    EnumerationDomain_isDefinedBy_Concept_ (this)
  {
  }

  EnumerationDomain::
  EnumerationDomain (const EnumerationDomain& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    EnumerationDomain_uses_LevelStructure_ (x.EnumerationDomain_uses_LevelStructure_, f, this),
    EnumerationDomain_references_CategorySet_ (x.EnumerationDomain_references_CategorySet_, f, this),
    EnumerationDomain_isDefinedBy_Concept_ (x.EnumerationDomain_isDefinedBy_Concept_, f, this)
  {
  }

  EnumerationDomain::
  EnumerationDomain (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    EnumerationDomain_uses_LevelStructure_ (this),
    EnumerationDomain_references_CategorySet_ (this),
    EnumerationDomain_isDefinedBy_Concept_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void EnumerationDomain::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // EnumerationDomain_uses_LevelStructure
      //
      if (n.name () == "EnumerationDomain_uses_LevelStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< EnumerationDomain_uses_LevelStructure_type > r (
          EnumerationDomain_uses_LevelStructure_traits::create (i, f, this));

        if (!this->EnumerationDomain_uses_LevelStructure_)
        {
          this->EnumerationDomain_uses_LevelStructure_.set (::std::move (r));
          continue;
        }
      }

      // EnumerationDomain_references_CategorySet
      //
      if (n.name () == "EnumerationDomain_references_CategorySet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< EnumerationDomain_references_CategorySet_type > r (
          EnumerationDomain_references_CategorySet_traits::create (i, f, this));

        if (!this->EnumerationDomain_references_CategorySet_)
        {
          this->EnumerationDomain_references_CategorySet_.set (::std::move (r));
          continue;
        }
      }

      // EnumerationDomain_isDefinedBy_Concept
      //
      if (n.name () == "EnumerationDomain_isDefinedBy_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< EnumerationDomain_isDefinedBy_Concept_type > r (
          EnumerationDomain_isDefinedBy_Concept_traits::create (i, f, this));

        this->EnumerationDomain_isDefinedBy_Concept_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  EnumerationDomain* EnumerationDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EnumerationDomain (*this, f, c);
  }

  EnumerationDomain& EnumerationDomain::
  operator= (const EnumerationDomain& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->EnumerationDomain_uses_LevelStructure_ = x.EnumerationDomain_uses_LevelStructure_;
      this->EnumerationDomain_references_CategorySet_ = x.EnumerationDomain_references_CategorySet_;
      this->EnumerationDomain_isDefinedBy_Concept_ = x.EnumerationDomain_isDefinedBy_Concept_;
    }

    return *this;
  }

  EnumerationDomain::
  ~EnumerationDomain ()
  {
  }

  // CodeList
  //

  CodeList::
  CodeList (const allowsDuplicates_type& allowsDuplicates)
  : ::XMLSchema::EnumerationDomain (),
    allowsDuplicates_ (allowsDuplicates, this),
    CodeList_has_CodePosition_ (this),
    CodeList_has_Code_ (this)
  {
  }

  CodeList::
  CodeList (const CodeList& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::XMLSchema::EnumerationDomain (x, f, c),
    allowsDuplicates_ (x.allowsDuplicates_, f, this),
    CodeList_has_CodePosition_ (x.CodeList_has_CodePosition_, f, this),
    CodeList_has_Code_ (x.CodeList_has_Code_, f, this)
  {
  }

  CodeList::
  CodeList (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::XMLSchema::EnumerationDomain (e, f | ::xml_schema::flags::base, c),
    allowsDuplicates_ (this),
    CodeList_has_CodePosition_ (this),
    CodeList_has_Code_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CodeList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::EnumerationDomain::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // allowsDuplicates
      //
      if (n.name () == "allowsDuplicates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!allowsDuplicates_.present ())
        {
          this->allowsDuplicates_.set (allowsDuplicates_traits::create (i, f, this));
          continue;
        }
      }

      // CodeList_has_CodePosition
      //
      if (n.name () == "CodeList_has_CodePosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodeList_has_CodePosition_type > r (
          CodeList_has_CodePosition_traits::create (i, f, this));

        this->CodeList_has_CodePosition_.push_back (::std::move (r));
        continue;
      }

      // CodeList_has_Code
      //
      if (n.name () == "CodeList_has_Code" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodeList_has_Code_type > r (
          CodeList_has_Code_traits::create (i, f, this));

        this->CodeList_has_Code_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!allowsDuplicates_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "allowsDuplicates",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  CodeList* CodeList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CodeList (*this, f, c);
  }

  CodeList& CodeList::
  operator= (const CodeList& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::EnumerationDomain& > (*this) = x;
      this->allowsDuplicates_ = x.allowsDuplicates_;
      this->CodeList_has_CodePosition_ = x.CodeList_has_CodePosition_;
      this->CodeList_has_Code_ = x.CodeList_has_Code_;
    }

    return *this;
  }

  CodeList::
  ~CodeList ()
  {
  }

  // CodeListStructure
  //

  CodeListStructure::
  CodeListStructure (const topology_type& topology)
  : ::xml_schema::type (),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (topology, this),
    totality_ (this),
    CodeListStructure_structures_CodeList_ (this),
    CodeListStructure_has_CodeRelationship_ (this)
  {
  }

  CodeListStructure::
  CodeListStructure (::std::unique_ptr< topology_type > topology)
  : ::xml_schema::type (),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (std::move (topology), this),
    totality_ (this),
    CodeListStructure_structures_CodeList_ (this),
    CodeListStructure_has_CodeRelationship_ (this)
  {
  }

  CodeListStructure::
  CodeListStructure (const CodeListStructure& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    semantics_ (x.semantics_, f, this),
    specification_ (x.specification_, f, this),
    topology_ (x.topology_, f, this),
    totality_ (x.totality_, f, this),
    CodeListStructure_structures_CodeList_ (x.CodeListStructure_structures_CodeList_, f, this),
    CodeListStructure_has_CodeRelationship_ (x.CodeListStructure_has_CodeRelationship_, f, this)
  {
  }

  CodeListStructure::
  CodeListStructure (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    CodeListStructure_structures_CodeList_ (this),
    CodeListStructure_has_CodeRelationship_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CodeListStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // specification
      //
      if (n.name () == "specification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< specification_type > r (
          specification_traits::create (i, f, this));

        if (!this->specification_)
        {
          this->specification_.set (::std::move (r));
          continue;
        }
      }

      // topology
      //
      if (n.name () == "topology" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< topology_type > r (
          topology_traits::create (i, f, this));

        if (!topology_.present ())
        {
          this->topology_.set (::std::move (r));
          continue;
        }
      }

      // totality
      //
      if (n.name () == "totality" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< totality_type > r (
          totality_traits::create (i, f, this));

        if (!this->totality_)
        {
          this->totality_.set (::std::move (r));
          continue;
        }
      }

      // CodeListStructure_structures_CodeList
      //
      if (n.name () == "CodeListStructure_structures_CodeList" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodeListStructure_structures_CodeList_type > r (
          CodeListStructure_structures_CodeList_traits::create (i, f, this));

        if (!this->CodeListStructure_structures_CodeList_)
        {
          this->CodeListStructure_structures_CodeList_.set (::std::move (r));
          continue;
        }
      }

      // CodeListStructure_has_CodeRelationship
      //
      if (n.name () == "CodeListStructure_has_CodeRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodeListStructure_has_CodeRelationship_type > r (
          CodeListStructure_has_CodeRelationship_traits::create (i, f, this));

        this->CodeListStructure_has_CodeRelationship_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!topology_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "topology",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  CodeListStructure* CodeListStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CodeListStructure (*this, f, c);
  }

  CodeListStructure& CodeListStructure::
  operator= (const CodeListStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->semantics_ = x.semantics_;
      this->specification_ = x.specification_;
      this->topology_ = x.topology_;
      this->totality_ = x.totality_;
      this->CodeListStructure_structures_CodeList_ = x.CodeListStructure_structures_CodeList_;
      this->CodeListStructure_has_CodeRelationship_ = x.CodeListStructure_has_CodeRelationship_;
    }

    return *this;
  }

  CodeListStructure::
  ~CodeListStructure ()
  {
  }

  // CodePosition
  //

  CodePosition::
  CodePosition (const value_type& value)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    CodePosition_indexes_Code_ (this)
  {
  }

  CodePosition::
  CodePosition (const CodePosition& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    value_ (x.value_, f, this),
    CodePosition_indexes_Code_ (x.CodePosition_indexes_Code_, f, this)
  {
  }

  CodePosition::
  CodePosition (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    value_ (this),
    CodePosition_indexes_Code_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CodePosition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      // CodePosition_indexes_Code
      //
      if (n.name () == "CodePosition_indexes_Code" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodePosition_indexes_Code_type > r (
          CodePosition_indexes_Code_traits::create (i, f, this));

        if (!this->CodePosition_indexes_Code_)
        {
          this->CodePosition_indexes_Code_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  CodePosition* CodePosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CodePosition (*this, f, c);
  }

  CodePosition& CodePosition::
  operator= (const CodePosition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->value_ = x.value_;
      this->CodePosition_indexes_Code_ = x.CodePosition_indexes_Code_;
    }

    return *this;
  }

  CodePosition::
  ~CodePosition ()
  {
  }

  // CodeRelationship
  //

  CodeRelationship::
  CodeRelationship ()
  : ::xml_schema::type (),
    identifier_ (this),
    semantics_ (this),
    CodeRelationship_hasTarget_Code_ (this),
    CodeRelationship_hasSource_Code_ (this)
  {
  }

  CodeRelationship::
  CodeRelationship (const CodeRelationship& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    semantics_ (x.semantics_, f, this),
    CodeRelationship_hasTarget_Code_ (x.CodeRelationship_hasTarget_Code_, f, this),
    CodeRelationship_hasSource_Code_ (x.CodeRelationship_hasSource_Code_, f, this)
  {
  }

  CodeRelationship::
  CodeRelationship (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    semantics_ (this),
    CodeRelationship_hasTarget_Code_ (this),
    CodeRelationship_hasSource_Code_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CodeRelationship::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // CodeRelationship_hasTarget_Code
      //
      if (n.name () == "CodeRelationship_hasTarget_Code" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodeRelationship_hasTarget_Code_type > r (
          CodeRelationship_hasTarget_Code_traits::create (i, f, this));

        this->CodeRelationship_hasTarget_Code_.push_back (::std::move (r));
        continue;
      }

      // CodeRelationship_hasSource_Code
      //
      if (n.name () == "CodeRelationship_hasSource_Code" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CodeRelationship_hasSource_Code_type > r (
          CodeRelationship_hasSource_Code_traits::create (i, f, this));

        this->CodeRelationship_hasSource_Code_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CodeRelationship* CodeRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CodeRelationship (*this, f, c);
  }

  CodeRelationship& CodeRelationship::
  operator= (const CodeRelationship& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->semantics_ = x.semantics_;
      this->CodeRelationship_hasTarget_Code_ = x.CodeRelationship_hasTarget_Code_;
      this->CodeRelationship_hasSource_Code_ = x.CodeRelationship_hasSource_Code_;
    }

    return *this;
  }

  CodeRelationship::
  ~CodeRelationship ()
  {
  }

  // ComponentPosition
  //

  ComponentPosition::
  ComponentPosition (const value_type& value)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    ComponentPosition_indexes_DataStructureComponent_ (this)
  {
  }

  ComponentPosition::
  ComponentPosition (const ComponentPosition& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    value_ (x.value_, f, this),
    ComponentPosition_indexes_DataStructureComponent_ (x.ComponentPosition_indexes_DataStructureComponent_, f, this)
  {
  }

  ComponentPosition::
  ComponentPosition (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    value_ (this),
    ComponentPosition_indexes_DataStructureComponent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ComponentPosition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      // ComponentPosition_indexes_DataStructureComponent
      //
      if (n.name () == "ComponentPosition_indexes_DataStructureComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ComponentPosition_indexes_DataStructureComponent_type > r (
          ComponentPosition_indexes_DataStructureComponent_traits::create (i, f, this));

        if (!this->ComponentPosition_indexes_DataStructureComponent_)
        {
          this->ComponentPosition_indexes_DataStructureComponent_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ComponentPosition* ComponentPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComponentPosition (*this, f, c);
  }

  ComponentPosition& ComponentPosition::
  operator= (const ComponentPosition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->value_ = x.value_;
      this->ComponentPosition_indexes_DataStructureComponent_ = x.ComponentPosition_indexes_DataStructureComponent_;
    }

    return *this;
  }

  ComponentPosition::
  ~ComponentPosition ()
  {
  }

  // ConceptMap
  //

  ConceptMap::
  ConceptMap ()
  : ::xml_schema::type (),
    correspondence_ (this),
    displayLabel_ (this),
    identifier_ (this),
    usage_ (this),
    validDates_ (this),
    ConceptMap_hasSource_Concept_ (this),
    ConceptMap_hasTarget_Concept_ (this)
  {
  }

  ConceptMap::
  ConceptMap (const ConceptMap& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    correspondence_ (x.correspondence_, f, this),
    displayLabel_ (x.displayLabel_, f, this),
    identifier_ (x.identifier_, f, this),
    usage_ (x.usage_, f, this),
    validDates_ (x.validDates_, f, this),
    ConceptMap_hasSource_Concept_ (x.ConceptMap_hasSource_Concept_, f, this),
    ConceptMap_hasTarget_Concept_ (x.ConceptMap_hasTarget_Concept_, f, this)
  {
  }

  ConceptMap::
  ConceptMap (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    correspondence_ (this),
    displayLabel_ (this),
    identifier_ (this),
    usage_ (this),
    validDates_ (this),
    ConceptMap_hasSource_Concept_ (this),
    ConceptMap_hasTarget_Concept_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ConceptMap::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // correspondence
      //
      if (n.name () == "correspondence" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< correspondence_type > r (
          correspondence_traits::create (i, f, this));

        if (!this->correspondence_)
        {
          this->correspondence_.set (::std::move (r));
          continue;
        }
      }

      // displayLabel
      //
      if (n.name () == "displayLabel" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< displayLabel_type > r (
          displayLabel_traits::create (i, f, this));

        if (!this->displayLabel_)
        {
          this->displayLabel_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // usage
      //
      if (n.name () == "usage" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< usage_type > r (
          usage_traits::create (i, f, this));

        if (!this->usage_)
        {
          this->usage_.set (::std::move (r));
          continue;
        }
      }

      // validDates
      //
      if (n.name () == "validDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< validDates_type > r (
          validDates_traits::create (i, f, this));

        if (!this->validDates_)
        {
          this->validDates_.set (::std::move (r));
          continue;
        }
      }

      // ConceptMap_hasSource_Concept
      //
      if (n.name () == "ConceptMap_hasSource_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptMap_hasSource_Concept_type > r (
          ConceptMap_hasSource_Concept_traits::create (i, f, this));

        this->ConceptMap_hasSource_Concept_.push_back (::std::move (r));
        continue;
      }

      // ConceptMap_hasTarget_Concept
      //
      if (n.name () == "ConceptMap_hasTarget_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptMap_hasTarget_Concept_type > r (
          ConceptMap_hasTarget_Concept_traits::create (i, f, this));

        this->ConceptMap_hasTarget_Concept_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ConceptMap* ConceptMap::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptMap (*this, f, c);
  }

  ConceptMap& ConceptMap::
  operator= (const ConceptMap& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->correspondence_ = x.correspondence_;
      this->displayLabel_ = x.displayLabel_;
      this->identifier_ = x.identifier_;
      this->usage_ = x.usage_;
      this->validDates_ = x.validDates_;
      this->ConceptMap_hasSource_Concept_ = x.ConceptMap_hasSource_Concept_;
      this->ConceptMap_hasTarget_Concept_ = x.ConceptMap_hasTarget_Concept_;
    }

    return *this;
  }

  ConceptMap::
  ~ConceptMap ()
  {
  }

  // ConceptRelationship
  //

  ConceptRelationship::
  ConceptRelationship (const ConceptRelationship_hasSource_Concept_type& ConceptRelationship_hasSource_Concept,
                       const ConceptRelationship_hasTarget_Concept_type& ConceptRelationship_hasTarget_Concept)
  : ::xml_schema::type (),
    identifier_ (this),
    semantics_ (this),
    ConceptRelationship_hasSource_Concept_ (ConceptRelationship_hasSource_Concept, this),
    ConceptRelationship_hasTarget_Concept_ (ConceptRelationship_hasTarget_Concept, this)
  {
  }

  ConceptRelationship::
  ConceptRelationship (::std::unique_ptr< ConceptRelationship_hasSource_Concept_type > ConceptRelationship_hasSource_Concept,
                       ::std::unique_ptr< ConceptRelationship_hasTarget_Concept_type > ConceptRelationship_hasTarget_Concept)
  : ::xml_schema::type (),
    identifier_ (this),
    semantics_ (this),
    ConceptRelationship_hasSource_Concept_ (std::move (ConceptRelationship_hasSource_Concept), this),
    ConceptRelationship_hasTarget_Concept_ (std::move (ConceptRelationship_hasTarget_Concept), this)
  {
  }

  ConceptRelationship::
  ConceptRelationship (const ConceptRelationship& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    semantics_ (x.semantics_, f, this),
    ConceptRelationship_hasSource_Concept_ (x.ConceptRelationship_hasSource_Concept_, f, this),
    ConceptRelationship_hasTarget_Concept_ (x.ConceptRelationship_hasTarget_Concept_, f, this)
  {
  }

  ConceptRelationship::
  ConceptRelationship (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    semantics_ (this),
    ConceptRelationship_hasSource_Concept_ (this),
    ConceptRelationship_hasTarget_Concept_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ConceptRelationship::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // ConceptRelationship_hasSource_Concept
      //
      if (n.name () == "ConceptRelationship_hasSource_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptRelationship_hasSource_Concept_type > r (
          ConceptRelationship_hasSource_Concept_traits::create (i, f, this));

        if (!ConceptRelationship_hasSource_Concept_.present ())
        {
          this->ConceptRelationship_hasSource_Concept_.set (::std::move (r));
          continue;
        }
      }

      // ConceptRelationship_hasTarget_Concept
      //
      if (n.name () == "ConceptRelationship_hasTarget_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptRelationship_hasTarget_Concept_type > r (
          ConceptRelationship_hasTarget_Concept_traits::create (i, f, this));

        if (!ConceptRelationship_hasTarget_Concept_.present ())
        {
          this->ConceptRelationship_hasTarget_Concept_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!ConceptRelationship_hasSource_Concept_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ConceptRelationship_hasSource_Concept",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!ConceptRelationship_hasTarget_Concept_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ConceptRelationship_hasTarget_Concept",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ConceptRelationship* ConceptRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptRelationship (*this, f, c);
  }

  ConceptRelationship& ConceptRelationship::
  operator= (const ConceptRelationship& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->semantics_ = x.semantics_;
      this->ConceptRelationship_hasSource_Concept_ = x.ConceptRelationship_hasSource_Concept_;
      this->ConceptRelationship_hasTarget_Concept_ = x.ConceptRelationship_hasTarget_Concept_;
    }

    return *this;
  }

  ConceptRelationship::
  ~ConceptRelationship ()
  {
  }

  // ConceptStructure
  //

  ConceptStructure::
  ConceptStructure ()
  : ::xml_schema::type (),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    ConceptStructure_structures_ConceptSystem_ (this),
    ConceptStructure_has_ConceptRelationship_ (this)
  {
  }

  ConceptStructure::
  ConceptStructure (const ConceptStructure& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    semantics_ (x.semantics_, f, this),
    specification_ (x.specification_, f, this),
    topology_ (x.topology_, f, this),
    totality_ (x.totality_, f, this),
    ConceptStructure_structures_ConceptSystem_ (x.ConceptStructure_structures_ConceptSystem_, f, this),
    ConceptStructure_has_ConceptRelationship_ (x.ConceptStructure_has_ConceptRelationship_, f, this)
  {
  }

  ConceptStructure::
  ConceptStructure (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    ConceptStructure_structures_ConceptSystem_ (this),
    ConceptStructure_has_ConceptRelationship_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ConceptStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // specification
      //
      if (n.name () == "specification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< specification_type > r (
          specification_traits::create (i, f, this));

        if (!this->specification_)
        {
          this->specification_.set (::std::move (r));
          continue;
        }
      }

      // topology
      //
      if (n.name () == "topology" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< topology_type > r (
          topology_traits::create (i, f, this));

        if (!this->topology_)
        {
          this->topology_.set (::std::move (r));
          continue;
        }
      }

      // totality
      //
      if (n.name () == "totality" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< totality_type > r (
          totality_traits::create (i, f, this));

        if (!this->totality_)
        {
          this->totality_.set (::std::move (r));
          continue;
        }
      }

      // ConceptStructure_structures_ConceptSystem
      //
      if (n.name () == "ConceptStructure_structures_ConceptSystem" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptStructure_structures_ConceptSystem_type > r (
          ConceptStructure_structures_ConceptSystem_traits::create (i, f, this));

        if (!this->ConceptStructure_structures_ConceptSystem_)
        {
          this->ConceptStructure_structures_ConceptSystem_.set (::std::move (r));
          continue;
        }
      }

      // ConceptStructure_has_ConceptRelationship
      //
      if (n.name () == "ConceptStructure_has_ConceptRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptStructure_has_ConceptRelationship_type > r (
          ConceptStructure_has_ConceptRelationship_traits::create (i, f, this));

        this->ConceptStructure_has_ConceptRelationship_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ConceptStructure* ConceptStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptStructure (*this, f, c);
  }

  ConceptStructure& ConceptStructure::
  operator= (const ConceptStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->semantics_ = x.semantics_;
      this->specification_ = x.specification_;
      this->topology_ = x.topology_;
      this->totality_ = x.totality_;
      this->ConceptStructure_structures_ConceptSystem_ = x.ConceptStructure_structures_ConceptSystem_;
      this->ConceptStructure_has_ConceptRelationship_ = x.ConceptStructure_has_ConceptRelationship_;
    }

    return *this;
  }

  ConceptStructure::
  ~ConceptStructure ()
  {
  }

  // ConceptSystemCorrespondence
  //

  ConceptSystemCorrespondence::
  ConceptSystemCorrespondence ()
  : ::xml_schema::type (),
    catalogDetails_ (this),
    displayLabel_ (this),
    identifier_ (this),
    purpose_ (this),
    usage_ (this),
    ConceptSystemCorrespondence_maps_ConceptSystem_ (this),
    ConceptSystemCorrespondence_has_ConceptMap_ (this)
  {
  }

  ConceptSystemCorrespondence::
  ConceptSystemCorrespondence (const ConceptSystemCorrespondence& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    displayLabel_ (x.displayLabel_, f, this),
    identifier_ (x.identifier_, f, this),
    purpose_ (x.purpose_, f, this),
    usage_ (x.usage_, f, this),
    ConceptSystemCorrespondence_maps_ConceptSystem_ (x.ConceptSystemCorrespondence_maps_ConceptSystem_, f, this),
    ConceptSystemCorrespondence_has_ConceptMap_ (x.ConceptSystemCorrespondence_has_ConceptMap_, f, this)
  {
  }

  ConceptSystemCorrespondence::
  ConceptSystemCorrespondence (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    displayLabel_ (this),
    identifier_ (this),
    purpose_ (this),
    usage_ (this),
    ConceptSystemCorrespondence_maps_ConceptSystem_ (this),
    ConceptSystemCorrespondence_has_ConceptMap_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ConceptSystemCorrespondence::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // displayLabel
      //
      if (n.name () == "displayLabel" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< displayLabel_type > r (
          displayLabel_traits::create (i, f, this));

        this->displayLabel_.push_back (::std::move (r));
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // usage
      //
      if (n.name () == "usage" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< usage_type > r (
          usage_traits::create (i, f, this));

        if (!this->usage_)
        {
          this->usage_.set (::std::move (r));
          continue;
        }
      }

      // ConceptSystemCorrespondence_maps_ConceptSystem
      //
      if (n.name () == "ConceptSystemCorrespondence_maps_ConceptSystem" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptSystemCorrespondence_maps_ConceptSystem_type > r (
          ConceptSystemCorrespondence_maps_ConceptSystem_traits::create (i, f, this));

        this->ConceptSystemCorrespondence_maps_ConceptSystem_.push_back (::std::move (r));
        continue;
      }

      // ConceptSystemCorrespondence_has_ConceptMap
      //
      if (n.name () == "ConceptSystemCorrespondence_has_ConceptMap" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptSystemCorrespondence_has_ConceptMap_type > r (
          ConceptSystemCorrespondence_has_ConceptMap_traits::create (i, f, this));

        this->ConceptSystemCorrespondence_has_ConceptMap_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ConceptSystemCorrespondence* ConceptSystemCorrespondence::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptSystemCorrespondence (*this, f, c);
  }

  ConceptSystemCorrespondence& ConceptSystemCorrespondence::
  operator= (const ConceptSystemCorrespondence& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->displayLabel_ = x.displayLabel_;
      this->identifier_ = x.identifier_;
      this->purpose_ = x.purpose_;
      this->usage_ = x.usage_;
      this->ConceptSystemCorrespondence_maps_ConceptSystem_ = x.ConceptSystemCorrespondence_maps_ConceptSystem_;
      this->ConceptSystemCorrespondence_has_ConceptMap_ = x.ConceptSystemCorrespondence_has_ConceptMap_;
    }

    return *this;
  }

  ConceptSystemCorrespondence::
  ~ConceptSystemCorrespondence ()
  {
  }

  // ConceptualDomain
  //

  ConceptualDomain::
  ConceptualDomain ()
  : ::xml_schema::type (),
    catalogDetails_ (this),
    displayLabel_ (this),
    identifier_ (this),
    ConceptualDomain_isDescribedBy_ValueAndConceptDescription_ (this),
    ConceptualDomain_takesConceptsFrom_ConceptSystem_ (this)
  {
  }

  ConceptualDomain::
  ConceptualDomain (const ConceptualDomain& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    displayLabel_ (x.displayLabel_, f, this),
    identifier_ (x.identifier_, f, this),
    ConceptualDomain_isDescribedBy_ValueAndConceptDescription_ (x.ConceptualDomain_isDescribedBy_ValueAndConceptDescription_, f, this),
    ConceptualDomain_takesConceptsFrom_ConceptSystem_ (x.ConceptualDomain_takesConceptsFrom_ConceptSystem_, f, this)
  {
  }

  ConceptualDomain::
  ConceptualDomain (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    displayLabel_ (this),
    identifier_ (this),
    ConceptualDomain_isDescribedBy_ValueAndConceptDescription_ (this),
    ConceptualDomain_takesConceptsFrom_ConceptSystem_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ConceptualDomain::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // displayLabel
      //
      if (n.name () == "displayLabel" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< displayLabel_type > r (
          displayLabel_traits::create (i, f, this));

        this->displayLabel_.push_back (::std::move (r));
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // ConceptualDomain_isDescribedBy_ValueAndConceptDescription
      //
      if (n.name () == "ConceptualDomain_isDescribedBy_ValueAndConceptDescription" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptualDomain_isDescribedBy_ValueAndConceptDescription_type > r (
          ConceptualDomain_isDescribedBy_ValueAndConceptDescription_traits::create (i, f, this));

        if (!this->ConceptualDomain_isDescribedBy_ValueAndConceptDescription_)
        {
          this->ConceptualDomain_isDescribedBy_ValueAndConceptDescription_.set (::std::move (r));
          continue;
        }
      }

      // ConceptualDomain_takesConceptsFrom_ConceptSystem
      //
      if (n.name () == "ConceptualDomain_takesConceptsFrom_ConceptSystem" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptualDomain_takesConceptsFrom_ConceptSystem_type > r (
          ConceptualDomain_takesConceptsFrom_ConceptSystem_traits::create (i, f, this));

        if (!this->ConceptualDomain_takesConceptsFrom_ConceptSystem_)
        {
          this->ConceptualDomain_takesConceptsFrom_ConceptSystem_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ConceptualDomain* ConceptualDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptualDomain (*this, f, c);
  }

  ConceptualDomain& ConceptualDomain::
  operator= (const ConceptualDomain& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->displayLabel_ = x.displayLabel_;
      this->identifier_ = x.identifier_;
      this->ConceptualDomain_isDescribedBy_ValueAndConceptDescription_ = x.ConceptualDomain_isDescribedBy_ValueAndConceptDescription_;
      this->ConceptualDomain_takesConceptsFrom_ConceptSystem_ = x.ConceptualDomain_takesConceptsFrom_ConceptSystem_;
    }

    return *this;
  }

  ConceptualDomain::
  ~ConceptualDomain ()
  {
  }

  // ConceptualValue
  //

  ConceptualValue::
  ConceptualValue (const ConceptualValue_hasConceptFrom_ConceptualDomain_type& ConceptualValue_hasConceptFrom_ConceptualDomain)
  : ::XMLSchema::Concept (),
    ConceptualValue_hasConceptFrom_ConceptualDomain_ (ConceptualValue_hasConceptFrom_ConceptualDomain, this)
  {
  }

  ConceptualValue::
  ConceptualValue (::std::unique_ptr< ConceptualValue_hasConceptFrom_ConceptualDomain_type > ConceptualValue_hasConceptFrom_ConceptualDomain)
  : ::XMLSchema::Concept (),
    ConceptualValue_hasConceptFrom_ConceptualDomain_ (std::move (ConceptualValue_hasConceptFrom_ConceptualDomain), this)
  {
  }

  ConceptualValue::
  ConceptualValue (const ConceptualValue& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::XMLSchema::Concept (x, f, c),
    ConceptualValue_hasConceptFrom_ConceptualDomain_ (x.ConceptualValue_hasConceptFrom_ConceptualDomain_, f, this)
  {
  }

  ConceptualValue::
  ConceptualValue (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::XMLSchema::Concept (e, f | ::xml_schema::flags::base, c),
    ConceptualValue_hasConceptFrom_ConceptualDomain_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ConceptualValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::Concept::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ConceptualValue_hasConceptFrom_ConceptualDomain
      //
      if (n.name () == "ConceptualValue_hasConceptFrom_ConceptualDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptualValue_hasConceptFrom_ConceptualDomain_type > r (
          ConceptualValue_hasConceptFrom_ConceptualDomain_traits::create (i, f, this));

        if (!ConceptualValue_hasConceptFrom_ConceptualDomain_.present ())
        {
          this->ConceptualValue_hasConceptFrom_ConceptualDomain_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!ConceptualValue_hasConceptFrom_ConceptualDomain_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ConceptualValue_hasConceptFrom_ConceptualDomain",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ConceptualValue* ConceptualValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptualValue (*this, f, c);
  }

  ConceptualValue& ConceptualValue::
  operator= (const ConceptualValue& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Concept& > (*this) = x;
      this->ConceptualValue_hasConceptFrom_ConceptualDomain_ = x.ConceptualValue_hasConceptFrom_ConceptualDomain_;
    }

    return *this;
  }

  ConceptualValue::
  ~ConceptualValue ()
  {
  }

  // ConceptualVariable
  //

  ConceptualVariable::
  ConceptualVariable ()
  : ::XMLSchema::Concept (),
    descriptiveText_ (this),
    unitOfMeasureKind_ (this),
    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_ (this),
    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_ (this),
    ConceptualVariable_measures_UnitType_ (this)
  {
  }

  ConceptualVariable::
  ConceptualVariable (const ConceptualVariable& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::Concept (x, f, c),
    descriptiveText_ (x.descriptiveText_, f, this),
    unitOfMeasureKind_ (x.unitOfMeasureKind_, f, this),
    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_ (x.ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_, f, this),
    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_ (x.ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_, f, this),
    ConceptualVariable_measures_UnitType_ (x.ConceptualVariable_measures_UnitType_, f, this)
  {
  }

  ConceptualVariable::
  ConceptualVariable (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::Concept (e, f | ::xml_schema::flags::base, c),
    descriptiveText_ (this),
    unitOfMeasureKind_ (this),
    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_ (this),
    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_ (this),
    ConceptualVariable_measures_UnitType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ConceptualVariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::Concept::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // descriptiveText
      //
      if (n.name () == "descriptiveText" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< descriptiveText_type > r (
          descriptiveText_traits::create (i, f, this));

        if (!this->descriptiveText_)
        {
          this->descriptiveText_.set (::std::move (r));
          continue;
        }
      }

      // unitOfMeasureKind
      //
      if (n.name () == "unitOfMeasureKind" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< unitOfMeasureKind_type > r (
          unitOfMeasureKind_traits::create (i, f, this));

        if (!this->unitOfMeasureKind_)
        {
          this->unitOfMeasureKind_.set (::std::move (r));
          continue;
        }
      }

      // ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain
      //
      if (n.name () == "ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_type > r (
          ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_traits::create (i, f, this));

        if (!this->ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_)
        {
          this->ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_.set (::std::move (r));
          continue;
        }
      }

      // ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain
      //
      if (n.name () == "ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_type > r (
          ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_traits::create (i, f, this));

        if (!this->ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_)
        {
          this->ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_.set (::std::move (r));
          continue;
        }
      }

      // ConceptualVariable_measures_UnitType
      //
      if (n.name () == "ConceptualVariable_measures_UnitType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ConceptualVariable_measures_UnitType_type > r (
          ConceptualVariable_measures_UnitType_traits::create (i, f, this));

        if (!this->ConceptualVariable_measures_UnitType_)
        {
          this->ConceptualVariable_measures_UnitType_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ConceptualVariable* ConceptualVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptualVariable (*this, f, c);
  }

  ConceptualVariable& ConceptualVariable::
  operator= (const ConceptualVariable& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Concept& > (*this) = x;
      this->descriptiveText_ = x.descriptiveText_;
      this->unitOfMeasureKind_ = x.unitOfMeasureKind_;
      this->ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_ = x.ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_;
      this->ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_ = x.ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_;
      this->ConceptualVariable_measures_UnitType_ = x.ConceptualVariable_measures_UnitType_;
    }

    return *this;
  }

  ConceptualVariable::
  ~ConceptualVariable ()
  {
  }

  // DeterministicImperative
  //

  DeterministicImperative::
  DeterministicImperative ()
  : ::XMLSchema::ControlLogic ()
  {
  }

  DeterministicImperative::
  DeterministicImperative (const DeterministicImperative& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::XMLSchema::ControlLogic (x, f, c)
  {
  }

  DeterministicImperative::
  DeterministicImperative (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::XMLSchema::ControlLogic (e, f, c)
  {
  }

  DeterministicImperative* DeterministicImperative::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DeterministicImperative (*this, f, c);
  }

  DeterministicImperative::
  ~DeterministicImperative ()
  {
  }

  // ConditionalControlLogic
  //

  ConditionalControlLogic::
  ConditionalControlLogic (const condition_type& condition,
                           const construct_type& construct)
  : ::XMLSchema::DeterministicImperative (),
    condition_ (condition, this),
    construct_ (construct, this)
  {
  }

  ConditionalControlLogic::
  ConditionalControlLogic (::std::unique_ptr< condition_type > condition,
                           const construct_type& construct)
  : ::XMLSchema::DeterministicImperative (),
    condition_ (std::move (condition), this),
    construct_ (construct, this)
  {
  }

  ConditionalControlLogic::
  ConditionalControlLogic (const ConditionalControlLogic& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::XMLSchema::DeterministicImperative (x, f, c),
    condition_ (x.condition_, f, this),
    construct_ (x.construct_, f, this)
  {
  }

  ConditionalControlLogic::
  ConditionalControlLogic (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::XMLSchema::DeterministicImperative (e, f | ::xml_schema::flags::base, c),
    condition_ (this),
    construct_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ConditionalControlLogic::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::DeterministicImperative::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // condition
      //
      if (n.name () == "condition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< condition_type > r (
          condition_traits::create (i, f, this));

        if (!condition_.present ())
        {
          this->condition_.set (::std::move (r));
          continue;
        }
      }

      // construct
      //
      if (n.name () == "construct" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< construct_type > r (
          construct_traits::create (i, f, this));

        if (!construct_.present ())
        {
          this->construct_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!condition_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "condition",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!construct_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "construct",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ConditionalControlLogic* ConditionalControlLogic::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConditionalControlLogic (*this, f, c);
  }

  ConditionalControlLogic& ConditionalControlLogic::
  operator= (const ConditionalControlLogic& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::DeterministicImperative& > (*this) = x;
      this->condition_ = x.condition_;
      this->construct_ = x.construct_;
    }

    return *this;
  }

  ConditionalControlLogic::
  ~ConditionalControlLogic ()
  {
  }

  // ContextualComponent
  //

  ContextualComponent::
  ContextualComponent ()
  : ::XMLSchema::DataStructureComponent ()
  {
  }

  ContextualComponent::
  ContextualComponent (const ContextualComponent& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (x, f, c)
  {
  }

  ContextualComponent::
  ContextualComponent (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (e, f, c)
  {
  }

  ContextualComponent* ContextualComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ContextualComponent (*this, f, c);
  }

  ContextualComponent::
  ~ContextualComponent ()
  {
  }

  // CorrespondenceTable
  //

  CorrespondenceTable::
  CorrespondenceTable ()
  : ::xml_schema::type (),
    catalogDetails_ (this),
    effectiveDates_ (this),
    identifier_ (this),
    CorrespondenceTable_hasSource_Level_ (this),
    CorrespondenceTable_hasTarget_Level_ (this),
    CorrespondenceTable_isOwnedBy_Agent_ (this),
    CorrespondenceTable_mapsTo_StatisticalClassification_ (this),
    CorrespondenceTable_hasContact_Agent_ (this),
    CorrespondenceTable_isMaintainedBy_Agent_ (this),
    CorrespondenceTable_has_ConceptMap_ (this)
  {
  }

  CorrespondenceTable::
  CorrespondenceTable (const CorrespondenceTable& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    effectiveDates_ (x.effectiveDates_, f, this),
    identifier_ (x.identifier_, f, this),
    CorrespondenceTable_hasSource_Level_ (x.CorrespondenceTable_hasSource_Level_, f, this),
    CorrespondenceTable_hasTarget_Level_ (x.CorrespondenceTable_hasTarget_Level_, f, this),
    CorrespondenceTable_isOwnedBy_Agent_ (x.CorrespondenceTable_isOwnedBy_Agent_, f, this),
    CorrespondenceTable_mapsTo_StatisticalClassification_ (x.CorrespondenceTable_mapsTo_StatisticalClassification_, f, this),
    CorrespondenceTable_hasContact_Agent_ (x.CorrespondenceTable_hasContact_Agent_, f, this),
    CorrespondenceTable_isMaintainedBy_Agent_ (x.CorrespondenceTable_isMaintainedBy_Agent_, f, this),
    CorrespondenceTable_has_ConceptMap_ (x.CorrespondenceTable_has_ConceptMap_, f, this)
  {
  }

  CorrespondenceTable::
  CorrespondenceTable (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    effectiveDates_ (this),
    identifier_ (this),
    CorrespondenceTable_hasSource_Level_ (this),
    CorrespondenceTable_hasTarget_Level_ (this),
    CorrespondenceTable_isOwnedBy_Agent_ (this),
    CorrespondenceTable_mapsTo_StatisticalClassification_ (this),
    CorrespondenceTable_hasContact_Agent_ (this),
    CorrespondenceTable_isMaintainedBy_Agent_ (this),
    CorrespondenceTable_has_ConceptMap_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CorrespondenceTable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // effectiveDates
      //
      if (n.name () == "effectiveDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< effectiveDates_type > r (
          effectiveDates_traits::create (i, f, this));

        if (!this->effectiveDates_)
        {
          this->effectiveDates_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // CorrespondenceTable_hasSource_Level
      //
      if (n.name () == "CorrespondenceTable_hasSource_Level" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CorrespondenceTable_hasSource_Level_type > r (
          CorrespondenceTable_hasSource_Level_traits::create (i, f, this));

        if (!this->CorrespondenceTable_hasSource_Level_)
        {
          this->CorrespondenceTable_hasSource_Level_.set (::std::move (r));
          continue;
        }
      }

      // CorrespondenceTable_hasTarget_Level
      //
      if (n.name () == "CorrespondenceTable_hasTarget_Level" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CorrespondenceTable_hasTarget_Level_type > r (
          CorrespondenceTable_hasTarget_Level_traits::create (i, f, this));

        if (!this->CorrespondenceTable_hasTarget_Level_)
        {
          this->CorrespondenceTable_hasTarget_Level_.set (::std::move (r));
          continue;
        }
      }

      // CorrespondenceTable_isOwnedBy_Agent
      //
      if (n.name () == "CorrespondenceTable_isOwnedBy_Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CorrespondenceTable_isOwnedBy_Agent_type > r (
          CorrespondenceTable_isOwnedBy_Agent_traits::create (i, f, this));

        this->CorrespondenceTable_isOwnedBy_Agent_.push_back (::std::move (r));
        continue;
      }

      // CorrespondenceTable_mapsTo_StatisticalClassification
      //
      if (n.name () == "CorrespondenceTable_mapsTo_StatisticalClassification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CorrespondenceTable_mapsTo_StatisticalClassification_type > r (
          CorrespondenceTable_mapsTo_StatisticalClassification_traits::create (i, f, this));

        this->CorrespondenceTable_mapsTo_StatisticalClassification_.push_back (::std::move (r));
        continue;
      }

      // CorrespondenceTable_hasContact_Agent
      //
      if (n.name () == "CorrespondenceTable_hasContact_Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CorrespondenceTable_hasContact_Agent_type > r (
          CorrespondenceTable_hasContact_Agent_traits::create (i, f, this));

        this->CorrespondenceTable_hasContact_Agent_.push_back (::std::move (r));
        continue;
      }

      // CorrespondenceTable_isMaintainedBy_Agent
      //
      if (n.name () == "CorrespondenceTable_isMaintainedBy_Agent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CorrespondenceTable_isMaintainedBy_Agent_type > r (
          CorrespondenceTable_isMaintainedBy_Agent_traits::create (i, f, this));

        if (!this->CorrespondenceTable_isMaintainedBy_Agent_)
        {
          this->CorrespondenceTable_isMaintainedBy_Agent_.set (::std::move (r));
          continue;
        }
      }

      // CorrespondenceTable_has_ConceptMap
      //
      if (n.name () == "CorrespondenceTable_has_ConceptMap" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< CorrespondenceTable_has_ConceptMap_type > r (
          CorrespondenceTable_has_ConceptMap_traits::create (i, f, this));

        this->CorrespondenceTable_has_ConceptMap_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CorrespondenceTable* CorrespondenceTable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CorrespondenceTable (*this, f, c);
  }

  CorrespondenceTable& CorrespondenceTable::
  operator= (const CorrespondenceTable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->effectiveDates_ = x.effectiveDates_;
      this->identifier_ = x.identifier_;
      this->CorrespondenceTable_hasSource_Level_ = x.CorrespondenceTable_hasSource_Level_;
      this->CorrespondenceTable_hasTarget_Level_ = x.CorrespondenceTable_hasTarget_Level_;
      this->CorrespondenceTable_isOwnedBy_Agent_ = x.CorrespondenceTable_isOwnedBy_Agent_;
      this->CorrespondenceTable_mapsTo_StatisticalClassification_ = x.CorrespondenceTable_mapsTo_StatisticalClassification_;
      this->CorrespondenceTable_hasContact_Agent_ = x.CorrespondenceTable_hasContact_Agent_;
      this->CorrespondenceTable_isMaintainedBy_Agent_ = x.CorrespondenceTable_isMaintainedBy_Agent_;
      this->CorrespondenceTable_has_ConceptMap_ = x.CorrespondenceTable_has_ConceptMap_;
    }

    return *this;
  }

  CorrespondenceTable::
  ~CorrespondenceTable ()
  {
  }

  // ProcessingAgent
  //

  ProcessingAgent::
  ProcessingAgent ()
  : ::XMLSchema::Agent (),
    ProcessingAgent_performs_Activity_ (this),
    ProcessingAgent_operatesOn_ProductionEnvironment_ (this)
  {
  }

  ProcessingAgent::
  ProcessingAgent (const ProcessingAgent& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::XMLSchema::Agent (x, f, c),
    ProcessingAgent_performs_Activity_ (x.ProcessingAgent_performs_Activity_, f, this),
    ProcessingAgent_operatesOn_ProductionEnvironment_ (x.ProcessingAgent_operatesOn_ProductionEnvironment_, f, this)
  {
  }

  ProcessingAgent::
  ProcessingAgent (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::XMLSchema::Agent (e, f | ::xml_schema::flags::base, c),
    ProcessingAgent_performs_Activity_ (this),
    ProcessingAgent_operatesOn_ProductionEnvironment_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ProcessingAgent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::Agent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ProcessingAgent_performs_Activity
      //
      if (n.name () == "ProcessingAgent_performs_Activity" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ProcessingAgent_performs_Activity_type > r (
          ProcessingAgent_performs_Activity_traits::create (i, f, this));

        this->ProcessingAgent_performs_Activity_.push_back (::std::move (r));
        continue;
      }

      // ProcessingAgent_operatesOn_ProductionEnvironment
      //
      if (n.name () == "ProcessingAgent_operatesOn_ProductionEnvironment" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ProcessingAgent_operatesOn_ProductionEnvironment_type > r (
          ProcessingAgent_operatesOn_ProductionEnvironment_traits::create (i, f, this));

        this->ProcessingAgent_operatesOn_ProductionEnvironment_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ProcessingAgent* ProcessingAgent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProcessingAgent (*this, f, c);
  }

  ProcessingAgent& ProcessingAgent::
  operator= (const ProcessingAgent& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Agent& > (*this) = x;
      this->ProcessingAgent_performs_Activity_ = x.ProcessingAgent_performs_Activity_;
      this->ProcessingAgent_operatesOn_ProductionEnvironment_ = x.ProcessingAgent_operatesOn_ProductionEnvironment_;
    }

    return *this;
  }

  ProcessingAgent::
  ~ProcessingAgent ()
  {
  }

  // Curator
  //

  Curator::
  Curator ()
  : ::XMLSchema::ProcessingAgent ()
  {
  }

  Curator::
  Curator (const Curator& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::XMLSchema::ProcessingAgent (x, f, c)
  {
  }

  Curator::
  Curator (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::XMLSchema::ProcessingAgent (e, f, c)
  {
  }

  Curator* Curator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Curator (*this, f, c);
  }

  Curator::
  ~Curator ()
  {
  }

  // DataPoint
  //

  DataPoint::
  DataPoint (const DataPoint_isDescribedBy_InstanceVariable_type& DataPoint_isDescribedBy_InstanceVariable)
  : ::xml_schema::type (),
    catalogDetails_ (this),
    identifier_ (this),
    DataPoint_correspondsTo_DataStructureComponent_ (this),
    DataPoint_isDescribedBy_InstanceVariable_ (DataPoint_isDescribedBy_InstanceVariable, this)
  {
  }

  DataPoint::
  DataPoint (::std::unique_ptr< DataPoint_isDescribedBy_InstanceVariable_type > DataPoint_isDescribedBy_InstanceVariable)
  : ::xml_schema::type (),
    catalogDetails_ (this),
    identifier_ (this),
    DataPoint_correspondsTo_DataStructureComponent_ (this),
    DataPoint_isDescribedBy_InstanceVariable_ (std::move (DataPoint_isDescribedBy_InstanceVariable), this)
  {
  }

  DataPoint::
  DataPoint (const DataPoint& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    identifier_ (x.identifier_, f, this),
    DataPoint_correspondsTo_DataStructureComponent_ (x.DataPoint_correspondsTo_DataStructureComponent_, f, this),
    DataPoint_isDescribedBy_InstanceVariable_ (x.DataPoint_isDescribedBy_InstanceVariable_, f, this)
  {
  }

  DataPoint::
  DataPoint (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    identifier_ (this),
    DataPoint_correspondsTo_DataStructureComponent_ (this),
    DataPoint_isDescribedBy_InstanceVariable_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DataPoint::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // DataPoint_correspondsTo_DataStructureComponent
      //
      if (n.name () == "DataPoint_correspondsTo_DataStructureComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataPoint_correspondsTo_DataStructureComponent_type > r (
          DataPoint_correspondsTo_DataStructureComponent_traits::create (i, f, this));

        this->DataPoint_correspondsTo_DataStructureComponent_.push_back (::std::move (r));
        continue;
      }

      // DataPoint_isDescribedBy_InstanceVariable
      //
      if (n.name () == "DataPoint_isDescribedBy_InstanceVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataPoint_isDescribedBy_InstanceVariable_type > r (
          DataPoint_isDescribedBy_InstanceVariable_traits::create (i, f, this));

        if (!DataPoint_isDescribedBy_InstanceVariable_.present ())
        {
          this->DataPoint_isDescribedBy_InstanceVariable_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!DataPoint_isDescribedBy_InstanceVariable_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DataPoint_isDescribedBy_InstanceVariable",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  DataPoint* DataPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataPoint (*this, f, c);
  }

  DataPoint& DataPoint::
  operator= (const DataPoint& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->identifier_ = x.identifier_;
      this->DataPoint_correspondsTo_DataStructureComponent_ = x.DataPoint_correspondsTo_DataStructureComponent_;
      this->DataPoint_isDescribedBy_InstanceVariable_ = x.DataPoint_isDescribedBy_InstanceVariable_;
    }

    return *this;
  }

  DataPoint::
  ~DataPoint ()
  {
  }

  // DataPointPosition
  //

  DataPointPosition::
  DataPointPosition (const value_type& value)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    DataPointPosition_indexes_DataPoint_ (this)
  {
  }

  DataPointPosition::
  DataPointPosition (const DataPointPosition& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    value_ (x.value_, f, this),
    DataPointPosition_indexes_DataPoint_ (x.DataPointPosition_indexes_DataPoint_, f, this)
  {
  }

  DataPointPosition::
  DataPointPosition (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    value_ (this),
    DataPointPosition_indexes_DataPoint_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DataPointPosition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      // DataPointPosition_indexes_DataPoint
      //
      if (n.name () == "DataPointPosition_indexes_DataPoint" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataPointPosition_indexes_DataPoint_type > r (
          DataPointPosition_indexes_DataPoint_traits::create (i, f, this));

        if (!this->DataPointPosition_indexes_DataPoint_)
        {
          this->DataPointPosition_indexes_DataPoint_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  DataPointPosition* DataPointPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataPointPosition (*this, f, c);
  }

  DataPointPosition& DataPointPosition::
  operator= (const DataPointPosition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->value_ = x.value_;
      this->DataPointPosition_indexes_DataPoint_ = x.DataPointPosition_indexes_DataPoint_;
    }

    return *this;
  }

  DataPointPosition::
  ~DataPointPosition ()
  {
  }

  // DataPointRelationship
  //

  DataPointRelationship::
  DataPointRelationship ()
  : ::xml_schema::type (),
    identifier_ (this),
    semantics_ (this),
    DataPointRelationship_hasTarget_DataPoint_ (this),
    DataPointRelationship_hasSource_DataPoint_ (this)
  {
  }

  DataPointRelationship::
  DataPointRelationship (const DataPointRelationship& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    semantics_ (x.semantics_, f, this),
    DataPointRelationship_hasTarget_DataPoint_ (x.DataPointRelationship_hasTarget_DataPoint_, f, this),
    DataPointRelationship_hasSource_DataPoint_ (x.DataPointRelationship_hasSource_DataPoint_, f, this)
  {
  }

  DataPointRelationship::
  DataPointRelationship (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    semantics_ (this),
    DataPointRelationship_hasTarget_DataPoint_ (this),
    DataPointRelationship_hasSource_DataPoint_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DataPointRelationship::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // DataPointRelationship_hasTarget_DataPoint
      //
      if (n.name () == "DataPointRelationship_hasTarget_DataPoint" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataPointRelationship_hasTarget_DataPoint_type > r (
          DataPointRelationship_hasTarget_DataPoint_traits::create (i, f, this));

        this->DataPointRelationship_hasTarget_DataPoint_.push_back (::std::move (r));
        continue;
      }

      // DataPointRelationship_hasSource_DataPoint
      //
      if (n.name () == "DataPointRelationship_hasSource_DataPoint" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataPointRelationship_hasSource_DataPoint_type > r (
          DataPointRelationship_hasSource_DataPoint_traits::create (i, f, this));

        this->DataPointRelationship_hasSource_DataPoint_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DataPointRelationship* DataPointRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataPointRelationship (*this, f, c);
  }

  DataPointRelationship& DataPointRelationship::
  operator= (const DataPointRelationship& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->semantics_ = x.semantics_;
      this->DataPointRelationship_hasTarget_DataPoint_ = x.DataPointRelationship_hasTarget_DataPoint_;
      this->DataPointRelationship_hasSource_DataPoint_ = x.DataPointRelationship_hasSource_DataPoint_;
    }

    return *this;
  }

  DataPointRelationship::
  ~DataPointRelationship ()
  {
  }

  // DataSet
  //

  DataSet::
  DataSet ()
  : ::xml_schema::type (),
    catalogDetails_ (this),
    identifier_ (this),
    DataSet_isStructuredBy_DataStructure_ (this),
    DataSet_has_DataPoint_ (this),
    DataSet_has_Key_ (this)
  {
  }

  DataSet::
  DataSet (const DataSet& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    identifier_ (x.identifier_, f, this),
    DataSet_isStructuredBy_DataStructure_ (x.DataSet_isStructuredBy_DataStructure_, f, this),
    DataSet_has_DataPoint_ (x.DataSet_has_DataPoint_, f, this),
    DataSet_has_Key_ (x.DataSet_has_Key_, f, this)
  {
  }

  DataSet::
  DataSet (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    identifier_ (this),
    DataSet_isStructuredBy_DataStructure_ (this),
    DataSet_has_DataPoint_ (this),
    DataSet_has_Key_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DataSet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // DataSet_isStructuredBy_DataStructure
      //
      if (n.name () == "DataSet_isStructuredBy_DataStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataSet_isStructuredBy_DataStructure_type > r (
          DataSet_isStructuredBy_DataStructure_traits::create (i, f, this));

        this->DataSet_isStructuredBy_DataStructure_.push_back (::std::move (r));
        continue;
      }

      // DataSet_has_DataPoint
      //
      if (n.name () == "DataSet_has_DataPoint" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataSet_has_DataPoint_type > r (
          DataSet_has_DataPoint_traits::create (i, f, this));

        this->DataSet_has_DataPoint_.push_back (::std::move (r));
        continue;
      }

      // DataSet_has_Key
      //
      if (n.name () == "DataSet_has_Key" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataSet_has_Key_type > r (
          DataSet_has_Key_traits::create (i, f, this));

        this->DataSet_has_Key_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DataSet* DataSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataSet (*this, f, c);
  }

  DataSet& DataSet::
  operator= (const DataSet& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->identifier_ = x.identifier_;
      this->DataSet_isStructuredBy_DataStructure_ = x.DataSet_isStructuredBy_DataStructure_;
      this->DataSet_has_DataPoint_ = x.DataSet_has_DataPoint_;
      this->DataSet_has_Key_ = x.DataSet_has_Key_;
    }

    return *this;
  }

  DataSet::
  ~DataSet ()
  {
  }

  // DataStore
  //

  DataStore::
  DataStore (const allowsDuplicates_type& allowsDuplicates)
  : ::xml_schema::type (),
    aboutMissing_ (this),
    allowsDuplicates_ (allowsDuplicates, this),
    catalogDetails_ (this),
    characterSet_ (this),
    dataStoreType_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    recordCount_ (this),
    DataStore_isDefinedBy_Concept_ (this),
    DataStore_has_LogicalRecordPosition_ (this),
    DataStore_has_LogicalRecord_ (this),
    DataStore_has_RecordRelation_ (this)
  {
  }

  DataStore::
  DataStore (const DataStore& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    aboutMissing_ (x.aboutMissing_, f, this),
    allowsDuplicates_ (x.allowsDuplicates_, f, this),
    catalogDetails_ (x.catalogDetails_, f, this),
    characterSet_ (x.characterSet_, f, this),
    dataStoreType_ (x.dataStoreType_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    recordCount_ (x.recordCount_, f, this),
    DataStore_isDefinedBy_Concept_ (x.DataStore_isDefinedBy_Concept_, f, this),
    DataStore_has_LogicalRecordPosition_ (x.DataStore_has_LogicalRecordPosition_, f, this),
    DataStore_has_LogicalRecord_ (x.DataStore_has_LogicalRecord_, f, this),
    DataStore_has_RecordRelation_ (x.DataStore_has_RecordRelation_, f, this)
  {
  }

  DataStore::
  DataStore (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    aboutMissing_ (this),
    allowsDuplicates_ (this),
    catalogDetails_ (this),
    characterSet_ (this),
    dataStoreType_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    recordCount_ (this),
    DataStore_isDefinedBy_Concept_ (this),
    DataStore_has_LogicalRecordPosition_ (this),
    DataStore_has_LogicalRecord_ (this),
    DataStore_has_RecordRelation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DataStore::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // aboutMissing
      //
      if (n.name () == "aboutMissing" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< aboutMissing_type > r (
          aboutMissing_traits::create (i, f, this));

        if (!this->aboutMissing_)
        {
          this->aboutMissing_.set (::std::move (r));
          continue;
        }
      }

      // allowsDuplicates
      //
      if (n.name () == "allowsDuplicates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!allowsDuplicates_.present ())
        {
          this->allowsDuplicates_.set (allowsDuplicates_traits::create (i, f, this));
          continue;
        }
      }

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // characterSet
      //
      if (n.name () == "characterSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< characterSet_type > r (
          characterSet_traits::create (i, f, this));

        if (!this->characterSet_)
        {
          this->characterSet_.set (::std::move (r));
          continue;
        }
      }

      // dataStoreType
      //
      if (n.name () == "dataStoreType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< dataStoreType_type > r (
          dataStoreType_traits::create (i, f, this));

        if (!this->dataStoreType_)
        {
          this->dataStoreType_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // recordCount
      //
      if (n.name () == "recordCount" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->recordCount_)
        {
          this->recordCount_.set (recordCount_traits::create (i, f, this));
          continue;
        }
      }

      // DataStore_isDefinedBy_Concept
      //
      if (n.name () == "DataStore_isDefinedBy_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStore_isDefinedBy_Concept_type > r (
          DataStore_isDefinedBy_Concept_traits::create (i, f, this));

        this->DataStore_isDefinedBy_Concept_.push_back (::std::move (r));
        continue;
      }

      // DataStore_has_LogicalRecordPosition
      //
      if (n.name () == "DataStore_has_LogicalRecordPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStore_has_LogicalRecordPosition_type > r (
          DataStore_has_LogicalRecordPosition_traits::create (i, f, this));

        this->DataStore_has_LogicalRecordPosition_.push_back (::std::move (r));
        continue;
      }

      // DataStore_has_LogicalRecord
      //
      if (n.name () == "DataStore_has_LogicalRecord" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStore_has_LogicalRecord_type > r (
          DataStore_has_LogicalRecord_traits::create (i, f, this));

        this->DataStore_has_LogicalRecord_.push_back (::std::move (r));
        continue;
      }

      // DataStore_has_RecordRelation
      //
      if (n.name () == "DataStore_has_RecordRelation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStore_has_RecordRelation_type > r (
          DataStore_has_RecordRelation_traits::create (i, f, this));

        if (!this->DataStore_has_RecordRelation_)
        {
          this->DataStore_has_RecordRelation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!allowsDuplicates_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "allowsDuplicates",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  DataStore* DataStore::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataStore (*this, f, c);
  }

  DataStore& DataStore::
  operator= (const DataStore& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->aboutMissing_ = x.aboutMissing_;
      this->allowsDuplicates_ = x.allowsDuplicates_;
      this->catalogDetails_ = x.catalogDetails_;
      this->characterSet_ = x.characterSet_;
      this->dataStoreType_ = x.dataStoreType_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->recordCount_ = x.recordCount_;
      this->DataStore_isDefinedBy_Concept_ = x.DataStore_isDefinedBy_Concept_;
      this->DataStore_has_LogicalRecordPosition_ = x.DataStore_has_LogicalRecordPosition_;
      this->DataStore_has_LogicalRecord_ = x.DataStore_has_LogicalRecord_;
      this->DataStore_has_RecordRelation_ = x.DataStore_has_RecordRelation_;
    }

    return *this;
  }

  DataStore::
  ~DataStore ()
  {
  }

  // DataStructure
  //

  DataStructure::
  DataStructure ()
  : ::XMLSchema::DataStructureComponent (),
    DataStructure_has_ForeignKey_ (this),
    DataStructure_has_DataStructureComponent_ (this),
    DataStructure_has_ComponentPosition_ (this),
    DataStructure_has_PrimaryKey_ (this)
  {
  }

  DataStructure::
  DataStructure (const DataStructure& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (x, f, c),
    DataStructure_has_ForeignKey_ (x.DataStructure_has_ForeignKey_, f, this),
    DataStructure_has_DataStructureComponent_ (x.DataStructure_has_DataStructureComponent_, f, this),
    DataStructure_has_ComponentPosition_ (x.DataStructure_has_ComponentPosition_, f, this),
    DataStructure_has_PrimaryKey_ (x.DataStructure_has_PrimaryKey_, f, this)
  {
  }

  DataStructure::
  DataStructure (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (e, f | ::xml_schema::flags::base, c),
    DataStructure_has_ForeignKey_ (this),
    DataStructure_has_DataStructureComponent_ (this),
    DataStructure_has_ComponentPosition_ (this),
    DataStructure_has_PrimaryKey_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DataStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::DataStructureComponent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DataStructure_has_ForeignKey
      //
      if (n.name () == "DataStructure_has_ForeignKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStructure_has_ForeignKey_type > r (
          DataStructure_has_ForeignKey_traits::create (i, f, this));

        this->DataStructure_has_ForeignKey_.push_back (::std::move (r));
        continue;
      }

      // DataStructure_has_DataStructureComponent
      //
      if (n.name () == "DataStructure_has_DataStructureComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStructure_has_DataStructureComponent_type > r (
          DataStructure_has_DataStructureComponent_traits::create (i, f, this));

        this->DataStructure_has_DataStructureComponent_.push_back (::std::move (r));
        continue;
      }

      // DataStructure_has_ComponentPosition
      //
      if (n.name () == "DataStructure_has_ComponentPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStructure_has_ComponentPosition_type > r (
          DataStructure_has_ComponentPosition_traits::create (i, f, this));

        this->DataStructure_has_ComponentPosition_.push_back (::std::move (r));
        continue;
      }

      // DataStructure_has_PrimaryKey
      //
      if (n.name () == "DataStructure_has_PrimaryKey" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DataStructure_has_PrimaryKey_type > r (
          DataStructure_has_PrimaryKey_traits::create (i, f, this));

        if (!this->DataStructure_has_PrimaryKey_)
        {
          this->DataStructure_has_PrimaryKey_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  DataStructure* DataStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataStructure (*this, f, c);
  }

  DataStructure& DataStructure::
  operator= (const DataStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::DataStructureComponent& > (*this) = x;
      this->DataStructure_has_ForeignKey_ = x.DataStructure_has_ForeignKey_;
      this->DataStructure_has_DataStructureComponent_ = x.DataStructure_has_DataStructureComponent_;
      this->DataStructure_has_ComponentPosition_ = x.DataStructure_has_ComponentPosition_;
      this->DataStructure_has_PrimaryKey_ = x.DataStructure_has_PrimaryKey_;
    }

    return *this;
  }

  DataStructure::
  ~DataStructure ()
  {
  }

  // Datum
  //

  Datum::
  Datum (const Datum_denotes_ConceptualValue_type& Datum_denotes_ConceptualValue)
  : ::xml_schema::type (),
    catalogDetails_ (this),
    identifier_ (this),
    Datum_uses_Notation_ (this),
    Datum_denotes_ConceptualValue_ (Datum_denotes_ConceptualValue, this),
    Datum_uses_InstanceValue_ (this),
    Datum_isBoundedBy_InstanceVariable_ (this)
  {
  }

  Datum::
  Datum (::std::unique_ptr< Datum_denotes_ConceptualValue_type > Datum_denotes_ConceptualValue)
  : ::xml_schema::type (),
    catalogDetails_ (this),
    identifier_ (this),
    Datum_uses_Notation_ (this),
    Datum_denotes_ConceptualValue_ (std::move (Datum_denotes_ConceptualValue), this),
    Datum_uses_InstanceValue_ (this),
    Datum_isBoundedBy_InstanceVariable_ (this)
  {
  }

  Datum::
  Datum (const Datum& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    identifier_ (x.identifier_, f, this),
    Datum_uses_Notation_ (x.Datum_uses_Notation_, f, this),
    Datum_denotes_ConceptualValue_ (x.Datum_denotes_ConceptualValue_, f, this),
    Datum_uses_InstanceValue_ (x.Datum_uses_InstanceValue_, f, this),
    Datum_isBoundedBy_InstanceVariable_ (x.Datum_isBoundedBy_InstanceVariable_, f, this)
  {
  }

  Datum::
  Datum (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    identifier_ (this),
    Datum_uses_Notation_ (this),
    Datum_denotes_ConceptualValue_ (this),
    Datum_uses_InstanceValue_ (this),
    Datum_isBoundedBy_InstanceVariable_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Datum::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // Datum_uses_Notation
      //
      if (n.name () == "Datum_uses_Notation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Datum_uses_Notation_type > r (
          Datum_uses_Notation_traits::create (i, f, this));

        if (!this->Datum_uses_Notation_)
        {
          this->Datum_uses_Notation_.set (::std::move (r));
          continue;
        }
      }

      // Datum_denotes_ConceptualValue
      //
      if (n.name () == "Datum_denotes_ConceptualValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Datum_denotes_ConceptualValue_type > r (
          Datum_denotes_ConceptualValue_traits::create (i, f, this));

        if (!Datum_denotes_ConceptualValue_.present ())
        {
          this->Datum_denotes_ConceptualValue_.set (::std::move (r));
          continue;
        }
      }

      // Datum_uses_InstanceValue
      //
      if (n.name () == "Datum_uses_InstanceValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Datum_uses_InstanceValue_type > r (
          Datum_uses_InstanceValue_traits::create (i, f, this));

        this->Datum_uses_InstanceValue_.push_back (::std::move (r));
        continue;
      }

      // Datum_isBoundedBy_InstanceVariable
      //
      if (n.name () == "Datum_isBoundedBy_InstanceVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Datum_isBoundedBy_InstanceVariable_type > r (
          Datum_isBoundedBy_InstanceVariable_traits::create (i, f, this));

        this->Datum_isBoundedBy_InstanceVariable_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!Datum_denotes_ConceptualValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Datum_denotes_ConceptualValue",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  Datum* Datum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Datum (*this, f, c);
  }

  Datum& Datum::
  operator= (const Datum& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->identifier_ = x.identifier_;
      this->Datum_uses_Notation_ = x.Datum_uses_Notation_;
      this->Datum_denotes_ConceptualValue_ = x.Datum_denotes_ConceptualValue_;
      this->Datum_uses_InstanceValue_ = x.Datum_uses_InstanceValue_;
      this->Datum_isBoundedBy_InstanceVariable_ = x.Datum_isBoundedBy_InstanceVariable_;
    }

    return *this;
  }

  Datum::
  ~Datum ()
  {
  }

  // InstanceValue
  //

  InstanceValue::
  InstanceValue (const InstanceValue_hasValueFrom_ValueDomain_type& InstanceValue_hasValueFrom_ValueDomain)
  : ::xml_schema::type (),
    content_ (this),
    identifier_ (this),
    whiteSpace_ (this),
    InstanceValue_hasValueFrom_ValueDomain_ (InstanceValue_hasValueFrom_ValueDomain, this),
    InstanceValue_isStoredIn_DataPoint_ (this),
    InstanceValue_represents_ConceptualValue_ (this)
  {
  }

  InstanceValue::
  InstanceValue (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type > InstanceValue_hasValueFrom_ValueDomain)
  : ::xml_schema::type (),
    content_ (this),
    identifier_ (this),
    whiteSpace_ (this),
    InstanceValue_hasValueFrom_ValueDomain_ (std::move (InstanceValue_hasValueFrom_ValueDomain), this),
    InstanceValue_isStoredIn_DataPoint_ (this),
    InstanceValue_represents_ConceptualValue_ (this)
  {
  }

  InstanceValue::
  InstanceValue (const InstanceValue& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_ (x.content_, f, this),
    identifier_ (x.identifier_, f, this),
    whiteSpace_ (x.whiteSpace_, f, this),
    InstanceValue_hasValueFrom_ValueDomain_ (x.InstanceValue_hasValueFrom_ValueDomain_, f, this),
    InstanceValue_isStoredIn_DataPoint_ (x.InstanceValue_isStoredIn_DataPoint_, f, this),
    InstanceValue_represents_ConceptualValue_ (x.InstanceValue_represents_ConceptualValue_, f, this)
  {
  }

  InstanceValue::
  InstanceValue (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    content_ (this),
    identifier_ (this),
    whiteSpace_ (this),
    InstanceValue_hasValueFrom_ValueDomain_ (this),
    InstanceValue_isStoredIn_DataPoint_ (this),
    InstanceValue_represents_ConceptualValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InstanceValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // content
      //
      if (n.name () == "content" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< content_type > r (
          content_traits::create (i, f, this));

        if (!this->content_)
        {
          this->content_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // whiteSpace
      //
      if (n.name () == "whiteSpace" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< whiteSpace_type > r (
          whiteSpace_traits::create (i, f, this));

        if (!this->whiteSpace_)
        {
          this->whiteSpace_.set (::std::move (r));
          continue;
        }
      }

      // InstanceValue_hasValueFrom_ValueDomain
      //
      if (n.name () == "InstanceValue_hasValueFrom_ValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type > r (
          InstanceValue_hasValueFrom_ValueDomain_traits::create (i, f, this));

        if (!InstanceValue_hasValueFrom_ValueDomain_.present ())
        {
          this->InstanceValue_hasValueFrom_ValueDomain_.set (::std::move (r));
          continue;
        }
      }

      // InstanceValue_isStoredIn_DataPoint
      //
      if (n.name () == "InstanceValue_isStoredIn_DataPoint" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceValue_isStoredIn_DataPoint_type > r (
          InstanceValue_isStoredIn_DataPoint_traits::create (i, f, this));

        if (!this->InstanceValue_isStoredIn_DataPoint_)
        {
          this->InstanceValue_isStoredIn_DataPoint_.set (::std::move (r));
          continue;
        }
      }

      // InstanceValue_represents_ConceptualValue
      //
      if (n.name () == "InstanceValue_represents_ConceptualValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceValue_represents_ConceptualValue_type > r (
          InstanceValue_represents_ConceptualValue_traits::create (i, f, this));

        if (!this->InstanceValue_represents_ConceptualValue_)
        {
          this->InstanceValue_represents_ConceptualValue_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!InstanceValue_hasValueFrom_ValueDomain_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "InstanceValue_hasValueFrom_ValueDomain",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  InstanceValue* InstanceValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstanceValue (*this, f, c);
  }

  InstanceValue& InstanceValue::
  operator= (const InstanceValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_ = x.content_;
      this->identifier_ = x.identifier_;
      this->whiteSpace_ = x.whiteSpace_;
      this->InstanceValue_hasValueFrom_ValueDomain_ = x.InstanceValue_hasValueFrom_ValueDomain_;
      this->InstanceValue_isStoredIn_DataPoint_ = x.InstanceValue_isStoredIn_DataPoint_;
      this->InstanceValue_represents_ConceptualValue_ = x.InstanceValue_represents_ConceptualValue_;
    }

    return *this;
  }

  InstanceValue::
  ~InstanceValue ()
  {
  }

  // KeyMember
  //

  KeyMember::
  KeyMember (const InstanceValue_hasValueFrom_ValueDomain_type& InstanceValue_hasValueFrom_ValueDomain)
  : ::XMLSchema::InstanceValue (InstanceValue_hasValueFrom_ValueDomain),
    KeyMember_isBasedOn_DataStructureComponent_ (this)
  {
  }

  KeyMember::
  KeyMember (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type > InstanceValue_hasValueFrom_ValueDomain)
  : ::XMLSchema::InstanceValue (std::move (InstanceValue_hasValueFrom_ValueDomain)),
    KeyMember_isBasedOn_DataStructureComponent_ (this)
  {
  }

  KeyMember::
  KeyMember (const KeyMember& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::XMLSchema::InstanceValue (x, f, c),
    KeyMember_isBasedOn_DataStructureComponent_ (x.KeyMember_isBasedOn_DataStructureComponent_, f, this)
  {
  }

  KeyMember::
  KeyMember (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::XMLSchema::InstanceValue (e, f | ::xml_schema::flags::base, c),
    KeyMember_isBasedOn_DataStructureComponent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void KeyMember::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::InstanceValue::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // KeyMember_isBasedOn_DataStructureComponent
      //
      if (n.name () == "KeyMember_isBasedOn_DataStructureComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyMember_isBasedOn_DataStructureComponent_type > r (
          KeyMember_isBasedOn_DataStructureComponent_traits::create (i, f, this));

        this->KeyMember_isBasedOn_DataStructureComponent_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  KeyMember* KeyMember::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class KeyMember (*this, f, c);
  }

  KeyMember& KeyMember::
  operator= (const KeyMember& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::InstanceValue& > (*this) = x;
      this->KeyMember_isBasedOn_DataStructureComponent_ = x.KeyMember_isBasedOn_DataStructureComponent_;
    }

    return *this;
  }

  KeyMember::
  ~KeyMember ()
  {
  }

  // Descriptor
  //

  Descriptor::
  Descriptor (const InstanceValue_hasValueFrom_ValueDomain_type& InstanceValue_hasValueFrom_ValueDomain,
              const Descriptor_identifies_ReferenceVariable_type& Descriptor_identifies_ReferenceVariable,
              const Descriptor_hasValueFrom_DescriptorValueDomain_type& Descriptor_hasValueFrom_DescriptorValueDomain)
  : ::XMLSchema::KeyMember (InstanceValue_hasValueFrom_ValueDomain),
    Descriptor_refersTo_ReferenceValue_ (this),
    Descriptor_identifies_ReferenceVariable_ (Descriptor_identifies_ReferenceVariable, this),
    Descriptor_hasValueFrom_DescriptorValueDomain_ (Descriptor_hasValueFrom_DescriptorValueDomain, this)
  {
  }

  Descriptor::
  Descriptor (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type > InstanceValue_hasValueFrom_ValueDomain,
              ::std::unique_ptr< Descriptor_identifies_ReferenceVariable_type > Descriptor_identifies_ReferenceVariable,
              ::std::unique_ptr< Descriptor_hasValueFrom_DescriptorValueDomain_type > Descriptor_hasValueFrom_DescriptorValueDomain)
  : ::XMLSchema::KeyMember (std::move (InstanceValue_hasValueFrom_ValueDomain)),
    Descriptor_refersTo_ReferenceValue_ (this),
    Descriptor_identifies_ReferenceVariable_ (std::move (Descriptor_identifies_ReferenceVariable), this),
    Descriptor_hasValueFrom_DescriptorValueDomain_ (std::move (Descriptor_hasValueFrom_DescriptorValueDomain), this)
  {
  }

  Descriptor::
  Descriptor (const Descriptor& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::XMLSchema::KeyMember (x, f, c),
    Descriptor_refersTo_ReferenceValue_ (x.Descriptor_refersTo_ReferenceValue_, f, this),
    Descriptor_identifies_ReferenceVariable_ (x.Descriptor_identifies_ReferenceVariable_, f, this),
    Descriptor_hasValueFrom_DescriptorValueDomain_ (x.Descriptor_hasValueFrom_DescriptorValueDomain_, f, this)
  {
  }

  Descriptor::
  Descriptor (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::XMLSchema::KeyMember (e, f | ::xml_schema::flags::base, c),
    Descriptor_refersTo_ReferenceValue_ (this),
    Descriptor_identifies_ReferenceVariable_ (this),
    Descriptor_hasValueFrom_DescriptorValueDomain_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Descriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::KeyMember::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Descriptor_refersTo_ReferenceValue
      //
      if (n.name () == "Descriptor_refersTo_ReferenceValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Descriptor_refersTo_ReferenceValue_type > r (
          Descriptor_refersTo_ReferenceValue_traits::create (i, f, this));

        this->Descriptor_refersTo_ReferenceValue_.push_back (::std::move (r));
        continue;
      }

      // Descriptor_identifies_ReferenceVariable
      //
      if (n.name () == "Descriptor_identifies_ReferenceVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Descriptor_identifies_ReferenceVariable_type > r (
          Descriptor_identifies_ReferenceVariable_traits::create (i, f, this));

        if (!Descriptor_identifies_ReferenceVariable_.present ())
        {
          this->Descriptor_identifies_ReferenceVariable_.set (::std::move (r));
          continue;
        }
      }

      // Descriptor_hasValueFrom_DescriptorValueDomain
      //
      if (n.name () == "Descriptor_hasValueFrom_DescriptorValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Descriptor_hasValueFrom_DescriptorValueDomain_type > r (
          Descriptor_hasValueFrom_DescriptorValueDomain_traits::create (i, f, this));

        if (!Descriptor_hasValueFrom_DescriptorValueDomain_.present ())
        {
          this->Descriptor_hasValueFrom_DescriptorValueDomain_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Descriptor_identifies_ReferenceVariable_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Descriptor_identifies_ReferenceVariable",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!Descriptor_hasValueFrom_DescriptorValueDomain_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Descriptor_hasValueFrom_DescriptorValueDomain",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  Descriptor* Descriptor::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Descriptor (*this, f, c);
  }

  Descriptor& Descriptor::
  operator= (const Descriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::KeyMember& > (*this) = x;
      this->Descriptor_refersTo_ReferenceValue_ = x.Descriptor_refersTo_ReferenceValue_;
      this->Descriptor_identifies_ReferenceVariable_ = x.Descriptor_identifies_ReferenceVariable_;
      this->Descriptor_hasValueFrom_DescriptorValueDomain_ = x.Descriptor_hasValueFrom_DescriptorValueDomain_;
    }

    return *this;
  }

  Descriptor::
  ~Descriptor ()
  {
  }

  // ValueDomain
  //

  ValueDomain::
  ValueDomain ()
  : ::xml_schema::type (),
    catalogDetails_ (this),
    displayLabel_ (this),
    identifier_ (this),
    recommendedDataType_ (this)
  {
  }

  ValueDomain::
  ValueDomain (const ValueDomain& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    displayLabel_ (x.displayLabel_, f, this),
    identifier_ (x.identifier_, f, this),
    recommendedDataType_ (x.recommendedDataType_, f, this)
  {
  }

  ValueDomain::
  ValueDomain (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    displayLabel_ (this),
    identifier_ (this),
    recommendedDataType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ValueDomain::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // displayLabel
      //
      if (n.name () == "displayLabel" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< displayLabel_type > r (
          displayLabel_traits::create (i, f, this));

        this->displayLabel_.push_back (::std::move (r));
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // recommendedDataType
      //
      if (n.name () == "recommendedDataType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< recommendedDataType_type > r (
          recommendedDataType_traits::create (i, f, this));

        this->recommendedDataType_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ValueDomain* ValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ValueDomain (*this, f, c);
  }

  ValueDomain& ValueDomain::
  operator= (const ValueDomain& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->displayLabel_ = x.displayLabel_;
      this->identifier_ = x.identifier_;
      this->recommendedDataType_ = x.recommendedDataType_;
    }

    return *this;
  }

  ValueDomain::
  ~ValueDomain ()
  {
  }

  // SubstantiveValueDomain
  //

  SubstantiveValueDomain::
  SubstantiveValueDomain ()
  : ::XMLSchema::ValueDomain (),
    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_ (this),
    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_ (this),
    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_ (this)
  {
  }

  SubstantiveValueDomain::
  SubstantiveValueDomain (const SubstantiveValueDomain& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::XMLSchema::ValueDomain (x, f, c),
    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_ (x.SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_, f, this),
    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_ (x.SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_, f, this),
    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_ (x.SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_, f, this)
  {
  }

  SubstantiveValueDomain::
  SubstantiveValueDomain (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::XMLSchema::ValueDomain (e, f | ::xml_schema::flags::base, c),
    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_ (this),
    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_ (this),
    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SubstantiveValueDomain::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::ValueDomain::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SubstantiveValueDomain_takesValuesFrom_EnumerationDomain
      //
      if (n.name () == "SubstantiveValueDomain_takesValuesFrom_EnumerationDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_type > r (
          SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_traits::create (i, f, this));

        if (!this->SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_)
        {
          this->SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_.set (::std::move (r));
          continue;
        }
      }

      // SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription
      //
      if (n.name () == "SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_type > r (
          SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_traits::create (i, f, this));

        if (!this->SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_)
        {
          this->SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_.set (::std::move (r));
          continue;
        }
      }

      // SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain
      //
      if (n.name () == "SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_type > r (
          SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_traits::create (i, f, this));

        if (!this->SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_)
        {
          this->SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SubstantiveValueDomain* SubstantiveValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SubstantiveValueDomain (*this, f, c);
  }

  SubstantiveValueDomain& SubstantiveValueDomain::
  operator= (const SubstantiveValueDomain& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::ValueDomain& > (*this) = x;
      this->SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_ = x.SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_;
      this->SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_ = x.SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_;
      this->SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_ = x.SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_;
    }

    return *this;
  }

  SubstantiveValueDomain::
  ~SubstantiveValueDomain ()
  {
  }

  // DescriptorValueDomain
  //

  DescriptorValueDomain::
  DescriptorValueDomain ()
  : ::XMLSchema::SubstantiveValueDomain ()
  {
  }

  DescriptorValueDomain::
  DescriptorValueDomain (const DescriptorValueDomain& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::XMLSchema::SubstantiveValueDomain (x, f, c)
  {
  }

  DescriptorValueDomain::
  DescriptorValueDomain (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::XMLSchema::SubstantiveValueDomain (e, f, c)
  {
  }

  DescriptorValueDomain* DescriptorValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DescriptorValueDomain (*this, f, c);
  }

  DescriptorValueDomain::
  ~DescriptorValueDomain ()
  {
  }

  // RepresentedVariable
  //

  RepresentedVariable::
  RepresentedVariable ()
  : ::XMLSchema::ConceptualVariable (),
    describedUnitOfMeasure_ (this),
    hasIntendedDataType_ (this),
    simpleUnitOfMeasure_ (this),
    RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_ (this),
    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_ (this)
  {
  }

  RepresentedVariable::
  RepresentedVariable (const RepresentedVariable& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::ConceptualVariable (x, f, c),
    describedUnitOfMeasure_ (x.describedUnitOfMeasure_, f, this),
    hasIntendedDataType_ (x.hasIntendedDataType_, f, this),
    simpleUnitOfMeasure_ (x.simpleUnitOfMeasure_, f, this),
    RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_ (x.RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_, f, this),
    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_ (x.RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_, f, this)
  {
  }

  RepresentedVariable::
  RepresentedVariable (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::ConceptualVariable (e, f | ::xml_schema::flags::base, c),
    describedUnitOfMeasure_ (this),
    hasIntendedDataType_ (this),
    simpleUnitOfMeasure_ (this),
    RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_ (this),
    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RepresentedVariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::ConceptualVariable::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // describedUnitOfMeasure
      //
      if (n.name () == "describedUnitOfMeasure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< describedUnitOfMeasure_type > r (
          describedUnitOfMeasure_traits::create (i, f, this));

        if (!this->describedUnitOfMeasure_)
        {
          this->describedUnitOfMeasure_.set (::std::move (r));
          continue;
        }
      }

      // hasIntendedDataType
      //
      if (n.name () == "hasIntendedDataType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< hasIntendedDataType_type > r (
          hasIntendedDataType_traits::create (i, f, this));

        if (!this->hasIntendedDataType_)
        {
          this->hasIntendedDataType_.set (::std::move (r));
          continue;
        }
      }

      // simpleUnitOfMeasure
      //
      if (n.name () == "simpleUnitOfMeasure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< simpleUnitOfMeasure_type > r (
          simpleUnitOfMeasure_traits::create (i, f, this));

        if (!this->simpleUnitOfMeasure_)
        {
          this->simpleUnitOfMeasure_.set (::std::move (r));
          continue;
        }
      }

      // RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain
      //
      if (n.name () == "RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_type > r (
          RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_traits::create (i, f, this));

        this->RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_.push_back (::std::move (r));
        continue;
      }

      // RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain
      //
      if (n.name () == "RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_type > r (
          RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_traits::create (i, f, this));

        if (!this->RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_)
        {
          this->RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  RepresentedVariable* RepresentedVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RepresentedVariable (*this, f, c);
  }

  RepresentedVariable& RepresentedVariable::
  operator= (const RepresentedVariable& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::ConceptualVariable& > (*this) = x;
      this->describedUnitOfMeasure_ = x.describedUnitOfMeasure_;
      this->hasIntendedDataType_ = x.hasIntendedDataType_;
      this->simpleUnitOfMeasure_ = x.simpleUnitOfMeasure_;
      this->RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_ = x.RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_;
      this->RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_ = x.RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_;
    }

    return *this;
  }

  RepresentedVariable::
  ~RepresentedVariable ()
  {
  }

  // DescriptorVariable
  //

  DescriptorVariable::
  DescriptorVariable ()
  : ::XMLSchema::RepresentedVariable (),
    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_ (this)
  {
  }

  DescriptorVariable::
  DescriptorVariable (const DescriptorVariable& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::RepresentedVariable (x, f, c),
    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_ (x.DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_, f, this)
  {
  }

  DescriptorVariable::
  DescriptorVariable (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::RepresentedVariable (e, f | ::xml_schema::flags::base, c),
    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DescriptorVariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::RepresentedVariable::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain
      //
      if (n.name () == "DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_type > r (
          DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_traits::create (i, f, this));

        if (!this->DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_)
        {
          this->DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  DescriptorVariable* DescriptorVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DescriptorVariable (*this, f, c);
  }

  DescriptorVariable& DescriptorVariable::
  operator= (const DescriptorVariable& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::RepresentedVariable& > (*this) = x;
      this->DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_ = x.DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_;
    }

    return *this;
  }

  DescriptorVariable::
  ~DescriptorVariable ()
  {
  }

  // DimensionComponent
  //

  DimensionComponent::
  DimensionComponent ()
  : ::XMLSchema::DataStructureComponent (),
    categoricalAdditivity_ (this),
    DimensionComponent_isStructuredBy_ValueDomain_ (this)
  {
  }

  DimensionComponent::
  DimensionComponent (const DimensionComponent& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (x, f, c),
    categoricalAdditivity_ (x.categoricalAdditivity_, f, this),
    DimensionComponent_isStructuredBy_ValueDomain_ (x.DimensionComponent_isStructuredBy_ValueDomain_, f, this)
  {
  }

  DimensionComponent::
  DimensionComponent (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (e, f | ::xml_schema::flags::base, c),
    categoricalAdditivity_ (this),
    DimensionComponent_isStructuredBy_ValueDomain_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DimensionComponent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::DataStructureComponent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // categoricalAdditivity
      //
      if (n.name () == "categoricalAdditivity" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->categoricalAdditivity_)
        {
          this->categoricalAdditivity_.set (categoricalAdditivity_traits::create (i, f, this));
          continue;
        }
      }

      // DimensionComponent_isStructuredBy_ValueDomain
      //
      if (n.name () == "DimensionComponent_isStructuredBy_ValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionComponent_isStructuredBy_ValueDomain_type > r (
          DimensionComponent_isStructuredBy_ValueDomain_traits::create (i, f, this));

        if (!this->DimensionComponent_isStructuredBy_ValueDomain_)
        {
          this->DimensionComponent_isStructuredBy_ValueDomain_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  DimensionComponent* DimensionComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionComponent (*this, f, c);
  }

  DimensionComponent& DimensionComponent::
  operator= (const DimensionComponent& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::DataStructureComponent& > (*this) = x;
      this->categoricalAdditivity_ = x.categoricalAdditivity_;
      this->DimensionComponent_isStructuredBy_ValueDomain_ = x.DimensionComponent_isStructuredBy_ValueDomain_;
    }

    return *this;
  }

  DimensionComponent::
  ~DimensionComponent ()
  {
  }

  // DimensionGroup
  //

  DimensionGroup::
  DimensionGroup ()
  : ::xml_schema::type (),
    identifier_ (this),
    name_ (this),
    DimensionGroup_has_DimensionComponent_ (this)
  {
  }

  DimensionGroup::
  DimensionGroup (const DimensionGroup& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    DimensionGroup_has_DimensionComponent_ (x.DimensionGroup_has_DimensionComponent_, f, this)
  {
  }

  DimensionGroup::
  DimensionGroup (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    name_ (this),
    DimensionGroup_has_DimensionComponent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DimensionGroup::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // DimensionGroup_has_DimensionComponent
      //
      if (n.name () == "DimensionGroup_has_DimensionComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionGroup_has_DimensionComponent_type > r (
          DimensionGroup_has_DimensionComponent_traits::create (i, f, this));

        this->DimensionGroup_has_DimensionComponent_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DimensionGroup* DimensionGroup::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionGroup (*this, f, c);
  }

  DimensionGroup& DimensionGroup::
  operator= (const DimensionGroup& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->DimensionGroup_has_DimensionComponent_ = x.DimensionGroup_has_DimensionComponent_;
    }

    return *this;
  }

  DimensionGroup::
  ~DimensionGroup ()
  {
  }

  // DimensionalDataSet
  //

  DimensionalDataSet::
  DimensionalDataSet ()
  : ::XMLSchema::DataSet (),
    name_ (this),
    DimensionalDataSet_represents_ScopedMeasure_ (this)
  {
  }

  DimensionalDataSet::
  DimensionalDataSet (const DimensionalDataSet& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::DataSet (x, f, c),
    name_ (x.name_, f, this),
    DimensionalDataSet_represents_ScopedMeasure_ (x.DimensionalDataSet_represents_ScopedMeasure_, f, this)
  {
  }

  DimensionalDataSet::
  DimensionalDataSet (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::DataSet (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    DimensionalDataSet_represents_ScopedMeasure_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DimensionalDataSet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::DataSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // DimensionalDataSet_represents_ScopedMeasure
      //
      if (n.name () == "DimensionalDataSet_represents_ScopedMeasure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalDataSet_represents_ScopedMeasure_type > r (
          DimensionalDataSet_represents_ScopedMeasure_traits::create (i, f, this));

        this->DimensionalDataSet_represents_ScopedMeasure_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DimensionalDataSet* DimensionalDataSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionalDataSet (*this, f, c);
  }

  DimensionalDataSet& DimensionalDataSet::
  operator= (const DimensionalDataSet& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::DataSet& > (*this) = x;
      this->name_ = x.name_;
      this->DimensionalDataSet_represents_ScopedMeasure_ = x.DimensionalDataSet_represents_ScopedMeasure_;
    }

    return *this;
  }

  DimensionalDataSet::
  ~DimensionalDataSet ()
  {
  }

  // DimensionalDataStructure
  //

  DimensionalDataStructure::
  DimensionalDataStructure ()
  : ::XMLSchema::DataStructure (),
    DimensionalDataStructure_uses_DimensionGroup_ (this)
  {
  }

  DimensionalDataStructure::
  DimensionalDataStructure (const DimensionalDataStructure& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::DataStructure (x, f, c),
    DimensionalDataStructure_uses_DimensionGroup_ (x.DimensionalDataStructure_uses_DimensionGroup_, f, this)
  {
  }

  DimensionalDataStructure::
  DimensionalDataStructure (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::DataStructure (e, f | ::xml_schema::flags::base, c),
    DimensionalDataStructure_uses_DimensionGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DimensionalDataStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::DataStructure::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DimensionalDataStructure_uses_DimensionGroup
      //
      if (n.name () == "DimensionalDataStructure_uses_DimensionGroup" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalDataStructure_uses_DimensionGroup_type > r (
          DimensionalDataStructure_uses_DimensionGroup_traits::create (i, f, this));

        this->DimensionalDataStructure_uses_DimensionGroup_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DimensionalDataStructure* DimensionalDataStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionalDataStructure (*this, f, c);
  }

  DimensionalDataStructure& DimensionalDataStructure::
  operator= (const DimensionalDataStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::DataStructure& > (*this) = x;
      this->DimensionalDataStructure_uses_DimensionGroup_ = x.DimensionalDataStructure_uses_DimensionGroup_;
    }

    return *this;
  }

  DimensionalDataStructure::
  ~DimensionalDataStructure ()
  {
  }

  // Key
  //

  Key::
  Key ()
  : ::xml_schema::type (),
    identifier_ (this),
    Key_correspondsTo_Unit_ (this),
    Key_represents_KeyDefinition_ (this),
    Key_identifies_DataPoint_ (this),
    Key_correspondsTo_Universe_ (this),
    Key_has_KeyMember_ (this)
  {
  }

  Key::
  Key (const Key& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    Key_correspondsTo_Unit_ (x.Key_correspondsTo_Unit_, f, this),
    Key_represents_KeyDefinition_ (x.Key_represents_KeyDefinition_, f, this),
    Key_identifies_DataPoint_ (x.Key_identifies_DataPoint_, f, this),
    Key_correspondsTo_Universe_ (x.Key_correspondsTo_Universe_, f, this),
    Key_has_KeyMember_ (x.Key_has_KeyMember_, f, this)
  {
  }

  Key::
  Key (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    Key_correspondsTo_Unit_ (this),
    Key_represents_KeyDefinition_ (this),
    Key_identifies_DataPoint_ (this),
    Key_correspondsTo_Universe_ (this),
    Key_has_KeyMember_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Key::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // Key_correspondsTo_Unit
      //
      if (n.name () == "Key_correspondsTo_Unit" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Key_correspondsTo_Unit_type > r (
          Key_correspondsTo_Unit_traits::create (i, f, this));

        if (!this->Key_correspondsTo_Unit_)
        {
          this->Key_correspondsTo_Unit_.set (::std::move (r));
          continue;
        }
      }

      // Key_represents_KeyDefinition
      //
      if (n.name () == "Key_represents_KeyDefinition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Key_represents_KeyDefinition_type > r (
          Key_represents_KeyDefinition_traits::create (i, f, this));

        if (!this->Key_represents_KeyDefinition_)
        {
          this->Key_represents_KeyDefinition_.set (::std::move (r));
          continue;
        }
      }

      // Key_identifies_DataPoint
      //
      if (n.name () == "Key_identifies_DataPoint" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Key_identifies_DataPoint_type > r (
          Key_identifies_DataPoint_traits::create (i, f, this));

        this->Key_identifies_DataPoint_.push_back (::std::move (r));
        continue;
      }

      // Key_correspondsTo_Universe
      //
      if (n.name () == "Key_correspondsTo_Universe" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Key_correspondsTo_Universe_type > r (
          Key_correspondsTo_Universe_traits::create (i, f, this));

        if (!this->Key_correspondsTo_Universe_)
        {
          this->Key_correspondsTo_Universe_.set (::std::move (r));
          continue;
        }
      }

      // Key_has_KeyMember
      //
      if (n.name () == "Key_has_KeyMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Key_has_KeyMember_type > r (
          Key_has_KeyMember_traits::create (i, f, this));

        this->Key_has_KeyMember_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Key* Key::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Key (*this, f, c);
  }

  Key& Key::
  operator= (const Key& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->Key_correspondsTo_Unit_ = x.Key_correspondsTo_Unit_;
      this->Key_represents_KeyDefinition_ = x.Key_represents_KeyDefinition_;
      this->Key_identifies_DataPoint_ = x.Key_identifies_DataPoint_;
      this->Key_correspondsTo_Universe_ = x.Key_correspondsTo_Universe_;
      this->Key_has_KeyMember_ = x.Key_has_KeyMember_;
    }

    return *this;
  }

  Key::
  ~Key ()
  {
  }

  // DimensionalKey
  //

  DimensionalKey::
  DimensionalKey ()
  : ::XMLSchema::Key ()
  {
  }

  DimensionalKey::
  DimensionalKey (const DimensionalKey& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::XMLSchema::Key (x, f, c)
  {
  }

  DimensionalKey::
  DimensionalKey (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::XMLSchema::Key (e, f, c)
  {
  }

  DimensionalKey* DimensionalKey::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionalKey (*this, f, c);
  }

  DimensionalKey::
  ~DimensionalKey ()
  {
  }

  // KeyDefinition
  //

  KeyDefinition::
  KeyDefinition ()
  : ::xml_schema::type (),
    identifier_ (this),
    KeyDefinition_correspondsTo_Universe_ (this),
    KeyDefinition_correspondsTo_Unit_ (this),
    KeyDefinition_has_KeyDefinitionMember_ (this)
  {
  }

  KeyDefinition::
  KeyDefinition (const KeyDefinition& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    KeyDefinition_correspondsTo_Universe_ (x.KeyDefinition_correspondsTo_Universe_, f, this),
    KeyDefinition_correspondsTo_Unit_ (x.KeyDefinition_correspondsTo_Unit_, f, this),
    KeyDefinition_has_KeyDefinitionMember_ (x.KeyDefinition_has_KeyDefinitionMember_, f, this)
  {
  }

  KeyDefinition::
  KeyDefinition (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    KeyDefinition_correspondsTo_Universe_ (this),
    KeyDefinition_correspondsTo_Unit_ (this),
    KeyDefinition_has_KeyDefinitionMember_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void KeyDefinition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // KeyDefinition_correspondsTo_Universe
      //
      if (n.name () == "KeyDefinition_correspondsTo_Universe" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyDefinition_correspondsTo_Universe_type > r (
          KeyDefinition_correspondsTo_Universe_traits::create (i, f, this));

        if (!this->KeyDefinition_correspondsTo_Universe_)
        {
          this->KeyDefinition_correspondsTo_Universe_.set (::std::move (r));
          continue;
        }
      }

      // KeyDefinition_correspondsTo_Unit
      //
      if (n.name () == "KeyDefinition_correspondsTo_Unit" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyDefinition_correspondsTo_Unit_type > r (
          KeyDefinition_correspondsTo_Unit_traits::create (i, f, this));

        if (!this->KeyDefinition_correspondsTo_Unit_)
        {
          this->KeyDefinition_correspondsTo_Unit_.set (::std::move (r));
          continue;
        }
      }

      // KeyDefinition_has_KeyDefinitionMember
      //
      if (n.name () == "KeyDefinition_has_KeyDefinitionMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< KeyDefinition_has_KeyDefinitionMember_type > r (
          KeyDefinition_has_KeyDefinitionMember_traits::create (i, f, this));

        this->KeyDefinition_has_KeyDefinitionMember_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  KeyDefinition* KeyDefinition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class KeyDefinition (*this, f, c);
  }

  KeyDefinition& KeyDefinition::
  operator= (const KeyDefinition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->KeyDefinition_correspondsTo_Universe_ = x.KeyDefinition_correspondsTo_Universe_;
      this->KeyDefinition_correspondsTo_Unit_ = x.KeyDefinition_correspondsTo_Unit_;
      this->KeyDefinition_has_KeyDefinitionMember_ = x.KeyDefinition_has_KeyDefinitionMember_;
    }

    return *this;
  }

  KeyDefinition::
  ~KeyDefinition ()
  {
  }

  // DimensionalKeyDefinition
  //

  DimensionalKeyDefinition::
  DimensionalKeyDefinition ()
  : ::XMLSchema::KeyDefinition ()
  {
  }

  DimensionalKeyDefinition::
  DimensionalKeyDefinition (const DimensionalKeyDefinition& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::KeyDefinition (x, f, c)
  {
  }

  DimensionalKeyDefinition::
  DimensionalKeyDefinition (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::KeyDefinition (e, f, c)
  {
  }

  DimensionalKeyDefinition* DimensionalKeyDefinition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionalKeyDefinition (*this, f, c);
  }

  DimensionalKeyDefinition::
  ~DimensionalKeyDefinition ()
  {
  }

  // DimensionalKeyDefinitionMember
  //

  DimensionalKeyDefinitionMember::
  DimensionalKeyDefinitionMember (const ConceptualValue_hasConceptFrom_ConceptualDomain_type& ConceptualValue_hasConceptFrom_ConceptualDomain)
  : ::XMLSchema::ConceptualValue (ConceptualValue_hasConceptFrom_ConceptualDomain),
    DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_ (this)
  {
  }

  DimensionalKeyDefinitionMember::
  DimensionalKeyDefinitionMember (::std::unique_ptr< ConceptualValue_hasConceptFrom_ConceptualDomain_type > ConceptualValue_hasConceptFrom_ConceptualDomain)
  : ::XMLSchema::ConceptualValue (std::move (ConceptualValue_hasConceptFrom_ConceptualDomain)),
    DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_ (this)
  {
  }

  DimensionalKeyDefinitionMember::
  DimensionalKeyDefinitionMember (const DimensionalKeyDefinitionMember& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::XMLSchema::ConceptualValue (x, f, c),
    DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_ (x.DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_, f, this)
  {
  }

  DimensionalKeyDefinitionMember::
  DimensionalKeyDefinitionMember (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::XMLSchema::ConceptualValue (e, f | ::xml_schema::flags::base, c),
    DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DimensionalKeyDefinitionMember::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::ConceptualValue::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember
      //
      if (n.name () == "DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_type > r (
          DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_traits::create (i, f, this));

        this->DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DimensionalKeyDefinitionMember* DimensionalKeyDefinitionMember::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionalKeyDefinitionMember (*this, f, c);
  }

  DimensionalKeyDefinitionMember& DimensionalKeyDefinitionMember::
  operator= (const DimensionalKeyDefinitionMember& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::ConceptualValue& > (*this) = x;
      this->DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_ = x.DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_;
    }

    return *this;
  }

  DimensionalKeyDefinitionMember::
  ~DimensionalKeyDefinitionMember ()
  {
  }

  // DimensionalKeyMember
  //

  DimensionalKeyMember::
  DimensionalKeyMember (const InstanceValue_hasValueFrom_ValueDomain_type& InstanceValue_hasValueFrom_ValueDomain,
                        const DimensionalKeyMember_hasValueFrom_CodeList_type& DimensionalKeyMember_hasValueFrom_CodeList)
  : ::XMLSchema::KeyMember (InstanceValue_hasValueFrom_ValueDomain),
    DimensionalKeyMember_hasValueFrom_CodeList_ (DimensionalKeyMember_hasValueFrom_CodeList, this)
  {
  }

  DimensionalKeyMember::
  DimensionalKeyMember (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type > InstanceValue_hasValueFrom_ValueDomain,
                        ::std::unique_ptr< DimensionalKeyMember_hasValueFrom_CodeList_type > DimensionalKeyMember_hasValueFrom_CodeList)
  : ::XMLSchema::KeyMember (std::move (InstanceValue_hasValueFrom_ValueDomain)),
    DimensionalKeyMember_hasValueFrom_CodeList_ (std::move (DimensionalKeyMember_hasValueFrom_CodeList), this)
  {
  }

  DimensionalKeyMember::
  DimensionalKeyMember (const DimensionalKeyMember& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::KeyMember (x, f, c),
    DimensionalKeyMember_hasValueFrom_CodeList_ (x.DimensionalKeyMember_hasValueFrom_CodeList_, f, this)
  {
  }

  DimensionalKeyMember::
  DimensionalKeyMember (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::KeyMember (e, f | ::xml_schema::flags::base, c),
    DimensionalKeyMember_hasValueFrom_CodeList_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DimensionalKeyMember::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::KeyMember::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DimensionalKeyMember_hasValueFrom_CodeList
      //
      if (n.name () == "DimensionalKeyMember_hasValueFrom_CodeList" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< DimensionalKeyMember_hasValueFrom_CodeList_type > r (
          DimensionalKeyMember_hasValueFrom_CodeList_traits::create (i, f, this));

        if (!DimensionalKeyMember_hasValueFrom_CodeList_.present ())
        {
          this->DimensionalKeyMember_hasValueFrom_CodeList_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!DimensionalKeyMember_hasValueFrom_CodeList_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DimensionalKeyMember_hasValueFrom_CodeList",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  DimensionalKeyMember* DimensionalKeyMember::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionalKeyMember (*this, f, c);
  }

  DimensionalKeyMember& DimensionalKeyMember::
  operator= (const DimensionalKeyMember& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::KeyMember& > (*this) = x;
      this->DimensionalKeyMember_hasValueFrom_CodeList_ = x.DimensionalKeyMember_hasValueFrom_CodeList_;
    }

    return *this;
  }

  DimensionalKeyMember::
  ~DimensionalKeyMember ()
  {
  }

  // ForeignKey
  //

  ForeignKey::
  ForeignKey ()
  : ::xml_schema::type (),
    identifier_ (this),
    ForeignKey_isComposedOf_ForeignKeyComponent_ (this)
  {
  }

  ForeignKey::
  ForeignKey (const ForeignKey& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    ForeignKey_isComposedOf_ForeignKeyComponent_ (x.ForeignKey_isComposedOf_ForeignKeyComponent_, f, this)
  {
  }

  ForeignKey::
  ForeignKey (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    ForeignKey_isComposedOf_ForeignKeyComponent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ForeignKey::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // ForeignKey_isComposedOf_ForeignKeyComponent
      //
      if (n.name () == "ForeignKey_isComposedOf_ForeignKeyComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ForeignKey_isComposedOf_ForeignKeyComponent_type > r (
          ForeignKey_isComposedOf_ForeignKeyComponent_traits::create (i, f, this));

        this->ForeignKey_isComposedOf_ForeignKeyComponent_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ForeignKey* ForeignKey::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ForeignKey (*this, f, c);
  }

  ForeignKey& ForeignKey::
  operator= (const ForeignKey& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->ForeignKey_isComposedOf_ForeignKeyComponent_ = x.ForeignKey_isComposedOf_ForeignKeyComponent_;
    }

    return *this;
  }

  ForeignKey::
  ~ForeignKey ()
  {
  }

  // ForeignKeyComponent
  //

  ForeignKeyComponent::
  ForeignKeyComponent (const ForeignKeyComponent_references_PrimaryKeyComponent_type& ForeignKeyComponent_references_PrimaryKeyComponent,
                       const ForeignKeyComponent_correspondsTo_DataStructureComponent_type& ForeignKeyComponent_correspondsTo_DataStructureComponent)
  : ::xml_schema::type (),
    identifier_ (this),
    ForeignKeyComponent_references_PrimaryKeyComponent_ (ForeignKeyComponent_references_PrimaryKeyComponent, this),
    ForeignKeyComponent_correspondsTo_DataStructureComponent_ (ForeignKeyComponent_correspondsTo_DataStructureComponent, this)
  {
  }

  ForeignKeyComponent::
  ForeignKeyComponent (::std::unique_ptr< ForeignKeyComponent_references_PrimaryKeyComponent_type > ForeignKeyComponent_references_PrimaryKeyComponent,
                       ::std::unique_ptr< ForeignKeyComponent_correspondsTo_DataStructureComponent_type > ForeignKeyComponent_correspondsTo_DataStructureComponent)
  : ::xml_schema::type (),
    identifier_ (this),
    ForeignKeyComponent_references_PrimaryKeyComponent_ (std::move (ForeignKeyComponent_references_PrimaryKeyComponent), this),
    ForeignKeyComponent_correspondsTo_DataStructureComponent_ (std::move (ForeignKeyComponent_correspondsTo_DataStructureComponent), this)
  {
  }

  ForeignKeyComponent::
  ForeignKeyComponent (const ForeignKeyComponent& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    ForeignKeyComponent_references_PrimaryKeyComponent_ (x.ForeignKeyComponent_references_PrimaryKeyComponent_, f, this),
    ForeignKeyComponent_correspondsTo_DataStructureComponent_ (x.ForeignKeyComponent_correspondsTo_DataStructureComponent_, f, this)
  {
  }

  ForeignKeyComponent::
  ForeignKeyComponent (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    ForeignKeyComponent_references_PrimaryKeyComponent_ (this),
    ForeignKeyComponent_correspondsTo_DataStructureComponent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ForeignKeyComponent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // ForeignKeyComponent_references_PrimaryKeyComponent
      //
      if (n.name () == "ForeignKeyComponent_references_PrimaryKeyComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ForeignKeyComponent_references_PrimaryKeyComponent_type > r (
          ForeignKeyComponent_references_PrimaryKeyComponent_traits::create (i, f, this));

        if (!ForeignKeyComponent_references_PrimaryKeyComponent_.present ())
        {
          this->ForeignKeyComponent_references_PrimaryKeyComponent_.set (::std::move (r));
          continue;
        }
      }

      // ForeignKeyComponent_correspondsTo_DataStructureComponent
      //
      if (n.name () == "ForeignKeyComponent_correspondsTo_DataStructureComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ForeignKeyComponent_correspondsTo_DataStructureComponent_type > r (
          ForeignKeyComponent_correspondsTo_DataStructureComponent_traits::create (i, f, this));

        if (!ForeignKeyComponent_correspondsTo_DataStructureComponent_.present ())
        {
          this->ForeignKeyComponent_correspondsTo_DataStructureComponent_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!ForeignKeyComponent_references_PrimaryKeyComponent_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ForeignKeyComponent_references_PrimaryKeyComponent",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!ForeignKeyComponent_correspondsTo_DataStructureComponent_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ForeignKeyComponent_correspondsTo_DataStructureComponent",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ForeignKeyComponent* ForeignKeyComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ForeignKeyComponent (*this, f, c);
  }

  ForeignKeyComponent& ForeignKeyComponent::
  operator= (const ForeignKeyComponent& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->ForeignKeyComponent_references_PrimaryKeyComponent_ = x.ForeignKeyComponent_references_PrimaryKeyComponent_;
      this->ForeignKeyComponent_correspondsTo_DataStructureComponent_ = x.ForeignKeyComponent_correspondsTo_DataStructureComponent_;
    }

    return *this;
  }

  ForeignKeyComponent::
  ~ForeignKeyComponent ()
  {
  }

  // IdentifierComponent
  //

  IdentifierComponent::
  IdentifierComponent ()
  : ::XMLSchema::DataStructureComponent ()
  {
  }

  IdentifierComponent::
  IdentifierComponent (const IdentifierComponent& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (x, f, c)
  {
  }

  IdentifierComponent::
  IdentifierComponent (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (e, f, c)
  {
  }

  IdentifierComponent* IdentifierComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IdentifierComponent (*this, f, c);
  }

  IdentifierComponent::
  ~IdentifierComponent ()
  {
  }

  // Individual
  //

  Individual::
  Individual ()
  : ::XMLSchema::Agent (),
    contactInformation_ (this),
    individualName_ (this)
  {
  }

  Individual::
  Individual (const Individual& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::XMLSchema::Agent (x, f, c),
    contactInformation_ (x.contactInformation_, f, this),
    individualName_ (x.individualName_, f, this)
  {
  }

  Individual::
  Individual (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::XMLSchema::Agent (e, f | ::xml_schema::flags::base, c),
    contactInformation_ (this),
    individualName_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Individual::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::Agent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // contactInformation
      //
      if (n.name () == "contactInformation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< contactInformation_type > r (
          contactInformation_traits::create (i, f, this));

        if (!this->contactInformation_)
        {
          this->contactInformation_.set (::std::move (r));
          continue;
        }
      }

      // individualName
      //
      if (n.name () == "individualName" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< individualName_type > r (
          individualName_traits::create (i, f, this));

        this->individualName_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Individual* Individual::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Individual (*this, f, c);
  }

  Individual& Individual::
  operator= (const Individual& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Agent& > (*this) = x;
      this->contactInformation_ = x.contactInformation_;
      this->individualName_ = x.individualName_;
    }

    return *this;
  }

  Individual::
  ~Individual ()
  {
  }

  // InformationFlowDefinition
  //

  InformationFlowDefinition::
  InformationFlowDefinition ()
  : ::xml_schema::type (),
    identifier_ (this),
    InformationFlowDefinition_from_Parameter_ (this),
    InformationFlowDefinition_to_Parameter_ (this)
  {
  }

  InformationFlowDefinition::
  InformationFlowDefinition (const InformationFlowDefinition& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    InformationFlowDefinition_from_Parameter_ (x.InformationFlowDefinition_from_Parameter_, f, this),
    InformationFlowDefinition_to_Parameter_ (x.InformationFlowDefinition_to_Parameter_, f, this)
  {
  }

  InformationFlowDefinition::
  InformationFlowDefinition (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    InformationFlowDefinition_from_Parameter_ (this),
    InformationFlowDefinition_to_Parameter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InformationFlowDefinition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // InformationFlowDefinition_from_Parameter
      //
      if (n.name () == "InformationFlowDefinition_from_Parameter" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InformationFlowDefinition_from_Parameter_type > r (
          InformationFlowDefinition_from_Parameter_traits::create (i, f, this));

        if (!this->InformationFlowDefinition_from_Parameter_)
        {
          this->InformationFlowDefinition_from_Parameter_.set (::std::move (r));
          continue;
        }
      }

      // InformationFlowDefinition_to_Parameter
      //
      if (n.name () == "InformationFlowDefinition_to_Parameter" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InformationFlowDefinition_to_Parameter_type > r (
          InformationFlowDefinition_to_Parameter_traits::create (i, f, this));

        this->InformationFlowDefinition_to_Parameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  InformationFlowDefinition* InformationFlowDefinition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InformationFlowDefinition (*this, f, c);
  }

  InformationFlowDefinition& InformationFlowDefinition::
  operator= (const InformationFlowDefinition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->InformationFlowDefinition_from_Parameter_ = x.InformationFlowDefinition_from_Parameter_;
      this->InformationFlowDefinition_to_Parameter_ = x.InformationFlowDefinition_to_Parameter_;
    }

    return *this;
  }

  InformationFlowDefinition::
  ~InformationFlowDefinition ()
  {
  }

  // InstanceKey
  //

  InstanceKey::
  InstanceKey (const InstanceKey_refersTo_ReferenceValue_type& InstanceKey_refersTo_ReferenceValue)
  : ::XMLSchema::Key (),
    InstanceKey_has_InstanceValue_ (this),
    InstanceKey_refersTo_ReferenceValue_ (InstanceKey_refersTo_ReferenceValue, this)
  {
  }

  InstanceKey::
  InstanceKey (::std::unique_ptr< InstanceKey_refersTo_ReferenceValue_type > InstanceKey_refersTo_ReferenceValue)
  : ::XMLSchema::Key (),
    InstanceKey_has_InstanceValue_ (this),
    InstanceKey_refersTo_ReferenceValue_ (std::move (InstanceKey_refersTo_ReferenceValue), this)
  {
  }

  InstanceKey::
  InstanceKey (const InstanceKey& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::XMLSchema::Key (x, f, c),
    InstanceKey_has_InstanceValue_ (x.InstanceKey_has_InstanceValue_, f, this),
    InstanceKey_refersTo_ReferenceValue_ (x.InstanceKey_refersTo_ReferenceValue_, f, this)
  {
  }

  InstanceKey::
  InstanceKey (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::XMLSchema::Key (e, f | ::xml_schema::flags::base, c),
    InstanceKey_has_InstanceValue_ (this),
    InstanceKey_refersTo_ReferenceValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InstanceKey::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::Key::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // InstanceKey_has_InstanceValue
      //
      if (n.name () == "InstanceKey_has_InstanceValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceKey_has_InstanceValue_type > r (
          InstanceKey_has_InstanceValue_traits::create (i, f, this));

        if (!this->InstanceKey_has_InstanceValue_)
        {
          this->InstanceKey_has_InstanceValue_.set (::std::move (r));
          continue;
        }
      }

      // InstanceKey_refersTo_ReferenceValue
      //
      if (n.name () == "InstanceKey_refersTo_ReferenceValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceKey_refersTo_ReferenceValue_type > r (
          InstanceKey_refersTo_ReferenceValue_traits::create (i, f, this));

        if (!InstanceKey_refersTo_ReferenceValue_.present ())
        {
          this->InstanceKey_refersTo_ReferenceValue_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!InstanceKey_refersTo_ReferenceValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "InstanceKey_refersTo_ReferenceValue",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  InstanceKey* InstanceKey::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstanceKey (*this, f, c);
  }

  InstanceKey& InstanceKey::
  operator= (const InstanceKey& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Key& > (*this) = x;
      this->InstanceKey_has_InstanceValue_ = x.InstanceKey_has_InstanceValue_;
      this->InstanceKey_refersTo_ReferenceValue_ = x.InstanceKey_refersTo_ReferenceValue_;
    }

    return *this;
  }

  InstanceKey::
  ~InstanceKey ()
  {
  }

  // InstanceVariable
  //

  InstanceVariable::
  InstanceVariable ()
  : ::XMLSchema::RepresentedVariable (),
    physicalDataType_ (this),
    platformType_ (this),
    source_ (this),
    variableFunction_ (this)
  {
  }

  InstanceVariable::
  InstanceVariable (const InstanceVariable& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::XMLSchema::RepresentedVariable (x, f, c),
    physicalDataType_ (x.physicalDataType_, f, this),
    platformType_ (x.platformType_, f, this),
    source_ (x.source_, f, this),
    variableFunction_ (x.variableFunction_, f, this)
  {
  }

  InstanceVariable::
  InstanceVariable (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::XMLSchema::RepresentedVariable (e, f | ::xml_schema::flags::base, c),
    physicalDataType_ (this),
    platformType_ (this),
    source_ (this),
    variableFunction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InstanceVariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::RepresentedVariable::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // physicalDataType
      //
      if (n.name () == "physicalDataType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< physicalDataType_type > r (
          physicalDataType_traits::create (i, f, this));

        if (!this->physicalDataType_)
        {
          this->physicalDataType_.set (::std::move (r));
          continue;
        }
      }

      // platformType
      //
      if (n.name () == "platformType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< platformType_type > r (
          platformType_traits::create (i, f, this));

        if (!this->platformType_)
        {
          this->platformType_.set (::std::move (r));
          continue;
        }
      }

      // source
      //
      if (n.name () == "source" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< source_type > r (
          source_traits::create (i, f, this));

        if (!this->source_)
        {
          this->source_.set (::std::move (r));
          continue;
        }
      }

      // variableFunction
      //
      if (n.name () == "variableFunction" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< variableFunction_type > r (
          variableFunction_traits::create (i, f, this));

        this->variableFunction_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  InstanceVariable* InstanceVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstanceVariable (*this, f, c);
  }

  InstanceVariable& InstanceVariable::
  operator= (const InstanceVariable& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::RepresentedVariable& > (*this) = x;
      this->physicalDataType_ = x.physicalDataType_;
      this->platformType_ = x.platformType_;
      this->source_ = x.source_;
      this->variableFunction_ = x.variableFunction_;
    }

    return *this;
  }

  InstanceVariable::
  ~InstanceVariable ()
  {
  }

  // InstanceVariableMap
  //

  InstanceVariableMap::
  InstanceVariableMap (const comparison_type& comparison,
                       const correspondence_type& correspondence,
                       const setValue_type& setValue)
  : ::xml_schema::type (),
    comparison_ (comparison, this),
    correspondence_ (correspondence, this),
    identifier_ (this),
    setValue_ (setValue, this),
    InstanceVariableMap_hasTarget_InstanceVariable_ (this),
    InstanceVariableMap_hasSource_InstanceVariable_ (this)
  {
  }

  InstanceVariableMap::
  InstanceVariableMap (const comparison_type& comparison,
                       ::std::unique_ptr< correspondence_type > correspondence,
                       const setValue_type& setValue)
  : ::xml_schema::type (),
    comparison_ (comparison, this),
    correspondence_ (std::move (correspondence), this),
    identifier_ (this),
    setValue_ (setValue, this),
    InstanceVariableMap_hasTarget_InstanceVariable_ (this),
    InstanceVariableMap_hasSource_InstanceVariable_ (this)
  {
  }

  InstanceVariableMap::
  InstanceVariableMap (const InstanceVariableMap& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    comparison_ (x.comparison_, f, this),
    correspondence_ (x.correspondence_, f, this),
    identifier_ (x.identifier_, f, this),
    setValue_ (x.setValue_, f, this),
    InstanceVariableMap_hasTarget_InstanceVariable_ (x.InstanceVariableMap_hasTarget_InstanceVariable_, f, this),
    InstanceVariableMap_hasSource_InstanceVariable_ (x.InstanceVariableMap_hasSource_InstanceVariable_, f, this)
  {
  }

  InstanceVariableMap::
  InstanceVariableMap (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    comparison_ (this),
    correspondence_ (this),
    identifier_ (this),
    setValue_ (this),
    InstanceVariableMap_hasTarget_InstanceVariable_ (this),
    InstanceVariableMap_hasSource_InstanceVariable_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InstanceVariableMap::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // comparison
      //
      if (n.name () == "comparison" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< comparison_type > r (
          comparison_traits::create (i, f, this));

        if (!comparison_.present ())
        {
          this->comparison_.set (::std::move (r));
          continue;
        }
      }

      // correspondence
      //
      if (n.name () == "correspondence" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< correspondence_type > r (
          correspondence_traits::create (i, f, this));

        if (!correspondence_.present ())
        {
          this->correspondence_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // setValue
      //
      if (n.name () == "setValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< setValue_type > r (
          setValue_traits::create (i, f, this));

        if (!setValue_.present ())
        {
          this->setValue_.set (::std::move (r));
          continue;
        }
      }

      // InstanceVariableMap_hasTarget_InstanceVariable
      //
      if (n.name () == "InstanceVariableMap_hasTarget_InstanceVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceVariableMap_hasTarget_InstanceVariable_type > r (
          InstanceVariableMap_hasTarget_InstanceVariable_traits::create (i, f, this));

        this->InstanceVariableMap_hasTarget_InstanceVariable_.push_back (::std::move (r));
        continue;
      }

      // InstanceVariableMap_hasSource_InstanceVariable
      //
      if (n.name () == "InstanceVariableMap_hasSource_InstanceVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< InstanceVariableMap_hasSource_InstanceVariable_type > r (
          InstanceVariableMap_hasSource_InstanceVariable_traits::create (i, f, this));

        this->InstanceVariableMap_hasSource_InstanceVariable_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!comparison_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "comparison",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!correspondence_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "correspondence",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!setValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "setValue",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  InstanceVariableMap* InstanceVariableMap::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstanceVariableMap (*this, f, c);
  }

  InstanceVariableMap& InstanceVariableMap::
  operator= (const InstanceVariableMap& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->comparison_ = x.comparison_;
      this->correspondence_ = x.correspondence_;
      this->identifier_ = x.identifier_;
      this->setValue_ = x.setValue_;
      this->InstanceVariableMap_hasTarget_InstanceVariable_ = x.InstanceVariableMap_hasTarget_InstanceVariable_;
      this->InstanceVariableMap_hasSource_InstanceVariable_ = x.InstanceVariableMap_hasSource_InstanceVariable_;
    }

    return *this;
  }

  InstanceVariableMap::
  ~InstanceVariableMap ()
  {
  }

  // KeyDefinitionMember
  //

  KeyDefinitionMember::
  KeyDefinitionMember (const ConceptualValue_hasConceptFrom_ConceptualDomain_type& ConceptualValue_hasConceptFrom_ConceptualDomain)
  : ::XMLSchema::ConceptualValue (ConceptualValue_hasConceptFrom_ConceptualDomain)
  {
  }

  KeyDefinitionMember::
  KeyDefinitionMember (::std::unique_ptr< ConceptualValue_hasConceptFrom_ConceptualDomain_type > ConceptualValue_hasConceptFrom_ConceptualDomain)
  : ::XMLSchema::ConceptualValue (std::move (ConceptualValue_hasConceptFrom_ConceptualDomain))
  {
  }

  KeyDefinitionMember::
  KeyDefinitionMember (const KeyDefinitionMember& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::ConceptualValue (x, f, c)
  {
  }

  KeyDefinitionMember::
  KeyDefinitionMember (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::ConceptualValue (e, f, c)
  {
  }

  KeyDefinitionMember* KeyDefinitionMember::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class KeyDefinitionMember (*this, f, c);
  }

  KeyDefinitionMember::
  ~KeyDefinitionMember ()
  {
  }

  // KeyValueDataStore
  //

  KeyValueDataStore::
  KeyValueDataStore ()
  : ::XMLSchema::DataSet ()
  {
  }

  KeyValueDataStore::
  KeyValueDataStore (const KeyValueDataStore& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::DataSet (x, f, c)
  {
  }

  KeyValueDataStore::
  KeyValueDataStore (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::DataSet (e, f, c)
  {
  }

  KeyValueDataStore* KeyValueDataStore::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class KeyValueDataStore (*this, f, c);
  }

  KeyValueDataStore::
  ~KeyValueDataStore ()
  {
  }

  // KeyValueStructure
  //

  KeyValueStructure::
  KeyValueStructure ()
  : ::XMLSchema::DataStructure ()
  {
  }

  KeyValueStructure::
  KeyValueStructure (const KeyValueStructure& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::DataStructure (x, f, c)
  {
  }

  KeyValueStructure::
  KeyValueStructure (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::DataStructure (e, f, c)
  {
  }

  KeyValueStructure* KeyValueStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class KeyValueStructure (*this, f, c);
  }

  KeyValueStructure::
  ~KeyValueStructure ()
  {
  }

  // Level
  //

  Level::
  Level (const levelNumber_type& levelNumber)
  : ::xml_schema::type (),
    displayLabel_ (this),
    identifier_ (this),
    levelNumber_ (levelNumber, this),
    Level_isDefinedBy_Concept_ (this),
    Level_groups_ClassificationItem_ (this)
  {
  }

  Level::
  Level (const Level& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    displayLabel_ (x.displayLabel_, f, this),
    identifier_ (x.identifier_, f, this),
    levelNumber_ (x.levelNumber_, f, this),
    Level_isDefinedBy_Concept_ (x.Level_isDefinedBy_Concept_, f, this),
    Level_groups_ClassificationItem_ (x.Level_groups_ClassificationItem_, f, this)
  {
  }

  Level::
  Level (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    displayLabel_ (this),
    identifier_ (this),
    levelNumber_ (this),
    Level_isDefinedBy_Concept_ (this),
    Level_groups_ClassificationItem_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Level::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // displayLabel
      //
      if (n.name () == "displayLabel" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< displayLabel_type > r (
          displayLabel_traits::create (i, f, this));

        this->displayLabel_.push_back (::std::move (r));
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // levelNumber
      //
      if (n.name () == "levelNumber" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!levelNumber_.present ())
        {
          this->levelNumber_.set (levelNumber_traits::create (i, f, this));
          continue;
        }
      }

      // Level_isDefinedBy_Concept
      //
      if (n.name () == "Level_isDefinedBy_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Level_isDefinedBy_Concept_type > r (
          Level_isDefinedBy_Concept_traits::create (i, f, this));

        if (!this->Level_isDefinedBy_Concept_)
        {
          this->Level_isDefinedBy_Concept_.set (::std::move (r));
          continue;
        }
      }

      // Level_groups_ClassificationItem
      //
      if (n.name () == "Level_groups_ClassificationItem" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Level_groups_ClassificationItem_type > r (
          Level_groups_ClassificationItem_traits::create (i, f, this));

        this->Level_groups_ClassificationItem_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!levelNumber_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "levelNumber",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  Level* Level::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Level (*this, f, c);
  }

  Level& Level::
  operator= (const Level& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->displayLabel_ = x.displayLabel_;
      this->identifier_ = x.identifier_;
      this->levelNumber_ = x.levelNumber_;
      this->Level_isDefinedBy_Concept_ = x.Level_isDefinedBy_Concept_;
      this->Level_groups_ClassificationItem_ = x.Level_groups_ClassificationItem_;
    }

    return *this;
  }

  Level::
  ~Level ()
  {
  }

  // LevelStructure
  //

  LevelStructure::
  LevelStructure ()
  : ::xml_schema::type (),
    catalogDetails_ (this),
    identifier_ (this),
    name_ (this),
    usage_ (this),
    validDateRange_ (this),
    LevelStructure_has_Level_ (this)
  {
  }

  LevelStructure::
  LevelStructure (const LevelStructure& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    usage_ (x.usage_, f, this),
    validDateRange_ (x.validDateRange_, f, this),
    LevelStructure_has_Level_ (x.LevelStructure_has_Level_, f, this)
  {
  }

  LevelStructure::
  LevelStructure (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    identifier_ (this),
    name_ (this),
    usage_ (this),
    validDateRange_ (this),
    LevelStructure_has_Level_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LevelStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // usage
      //
      if (n.name () == "usage" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< usage_type > r (
          usage_traits::create (i, f, this));

        if (!this->usage_)
        {
          this->usage_.set (::std::move (r));
          continue;
        }
      }

      // validDateRange
      //
      if (n.name () == "validDateRange" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< validDateRange_type > r (
          validDateRange_traits::create (i, f, this));

        if (!this->validDateRange_)
        {
          this->validDateRange_.set (::std::move (r));
          continue;
        }
      }

      // LevelStructure_has_Level
      //
      if (n.name () == "LevelStructure_has_Level" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LevelStructure_has_Level_type > r (
          LevelStructure_has_Level_traits::create (i, f, this));

        this->LevelStructure_has_Level_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LevelStructure* LevelStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LevelStructure (*this, f, c);
  }

  LevelStructure& LevelStructure::
  operator= (const LevelStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->usage_ = x.usage_;
      this->validDateRange_ = x.validDateRange_;
      this->LevelStructure_has_Level_ = x.LevelStructure_has_Level_;
    }

    return *this;
  }

  LevelStructure::
  ~LevelStructure ()
  {
  }

  // LogicalRecord
  //

  LogicalRecord::
  LogicalRecord ()
  : ::xml_schema::type (),
    identifier_ (this),
    LogicalRecord_organizes_DataSet_ (this),
    LogicalRecord_isDefinedBy_Concept_ (this),
    LogicalRecord_has_InstanceVariable_ (this)
  {
  }

  LogicalRecord::
  LogicalRecord (const LogicalRecord& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    LogicalRecord_organizes_DataSet_ (x.LogicalRecord_organizes_DataSet_, f, this),
    LogicalRecord_isDefinedBy_Concept_ (x.LogicalRecord_isDefinedBy_Concept_, f, this),
    LogicalRecord_has_InstanceVariable_ (x.LogicalRecord_has_InstanceVariable_, f, this)
  {
  }

  LogicalRecord::
  LogicalRecord (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    LogicalRecord_organizes_DataSet_ (this),
    LogicalRecord_isDefinedBy_Concept_ (this),
    LogicalRecord_has_InstanceVariable_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LogicalRecord::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // LogicalRecord_organizes_DataSet
      //
      if (n.name () == "LogicalRecord_organizes_DataSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecord_organizes_DataSet_type > r (
          LogicalRecord_organizes_DataSet_traits::create (i, f, this));

        this->LogicalRecord_organizes_DataSet_.push_back (::std::move (r));
        continue;
      }

      // LogicalRecord_isDefinedBy_Concept
      //
      if (n.name () == "LogicalRecord_isDefinedBy_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecord_isDefinedBy_Concept_type > r (
          LogicalRecord_isDefinedBy_Concept_traits::create (i, f, this));

        this->LogicalRecord_isDefinedBy_Concept_.push_back (::std::move (r));
        continue;
      }

      // LogicalRecord_has_InstanceVariable
      //
      if (n.name () == "LogicalRecord_has_InstanceVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecord_has_InstanceVariable_type > r (
          LogicalRecord_has_InstanceVariable_traits::create (i, f, this));

        this->LogicalRecord_has_InstanceVariable_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LogicalRecord* LogicalRecord::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalRecord (*this, f, c);
  }

  LogicalRecord& LogicalRecord::
  operator= (const LogicalRecord& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->LogicalRecord_organizes_DataSet_ = x.LogicalRecord_organizes_DataSet_;
      this->LogicalRecord_isDefinedBy_Concept_ = x.LogicalRecord_isDefinedBy_Concept_;
      this->LogicalRecord_has_InstanceVariable_ = x.LogicalRecord_has_InstanceVariable_;
    }

    return *this;
  }

  LogicalRecord::
  ~LogicalRecord ()
  {
  }

  // LogicalRecordPosition
  //

  LogicalRecordPosition::
  LogicalRecordPosition (const value_type& value,
                         const LogicalRecordPosition_indexes_LogicalRecord_type& LogicalRecordPosition_indexes_LogicalRecord)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    LogicalRecordPosition_indexes_LogicalRecord_ (LogicalRecordPosition_indexes_LogicalRecord, this)
  {
  }

  LogicalRecordPosition::
  LogicalRecordPosition (const value_type& value,
                         ::std::unique_ptr< LogicalRecordPosition_indexes_LogicalRecord_type > LogicalRecordPosition_indexes_LogicalRecord)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    LogicalRecordPosition_indexes_LogicalRecord_ (std::move (LogicalRecordPosition_indexes_LogicalRecord), this)
  {
  }

  LogicalRecordPosition::
  LogicalRecordPosition (const LogicalRecordPosition& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    value_ (x.value_, f, this),
    LogicalRecordPosition_indexes_LogicalRecord_ (x.LogicalRecordPosition_indexes_LogicalRecord_, f, this)
  {
  }

  LogicalRecordPosition::
  LogicalRecordPosition (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    value_ (this),
    LogicalRecordPosition_indexes_LogicalRecord_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LogicalRecordPosition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      // LogicalRecordPosition_indexes_LogicalRecord
      //
      if (n.name () == "LogicalRecordPosition_indexes_LogicalRecord" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecordPosition_indexes_LogicalRecord_type > r (
          LogicalRecordPosition_indexes_LogicalRecord_traits::create (i, f, this));

        if (!LogicalRecordPosition_indexes_LogicalRecord_.present ())
        {
          this->LogicalRecordPosition_indexes_LogicalRecord_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!LogicalRecordPosition_indexes_LogicalRecord_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LogicalRecordPosition_indexes_LogicalRecord",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  LogicalRecordPosition* LogicalRecordPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalRecordPosition (*this, f, c);
  }

  LogicalRecordPosition& LogicalRecordPosition::
  operator= (const LogicalRecordPosition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->value_ = x.value_;
      this->LogicalRecordPosition_indexes_LogicalRecord_ = x.LogicalRecordPosition_indexes_LogicalRecord_;
    }

    return *this;
  }

  LogicalRecordPosition::
  ~LogicalRecordPosition ()
  {
  }

  // LogicalRecordRelationStructure
  //

  LogicalRecordRelationStructure::
  LogicalRecordRelationStructure ()
  : ::xml_schema::type (),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    LogicalRecordRelationStructure_structures_DataStore_ (this),
    LogicalRecordRelationStructure_has_LogicalRecordRelationship_ (this)
  {
  }

  LogicalRecordRelationStructure::
  LogicalRecordRelationStructure (const LogicalRecordRelationStructure& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    semantics_ (x.semantics_, f, this),
    specification_ (x.specification_, f, this),
    topology_ (x.topology_, f, this),
    totality_ (x.totality_, f, this),
    LogicalRecordRelationStructure_structures_DataStore_ (x.LogicalRecordRelationStructure_structures_DataStore_, f, this),
    LogicalRecordRelationStructure_has_LogicalRecordRelationship_ (x.LogicalRecordRelationStructure_has_LogicalRecordRelationship_, f, this)
  {
  }

  LogicalRecordRelationStructure::
  LogicalRecordRelationStructure (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    LogicalRecordRelationStructure_structures_DataStore_ (this),
    LogicalRecordRelationStructure_has_LogicalRecordRelationship_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LogicalRecordRelationStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // specification
      //
      if (n.name () == "specification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< specification_type > r (
          specification_traits::create (i, f, this));

        if (!this->specification_)
        {
          this->specification_.set (::std::move (r));
          continue;
        }
      }

      // topology
      //
      if (n.name () == "topology" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< topology_type > r (
          topology_traits::create (i, f, this));

        if (!this->topology_)
        {
          this->topology_.set (::std::move (r));
          continue;
        }
      }

      // totality
      //
      if (n.name () == "totality" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< totality_type > r (
          totality_traits::create (i, f, this));

        if (!this->totality_)
        {
          this->totality_.set (::std::move (r));
          continue;
        }
      }

      // LogicalRecordRelationStructure_structures_DataStore
      //
      if (n.name () == "LogicalRecordRelationStructure_structures_DataStore" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecordRelationStructure_structures_DataStore_type > r (
          LogicalRecordRelationStructure_structures_DataStore_traits::create (i, f, this));

        this->LogicalRecordRelationStructure_structures_DataStore_.push_back (::std::move (r));
        continue;
      }

      // LogicalRecordRelationStructure_has_LogicalRecordRelationship
      //
      if (n.name () == "LogicalRecordRelationStructure_has_LogicalRecordRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecordRelationStructure_has_LogicalRecordRelationship_type > r (
          LogicalRecordRelationStructure_has_LogicalRecordRelationship_traits::create (i, f, this));

        this->LogicalRecordRelationStructure_has_LogicalRecordRelationship_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LogicalRecordRelationStructure* LogicalRecordRelationStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalRecordRelationStructure (*this, f, c);
  }

  LogicalRecordRelationStructure& LogicalRecordRelationStructure::
  operator= (const LogicalRecordRelationStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->semantics_ = x.semantics_;
      this->specification_ = x.specification_;
      this->topology_ = x.topology_;
      this->totality_ = x.totality_;
      this->LogicalRecordRelationStructure_structures_DataStore_ = x.LogicalRecordRelationStructure_structures_DataStore_;
      this->LogicalRecordRelationStructure_has_LogicalRecordRelationship_ = x.LogicalRecordRelationStructure_has_LogicalRecordRelationship_;
    }

    return *this;
  }

  LogicalRecordRelationStructure::
  ~LogicalRecordRelationStructure ()
  {
  }

  // LogicalRecordRelationship
  //

  LogicalRecordRelationship::
  LogicalRecordRelationship ()
  : ::xml_schema::type (),
    identifier_ (this),
    semantics_ (this),
    LogicalRecordRelationship_hasTarget_LogicalRecord_ (this),
    LogicalRecordRelationship_hasSource_LogicalRecord_ (this)
  {
  }

  LogicalRecordRelationship::
  LogicalRecordRelationship (const LogicalRecordRelationship& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    semantics_ (x.semantics_, f, this),
    LogicalRecordRelationship_hasTarget_LogicalRecord_ (x.LogicalRecordRelationship_hasTarget_LogicalRecord_, f, this),
    LogicalRecordRelationship_hasSource_LogicalRecord_ (x.LogicalRecordRelationship_hasSource_LogicalRecord_, f, this)
  {
  }

  LogicalRecordRelationship::
  LogicalRecordRelationship (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    semantics_ (this),
    LogicalRecordRelationship_hasTarget_LogicalRecord_ (this),
    LogicalRecordRelationship_hasSource_LogicalRecord_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LogicalRecordRelationship::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // LogicalRecordRelationship_hasTarget_LogicalRecord
      //
      if (n.name () == "LogicalRecordRelationship_hasTarget_LogicalRecord" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecordRelationship_hasTarget_LogicalRecord_type > r (
          LogicalRecordRelationship_hasTarget_LogicalRecord_traits::create (i, f, this));

        this->LogicalRecordRelationship_hasTarget_LogicalRecord_.push_back (::std::move (r));
        continue;
      }

      // LogicalRecordRelationship_hasSource_LogicalRecord
      //
      if (n.name () == "LogicalRecordRelationship_hasSource_LogicalRecord" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< LogicalRecordRelationship_hasSource_LogicalRecord_type > r (
          LogicalRecordRelationship_hasSource_LogicalRecord_traits::create (i, f, this));

        this->LogicalRecordRelationship_hasSource_LogicalRecord_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LogicalRecordRelationship* LogicalRecordRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalRecordRelationship (*this, f, c);
  }

  LogicalRecordRelationship& LogicalRecordRelationship::
  operator= (const LogicalRecordRelationship& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->semantics_ = x.semantics_;
      this->LogicalRecordRelationship_hasTarget_LogicalRecord_ = x.LogicalRecordRelationship_hasTarget_LogicalRecord_;
      this->LogicalRecordRelationship_hasSource_LogicalRecord_ = x.LogicalRecordRelationship_hasSource_LogicalRecord_;
    }

    return *this;
  }

  LogicalRecordRelationship::
  ~LogicalRecordRelationship ()
  {
  }

  // LongDataSet
  //

  LongDataSet::
  LongDataSet ()
  : ::XMLSchema::DataSet ()
  {
  }

  LongDataSet::
  LongDataSet (const LongDataSet& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::XMLSchema::DataSet (x, f, c)
  {
  }

  LongDataSet::
  LongDataSet (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::XMLSchema::DataSet (e, f, c)
  {
  }

  LongDataSet* LongDataSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LongDataSet (*this, f, c);
  }

  LongDataSet::
  ~LongDataSet ()
  {
  }

  // LongDataStructure
  //

  LongDataStructure::
  LongDataStructure ()
  : ::XMLSchema::DataStructure ()
  {
  }

  LongDataStructure::
  LongDataStructure (const LongDataStructure& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::DataStructure (x, f, c)
  {
  }

  LongDataStructure::
  LongDataStructure (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::DataStructure (e, f, c)
  {
  }

  LongDataStructure* LongDataStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LongDataStructure (*this, f, c);
  }

  LongDataStructure::
  ~LongDataStructure ()
  {
  }

  // LongKey
  //

  LongKey::
  LongKey ()
  : ::XMLSchema::Key ()
  {
  }

  LongKey::
  LongKey (const LongKey& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::XMLSchema::Key (x, f, c)
  {
  }

  LongKey::
  LongKey (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::XMLSchema::Key (e, f, c)
  {
  }

  LongKey* LongKey::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LongKey (*this, f, c);
  }

  LongKey::
  ~LongKey ()
  {
  }

  // LongMainKeyMember
  //

  LongMainKeyMember::
  LongMainKeyMember (const InstanceValue_hasValueFrom_ValueDomain_type& InstanceValue_hasValueFrom_ValueDomain)
  : ::XMLSchema::KeyMember (InstanceValue_hasValueFrom_ValueDomain)
  {
  }

  LongMainKeyMember::
  LongMainKeyMember (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type > InstanceValue_hasValueFrom_ValueDomain)
  : ::XMLSchema::KeyMember (std::move (InstanceValue_hasValueFrom_ValueDomain))
  {
  }

  LongMainKeyMember::
  LongMainKeyMember (const LongMainKeyMember& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::KeyMember (x, f, c)
  {
  }

  LongMainKeyMember::
  LongMainKeyMember (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::KeyMember (e, f, c)
  {
  }

  LongMainKeyMember* LongMainKeyMember::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LongMainKeyMember (*this, f, c);
  }

  LongMainKeyMember::
  ~LongMainKeyMember ()
  {
  }

  // Machine
  //

  Machine::
  Machine ()
  : ::XMLSchema::Agent (),
    accessLocation_ (this),
    function_ (this),
    machineInterface_ (this),
    name_ (this),
    ownerOperatorContact_ (this),
    typeOfMachine_ (this)
  {
  }

  Machine::
  Machine (const Machine& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::XMLSchema::Agent (x, f, c),
    accessLocation_ (x.accessLocation_, f, this),
    function_ (x.function_, f, this),
    machineInterface_ (x.machineInterface_, f, this),
    name_ (x.name_, f, this),
    ownerOperatorContact_ (x.ownerOperatorContact_, f, this),
    typeOfMachine_ (x.typeOfMachine_, f, this)
  {
  }

  Machine::
  Machine (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::XMLSchema::Agent (e, f | ::xml_schema::flags::base, c),
    accessLocation_ (this),
    function_ (this),
    machineInterface_ (this),
    name_ (this),
    ownerOperatorContact_ (this),
    typeOfMachine_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Machine::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::Agent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // accessLocation
      //
      if (n.name () == "accessLocation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< accessLocation_type > r (
          accessLocation_traits::create (i, f, this));

        if (!this->accessLocation_)
        {
          this->accessLocation_.set (::std::move (r));
          continue;
        }
      }

      // function
      //
      if (n.name () == "function" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< function_type > r (
          function_traits::create (i, f, this));

        this->function_.push_back (::std::move (r));
        continue;
      }

      // machineInterface
      //
      if (n.name () == "machineInterface" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< machineInterface_type > r (
          machineInterface_traits::create (i, f, this));

        this->machineInterface_.push_back (::std::move (r));
        continue;
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // ownerOperatorContact
      //
      if (n.name () == "ownerOperatorContact" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ownerOperatorContact_type > r (
          ownerOperatorContact_traits::create (i, f, this));

        if (!this->ownerOperatorContact_)
        {
          this->ownerOperatorContact_.set (::std::move (r));
          continue;
        }
      }

      // typeOfMachine
      //
      if (n.name () == "typeOfMachine" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< typeOfMachine_type > r (
          typeOfMachine_traits::create (i, f, this));

        if (!this->typeOfMachine_)
        {
          this->typeOfMachine_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Machine* Machine::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Machine (*this, f, c);
  }

  Machine& Machine::
  operator= (const Machine& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Agent& > (*this) = x;
      this->accessLocation_ = x.accessLocation_;
      this->function_ = x.function_;
      this->machineInterface_ = x.machineInterface_;
      this->name_ = x.name_;
      this->ownerOperatorContact_ = x.ownerOperatorContact_;
      this->typeOfMachine_ = x.typeOfMachine_;
    }

    return *this;
  }

  Machine::
  ~Machine ()
  {
  }

  // MainKeyMember
  //

  MainKeyMember::
  MainKeyMember (const InstanceValue_hasValueFrom_ValueDomain_type& InstanceValue_hasValueFrom_ValueDomain)
  : ::XMLSchema::KeyMember (InstanceValue_hasValueFrom_ValueDomain),
    MainKeyMember_hasValueFrom_SubstantiveValueDomain_ (this)
  {
  }

  MainKeyMember::
  MainKeyMember (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type > InstanceValue_hasValueFrom_ValueDomain)
  : ::XMLSchema::KeyMember (std::move (InstanceValue_hasValueFrom_ValueDomain)),
    MainKeyMember_hasValueFrom_SubstantiveValueDomain_ (this)
  {
  }

  MainKeyMember::
  MainKeyMember (const MainKeyMember& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::XMLSchema::KeyMember (x, f, c),
    MainKeyMember_hasValueFrom_SubstantiveValueDomain_ (x.MainKeyMember_hasValueFrom_SubstantiveValueDomain_, f, this)
  {
  }

  MainKeyMember::
  MainKeyMember (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::XMLSchema::KeyMember (e, f | ::xml_schema::flags::base, c),
    MainKeyMember_hasValueFrom_SubstantiveValueDomain_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MainKeyMember::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::KeyMember::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MainKeyMember_hasValueFrom_SubstantiveValueDomain
      //
      if (n.name () == "MainKeyMember_hasValueFrom_SubstantiveValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< MainKeyMember_hasValueFrom_SubstantiveValueDomain_type > r (
          MainKeyMember_hasValueFrom_SubstantiveValueDomain_traits::create (i, f, this));

        if (!this->MainKeyMember_hasValueFrom_SubstantiveValueDomain_)
        {
          this->MainKeyMember_hasValueFrom_SubstantiveValueDomain_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  MainKeyMember* MainKeyMember::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MainKeyMember (*this, f, c);
  }

  MainKeyMember& MainKeyMember::
  operator= (const MainKeyMember& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::KeyMember& > (*this) = x;
      this->MainKeyMember_hasValueFrom_SubstantiveValueDomain_ = x.MainKeyMember_hasValueFrom_SubstantiveValueDomain_;
    }

    return *this;
  }

  MainKeyMember::
  ~MainKeyMember ()
  {
  }

  // MeasureComponent
  //

  MeasureComponent::
  MeasureComponent ()
  : ::XMLSchema::DataStructureComponent (),
    name_ (this)
  {
  }

  MeasureComponent::
  MeasureComponent (const MeasureComponent& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (x, f, c),
    name_ (x.name_, f, this)
  {
  }

  MeasureComponent::
  MeasureComponent (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (e, f | ::xml_schema::flags::base, c),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MeasureComponent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::DataStructureComponent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  MeasureComponent* MeasureComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MeasureComponent (*this, f, c);
  }

  MeasureComponent& MeasureComponent::
  operator= (const MeasureComponent& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::DataStructureComponent& > (*this) = x;
      this->name_ = x.name_;
    }

    return *this;
  }

  MeasureComponent::
  ~MeasureComponent ()
  {
  }

  // Notation
  //

  Notation::
  Notation ()
  : ::xml_schema::type (),
    content_ (this),
    identifier_ (this),
    whiteSpace_ (this),
    Notation_represents_Category_ (this)
  {
  }

  Notation::
  Notation (const Notation& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_ (x.content_, f, this),
    identifier_ (x.identifier_, f, this),
    whiteSpace_ (x.whiteSpace_, f, this),
    Notation_represents_Category_ (x.Notation_represents_Category_, f, this)
  {
  }

  Notation::
  Notation (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    content_ (this),
    identifier_ (this),
    whiteSpace_ (this),
    Notation_represents_Category_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Notation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // content
      //
      if (n.name () == "content" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< content_type > r (
          content_traits::create (i, f, this));

        if (!this->content_)
        {
          this->content_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // whiteSpace
      //
      if (n.name () == "whiteSpace" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< whiteSpace_type > r (
          whiteSpace_traits::create (i, f, this));

        if (!this->whiteSpace_)
        {
          this->whiteSpace_.set (::std::move (r));
          continue;
        }
      }

      // Notation_represents_Category
      //
      if (n.name () == "Notation_represents_Category" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Notation_represents_Category_type > r (
          Notation_represents_Category_traits::create (i, f, this));

        this->Notation_represents_Category_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Notation* Notation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Notation (*this, f, c);
  }

  Notation& Notation::
  operator= (const Notation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_ = x.content_;
      this->identifier_ = x.identifier_;
      this->whiteSpace_ = x.whiteSpace_;
      this->Notation_represents_Category_ = x.Notation_represents_Category_;
    }

    return *this;
  }

  Notation::
  ~Notation ()
  {
  }

  // Organization
  //

  Organization::
  Organization ()
  : ::XMLSchema::Agent (),
    contactInformation_ (this),
    organizationName_ (this)
  {
  }

  Organization::
  Organization (const Organization& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::XMLSchema::Agent (x, f, c),
    contactInformation_ (x.contactInformation_, f, this),
    organizationName_ (x.organizationName_, f, this)
  {
  }

  Organization::
  Organization (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::XMLSchema::Agent (e, f | ::xml_schema::flags::base, c),
    contactInformation_ (this),
    organizationName_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Organization::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::Agent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // contactInformation
      //
      if (n.name () == "contactInformation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< contactInformation_type > r (
          contactInformation_traits::create (i, f, this));

        if (!this->contactInformation_)
        {
          this->contactInformation_.set (::std::move (r));
          continue;
        }
      }

      // organizationName
      //
      if (n.name () == "organizationName" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< organizationName_type > r (
          organizationName_traits::create (i, f, this));

        this->organizationName_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Organization* Organization::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Organization (*this, f, c);
  }

  Organization& Organization::
  operator= (const Organization& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Agent& > (*this) = x;
      this->contactInformation_ = x.contactInformation_;
      this->organizationName_ = x.organizationName_;
    }

    return *this;
  }

  Organization::
  ~Organization ()
  {
  }

  // Parameter
  //

  Parameter::
  Parameter ()
  : ::xml_schema::type (),
    entityBound_ (this),
    identifier_ (this),
    name_ (this)
  {
  }

  Parameter::
  Parameter (const Parameter& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    entityBound_ (x.entityBound_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this)
  {
  }

  Parameter::
  Parameter (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    entityBound_ (this),
    identifier_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Parameter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // entityBound
      //
      if (n.name () == "entityBound" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< entityBound_type > r (
          entityBound_traits::create (i, f, this));

        this->entityBound_.push_back (::std::move (r));
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Parameter* Parameter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Parameter (*this, f, c);
  }

  Parameter& Parameter::
  operator= (const Parameter& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->entityBound_ = x.entityBound_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
    }

    return *this;
  }

  Parameter::
  ~Parameter ()
  {
  }

  // PhysicalDataSet
  //

  PhysicalDataSet::
  PhysicalDataSet (const allowsDuplicates_type& allowsDuplicates)
  : ::xml_schema::type (),
    allowsDuplicates_ (allowsDuplicates, this),
    catalogDetails_ (this),
    identifier_ (this),
    name_ (this),
    numberOfSegments_ (this),
    overview_ (this),
    physicalFileName_ (this),
    purpose_ (this),
    PhysicalDataSet_isDefinedBy_Concept_ (this),
    PhysicalDataSet_formats_DataStore_ (this),
    PhysicalDataSet_has_InstanceVariable_ (this),
    PhysicalDataSet_has_PhysicalRecordSegment_ (this),
    PhysicalDataSet_has_PhysicalRecordSegmentPosition_ (this)
  {
  }

  PhysicalDataSet::
  PhysicalDataSet (const PhysicalDataSet& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    allowsDuplicates_ (x.allowsDuplicates_, f, this),
    catalogDetails_ (x.catalogDetails_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    numberOfSegments_ (x.numberOfSegments_, f, this),
    overview_ (x.overview_, f, this),
    physicalFileName_ (x.physicalFileName_, f, this),
    purpose_ (x.purpose_, f, this),
    PhysicalDataSet_isDefinedBy_Concept_ (x.PhysicalDataSet_isDefinedBy_Concept_, f, this),
    PhysicalDataSet_formats_DataStore_ (x.PhysicalDataSet_formats_DataStore_, f, this),
    PhysicalDataSet_has_InstanceVariable_ (x.PhysicalDataSet_has_InstanceVariable_, f, this),
    PhysicalDataSet_has_PhysicalRecordSegment_ (x.PhysicalDataSet_has_PhysicalRecordSegment_, f, this),
    PhysicalDataSet_has_PhysicalRecordSegmentPosition_ (x.PhysicalDataSet_has_PhysicalRecordSegmentPosition_, f, this)
  {
  }

  PhysicalDataSet::
  PhysicalDataSet (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    allowsDuplicates_ (this),
    catalogDetails_ (this),
    identifier_ (this),
    name_ (this),
    numberOfSegments_ (this),
    overview_ (this),
    physicalFileName_ (this),
    purpose_ (this),
    PhysicalDataSet_isDefinedBy_Concept_ (this),
    PhysicalDataSet_formats_DataStore_ (this),
    PhysicalDataSet_has_InstanceVariable_ (this),
    PhysicalDataSet_has_PhysicalRecordSegment_ (this),
    PhysicalDataSet_has_PhysicalRecordSegmentPosition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PhysicalDataSet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // allowsDuplicates
      //
      if (n.name () == "allowsDuplicates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!allowsDuplicates_.present ())
        {
          this->allowsDuplicates_.set (allowsDuplicates_traits::create (i, f, this));
          continue;
        }
      }

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!this->name_)
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // numberOfSegments
      //
      if (n.name () == "numberOfSegments" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->numberOfSegments_)
        {
          this->numberOfSegments_.set (numberOfSegments_traits::create (i, f, this));
          continue;
        }
      }

      // overview
      //
      if (n.name () == "overview" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< overview_type > r (
          overview_traits::create (i, f, this));

        if (!this->overview_)
        {
          this->overview_.set (::std::move (r));
          continue;
        }
      }

      // physicalFileName
      //
      if (n.name () == "physicalFileName" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< physicalFileName_type > r (
          physicalFileName_traits::create (i, f, this));

        if (!this->physicalFileName_)
        {
          this->physicalFileName_.set (::std::move (r));
          continue;
        }
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalDataSet_isDefinedBy_Concept
      //
      if (n.name () == "PhysicalDataSet_isDefinedBy_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalDataSet_isDefinedBy_Concept_type > r (
          PhysicalDataSet_isDefinedBy_Concept_traits::create (i, f, this));

        this->PhysicalDataSet_isDefinedBy_Concept_.push_back (::std::move (r));
        continue;
      }

      // PhysicalDataSet_formats_DataStore
      //
      if (n.name () == "PhysicalDataSet_formats_DataStore" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalDataSet_formats_DataStore_type > r (
          PhysicalDataSet_formats_DataStore_traits::create (i, f, this));

        this->PhysicalDataSet_formats_DataStore_.push_back (::std::move (r));
        continue;
      }

      // PhysicalDataSet_has_InstanceVariable
      //
      if (n.name () == "PhysicalDataSet_has_InstanceVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalDataSet_has_InstanceVariable_type > r (
          PhysicalDataSet_has_InstanceVariable_traits::create (i, f, this));

        this->PhysicalDataSet_has_InstanceVariable_.push_back (::std::move (r));
        continue;
      }

      // PhysicalDataSet_has_PhysicalRecordSegment
      //
      if (n.name () == "PhysicalDataSet_has_PhysicalRecordSegment" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalDataSet_has_PhysicalRecordSegment_type > r (
          PhysicalDataSet_has_PhysicalRecordSegment_traits::create (i, f, this));

        this->PhysicalDataSet_has_PhysicalRecordSegment_.push_back (::std::move (r));
        continue;
      }

      // PhysicalDataSet_has_PhysicalRecordSegmentPosition
      //
      if (n.name () == "PhysicalDataSet_has_PhysicalRecordSegmentPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalDataSet_has_PhysicalRecordSegmentPosition_type > r (
          PhysicalDataSet_has_PhysicalRecordSegmentPosition_traits::create (i, f, this));

        this->PhysicalDataSet_has_PhysicalRecordSegmentPosition_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!allowsDuplicates_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "allowsDuplicates",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  PhysicalDataSet* PhysicalDataSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalDataSet (*this, f, c);
  }

  PhysicalDataSet& PhysicalDataSet::
  operator= (const PhysicalDataSet& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->allowsDuplicates_ = x.allowsDuplicates_;
      this->catalogDetails_ = x.catalogDetails_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->numberOfSegments_ = x.numberOfSegments_;
      this->overview_ = x.overview_;
      this->physicalFileName_ = x.physicalFileName_;
      this->purpose_ = x.purpose_;
      this->PhysicalDataSet_isDefinedBy_Concept_ = x.PhysicalDataSet_isDefinedBy_Concept_;
      this->PhysicalDataSet_formats_DataStore_ = x.PhysicalDataSet_formats_DataStore_;
      this->PhysicalDataSet_has_InstanceVariable_ = x.PhysicalDataSet_has_InstanceVariable_;
      this->PhysicalDataSet_has_PhysicalRecordSegment_ = x.PhysicalDataSet_has_PhysicalRecordSegment_;
      this->PhysicalDataSet_has_PhysicalRecordSegmentPosition_ = x.PhysicalDataSet_has_PhysicalRecordSegmentPosition_;
    }

    return *this;
  }

  PhysicalDataSet::
  ~PhysicalDataSet ()
  {
  }

  // PhysicalDataSetStructure
  //

  PhysicalDataSetStructure::
  PhysicalDataSetStructure ()
  : ::xml_schema::type (),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    PhysicalDataSetStructure_structures_PhysicalDataSet_ (this),
    PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_ (this)
  {
  }

  PhysicalDataSetStructure::
  PhysicalDataSetStructure (const PhysicalDataSetStructure& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    semantics_ (x.semantics_, f, this),
    specification_ (x.specification_, f, this),
    topology_ (x.topology_, f, this),
    totality_ (x.totality_, f, this),
    PhysicalDataSetStructure_structures_PhysicalDataSet_ (x.PhysicalDataSetStructure_structures_PhysicalDataSet_, f, this),
    PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_ (x.PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_, f, this)
  {
  }

  PhysicalDataSetStructure::
  PhysicalDataSetStructure (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    PhysicalDataSetStructure_structures_PhysicalDataSet_ (this),
    PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PhysicalDataSetStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!this->name_)
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // specification
      //
      if (n.name () == "specification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< specification_type > r (
          specification_traits::create (i, f, this));

        if (!this->specification_)
        {
          this->specification_.set (::std::move (r));
          continue;
        }
      }

      // topology
      //
      if (n.name () == "topology" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< topology_type > r (
          topology_traits::create (i, f, this));

        if (!this->topology_)
        {
          this->topology_.set (::std::move (r));
          continue;
        }
      }

      // totality
      //
      if (n.name () == "totality" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< totality_type > r (
          totality_traits::create (i, f, this));

        if (!this->totality_)
        {
          this->totality_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalDataSetStructure_structures_PhysicalDataSet
      //
      if (n.name () == "PhysicalDataSetStructure_structures_PhysicalDataSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalDataSetStructure_structures_PhysicalDataSet_type > r (
          PhysicalDataSetStructure_structures_PhysicalDataSet_traits::create (i, f, this));

        if (!this->PhysicalDataSetStructure_structures_PhysicalDataSet_)
        {
          this->PhysicalDataSetStructure_structures_PhysicalDataSet_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship
      //
      if (n.name () == "PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_type > r (
          PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_traits::create (i, f, this));

        this->PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  PhysicalDataSetStructure* PhysicalDataSetStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalDataSetStructure (*this, f, c);
  }

  PhysicalDataSetStructure& PhysicalDataSetStructure::
  operator= (const PhysicalDataSetStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->semantics_ = x.semantics_;
      this->specification_ = x.specification_;
      this->topology_ = x.topology_;
      this->totality_ = x.totality_;
      this->PhysicalDataSetStructure_structures_PhysicalDataSet_ = x.PhysicalDataSetStructure_structures_PhysicalDataSet_;
      this->PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_ = x.PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_;
    }

    return *this;
  }

  PhysicalDataSetStructure::
  ~PhysicalDataSetStructure ()
  {
  }

  // PhysicalLayoutRelationStructure
  //

  PhysicalLayoutRelationStructure::
  PhysicalLayoutRelationStructure (const topology_type& topology)
  : ::xml_schema::type (),
    criteria_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (topology, this),
    totality_ (this),
    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_ (this),
    PhysicalLayoutRelationStructure_has_ValueMappingRelationship_ (this)
  {
  }

  PhysicalLayoutRelationStructure::
  PhysicalLayoutRelationStructure (::std::unique_ptr< topology_type > topology)
  : ::xml_schema::type (),
    criteria_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (std::move (topology), this),
    totality_ (this),
    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_ (this),
    PhysicalLayoutRelationStructure_has_ValueMappingRelationship_ (this)
  {
  }

  PhysicalLayoutRelationStructure::
  PhysicalLayoutRelationStructure (const PhysicalLayoutRelationStructure& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    criteria_ (x.criteria_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    semantics_ (x.semantics_, f, this),
    specification_ (x.specification_, f, this),
    topology_ (x.topology_, f, this),
    totality_ (x.totality_, f, this),
    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_ (x.PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_, f, this),
    PhysicalLayoutRelationStructure_has_ValueMappingRelationship_ (x.PhysicalLayoutRelationStructure_has_ValueMappingRelationship_, f, this)
  {
  }

  PhysicalLayoutRelationStructure::
  PhysicalLayoutRelationStructure (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    criteria_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_ (this),
    PhysicalLayoutRelationStructure_has_ValueMappingRelationship_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PhysicalLayoutRelationStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // criteria
      //
      if (n.name () == "criteria" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< criteria_type > r (
          criteria_traits::create (i, f, this));

        if (!this->criteria_)
        {
          this->criteria_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // specification
      //
      if (n.name () == "specification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< specification_type > r (
          specification_traits::create (i, f, this));

        if (!this->specification_)
        {
          this->specification_.set (::std::move (r));
          continue;
        }
      }

      // topology
      //
      if (n.name () == "topology" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< topology_type > r (
          topology_traits::create (i, f, this));

        if (!topology_.present ())
        {
          this->topology_.set (::std::move (r));
          continue;
        }
      }

      // totality
      //
      if (n.name () == "totality" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< totality_type > r (
          totality_traits::create (i, f, this));

        if (!this->totality_)
        {
          this->totality_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout
      //
      if (n.name () == "PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_type > r (
          PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_traits::create (i, f, this));

        if (!this->PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_)
        {
          this->PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalLayoutRelationStructure_has_ValueMappingRelationship
      //
      if (n.name () == "PhysicalLayoutRelationStructure_has_ValueMappingRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalLayoutRelationStructure_has_ValueMappingRelationship_type > r (
          PhysicalLayoutRelationStructure_has_ValueMappingRelationship_traits::create (i, f, this));

        this->PhysicalLayoutRelationStructure_has_ValueMappingRelationship_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!topology_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "topology",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  PhysicalLayoutRelationStructure* PhysicalLayoutRelationStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalLayoutRelationStructure (*this, f, c);
  }

  PhysicalLayoutRelationStructure& PhysicalLayoutRelationStructure::
  operator= (const PhysicalLayoutRelationStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->criteria_ = x.criteria_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->semantics_ = x.semantics_;
      this->specification_ = x.specification_;
      this->topology_ = x.topology_;
      this->totality_ = x.totality_;
      this->PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_ = x.PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_;
      this->PhysicalLayoutRelationStructure_has_ValueMappingRelationship_ = x.PhysicalLayoutRelationStructure_has_ValueMappingRelationship_;
    }

    return *this;
  }

  PhysicalLayoutRelationStructure::
  ~PhysicalLayoutRelationStructure ()
  {
  }

  // PhysicalRecordSegment
  //

  PhysicalRecordSegment::
  PhysicalRecordSegment (const allowsDuplicates_type& allowsDuplicates)
  : ::xml_schema::type (),
    allowsDuplicates_ (allowsDuplicates, this),
    catalogDetails_ (this),
    identifier_ (this),
    name_ (this),
    physicalFileName_ (this),
    purpose_ (this),
    PhysicalRecordSegment_represents_Population_ (this),
    PhysicalRecordSegment_isDefinedBy_Concept_ (this),
    PhysicalRecordSegment_has_PhysicalSegmentLayout_ (this),
    PhysicalRecordSegment_mapsTo_LogicalRecord_ (this),
    PhysicalRecordSegment_has_DataPointPosition_ (this),
    PhysicalRecordSegment_has_DataPoint_ (this)
  {
  }

  PhysicalRecordSegment::
  PhysicalRecordSegment (const PhysicalRecordSegment& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    allowsDuplicates_ (x.allowsDuplicates_, f, this),
    catalogDetails_ (x.catalogDetails_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    physicalFileName_ (x.physicalFileName_, f, this),
    purpose_ (x.purpose_, f, this),
    PhysicalRecordSegment_represents_Population_ (x.PhysicalRecordSegment_represents_Population_, f, this),
    PhysicalRecordSegment_isDefinedBy_Concept_ (x.PhysicalRecordSegment_isDefinedBy_Concept_, f, this),
    PhysicalRecordSegment_has_PhysicalSegmentLayout_ (x.PhysicalRecordSegment_has_PhysicalSegmentLayout_, f, this),
    PhysicalRecordSegment_mapsTo_LogicalRecord_ (x.PhysicalRecordSegment_mapsTo_LogicalRecord_, f, this),
    PhysicalRecordSegment_has_DataPointPosition_ (x.PhysicalRecordSegment_has_DataPointPosition_, f, this),
    PhysicalRecordSegment_has_DataPoint_ (x.PhysicalRecordSegment_has_DataPoint_, f, this)
  {
  }

  PhysicalRecordSegment::
  PhysicalRecordSegment (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    allowsDuplicates_ (this),
    catalogDetails_ (this),
    identifier_ (this),
    name_ (this),
    physicalFileName_ (this),
    purpose_ (this),
    PhysicalRecordSegment_represents_Population_ (this),
    PhysicalRecordSegment_isDefinedBy_Concept_ (this),
    PhysicalRecordSegment_has_PhysicalSegmentLayout_ (this),
    PhysicalRecordSegment_mapsTo_LogicalRecord_ (this),
    PhysicalRecordSegment_has_DataPointPosition_ (this),
    PhysicalRecordSegment_has_DataPoint_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PhysicalRecordSegment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // allowsDuplicates
      //
      if (n.name () == "allowsDuplicates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!allowsDuplicates_.present ())
        {
          this->allowsDuplicates_.set (allowsDuplicates_traits::create (i, f, this));
          continue;
        }
      }

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // physicalFileName
      //
      if (n.name () == "physicalFileName" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< physicalFileName_type > r (
          physicalFileName_traits::create (i, f, this));

        if (!this->physicalFileName_)
        {
          this->physicalFileName_.set (::std::move (r));
          continue;
        }
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalRecordSegment_represents_Population
      //
      if (n.name () == "PhysicalRecordSegment_represents_Population" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegment_represents_Population_type > r (
          PhysicalRecordSegment_represents_Population_traits::create (i, f, this));

        if (!this->PhysicalRecordSegment_represents_Population_)
        {
          this->PhysicalRecordSegment_represents_Population_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalRecordSegment_isDefinedBy_Concept
      //
      if (n.name () == "PhysicalRecordSegment_isDefinedBy_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegment_isDefinedBy_Concept_type > r (
          PhysicalRecordSegment_isDefinedBy_Concept_traits::create (i, f, this));

        this->PhysicalRecordSegment_isDefinedBy_Concept_.push_back (::std::move (r));
        continue;
      }

      // PhysicalRecordSegment_has_PhysicalSegmentLayout
      //
      if (n.name () == "PhysicalRecordSegment_has_PhysicalSegmentLayout" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegment_has_PhysicalSegmentLayout_type > r (
          PhysicalRecordSegment_has_PhysicalSegmentLayout_traits::create (i, f, this));

        if (!this->PhysicalRecordSegment_has_PhysicalSegmentLayout_)
        {
          this->PhysicalRecordSegment_has_PhysicalSegmentLayout_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalRecordSegment_mapsTo_LogicalRecord
      //
      if (n.name () == "PhysicalRecordSegment_mapsTo_LogicalRecord" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegment_mapsTo_LogicalRecord_type > r (
          PhysicalRecordSegment_mapsTo_LogicalRecord_traits::create (i, f, this));

        if (!this->PhysicalRecordSegment_mapsTo_LogicalRecord_)
        {
          this->PhysicalRecordSegment_mapsTo_LogicalRecord_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalRecordSegment_has_DataPointPosition
      //
      if (n.name () == "PhysicalRecordSegment_has_DataPointPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegment_has_DataPointPosition_type > r (
          PhysicalRecordSegment_has_DataPointPosition_traits::create (i, f, this));

        this->PhysicalRecordSegment_has_DataPointPosition_.push_back (::std::move (r));
        continue;
      }

      // PhysicalRecordSegment_has_DataPoint
      //
      if (n.name () == "PhysicalRecordSegment_has_DataPoint" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegment_has_DataPoint_type > r (
          PhysicalRecordSegment_has_DataPoint_traits::create (i, f, this));

        this->PhysicalRecordSegment_has_DataPoint_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!allowsDuplicates_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "allowsDuplicates",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  PhysicalRecordSegment* PhysicalRecordSegment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegment (*this, f, c);
  }

  PhysicalRecordSegment& PhysicalRecordSegment::
  operator= (const PhysicalRecordSegment& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->allowsDuplicates_ = x.allowsDuplicates_;
      this->catalogDetails_ = x.catalogDetails_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->physicalFileName_ = x.physicalFileName_;
      this->purpose_ = x.purpose_;
      this->PhysicalRecordSegment_represents_Population_ = x.PhysicalRecordSegment_represents_Population_;
      this->PhysicalRecordSegment_isDefinedBy_Concept_ = x.PhysicalRecordSegment_isDefinedBy_Concept_;
      this->PhysicalRecordSegment_has_PhysicalSegmentLayout_ = x.PhysicalRecordSegment_has_PhysicalSegmentLayout_;
      this->PhysicalRecordSegment_mapsTo_LogicalRecord_ = x.PhysicalRecordSegment_mapsTo_LogicalRecord_;
      this->PhysicalRecordSegment_has_DataPointPosition_ = x.PhysicalRecordSegment_has_DataPointPosition_;
      this->PhysicalRecordSegment_has_DataPoint_ = x.PhysicalRecordSegment_has_DataPoint_;
    }

    return *this;
  }

  PhysicalRecordSegment::
  ~PhysicalRecordSegment ()
  {
  }

  // PhysicalRecordSegmentPosition
  //

  PhysicalRecordSegmentPosition::
  PhysicalRecordSegmentPosition (const value_type& value,
                                 const PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type& PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_ (PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment, this)
  {
  }

  PhysicalRecordSegmentPosition::
  PhysicalRecordSegmentPosition (const value_type& value,
                                 ::std::unique_ptr< PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type > PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_ (std::move (PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment), this)
  {
  }

  PhysicalRecordSegmentPosition::
  PhysicalRecordSegmentPosition (const PhysicalRecordSegmentPosition& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    value_ (x.value_, f, this),
    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_ (x.PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_, f, this)
  {
  }

  PhysicalRecordSegmentPosition::
  PhysicalRecordSegmentPosition (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    value_ (this),
    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PhysicalRecordSegmentPosition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      // PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment
      //
      if (n.name () == "PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type > r (
          PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_traits::create (i, f, this));

        if (!PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_.present ())
        {
          this->PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  PhysicalRecordSegmentPosition* PhysicalRecordSegmentPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegmentPosition (*this, f, c);
  }

  PhysicalRecordSegmentPosition& PhysicalRecordSegmentPosition::
  operator= (const PhysicalRecordSegmentPosition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->value_ = x.value_;
      this->PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_ = x.PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_;
    }

    return *this;
  }

  PhysicalRecordSegmentPosition::
  ~PhysicalRecordSegmentPosition ()
  {
  }

  // PhysicalRecordSegmentRelationship
  //

  PhysicalRecordSegmentRelationship::
  PhysicalRecordSegmentRelationship ()
  : ::xml_schema::type (),
    identifier_ (this),
    semantics_ (this),
    PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_ (this),
    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_ (this)
  {
  }

  PhysicalRecordSegmentRelationship::
  PhysicalRecordSegmentRelationship (const PhysicalRecordSegmentRelationship& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    semantics_ (x.semantics_, f, this),
    PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_ (x.PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_, f, this),
    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_ (x.PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_, f, this)
  {
  }

  PhysicalRecordSegmentRelationship::
  PhysicalRecordSegmentRelationship (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    semantics_ (this),
    PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_ (this),
    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PhysicalRecordSegmentRelationship::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment
      //
      if (n.name () == "PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_type > r (
          PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_traits::create (i, f, this));

        this->PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_.push_back (::std::move (r));
        continue;
      }

      // PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment
      //
      if (n.name () == "PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_type > r (
          PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_traits::create (i, f, this));

        if (!this->PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_)
        {
          this->PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  PhysicalRecordSegmentRelationship* PhysicalRecordSegmentRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegmentRelationship (*this, f, c);
  }

  PhysicalRecordSegmentRelationship& PhysicalRecordSegmentRelationship::
  operator= (const PhysicalRecordSegmentRelationship& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->semantics_ = x.semantics_;
      this->PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_ = x.PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_;
      this->PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_ = x.PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_;
    }

    return *this;
  }

  PhysicalRecordSegmentRelationship::
  ~PhysicalRecordSegmentRelationship ()
  {
  }

  // PhysicalRecordSegmentStructure
  //

  PhysicalRecordSegmentStructure::
  PhysicalRecordSegmentStructure ()
  : ::xml_schema::type (),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_ (this),
    PhysicalRecordSegmentStructure_has_DataPointRelationship_ (this)
  {
  }

  PhysicalRecordSegmentStructure::
  PhysicalRecordSegmentStructure (const PhysicalRecordSegmentStructure& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    semantics_ (x.semantics_, f, this),
    specification_ (x.specification_, f, this),
    topology_ (x.topology_, f, this),
    totality_ (x.totality_, f, this),
    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_ (x.PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_, f, this),
    PhysicalRecordSegmentStructure_has_DataPointRelationship_ (x.PhysicalRecordSegmentStructure_has_DataPointRelationship_, f, this)
  {
  }

  PhysicalRecordSegmentStructure::
  PhysicalRecordSegmentStructure (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_ (this),
    PhysicalRecordSegmentStructure_has_DataPointRelationship_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PhysicalRecordSegmentStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!this->name_)
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // specification
      //
      if (n.name () == "specification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< specification_type > r (
          specification_traits::create (i, f, this));

        if (!this->specification_)
        {
          this->specification_.set (::std::move (r));
          continue;
        }
      }

      // topology
      //
      if (n.name () == "topology" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< topology_type > r (
          topology_traits::create (i, f, this));

        if (!this->topology_)
        {
          this->topology_.set (::std::move (r));
          continue;
        }
      }

      // totality
      //
      if (n.name () == "totality" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< totality_type > r (
          totality_traits::create (i, f, this));

        if (!this->totality_)
        {
          this->totality_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment
      //
      if (n.name () == "PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_type > r (
          PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_traits::create (i, f, this));

        if (!this->PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_)
        {
          this->PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalRecordSegmentStructure_has_DataPointRelationship
      //
      if (n.name () == "PhysicalRecordSegmentStructure_has_DataPointRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalRecordSegmentStructure_has_DataPointRelationship_type > r (
          PhysicalRecordSegmentStructure_has_DataPointRelationship_traits::create (i, f, this));

        this->PhysicalRecordSegmentStructure_has_DataPointRelationship_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  PhysicalRecordSegmentStructure* PhysicalRecordSegmentStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegmentStructure (*this, f, c);
  }

  PhysicalRecordSegmentStructure& PhysicalRecordSegmentStructure::
  operator= (const PhysicalRecordSegmentStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->semantics_ = x.semantics_;
      this->specification_ = x.specification_;
      this->topology_ = x.topology_;
      this->totality_ = x.totality_;
      this->PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_ = x.PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_;
      this->PhysicalRecordSegmentStructure_has_DataPointRelationship_ = x.PhysicalRecordSegmentStructure_has_DataPointRelationship_;
    }

    return *this;
  }

  PhysicalRecordSegmentStructure::
  ~PhysicalRecordSegmentStructure ()
  {
  }

  // PhysicalSegmentLayout
  //

  PhysicalSegmentLayout::
  PhysicalSegmentLayout (const allowsDuplicates_type& allowsDuplicates,
                         const isDelimited_type& isDelimited,
                         const isFixedWidth_type& isFixedWidth)
  : ::xml_schema::type (),
    allowsDuplicates_ (allowsDuplicates, this),
    arrayBase_ (this),
    catalogDetails_ (this),
    commentPrefix_ (this),
    delimiter_ (this),
    encoding_ (this),
    escapeCharacter_ (this),
    hasHeader_ (this),
    headerIsCaseSensitive_ (this),
    headerRowCount_ (this),
    identifier_ (this),
    isDelimited_ (isDelimited, this),
    isFixedWidth_ (isFixedWidth, this),
    lineTerminator_ (this),
    name_ (this),
    nullSequence_ (this),
    overview_ (this),
    purpose_ (this),
    quoteCharacter_ (this),
    skipBlankRows_ (this),
    skipDataColumns_ (this),
    skipInitialSpace_ (this),
    skipRows_ (this),
    tableDirection_ (this),
    textDirection_ (this),
    treatConsecutiveDelimitersAsOne_ (this),
    trim_ (this),
    PhysicalSegmentLayout_isDefinedBy_Concept_ (this),
    PhysicalSegmentLayout_formats_LogicalRecord_ (this),
    PhysicalSegmentLayout_has_ValueMapping_ (this),
    PhysicalSegmentLayout_has_ValueMappingPosition_ (this)
  {
  }

  PhysicalSegmentLayout::
  PhysicalSegmentLayout (const PhysicalSegmentLayout& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    allowsDuplicates_ (x.allowsDuplicates_, f, this),
    arrayBase_ (x.arrayBase_, f, this),
    catalogDetails_ (x.catalogDetails_, f, this),
    commentPrefix_ (x.commentPrefix_, f, this),
    delimiter_ (x.delimiter_, f, this),
    encoding_ (x.encoding_, f, this),
    escapeCharacter_ (x.escapeCharacter_, f, this),
    hasHeader_ (x.hasHeader_, f, this),
    headerIsCaseSensitive_ (x.headerIsCaseSensitive_, f, this),
    headerRowCount_ (x.headerRowCount_, f, this),
    identifier_ (x.identifier_, f, this),
    isDelimited_ (x.isDelimited_, f, this),
    isFixedWidth_ (x.isFixedWidth_, f, this),
    lineTerminator_ (x.lineTerminator_, f, this),
    name_ (x.name_, f, this),
    nullSequence_ (x.nullSequence_, f, this),
    overview_ (x.overview_, f, this),
    purpose_ (x.purpose_, f, this),
    quoteCharacter_ (x.quoteCharacter_, f, this),
    skipBlankRows_ (x.skipBlankRows_, f, this),
    skipDataColumns_ (x.skipDataColumns_, f, this),
    skipInitialSpace_ (x.skipInitialSpace_, f, this),
    skipRows_ (x.skipRows_, f, this),
    tableDirection_ (x.tableDirection_, f, this),
    textDirection_ (x.textDirection_, f, this),
    treatConsecutiveDelimitersAsOne_ (x.treatConsecutiveDelimitersAsOne_, f, this),
    trim_ (x.trim_, f, this),
    PhysicalSegmentLayout_isDefinedBy_Concept_ (x.PhysicalSegmentLayout_isDefinedBy_Concept_, f, this),
    PhysicalSegmentLayout_formats_LogicalRecord_ (x.PhysicalSegmentLayout_formats_LogicalRecord_, f, this),
    PhysicalSegmentLayout_has_ValueMapping_ (x.PhysicalSegmentLayout_has_ValueMapping_, f, this),
    PhysicalSegmentLayout_has_ValueMappingPosition_ (x.PhysicalSegmentLayout_has_ValueMappingPosition_, f, this)
  {
  }

  PhysicalSegmentLayout::
  PhysicalSegmentLayout (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    allowsDuplicates_ (this),
    arrayBase_ (this),
    catalogDetails_ (this),
    commentPrefix_ (this),
    delimiter_ (this),
    encoding_ (this),
    escapeCharacter_ (this),
    hasHeader_ (this),
    headerIsCaseSensitive_ (this),
    headerRowCount_ (this),
    identifier_ (this),
    isDelimited_ (this),
    isFixedWidth_ (this),
    lineTerminator_ (this),
    name_ (this),
    nullSequence_ (this),
    overview_ (this),
    purpose_ (this),
    quoteCharacter_ (this),
    skipBlankRows_ (this),
    skipDataColumns_ (this),
    skipInitialSpace_ (this),
    skipRows_ (this),
    tableDirection_ (this),
    textDirection_ (this),
    treatConsecutiveDelimitersAsOne_ (this),
    trim_ (this),
    PhysicalSegmentLayout_isDefinedBy_Concept_ (this),
    PhysicalSegmentLayout_formats_LogicalRecord_ (this),
    PhysicalSegmentLayout_has_ValueMapping_ (this),
    PhysicalSegmentLayout_has_ValueMappingPosition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PhysicalSegmentLayout::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // allowsDuplicates
      //
      if (n.name () == "allowsDuplicates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!allowsDuplicates_.present ())
        {
          this->allowsDuplicates_.set (allowsDuplicates_traits::create (i, f, this));
          continue;
        }
      }

      // arrayBase
      //
      if (n.name () == "arrayBase" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->arrayBase_)
        {
          this->arrayBase_.set (arrayBase_traits::create (i, f, this));
          continue;
        }
      }

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // commentPrefix
      //
      if (n.name () == "commentPrefix" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< commentPrefix_type > r (
          commentPrefix_traits::create (i, f, this));

        if (!this->commentPrefix_)
        {
          this->commentPrefix_.set (::std::move (r));
          continue;
        }
      }

      // delimiter
      //
      if (n.name () == "delimiter" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< delimiter_type > r (
          delimiter_traits::create (i, f, this));

        if (!this->delimiter_)
        {
          this->delimiter_.set (::std::move (r));
          continue;
        }
      }

      // encoding
      //
      if (n.name () == "encoding" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< encoding_type > r (
          encoding_traits::create (i, f, this));

        if (!this->encoding_)
        {
          this->encoding_.set (::std::move (r));
          continue;
        }
      }

      // escapeCharacter
      //
      if (n.name () == "escapeCharacter" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< escapeCharacter_type > r (
          escapeCharacter_traits::create (i, f, this));

        if (!this->escapeCharacter_)
        {
          this->escapeCharacter_.set (::std::move (r));
          continue;
        }
      }

      // hasHeader
      //
      if (n.name () == "hasHeader" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->hasHeader_)
        {
          this->hasHeader_.set (hasHeader_traits::create (i, f, this));
          continue;
        }
      }

      // headerIsCaseSensitive
      //
      if (n.name () == "headerIsCaseSensitive" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->headerIsCaseSensitive_)
        {
          this->headerIsCaseSensitive_.set (headerIsCaseSensitive_traits::create (i, f, this));
          continue;
        }
      }

      // headerRowCount
      //
      if (n.name () == "headerRowCount" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->headerRowCount_)
        {
          this->headerRowCount_.set (headerRowCount_traits::create (i, f, this));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // isDelimited
      //
      if (n.name () == "isDelimited" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!isDelimited_.present ())
        {
          this->isDelimited_.set (isDelimited_traits::create (i, f, this));
          continue;
        }
      }

      // isFixedWidth
      //
      if (n.name () == "isFixedWidth" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!isFixedWidth_.present ())
        {
          this->isFixedWidth_.set (isFixedWidth_traits::create (i, f, this));
          continue;
        }
      }

      // lineTerminator
      //
      if (n.name () == "lineTerminator" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< lineTerminator_type > r (
          lineTerminator_traits::create (i, f, this));

        this->lineTerminator_.push_back (::std::move (r));
        continue;
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // nullSequence
      //
      if (n.name () == "nullSequence" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< nullSequence_type > r (
          nullSequence_traits::create (i, f, this));

        if (!this->nullSequence_)
        {
          this->nullSequence_.set (::std::move (r));
          continue;
        }
      }

      // overview
      //
      if (n.name () == "overview" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< overview_type > r (
          overview_traits::create (i, f, this));

        if (!this->overview_)
        {
          this->overview_.set (::std::move (r));
          continue;
        }
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // quoteCharacter
      //
      if (n.name () == "quoteCharacter" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< quoteCharacter_type > r (
          quoteCharacter_traits::create (i, f, this));

        if (!this->quoteCharacter_)
        {
          this->quoteCharacter_.set (::std::move (r));
          continue;
        }
      }

      // skipBlankRows
      //
      if (n.name () == "skipBlankRows" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->skipBlankRows_)
        {
          this->skipBlankRows_.set (skipBlankRows_traits::create (i, f, this));
          continue;
        }
      }

      // skipDataColumns
      //
      if (n.name () == "skipDataColumns" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->skipDataColumns_)
        {
          this->skipDataColumns_.set (skipDataColumns_traits::create (i, f, this));
          continue;
        }
      }

      // skipInitialSpace
      //
      if (n.name () == "skipInitialSpace" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->skipInitialSpace_)
        {
          this->skipInitialSpace_.set (skipInitialSpace_traits::create (i, f, this));
          continue;
        }
      }

      // skipRows
      //
      if (n.name () == "skipRows" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->skipRows_)
        {
          this->skipRows_.set (skipRows_traits::create (i, f, this));
          continue;
        }
      }

      // tableDirection
      //
      if (n.name () == "tableDirection" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< tableDirection_type > r (
          tableDirection_traits::create (i, f, this));

        if (!this->tableDirection_)
        {
          this->tableDirection_.set (::std::move (r));
          continue;
        }
      }

      // textDirection
      //
      if (n.name () == "textDirection" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< textDirection_type > r (
          textDirection_traits::create (i, f, this));

        if (!this->textDirection_)
        {
          this->textDirection_.set (::std::move (r));
          continue;
        }
      }

      // treatConsecutiveDelimitersAsOne
      //
      if (n.name () == "treatConsecutiveDelimitersAsOne" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->treatConsecutiveDelimitersAsOne_)
        {
          this->treatConsecutiveDelimitersAsOne_.set (treatConsecutiveDelimitersAsOne_traits::create (i, f, this));
          continue;
        }
      }

      // trim
      //
      if (n.name () == "trim" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< trim_type > r (
          trim_traits::create (i, f, this));

        if (!this->trim_)
        {
          this->trim_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalSegmentLayout_isDefinedBy_Concept
      //
      if (n.name () == "PhysicalSegmentLayout_isDefinedBy_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalSegmentLayout_isDefinedBy_Concept_type > r (
          PhysicalSegmentLayout_isDefinedBy_Concept_traits::create (i, f, this));

        this->PhysicalSegmentLayout_isDefinedBy_Concept_.push_back (::std::move (r));
        continue;
      }

      // PhysicalSegmentLayout_formats_LogicalRecord
      //
      if (n.name () == "PhysicalSegmentLayout_formats_LogicalRecord" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalSegmentLayout_formats_LogicalRecord_type > r (
          PhysicalSegmentLayout_formats_LogicalRecord_traits::create (i, f, this));

        if (!this->PhysicalSegmentLayout_formats_LogicalRecord_)
        {
          this->PhysicalSegmentLayout_formats_LogicalRecord_.set (::std::move (r));
          continue;
        }
      }

      // PhysicalSegmentLayout_has_ValueMapping
      //
      if (n.name () == "PhysicalSegmentLayout_has_ValueMapping" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalSegmentLayout_has_ValueMapping_type > r (
          PhysicalSegmentLayout_has_ValueMapping_traits::create (i, f, this));

        this->PhysicalSegmentLayout_has_ValueMapping_.push_back (::std::move (r));
        continue;
      }

      // PhysicalSegmentLayout_has_ValueMappingPosition
      //
      if (n.name () == "PhysicalSegmentLayout_has_ValueMappingPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PhysicalSegmentLayout_has_ValueMappingPosition_type > r (
          PhysicalSegmentLayout_has_ValueMappingPosition_traits::create (i, f, this));

        this->PhysicalSegmentLayout_has_ValueMappingPosition_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!allowsDuplicates_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "allowsDuplicates",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!isDelimited_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "isDelimited",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!isFixedWidth_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "isFixedWidth",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  PhysicalSegmentLayout* PhysicalSegmentLayout::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalSegmentLayout (*this, f, c);
  }

  PhysicalSegmentLayout& PhysicalSegmentLayout::
  operator= (const PhysicalSegmentLayout& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->allowsDuplicates_ = x.allowsDuplicates_;
      this->arrayBase_ = x.arrayBase_;
      this->catalogDetails_ = x.catalogDetails_;
      this->commentPrefix_ = x.commentPrefix_;
      this->delimiter_ = x.delimiter_;
      this->encoding_ = x.encoding_;
      this->escapeCharacter_ = x.escapeCharacter_;
      this->hasHeader_ = x.hasHeader_;
      this->headerIsCaseSensitive_ = x.headerIsCaseSensitive_;
      this->headerRowCount_ = x.headerRowCount_;
      this->identifier_ = x.identifier_;
      this->isDelimited_ = x.isDelimited_;
      this->isFixedWidth_ = x.isFixedWidth_;
      this->lineTerminator_ = x.lineTerminator_;
      this->name_ = x.name_;
      this->nullSequence_ = x.nullSequence_;
      this->overview_ = x.overview_;
      this->purpose_ = x.purpose_;
      this->quoteCharacter_ = x.quoteCharacter_;
      this->skipBlankRows_ = x.skipBlankRows_;
      this->skipDataColumns_ = x.skipDataColumns_;
      this->skipInitialSpace_ = x.skipInitialSpace_;
      this->skipRows_ = x.skipRows_;
      this->tableDirection_ = x.tableDirection_;
      this->textDirection_ = x.textDirection_;
      this->treatConsecutiveDelimitersAsOne_ = x.treatConsecutiveDelimitersAsOne_;
      this->trim_ = x.trim_;
      this->PhysicalSegmentLayout_isDefinedBy_Concept_ = x.PhysicalSegmentLayout_isDefinedBy_Concept_;
      this->PhysicalSegmentLayout_formats_LogicalRecord_ = x.PhysicalSegmentLayout_formats_LogicalRecord_;
      this->PhysicalSegmentLayout_has_ValueMapping_ = x.PhysicalSegmentLayout_has_ValueMapping_;
      this->PhysicalSegmentLayout_has_ValueMappingPosition_ = x.PhysicalSegmentLayout_has_ValueMappingPosition_;
    }

    return *this;
  }

  PhysicalSegmentLayout::
  ~PhysicalSegmentLayout ()
  {
  }

  // PhysicalSegmentLocation
  //

  PhysicalSegmentLocation::
  PhysicalSegmentLocation ()
  : ::xml_schema::type (),
    catalogDetails_ (this),
    identifier_ (this)
  {
  }

  PhysicalSegmentLocation::
  PhysicalSegmentLocation (const PhysicalSegmentLocation& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    identifier_ (x.identifier_, f, this)
  {
  }

  PhysicalSegmentLocation::
  PhysicalSegmentLocation (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    identifier_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PhysicalSegmentLocation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  PhysicalSegmentLocation* PhysicalSegmentLocation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalSegmentLocation (*this, f, c);
  }

  PhysicalSegmentLocation& PhysicalSegmentLocation::
  operator= (const PhysicalSegmentLocation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->identifier_ = x.identifier_;
    }

    return *this;
  }

  PhysicalSegmentLocation::
  ~PhysicalSegmentLocation ()
  {
  }

  // UnitType
  //

  UnitType::
  UnitType ()
  : ::XMLSchema::Concept (),
    descriptiveText_ (this)
  {
  }

  UnitType::
  UnitType (const UnitType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::XMLSchema::Concept (x, f, c),
    descriptiveText_ (x.descriptiveText_, f, this)
  {
  }

  UnitType::
  UnitType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::XMLSchema::Concept (e, f | ::xml_schema::flags::base, c),
    descriptiveText_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void UnitType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::Concept::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // descriptiveText
      //
      if (n.name () == "descriptiveText" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< descriptiveText_type > r (
          descriptiveText_traits::create (i, f, this));

        if (!this->descriptiveText_)
        {
          this->descriptiveText_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  UnitType* UnitType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UnitType (*this, f, c);
  }

  UnitType& UnitType::
  operator= (const UnitType& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Concept& > (*this) = x;
      this->descriptiveText_ = x.descriptiveText_;
    }

    return *this;
  }

  UnitType::
  ~UnitType ()
  {
  }

  // Universe
  //

  Universe::
  Universe ()
  : ::XMLSchema::UnitType (),
    isInclusive_ (this)
  {
  }

  Universe::
  Universe (const Universe& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::XMLSchema::UnitType (x, f, c),
    isInclusive_ (x.isInclusive_, f, this)
  {
  }

  Universe::
  Universe (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::XMLSchema::UnitType (e, f | ::xml_schema::flags::base, c),
    isInclusive_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Universe::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::UnitType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // isInclusive
      //
      if (n.name () == "isInclusive" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isInclusive_)
        {
          this->isInclusive_.set (isInclusive_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }
  }

  Universe* Universe::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Universe (*this, f, c);
  }

  Universe& Universe::
  operator= (const Universe& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::UnitType& > (*this) = x;
      this->isInclusive_ = x.isInclusive_;
    }

    return *this;
  }

  Universe::
  ~Universe ()
  {
  }

  // Population
  //

  Population::
  Population ()
  : ::XMLSchema::Universe (),
    timePeriodOfPopulation_ (this),
    Population_isComposedOf_Unit_ (this)
  {
  }

  Population::
  Population (const Population& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::XMLSchema::Universe (x, f, c),
    timePeriodOfPopulation_ (x.timePeriodOfPopulation_, f, this),
    Population_isComposedOf_Unit_ (x.Population_isComposedOf_Unit_, f, this)
  {
  }

  Population::
  Population (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::XMLSchema::Universe (e, f | ::xml_schema::flags::base, c),
    timePeriodOfPopulation_ (this),
    Population_isComposedOf_Unit_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Population::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::Universe::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // timePeriodOfPopulation
      //
      if (n.name () == "timePeriodOfPopulation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< timePeriodOfPopulation_type > r (
          timePeriodOfPopulation_traits::create (i, f, this));

        this->timePeriodOfPopulation_.push_back (::std::move (r));
        continue;
      }

      // Population_isComposedOf_Unit
      //
      if (n.name () == "Population_isComposedOf_Unit" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Population_isComposedOf_Unit_type > r (
          Population_isComposedOf_Unit_traits::create (i, f, this));

        this->Population_isComposedOf_Unit_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Population* Population::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Population (*this, f, c);
  }

  Population& Population::
  operator= (const Population& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Universe& > (*this) = x;
      this->timePeriodOfPopulation_ = x.timePeriodOfPopulation_;
      this->Population_isComposedOf_Unit_ = x.Population_isComposedOf_Unit_;
    }

    return *this;
  }

  Population::
  ~Population ()
  {
  }

  // PrimaryKey
  //

  PrimaryKey::
  PrimaryKey ()
  : ::xml_schema::type (),
    identifier_ (this),
    PrimaryKey_isComposedOf_PrimaryKeyComponent_ (this)
  {
  }

  PrimaryKey::
  PrimaryKey (const PrimaryKey& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    PrimaryKey_isComposedOf_PrimaryKeyComponent_ (x.PrimaryKey_isComposedOf_PrimaryKeyComponent_, f, this)
  {
  }

  PrimaryKey::
  PrimaryKey (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    PrimaryKey_isComposedOf_PrimaryKeyComponent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PrimaryKey::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // PrimaryKey_isComposedOf_PrimaryKeyComponent
      //
      if (n.name () == "PrimaryKey_isComposedOf_PrimaryKeyComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PrimaryKey_isComposedOf_PrimaryKeyComponent_type > r (
          PrimaryKey_isComposedOf_PrimaryKeyComponent_traits::create (i, f, this));

        this->PrimaryKey_isComposedOf_PrimaryKeyComponent_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  PrimaryKey* PrimaryKey::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PrimaryKey (*this, f, c);
  }

  PrimaryKey& PrimaryKey::
  operator= (const PrimaryKey& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->PrimaryKey_isComposedOf_PrimaryKeyComponent_ = x.PrimaryKey_isComposedOf_PrimaryKeyComponent_;
    }

    return *this;
  }

  PrimaryKey::
  ~PrimaryKey ()
  {
  }

  // PrimaryKeyComponent
  //

  PrimaryKeyComponent::
  PrimaryKeyComponent (const PrimaryKeyComponent_correspondsTo_DataStructureComponent_type& PrimaryKeyComponent_correspondsTo_DataStructureComponent)
  : ::xml_schema::type (),
    identifier_ (this),
    PrimaryKeyComponent_correspondsTo_DataStructureComponent_ (PrimaryKeyComponent_correspondsTo_DataStructureComponent, this)
  {
  }

  PrimaryKeyComponent::
  PrimaryKeyComponent (::std::unique_ptr< PrimaryKeyComponent_correspondsTo_DataStructureComponent_type > PrimaryKeyComponent_correspondsTo_DataStructureComponent)
  : ::xml_schema::type (),
    identifier_ (this),
    PrimaryKeyComponent_correspondsTo_DataStructureComponent_ (std::move (PrimaryKeyComponent_correspondsTo_DataStructureComponent), this)
  {
  }

  PrimaryKeyComponent::
  PrimaryKeyComponent (const PrimaryKeyComponent& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    PrimaryKeyComponent_correspondsTo_DataStructureComponent_ (x.PrimaryKeyComponent_correspondsTo_DataStructureComponent_, f, this)
  {
  }

  PrimaryKeyComponent::
  PrimaryKeyComponent (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    PrimaryKeyComponent_correspondsTo_DataStructureComponent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PrimaryKeyComponent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // PrimaryKeyComponent_correspondsTo_DataStructureComponent
      //
      if (n.name () == "PrimaryKeyComponent_correspondsTo_DataStructureComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< PrimaryKeyComponent_correspondsTo_DataStructureComponent_type > r (
          PrimaryKeyComponent_correspondsTo_DataStructureComponent_traits::create (i, f, this));

        if (!PrimaryKeyComponent_correspondsTo_DataStructureComponent_.present ())
        {
          this->PrimaryKeyComponent_correspondsTo_DataStructureComponent_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!PrimaryKeyComponent_correspondsTo_DataStructureComponent_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PrimaryKeyComponent_correspondsTo_DataStructureComponent",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  PrimaryKeyComponent* PrimaryKeyComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PrimaryKeyComponent (*this, f, c);
  }

  PrimaryKeyComponent& PrimaryKeyComponent::
  operator= (const PrimaryKeyComponent& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->PrimaryKeyComponent_correspondsTo_DataStructureComponent_ = x.PrimaryKeyComponent_correspondsTo_DataStructureComponent_;
    }

    return *this;
  }

  PrimaryKeyComponent::
  ~PrimaryKeyComponent ()
  {
  }

  // ProductionEnvironment
  //

  ProductionEnvironment::
  ProductionEnvironment ()
  : ::xml_schema::type (),
    identifier_ (this)
  {
  }

  ProductionEnvironment::
  ProductionEnvironment (const ProductionEnvironment& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this)
  {
  }

  ProductionEnvironment::
  ProductionEnvironment (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ProductionEnvironment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ProductionEnvironment* ProductionEnvironment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProductionEnvironment (*this, f, c);
  }

  ProductionEnvironment& ProductionEnvironment::
  operator= (const ProductionEnvironment& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
    }

    return *this;
  }

  ProductionEnvironment::
  ~ProductionEnvironment ()
  {
  }

  // QualifiedMeasure
  //

  QualifiedMeasure::
  QualifiedMeasure ()
  : ::XMLSchema::MeasureComponent (),
    QualifiedMeasure_refines_MeasureComponent_ (this)
  {
  }

  QualifiedMeasure::
  QualifiedMeasure (const QualifiedMeasure& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::XMLSchema::MeasureComponent (x, f, c),
    QualifiedMeasure_refines_MeasureComponent_ (x.QualifiedMeasure_refines_MeasureComponent_, f, this)
  {
  }

  QualifiedMeasure::
  QualifiedMeasure (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::XMLSchema::MeasureComponent (e, f | ::xml_schema::flags::base, c),
    QualifiedMeasure_refines_MeasureComponent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void QualifiedMeasure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::MeasureComponent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // QualifiedMeasure_refines_MeasureComponent
      //
      if (n.name () == "QualifiedMeasure_refines_MeasureComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< QualifiedMeasure_refines_MeasureComponent_type > r (
          QualifiedMeasure_refines_MeasureComponent_traits::create (i, f, this));

        if (!this->QualifiedMeasure_refines_MeasureComponent_)
        {
          this->QualifiedMeasure_refines_MeasureComponent_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  QualifiedMeasure* QualifiedMeasure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class QualifiedMeasure (*this, f, c);
  }

  QualifiedMeasure& QualifiedMeasure::
  operator= (const QualifiedMeasure& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::MeasureComponent& > (*this) = x;
      this->QualifiedMeasure_refines_MeasureComponent_ = x.QualifiedMeasure_refines_MeasureComponent_;
    }

    return *this;
  }

  QualifiedMeasure::
  ~QualifiedMeasure ()
  {
  }

  // RecordRelation
  //

  RecordRelation::
  RecordRelation ()
  : ::xml_schema::type (),
    catalogDetails_ (this),
    displayLabel_ (this),
    identifier_ (this),
    purpose_ (this),
    usage_ (this),
    RecordRelation_maps_LogicalRecord_ (this),
    RecordRelation_has_InstanceVariableMap_ (this)
  {
  }

  RecordRelation::
  RecordRelation (const RecordRelation& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    displayLabel_ (x.displayLabel_, f, this),
    identifier_ (x.identifier_, f, this),
    purpose_ (x.purpose_, f, this),
    usage_ (x.usage_, f, this),
    RecordRelation_maps_LogicalRecord_ (x.RecordRelation_maps_LogicalRecord_, f, this),
    RecordRelation_has_InstanceVariableMap_ (x.RecordRelation_has_InstanceVariableMap_, f, this)
  {
  }

  RecordRelation::
  RecordRelation (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    displayLabel_ (this),
    identifier_ (this),
    purpose_ (this),
    usage_ (this),
    RecordRelation_maps_LogicalRecord_ (this),
    RecordRelation_has_InstanceVariableMap_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RecordRelation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // displayLabel
      //
      if (n.name () == "displayLabel" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< displayLabel_type > r (
          displayLabel_traits::create (i, f, this));

        this->displayLabel_.push_back (::std::move (r));
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // usage
      //
      if (n.name () == "usage" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< usage_type > r (
          usage_traits::create (i, f, this));

        if (!this->usage_)
        {
          this->usage_.set (::std::move (r));
          continue;
        }
      }

      // RecordRelation_maps_LogicalRecord
      //
      if (n.name () == "RecordRelation_maps_LogicalRecord" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RecordRelation_maps_LogicalRecord_type > r (
          RecordRelation_maps_LogicalRecord_traits::create (i, f, this));

        this->RecordRelation_maps_LogicalRecord_.push_back (::std::move (r));
        continue;
      }

      // RecordRelation_has_InstanceVariableMap
      //
      if (n.name () == "RecordRelation_has_InstanceVariableMap" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RecordRelation_has_InstanceVariableMap_type > r (
          RecordRelation_has_InstanceVariableMap_traits::create (i, f, this));

        this->RecordRelation_has_InstanceVariableMap_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  RecordRelation* RecordRelation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RecordRelation (*this, f, c);
  }

  RecordRelation& RecordRelation::
  operator= (const RecordRelation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->displayLabel_ = x.displayLabel_;
      this->identifier_ = x.identifier_;
      this->purpose_ = x.purpose_;
      this->usage_ = x.usage_;
      this->RecordRelation_maps_LogicalRecord_ = x.RecordRelation_maps_LogicalRecord_;
      this->RecordRelation_has_InstanceVariableMap_ = x.RecordRelation_has_InstanceVariableMap_;
    }

    return *this;
  }

  RecordRelation::
  ~RecordRelation ()
  {
  }

  // ReferenceValue
  //

  ReferenceValue::
  ReferenceValue (const InstanceValue_hasValueFrom_ValueDomain_type& InstanceValue_hasValueFrom_ValueDomain,
                  const ReferenceValue_correspondsTo_VariableValueComponent_type& ReferenceValue_correspondsTo_VariableValueComponent,
                  const ReferenceValue_hasValueFrom_ReferenceValueDomain_type& ReferenceValue_hasValueFrom_ReferenceValueDomain)
  : ::XMLSchema::InstanceValue (InstanceValue_hasValueFrom_ValueDomain),
    ReferenceValue_correspondsTo_VariableValueComponent_ (ReferenceValue_correspondsTo_VariableValueComponent, this),
    ReferenceValue_hasValueFrom_ReferenceValueDomain_ (ReferenceValue_hasValueFrom_ReferenceValueDomain, this)
  {
  }

  ReferenceValue::
  ReferenceValue (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type > InstanceValue_hasValueFrom_ValueDomain,
                  ::std::unique_ptr< ReferenceValue_correspondsTo_VariableValueComponent_type > ReferenceValue_correspondsTo_VariableValueComponent,
                  ::std::unique_ptr< ReferenceValue_hasValueFrom_ReferenceValueDomain_type > ReferenceValue_hasValueFrom_ReferenceValueDomain)
  : ::XMLSchema::InstanceValue (std::move (InstanceValue_hasValueFrom_ValueDomain)),
    ReferenceValue_correspondsTo_VariableValueComponent_ (std::move (ReferenceValue_correspondsTo_VariableValueComponent), this),
    ReferenceValue_hasValueFrom_ReferenceValueDomain_ (std::move (ReferenceValue_hasValueFrom_ReferenceValueDomain), this)
  {
  }

  ReferenceValue::
  ReferenceValue (const ReferenceValue& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::XMLSchema::InstanceValue (x, f, c),
    ReferenceValue_correspondsTo_VariableValueComponent_ (x.ReferenceValue_correspondsTo_VariableValueComponent_, f, this),
    ReferenceValue_hasValueFrom_ReferenceValueDomain_ (x.ReferenceValue_hasValueFrom_ReferenceValueDomain_, f, this)
  {
  }

  ReferenceValue::
  ReferenceValue (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::XMLSchema::InstanceValue (e, f | ::xml_schema::flags::base, c),
    ReferenceValue_correspondsTo_VariableValueComponent_ (this),
    ReferenceValue_hasValueFrom_ReferenceValueDomain_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReferenceValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::InstanceValue::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReferenceValue_correspondsTo_VariableValueComponent
      //
      if (n.name () == "ReferenceValue_correspondsTo_VariableValueComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ReferenceValue_correspondsTo_VariableValueComponent_type > r (
          ReferenceValue_correspondsTo_VariableValueComponent_traits::create (i, f, this));

        if (!ReferenceValue_correspondsTo_VariableValueComponent_.present ())
        {
          this->ReferenceValue_correspondsTo_VariableValueComponent_.set (::std::move (r));
          continue;
        }
      }

      // ReferenceValue_hasValueFrom_ReferenceValueDomain
      //
      if (n.name () == "ReferenceValue_hasValueFrom_ReferenceValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ReferenceValue_hasValueFrom_ReferenceValueDomain_type > r (
          ReferenceValue_hasValueFrom_ReferenceValueDomain_traits::create (i, f, this));

        if (!ReferenceValue_hasValueFrom_ReferenceValueDomain_.present ())
        {
          this->ReferenceValue_hasValueFrom_ReferenceValueDomain_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!ReferenceValue_correspondsTo_VariableValueComponent_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ReferenceValue_correspondsTo_VariableValueComponent",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!ReferenceValue_hasValueFrom_ReferenceValueDomain_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ReferenceValue_hasValueFrom_ReferenceValueDomain",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ReferenceValue* ReferenceValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ReferenceValue (*this, f, c);
  }

  ReferenceValue& ReferenceValue::
  operator= (const ReferenceValue& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::InstanceValue& > (*this) = x;
      this->ReferenceValue_correspondsTo_VariableValueComponent_ = x.ReferenceValue_correspondsTo_VariableValueComponent_;
      this->ReferenceValue_hasValueFrom_ReferenceValueDomain_ = x.ReferenceValue_hasValueFrom_ReferenceValueDomain_;
    }

    return *this;
  }

  ReferenceValue::
  ~ReferenceValue ()
  {
  }

  // ReferenceValueDomain
  //

  ReferenceValueDomain::
  ReferenceValueDomain ()
  : ::XMLSchema::ValueDomain ()
  {
  }

  ReferenceValueDomain::
  ReferenceValueDomain (const ReferenceValueDomain& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::ValueDomain (x, f, c)
  {
  }

  ReferenceValueDomain::
  ReferenceValueDomain (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::ValueDomain (e, f, c)
  {
  }

  ReferenceValueDomain* ReferenceValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ReferenceValueDomain (*this, f, c);
  }

  ReferenceValueDomain::
  ~ReferenceValueDomain ()
  {
  }

  // ReferenceVariable
  //

  ReferenceVariable::
  ReferenceVariable ()
  : ::XMLSchema::RepresentedVariable (),
    ReferenceVariable_takesValuesFrom_ReferenceValueDomain_ (this)
  {
  }

  ReferenceVariable::
  ReferenceVariable (const ReferenceVariable& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::RepresentedVariable (x, f, c),
    ReferenceVariable_takesValuesFrom_ReferenceValueDomain_ (x.ReferenceVariable_takesValuesFrom_ReferenceValueDomain_, f, this)
  {
  }

  ReferenceVariable::
  ReferenceVariable (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::RepresentedVariable (e, f | ::xml_schema::flags::base, c),
    ReferenceVariable_takesValuesFrom_ReferenceValueDomain_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReferenceVariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::RepresentedVariable::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReferenceVariable_takesValuesFrom_ReferenceValueDomain
      //
      if (n.name () == "ReferenceVariable_takesValuesFrom_ReferenceValueDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ReferenceVariable_takesValuesFrom_ReferenceValueDomain_type > r (
          ReferenceVariable_takesValuesFrom_ReferenceValueDomain_traits::create (i, f, this));

        if (!this->ReferenceVariable_takesValuesFrom_ReferenceValueDomain_)
        {
          this->ReferenceVariable_takesValuesFrom_ReferenceValueDomain_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ReferenceVariable* ReferenceVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ReferenceVariable (*this, f, c);
  }

  ReferenceVariable& ReferenceVariable::
  operator= (const ReferenceVariable& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::RepresentedVariable& > (*this) = x;
      this->ReferenceVariable_takesValuesFrom_ReferenceValueDomain_ = x.ReferenceVariable_takesValuesFrom_ReferenceValueDomain_;
    }

    return *this;
  }

  ReferenceVariable::
  ~ReferenceVariable ()
  {
  }

  // RevisableDatum
  //

  RevisableDatum::
  RevisableDatum (const Datum_denotes_ConceptualValue_type& Datum_denotes_ConceptualValue,
                  const vintage_type& vintage)
  : ::XMLSchema::Datum (Datum_denotes_ConceptualValue),
    vintage_ (vintage, this),
    RevisableDatum_correspondsTo_Revision_ (this)
  {
  }

  RevisableDatum::
  RevisableDatum (::std::unique_ptr< Datum_denotes_ConceptualValue_type > Datum_denotes_ConceptualValue,
                  const vintage_type& vintage)
  : ::XMLSchema::Datum (std::move (Datum_denotes_ConceptualValue)),
    vintage_ (vintage, this),
    RevisableDatum_correspondsTo_Revision_ (this)
  {
  }

  RevisableDatum::
  RevisableDatum (const RevisableDatum& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::XMLSchema::Datum (x, f, c),
    vintage_ (x.vintage_, f, this),
    RevisableDatum_correspondsTo_Revision_ (x.RevisableDatum_correspondsTo_Revision_, f, this)
  {
  }

  RevisableDatum::
  RevisableDatum (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::XMLSchema::Datum (e, f | ::xml_schema::flags::base, c),
    vintage_ (this),
    RevisableDatum_correspondsTo_Revision_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RevisableDatum::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::Datum::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // vintage
      //
      if (n.name () == "vintage" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!vintage_.present ())
        {
          this->vintage_.set (vintage_traits::create (i, f, this));
          continue;
        }
      }

      // RevisableDatum_correspondsTo_Revision
      //
      if (n.name () == "RevisableDatum_correspondsTo_Revision" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RevisableDatum_correspondsTo_Revision_type > r (
          RevisableDatum_correspondsTo_Revision_traits::create (i, f, this));

        if (!this->RevisableDatum_correspondsTo_Revision_)
        {
          this->RevisableDatum_correspondsTo_Revision_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!vintage_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "vintage",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  RevisableDatum* RevisableDatum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RevisableDatum (*this, f, c);
  }

  RevisableDatum& RevisableDatum::
  operator= (const RevisableDatum& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Datum& > (*this) = x;
      this->vintage_ = x.vintage_;
      this->RevisableDatum_correspondsTo_Revision_ = x.RevisableDatum_correspondsTo_Revision_;
    }

    return *this;
  }

  RevisableDatum::
  ~RevisableDatum ()
  {
  }

  // Revision
  //

  Revision::
  Revision ()
  : ::xml_schema::type (),
    algorithm_ (this),
    identifier_ (this),
    overview_ (this)
  {
  }

  Revision::
  Revision (const Revision& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    algorithm_ (x.algorithm_, f, this),
    identifier_ (x.identifier_, f, this),
    overview_ (x.overview_, f, this)
  {
  }

  Revision::
  Revision (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    algorithm_ (this),
    identifier_ (this),
    overview_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Revision::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // algorithm
      //
      if (n.name () == "algorithm" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< algorithm_type > r (
          algorithm_traits::create (i, f, this));

        if (!this->algorithm_)
        {
          this->algorithm_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // overview
      //
      if (n.name () == "overview" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< overview_type > r (
          overview_traits::create (i, f, this));

        if (!this->overview_)
        {
          this->overview_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Revision* Revision::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Revision (*this, f, c);
  }

  Revision& Revision::
  operator= (const Revision& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->algorithm_ = x.algorithm_;
      this->identifier_ = x.identifier_;
      this->overview_ = x.overview_;
    }

    return *this;
  }

  Revision::
  ~Revision ()
  {
  }

  // Rule
  //

  Rule::
  Rule ()
  : ::xml_schema::type (),
    identifier_ (this),
    Rule_hasPrecondition_ConditionalControlLogic_ (this)
  {
  }

  Rule::
  Rule (const Rule& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    Rule_hasPrecondition_ConditionalControlLogic_ (x.Rule_hasPrecondition_ConditionalControlLogic_, f, this)
  {
  }

  Rule::
  Rule (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    Rule_hasPrecondition_ConditionalControlLogic_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Rule::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // Rule_hasPrecondition_ConditionalControlLogic
      //
      if (n.name () == "Rule_hasPrecondition_ConditionalControlLogic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Rule_hasPrecondition_ConditionalControlLogic_type > r (
          Rule_hasPrecondition_ConditionalControlLogic_traits::create (i, f, this));

        this->Rule_hasPrecondition_ConditionalControlLogic_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Rule* Rule::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Rule (*this, f, c);
  }

  Rule& Rule::
  operator= (const Rule& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->Rule_hasPrecondition_ConditionalControlLogic_ = x.Rule_hasPrecondition_ConditionalControlLogic_;
    }

    return *this;
  }

  Rule::
  ~Rule ()
  {
  }

  // RuleBasedScheduling
  //

  RuleBasedScheduling::
  RuleBasedScheduling (const schedulingType_type& schedulingType)
  : ::XMLSchema::NonDeterministicDeclarative (),
    schedulingType_ (schedulingType, this),
    RuleBasedScheduling_has_RuleSet_ (this),
    RuleBasedScheduling_has_Curator_ (this)
  {
  }

  RuleBasedScheduling::
  RuleBasedScheduling (const RuleBasedScheduling& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::NonDeterministicDeclarative (x, f, c),
    schedulingType_ (x.schedulingType_, f, this),
    RuleBasedScheduling_has_RuleSet_ (x.RuleBasedScheduling_has_RuleSet_, f, this),
    RuleBasedScheduling_has_Curator_ (x.RuleBasedScheduling_has_Curator_, f, this)
  {
  }

  RuleBasedScheduling::
  RuleBasedScheduling (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::NonDeterministicDeclarative (e, f | ::xml_schema::flags::base, c),
    schedulingType_ (this),
    RuleBasedScheduling_has_RuleSet_ (this),
    RuleBasedScheduling_has_Curator_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RuleBasedScheduling::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::NonDeterministicDeclarative::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // schedulingType
      //
      if (n.name () == "schedulingType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< schedulingType_type > r (
          schedulingType_traits::create (i, f, this));

        if (!schedulingType_.present ())
        {
          this->schedulingType_.set (::std::move (r));
          continue;
        }
      }

      // RuleBasedScheduling_has_RuleSet
      //
      if (n.name () == "RuleBasedScheduling_has_RuleSet" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RuleBasedScheduling_has_RuleSet_type > r (
          RuleBasedScheduling_has_RuleSet_traits::create (i, f, this));

        this->RuleBasedScheduling_has_RuleSet_.push_back (::std::move (r));
        continue;
      }

      // RuleBasedScheduling_has_Curator
      //
      if (n.name () == "RuleBasedScheduling_has_Curator" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RuleBasedScheduling_has_Curator_type > r (
          RuleBasedScheduling_has_Curator_traits::create (i, f, this));

        this->RuleBasedScheduling_has_Curator_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!schedulingType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "schedulingType",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  RuleBasedScheduling* RuleBasedScheduling::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RuleBasedScheduling (*this, f, c);
  }

  RuleBasedScheduling& RuleBasedScheduling::
  operator= (const RuleBasedScheduling& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::NonDeterministicDeclarative& > (*this) = x;
      this->schedulingType_ = x.schedulingType_;
      this->RuleBasedScheduling_has_RuleSet_ = x.RuleBasedScheduling_has_RuleSet_;
      this->RuleBasedScheduling_has_Curator_ = x.RuleBasedScheduling_has_Curator_;
    }

    return *this;
  }

  RuleBasedScheduling::
  ~RuleBasedScheduling ()
  {
  }

  // RuleSet
  //

  RuleSet::
  RuleSet ()
  : ::xml_schema::type (),
    identifier_ (this),
    RuleSet_has_Rule_ (this)
  {
  }

  RuleSet::
  RuleSet (const RuleSet& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    RuleSet_has_Rule_ (x.RuleSet_has_Rule_, f, this)
  {
  }

  RuleSet::
  RuleSet (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    RuleSet_has_Rule_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RuleSet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // RuleSet_has_Rule
      //
      if (n.name () == "RuleSet_has_Rule" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< RuleSet_has_Rule_type > r (
          RuleSet_has_Rule_traits::create (i, f, this));

        this->RuleSet_has_Rule_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  RuleSet* RuleSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RuleSet (*this, f, c);
  }

  RuleSet& RuleSet::
  operator= (const RuleSet& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->RuleSet_has_Rule_ = x.RuleSet_has_Rule_;
    }

    return *this;
  }

  RuleSet::
  ~RuleSet ()
  {
  }

  // ScopedMeasure
  //

  ScopedMeasure::
  ScopedMeasure (const ScopedMeasure_generates_RevisableDatum_type& ScopedMeasure_generates_RevisableDatum)
  : ::xml_schema::type (),
    frequency_ (this),
    identifier_ (this),
    ScopedMeasure_circumscribes_DimensionalKeyDefinition_ (this),
    ScopedMeasure_restricts_QualifiedMeasure_ (this),
    ScopedMeasure_generates_RevisableDatum_ (ScopedMeasure_generates_RevisableDatum, this)
  {
  }

  ScopedMeasure::
  ScopedMeasure (::std::unique_ptr< ScopedMeasure_generates_RevisableDatum_type > ScopedMeasure_generates_RevisableDatum)
  : ::xml_schema::type (),
    frequency_ (this),
    identifier_ (this),
    ScopedMeasure_circumscribes_DimensionalKeyDefinition_ (this),
    ScopedMeasure_restricts_QualifiedMeasure_ (this),
    ScopedMeasure_generates_RevisableDatum_ (std::move (ScopedMeasure_generates_RevisableDatum), this)
  {
  }

  ScopedMeasure::
  ScopedMeasure (const ScopedMeasure& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    frequency_ (x.frequency_, f, this),
    identifier_ (x.identifier_, f, this),
    ScopedMeasure_circumscribes_DimensionalKeyDefinition_ (x.ScopedMeasure_circumscribes_DimensionalKeyDefinition_, f, this),
    ScopedMeasure_restricts_QualifiedMeasure_ (x.ScopedMeasure_restricts_QualifiedMeasure_, f, this),
    ScopedMeasure_generates_RevisableDatum_ (x.ScopedMeasure_generates_RevisableDatum_, f, this)
  {
  }

  ScopedMeasure::
  ScopedMeasure (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    frequency_ (this),
    identifier_ (this),
    ScopedMeasure_circumscribes_DimensionalKeyDefinition_ (this),
    ScopedMeasure_restricts_QualifiedMeasure_ (this),
    ScopedMeasure_generates_RevisableDatum_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ScopedMeasure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // frequency
      //
      if (n.name () == "frequency" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< frequency_type > r (
          frequency_traits::create (i, f, this));

        if (!this->frequency_)
        {
          this->frequency_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // ScopedMeasure_circumscribes_DimensionalKeyDefinition
      //
      if (n.name () == "ScopedMeasure_circumscribes_DimensionalKeyDefinition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ScopedMeasure_circumscribes_DimensionalKeyDefinition_type > r (
          ScopedMeasure_circumscribes_DimensionalKeyDefinition_traits::create (i, f, this));

        if (!this->ScopedMeasure_circumscribes_DimensionalKeyDefinition_)
        {
          this->ScopedMeasure_circumscribes_DimensionalKeyDefinition_.set (::std::move (r));
          continue;
        }
      }

      // ScopedMeasure_restricts_QualifiedMeasure
      //
      if (n.name () == "ScopedMeasure_restricts_QualifiedMeasure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ScopedMeasure_restricts_QualifiedMeasure_type > r (
          ScopedMeasure_restricts_QualifiedMeasure_traits::create (i, f, this));

        if (!this->ScopedMeasure_restricts_QualifiedMeasure_)
        {
          this->ScopedMeasure_restricts_QualifiedMeasure_.set (::std::move (r));
          continue;
        }
      }

      // ScopedMeasure_generates_RevisableDatum
      //
      if (n.name () == "ScopedMeasure_generates_RevisableDatum" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ScopedMeasure_generates_RevisableDatum_type > r (
          ScopedMeasure_generates_RevisableDatum_traits::create (i, f, this));

        if (!ScopedMeasure_generates_RevisableDatum_.present ())
        {
          this->ScopedMeasure_generates_RevisableDatum_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!ScopedMeasure_generates_RevisableDatum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ScopedMeasure_generates_RevisableDatum",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ScopedMeasure* ScopedMeasure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ScopedMeasure (*this, f, c);
  }

  ScopedMeasure& ScopedMeasure::
  operator= (const ScopedMeasure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->frequency_ = x.frequency_;
      this->identifier_ = x.identifier_;
      this->ScopedMeasure_circumscribes_DimensionalKeyDefinition_ = x.ScopedMeasure_circumscribes_DimensionalKeyDefinition_;
      this->ScopedMeasure_restricts_QualifiedMeasure_ = x.ScopedMeasure_restricts_QualifiedMeasure_;
      this->ScopedMeasure_generates_RevisableDatum_ = x.ScopedMeasure_generates_RevisableDatum_;
    }

    return *this;
  }

  ScopedMeasure::
  ~ScopedMeasure ()
  {
  }

  // SegmentByText
  //

  SegmentByText::
  SegmentByText ()
  : ::XMLSchema::PhysicalSegmentLocation (),
    characterLength_ (this),
    endCharacterPosition_ (this),
    endLine_ (this),
    startCharacterPosition_ (this),
    startLine_ (this)
  {
  }

  SegmentByText::
  SegmentByText (const SegmentByText& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::XMLSchema::PhysicalSegmentLocation (x, f, c),
    characterLength_ (x.characterLength_, f, this),
    endCharacterPosition_ (x.endCharacterPosition_, f, this),
    endLine_ (x.endLine_, f, this),
    startCharacterPosition_ (x.startCharacterPosition_, f, this),
    startLine_ (x.startLine_, f, this)
  {
  }

  SegmentByText::
  SegmentByText (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::XMLSchema::PhysicalSegmentLocation (e, f | ::xml_schema::flags::base, c),
    characterLength_ (this),
    endCharacterPosition_ (this),
    endLine_ (this),
    startCharacterPosition_ (this),
    startLine_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SegmentByText::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::PhysicalSegmentLocation::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // characterLength
      //
      if (n.name () == "characterLength" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->characterLength_)
        {
          this->characterLength_.set (characterLength_traits::create (i, f, this));
          continue;
        }
      }

      // endCharacterPosition
      //
      if (n.name () == "endCharacterPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->endCharacterPosition_)
        {
          this->endCharacterPosition_.set (endCharacterPosition_traits::create (i, f, this));
          continue;
        }
      }

      // endLine
      //
      if (n.name () == "endLine" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->endLine_)
        {
          this->endLine_.set (endLine_traits::create (i, f, this));
          continue;
        }
      }

      // startCharacterPosition
      //
      if (n.name () == "startCharacterPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->startCharacterPosition_)
        {
          this->startCharacterPosition_.set (startCharacterPosition_traits::create (i, f, this));
          continue;
        }
      }

      // startLine
      //
      if (n.name () == "startLine" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->startLine_)
        {
          this->startLine_.set (startLine_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }
  }

  SegmentByText* SegmentByText::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SegmentByText (*this, f, c);
  }

  SegmentByText& SegmentByText::
  operator= (const SegmentByText& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::PhysicalSegmentLocation& > (*this) = x;
      this->characterLength_ = x.characterLength_;
      this->endCharacterPosition_ = x.endCharacterPosition_;
      this->endLine_ = x.endLine_;
      this->startCharacterPosition_ = x.startCharacterPosition_;
      this->startLine_ = x.startLine_;
    }

    return *this;
  }

  SegmentByText::
  ~SegmentByText ()
  {
  }

  // SentinelConceptualDomain
  //

  SentinelConceptualDomain::
  SentinelConceptualDomain ()
  : ::XMLSchema::ConceptualDomain ()
  {
  }

  SentinelConceptualDomain::
  SentinelConceptualDomain (const SentinelConceptualDomain& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::ConceptualDomain (x, f, c)
  {
  }

  SentinelConceptualDomain::
  SentinelConceptualDomain (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::ConceptualDomain (e, f, c)
  {
  }

  SentinelConceptualDomain* SentinelConceptualDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SentinelConceptualDomain (*this, f, c);
  }

  SentinelConceptualDomain::
  ~SentinelConceptualDomain ()
  {
  }

  // SentinelValueDomain
  //

  SentinelValueDomain::
  SentinelValueDomain ()
  : ::XMLSchema::ValueDomain (),
    platformType_ (this),
    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_ (this),
    SentinelValueDomain_takesValuesFrom_EnumerationDomain_ (this),
    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_ (this)
  {
  }

  SentinelValueDomain::
  SentinelValueDomain (const SentinelValueDomain& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::ValueDomain (x, f, c),
    platformType_ (x.platformType_, f, this),
    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_ (x.SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_, f, this),
    SentinelValueDomain_takesValuesFrom_EnumerationDomain_ (x.SentinelValueDomain_takesValuesFrom_EnumerationDomain_, f, this),
    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_ (x.SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_, f, this)
  {
  }

  SentinelValueDomain::
  SentinelValueDomain (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::ValueDomain (e, f | ::xml_schema::flags::base, c),
    platformType_ (this),
    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_ (this),
    SentinelValueDomain_takesValuesFrom_EnumerationDomain_ (this),
    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SentinelValueDomain::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::ValueDomain::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // platformType
      //
      if (n.name () == "platformType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< platformType_type > r (
          platformType_traits::create (i, f, this));

        if (!this->platformType_)
        {
          this->platformType_.set (::std::move (r));
          continue;
        }
      }

      // SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain
      //
      if (n.name () == "SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_type > r (
          SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_traits::create (i, f, this));

        if (!this->SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_)
        {
          this->SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_.set (::std::move (r));
          continue;
        }
      }

      // SentinelValueDomain_takesValuesFrom_EnumerationDomain
      //
      if (n.name () == "SentinelValueDomain_takesValuesFrom_EnumerationDomain" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SentinelValueDomain_takesValuesFrom_EnumerationDomain_type > r (
          SentinelValueDomain_takesValuesFrom_EnumerationDomain_traits::create (i, f, this));

        if (!this->SentinelValueDomain_takesValuesFrom_EnumerationDomain_)
        {
          this->SentinelValueDomain_takesValuesFrom_EnumerationDomain_.set (::std::move (r));
          continue;
        }
      }

      // SentinelValueDomain_isDescribedBy_ValueAndConceptDescription
      //
      if (n.name () == "SentinelValueDomain_isDescribedBy_ValueAndConceptDescription" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_type > r (
          SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_traits::create (i, f, this));

        if (!this->SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_)
        {
          this->SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SentinelValueDomain* SentinelValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SentinelValueDomain (*this, f, c);
  }

  SentinelValueDomain& SentinelValueDomain::
  operator= (const SentinelValueDomain& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::ValueDomain& > (*this) = x;
      this->platformType_ = x.platformType_;
      this->SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_ = x.SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_;
      this->SentinelValueDomain_takesValuesFrom_EnumerationDomain_ = x.SentinelValueDomain_takesValuesFrom_EnumerationDomain_;
      this->SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_ = x.SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_;
    }

    return *this;
  }

  SentinelValueDomain::
  ~SentinelValueDomain ()
  {
  }

  // Sequence
  //

  Sequence::
  Sequence ()
  : ::XMLSchema::DeterministicImperative (),
    Sequence_has_SequencePosition_ (this)
  {
  }

  Sequence::
  Sequence (const Sequence& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::XMLSchema::DeterministicImperative (x, f, c),
    Sequence_has_SequencePosition_ (x.Sequence_has_SequencePosition_, f, this)
  {
  }

  Sequence::
  Sequence (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::XMLSchema::DeterministicImperative (e, f | ::xml_schema::flags::base, c),
    Sequence_has_SequencePosition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Sequence::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::DeterministicImperative::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Sequence_has_SequencePosition
      //
      if (n.name () == "Sequence_has_SequencePosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Sequence_has_SequencePosition_type > r (
          Sequence_has_SequencePosition_traits::create (i, f, this));

        this->Sequence_has_SequencePosition_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Sequence* Sequence::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Sequence (*this, f, c);
  }

  Sequence& Sequence::
  operator= (const Sequence& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::DeterministicImperative& > (*this) = x;
      this->Sequence_has_SequencePosition_ = x.Sequence_has_SequencePosition_;
    }

    return *this;
  }

  Sequence::
  ~Sequence ()
  {
  }

  // SequencePosition
  //

  SequencePosition::
  SequencePosition (const value_type& value)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this)
  {
  }

  SequencePosition::
  SequencePosition (const SequencePosition& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    value_ (x.value_, f, this)
  {
  }

  SequencePosition::
  SequencePosition (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SequencePosition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  SequencePosition* SequencePosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SequencePosition (*this, f, c);
  }

  SequencePosition& SequencePosition::
  operator= (const SequencePosition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->value_ = x.value_;
    }

    return *this;
  }

  SequencePosition::
  ~SequencePosition ()
  {
  }

  // Service
  //

  Service::
  Service ()
  : ::XMLSchema::ProcessingAgent ()
  {
  }

  Service::
  Service (const Service& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::XMLSchema::ProcessingAgent (x, f, c)
  {
  }

  Service::
  Service (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::XMLSchema::ProcessingAgent (e, f, c)
  {
  }

  Service* Service::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Service (*this, f, c);
  }

  Service::
  ~Service ()
  {
  }

  // StatisticalClassification
  //

  StatisticalClassification::
  StatisticalClassification (const allowsDuplicates_type& allowsDuplicates)
  : ::XMLSchema::EnumerationDomain (),
    allowsDuplicates_ (allowsDuplicates, this),
    availableLanguage_ (this),
    catalogDetails_ (this),
    changeFromBase_ (this),
    copyright_ (this),
    displayLabel_ (this),
    isCurrent_ (this),
    isFloating_ (this),
    purposeOfVariant_ (this),
    rationale_ (this),
    releaseDate_ (this),
    updateChanges_ (this),
    usage_ (this),
    validDates_ (this),
    StatisticalClassification_isMaintainedBy_Organization_ (this),
    StatisticalClassification_isIndexedBy_ClassificationIndex_ (this),
    StatisticalClassification_isVariantOf_StatisticalClassification_ (this),
    StatisticalClassification_isSuccessorOf_StatisticalClassification_ (this),
    StatisticalClassification_isPredecessorOf_StatisticalClassification_ (this),
    StatisticalClassification_has_ClassificationItemPosition_ (this),
    StatisticalClassification_has_ClassificationItem_ (this),
    StatisticalClassification_has_LevelStructure_ (this)
  {
  }

  StatisticalClassification::
  StatisticalClassification (const StatisticalClassification& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::XMLSchema::EnumerationDomain (x, f, c),
    allowsDuplicates_ (x.allowsDuplicates_, f, this),
    availableLanguage_ (x.availableLanguage_, f, this),
    catalogDetails_ (x.catalogDetails_, f, this),
    changeFromBase_ (x.changeFromBase_, f, this),
    copyright_ (x.copyright_, f, this),
    displayLabel_ (x.displayLabel_, f, this),
    isCurrent_ (x.isCurrent_, f, this),
    isFloating_ (x.isFloating_, f, this),
    purposeOfVariant_ (x.purposeOfVariant_, f, this),
    rationale_ (x.rationale_, f, this),
    releaseDate_ (x.releaseDate_, f, this),
    updateChanges_ (x.updateChanges_, f, this),
    usage_ (x.usage_, f, this),
    validDates_ (x.validDates_, f, this),
    StatisticalClassification_isMaintainedBy_Organization_ (x.StatisticalClassification_isMaintainedBy_Organization_, f, this),
    StatisticalClassification_isIndexedBy_ClassificationIndex_ (x.StatisticalClassification_isIndexedBy_ClassificationIndex_, f, this),
    StatisticalClassification_isVariantOf_StatisticalClassification_ (x.StatisticalClassification_isVariantOf_StatisticalClassification_, f, this),
    StatisticalClassification_isSuccessorOf_StatisticalClassification_ (x.StatisticalClassification_isSuccessorOf_StatisticalClassification_, f, this),
    StatisticalClassification_isPredecessorOf_StatisticalClassification_ (x.StatisticalClassification_isPredecessorOf_StatisticalClassification_, f, this),
    StatisticalClassification_has_ClassificationItemPosition_ (x.StatisticalClassification_has_ClassificationItemPosition_, f, this),
    StatisticalClassification_has_ClassificationItem_ (x.StatisticalClassification_has_ClassificationItem_, f, this),
    StatisticalClassification_has_LevelStructure_ (x.StatisticalClassification_has_LevelStructure_, f, this)
  {
  }

  StatisticalClassification::
  StatisticalClassification (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::XMLSchema::EnumerationDomain (e, f | ::xml_schema::flags::base, c),
    allowsDuplicates_ (this),
    availableLanguage_ (this),
    catalogDetails_ (this),
    changeFromBase_ (this),
    copyright_ (this),
    displayLabel_ (this),
    isCurrent_ (this),
    isFloating_ (this),
    purposeOfVariant_ (this),
    rationale_ (this),
    releaseDate_ (this),
    updateChanges_ (this),
    usage_ (this),
    validDates_ (this),
    StatisticalClassification_isMaintainedBy_Organization_ (this),
    StatisticalClassification_isIndexedBy_ClassificationIndex_ (this),
    StatisticalClassification_isVariantOf_StatisticalClassification_ (this),
    StatisticalClassification_isSuccessorOf_StatisticalClassification_ (this),
    StatisticalClassification_isPredecessorOf_StatisticalClassification_ (this),
    StatisticalClassification_has_ClassificationItemPosition_ (this),
    StatisticalClassification_has_ClassificationItem_ (this),
    StatisticalClassification_has_LevelStructure_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void StatisticalClassification::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::EnumerationDomain::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // allowsDuplicates
      //
      if (n.name () == "allowsDuplicates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!allowsDuplicates_.present ())
        {
          this->allowsDuplicates_.set (allowsDuplicates_traits::create (i, f, this));
          continue;
        }
      }

      // availableLanguage
      //
      if (n.name () == "availableLanguage" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< availableLanguage_type > r (
          availableLanguage_traits::create (i, f, this));

        this->availableLanguage_.push_back (::std::move (r));
        continue;
      }

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // changeFromBase
      //
      if (n.name () == "changeFromBase" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< changeFromBase_type > r (
          changeFromBase_traits::create (i, f, this));

        if (!this->changeFromBase_)
        {
          this->changeFromBase_.set (::std::move (r));
          continue;
        }
      }

      // copyright
      //
      if (n.name () == "copyright" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< copyright_type > r (
          copyright_traits::create (i, f, this));

        this->copyright_.push_back (::std::move (r));
        continue;
      }

      // displayLabel
      //
      if (n.name () == "displayLabel" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< displayLabel_type > r (
          displayLabel_traits::create (i, f, this));

        this->displayLabel_.push_back (::std::move (r));
        continue;
      }

      // isCurrent
      //
      if (n.name () == "isCurrent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isCurrent_)
        {
          this->isCurrent_.set (isCurrent_traits::create (i, f, this));
          continue;
        }
      }

      // isFloating
      //
      if (n.name () == "isFloating" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isFloating_)
        {
          this->isFloating_.set (isFloating_traits::create (i, f, this));
          continue;
        }
      }

      // purposeOfVariant
      //
      if (n.name () == "purposeOfVariant" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purposeOfVariant_type > r (
          purposeOfVariant_traits::create (i, f, this));

        if (!this->purposeOfVariant_)
        {
          this->purposeOfVariant_.set (::std::move (r));
          continue;
        }
      }

      // rationale
      //
      if (n.name () == "rationale" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< rationale_type > r (
          rationale_traits::create (i, f, this));

        if (!this->rationale_)
        {
          this->rationale_.set (::std::move (r));
          continue;
        }
      }

      // releaseDate
      //
      if (n.name () == "releaseDate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< releaseDate_type > r (
          releaseDate_traits::create (i, f, this));

        if (!this->releaseDate_)
        {
          this->releaseDate_.set (::std::move (r));
          continue;
        }
      }

      // updateChanges
      //
      if (n.name () == "updateChanges" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< updateChanges_type > r (
          updateChanges_traits::create (i, f, this));

        this->updateChanges_.push_back (::std::move (r));
        continue;
      }

      // usage
      //
      if (n.name () == "usage" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< usage_type > r (
          usage_traits::create (i, f, this));

        if (!this->usage_)
        {
          this->usage_.set (::std::move (r));
          continue;
        }
      }

      // validDates
      //
      if (n.name () == "validDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< validDates_type > r (
          validDates_traits::create (i, f, this));

        if (!this->validDates_)
        {
          this->validDates_.set (::std::move (r));
          continue;
        }
      }

      // StatisticalClassification_isMaintainedBy_Organization
      //
      if (n.name () == "StatisticalClassification_isMaintainedBy_Organization" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassification_isMaintainedBy_Organization_type > r (
          StatisticalClassification_isMaintainedBy_Organization_traits::create (i, f, this));

        this->StatisticalClassification_isMaintainedBy_Organization_.push_back (::std::move (r));
        continue;
      }

      // StatisticalClassification_isIndexedBy_ClassificationIndex
      //
      if (n.name () == "StatisticalClassification_isIndexedBy_ClassificationIndex" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassification_isIndexedBy_ClassificationIndex_type > r (
          StatisticalClassification_isIndexedBy_ClassificationIndex_traits::create (i, f, this));

        this->StatisticalClassification_isIndexedBy_ClassificationIndex_.push_back (::std::move (r));
        continue;
      }

      // StatisticalClassification_isVariantOf_StatisticalClassification
      //
      if (n.name () == "StatisticalClassification_isVariantOf_StatisticalClassification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassification_isVariantOf_StatisticalClassification_type > r (
          StatisticalClassification_isVariantOf_StatisticalClassification_traits::create (i, f, this));

        if (!this->StatisticalClassification_isVariantOf_StatisticalClassification_)
        {
          this->StatisticalClassification_isVariantOf_StatisticalClassification_.set (::std::move (r));
          continue;
        }
      }

      // StatisticalClassification_isSuccessorOf_StatisticalClassification
      //
      if (n.name () == "StatisticalClassification_isSuccessorOf_StatisticalClassification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassification_isSuccessorOf_StatisticalClassification_type > r (
          StatisticalClassification_isSuccessorOf_StatisticalClassification_traits::create (i, f, this));

        this->StatisticalClassification_isSuccessorOf_StatisticalClassification_.push_back (::std::move (r));
        continue;
      }

      // StatisticalClassification_isPredecessorOf_StatisticalClassification
      //
      if (n.name () == "StatisticalClassification_isPredecessorOf_StatisticalClassification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassification_isPredecessorOf_StatisticalClassification_type > r (
          StatisticalClassification_isPredecessorOf_StatisticalClassification_traits::create (i, f, this));

        this->StatisticalClassification_isPredecessorOf_StatisticalClassification_.push_back (::std::move (r));
        continue;
      }

      // StatisticalClassification_has_ClassificationItemPosition
      //
      if (n.name () == "StatisticalClassification_has_ClassificationItemPosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassification_has_ClassificationItemPosition_type > r (
          StatisticalClassification_has_ClassificationItemPosition_traits::create (i, f, this));

        this->StatisticalClassification_has_ClassificationItemPosition_.push_back (::std::move (r));
        continue;
      }

      // StatisticalClassification_has_ClassificationItem
      //
      if (n.name () == "StatisticalClassification_has_ClassificationItem" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassification_has_ClassificationItem_type > r (
          StatisticalClassification_has_ClassificationItem_traits::create (i, f, this));

        this->StatisticalClassification_has_ClassificationItem_.push_back (::std::move (r));
        continue;
      }

      // StatisticalClassification_has_LevelStructure
      //
      if (n.name () == "StatisticalClassification_has_LevelStructure" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassification_has_LevelStructure_type > r (
          StatisticalClassification_has_LevelStructure_traits::create (i, f, this));

        if (!this->StatisticalClassification_has_LevelStructure_)
        {
          this->StatisticalClassification_has_LevelStructure_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!allowsDuplicates_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "allowsDuplicates",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  StatisticalClassification* StatisticalClassification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StatisticalClassification (*this, f, c);
  }

  StatisticalClassification& StatisticalClassification::
  operator= (const StatisticalClassification& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::EnumerationDomain& > (*this) = x;
      this->allowsDuplicates_ = x.allowsDuplicates_;
      this->availableLanguage_ = x.availableLanguage_;
      this->catalogDetails_ = x.catalogDetails_;
      this->changeFromBase_ = x.changeFromBase_;
      this->copyright_ = x.copyright_;
      this->displayLabel_ = x.displayLabel_;
      this->isCurrent_ = x.isCurrent_;
      this->isFloating_ = x.isFloating_;
      this->purposeOfVariant_ = x.purposeOfVariant_;
      this->rationale_ = x.rationale_;
      this->releaseDate_ = x.releaseDate_;
      this->updateChanges_ = x.updateChanges_;
      this->usage_ = x.usage_;
      this->validDates_ = x.validDates_;
      this->StatisticalClassification_isMaintainedBy_Organization_ = x.StatisticalClassification_isMaintainedBy_Organization_;
      this->StatisticalClassification_isIndexedBy_ClassificationIndex_ = x.StatisticalClassification_isIndexedBy_ClassificationIndex_;
      this->StatisticalClassification_isVariantOf_StatisticalClassification_ = x.StatisticalClassification_isVariantOf_StatisticalClassification_;
      this->StatisticalClassification_isSuccessorOf_StatisticalClassification_ = x.StatisticalClassification_isSuccessorOf_StatisticalClassification_;
      this->StatisticalClassification_isPredecessorOf_StatisticalClassification_ = x.StatisticalClassification_isPredecessorOf_StatisticalClassification_;
      this->StatisticalClassification_has_ClassificationItemPosition_ = x.StatisticalClassification_has_ClassificationItemPosition_;
      this->StatisticalClassification_has_ClassificationItem_ = x.StatisticalClassification_has_ClassificationItem_;
      this->StatisticalClassification_has_LevelStructure_ = x.StatisticalClassification_has_LevelStructure_;
    }

    return *this;
  }

  StatisticalClassification::
  ~StatisticalClassification ()
  {
  }

  // StatisticalClassificationRelationship
  //

  StatisticalClassificationRelationship::
  StatisticalClassificationRelationship ()
  : ::xml_schema::type (),
    identifier_ (this),
    semantics_ (this),
    StatisticalClassificationRelationship_hasTarget_StatisticalClassification_ (this),
    StatisticalClassificationRelationship_hasSource_StatisticalClassification_ (this)
  {
  }

  StatisticalClassificationRelationship::
  StatisticalClassificationRelationship (const StatisticalClassificationRelationship& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    semantics_ (x.semantics_, f, this),
    StatisticalClassificationRelationship_hasTarget_StatisticalClassification_ (x.StatisticalClassificationRelationship_hasTarget_StatisticalClassification_, f, this),
    StatisticalClassificationRelationship_hasSource_StatisticalClassification_ (x.StatisticalClassificationRelationship_hasSource_StatisticalClassification_, f, this)
  {
  }

  StatisticalClassificationRelationship::
  StatisticalClassificationRelationship (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    semantics_ (this),
    StatisticalClassificationRelationship_hasTarget_StatisticalClassification_ (this),
    StatisticalClassificationRelationship_hasSource_StatisticalClassification_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void StatisticalClassificationRelationship::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // StatisticalClassificationRelationship_hasTarget_StatisticalClassification
      //
      if (n.name () == "StatisticalClassificationRelationship_hasTarget_StatisticalClassification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassificationRelationship_hasTarget_StatisticalClassification_type > r (
          StatisticalClassificationRelationship_hasTarget_StatisticalClassification_traits::create (i, f, this));

        this->StatisticalClassificationRelationship_hasTarget_StatisticalClassification_.push_back (::std::move (r));
        continue;
      }

      // StatisticalClassificationRelationship_hasSource_StatisticalClassification
      //
      if (n.name () == "StatisticalClassificationRelationship_hasSource_StatisticalClassification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< StatisticalClassificationRelationship_hasSource_StatisticalClassification_type > r (
          StatisticalClassificationRelationship_hasSource_StatisticalClassification_traits::create (i, f, this));

        this->StatisticalClassificationRelationship_hasSource_StatisticalClassification_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  StatisticalClassificationRelationship* StatisticalClassificationRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StatisticalClassificationRelationship (*this, f, c);
  }

  StatisticalClassificationRelationship& StatisticalClassificationRelationship::
  operator= (const StatisticalClassificationRelationship& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->semantics_ = x.semantics_;
      this->StatisticalClassificationRelationship_hasTarget_StatisticalClassification_ = x.StatisticalClassificationRelationship_hasTarget_StatisticalClassification_;
      this->StatisticalClassificationRelationship_hasSource_StatisticalClassification_ = x.StatisticalClassificationRelationship_hasSource_StatisticalClassification_;
    }

    return *this;
  }

  StatisticalClassificationRelationship::
  ~StatisticalClassificationRelationship ()
  {
  }

  // Step
  //

  Step::
  Step ()
  : ::XMLSchema::Activity (),
    script_ (this),
    scriptingLanguage_ (this),
    Step_produces_Parameter_ (this),
    Step_receives_Parameter_ (this),
    Step_hasSubStep_Step_ (this)
  {
  }

  Step::
  Step (const Step& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::XMLSchema::Activity (x, f, c),
    script_ (x.script_, f, this),
    scriptingLanguage_ (x.scriptingLanguage_, f, this),
    Step_produces_Parameter_ (x.Step_produces_Parameter_, f, this),
    Step_receives_Parameter_ (x.Step_receives_Parameter_, f, this),
    Step_hasSubStep_Step_ (x.Step_hasSubStep_Step_, f, this)
  {
  }

  Step::
  Step (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::XMLSchema::Activity (e, f | ::xml_schema::flags::base, c),
    script_ (this),
    scriptingLanguage_ (this),
    Step_produces_Parameter_ (this),
    Step_receives_Parameter_ (this),
    Step_hasSubStep_Step_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Step::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::Activity::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // script
      //
      if (n.name () == "script" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< script_type > r (
          script_traits::create (i, f, this));

        if (!this->script_)
        {
          this->script_.set (::std::move (r));
          continue;
        }
      }

      // scriptingLanguage
      //
      if (n.name () == "scriptingLanguage" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< scriptingLanguage_type > r (
          scriptingLanguage_traits::create (i, f, this));

        if (!this->scriptingLanguage_)
        {
          this->scriptingLanguage_.set (::std::move (r));
          continue;
        }
      }

      // Step_produces_Parameter
      //
      if (n.name () == "Step_produces_Parameter" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Step_produces_Parameter_type > r (
          Step_produces_Parameter_traits::create (i, f, this));

        this->Step_produces_Parameter_.push_back (::std::move (r));
        continue;
      }

      // Step_receives_Parameter
      //
      if (n.name () == "Step_receives_Parameter" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Step_receives_Parameter_type > r (
          Step_receives_Parameter_traits::create (i, f, this));

        this->Step_receives_Parameter_.push_back (::std::move (r));
        continue;
      }

      // Step_hasSubStep_Step
      //
      if (n.name () == "Step_hasSubStep_Step" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Step_hasSubStep_Step_type > r (
          Step_hasSubStep_Step_traits::create (i, f, this));

        this->Step_hasSubStep_Step_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Step* Step::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Step (*this, f, c);
  }

  Step& Step::
  operator= (const Step& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Activity& > (*this) = x;
      this->script_ = x.script_;
      this->scriptingLanguage_ = x.scriptingLanguage_;
      this->Step_produces_Parameter_ = x.Step_produces_Parameter_;
      this->Step_receives_Parameter_ = x.Step_receives_Parameter_;
      this->Step_hasSubStep_Step_ = x.Step_hasSubStep_Step_;
    }

    return *this;
  }

  Step::
  ~Step ()
  {
  }

  // SubstantiveConceptualDomain
  //

  SubstantiveConceptualDomain::
  SubstantiveConceptualDomain ()
  : ::XMLSchema::ConceptualDomain ()
  {
  }

  SubstantiveConceptualDomain::
  SubstantiveConceptualDomain (const SubstantiveConceptualDomain& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::XMLSchema::ConceptualDomain (x, f, c)
  {
  }

  SubstantiveConceptualDomain::
  SubstantiveConceptualDomain (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::XMLSchema::ConceptualDomain (e, f, c)
  {
  }

  SubstantiveConceptualDomain* SubstantiveConceptualDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SubstantiveConceptualDomain (*this, f, c);
  }

  SubstantiveConceptualDomain::
  ~SubstantiveConceptualDomain ()
  {
  }

  // SyntheticIdComponent
  //

  SyntheticIdComponent::
  SyntheticIdComponent ()
  : ::XMLSchema::DataStructureComponent ()
  {
  }

  SyntheticIdComponent::
  SyntheticIdComponent (const SyntheticIdComponent& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (x, f, c)
  {
  }

  SyntheticIdComponent::
  SyntheticIdComponent (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (e, f, c)
  {
  }

  SyntheticIdComponent* SyntheticIdComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SyntheticIdComponent (*this, f, c);
  }

  SyntheticIdComponent::
  ~SyntheticIdComponent ()
  {
  }

  // TemporalControlConstruct
  //

  TemporalControlConstruct::
  TemporalControlConstruct (const temporalControl_type& temporalControl)
  : ::XMLSchema::TemporalConstraints (),
    temporalControl_ (temporalControl, this)
  {
  }

  TemporalControlConstruct::
  TemporalControlConstruct (const TemporalControlConstruct& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::TemporalConstraints (x, f, c),
    temporalControl_ (x.temporalControl_, f, this)
  {
  }

  TemporalControlConstruct::
  TemporalControlConstruct (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::TemporalConstraints (e, f | ::xml_schema::flags::base, c),
    temporalControl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TemporalControlConstruct::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::TemporalConstraints::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // temporalControl
      //
      if (n.name () == "temporalControl" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< temporalControl_type > r (
          temporalControl_traits::create (i, f, this));

        if (!temporalControl_.present ())
        {
          this->temporalControl_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!temporalControl_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "temporalControl",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  TemporalControlConstruct* TemporalControlConstruct::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TemporalControlConstruct (*this, f, c);
  }

  TemporalControlConstruct& TemporalControlConstruct::
  operator= (const TemporalControlConstruct& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::TemporalConstraints& > (*this) = x;
      this->temporalControl_ = x.temporalControl_;
    }

    return *this;
  }

  TemporalControlConstruct::
  ~TemporalControlConstruct ()
  {
  }

  // Unit
  //

  Unit::
  Unit ()
  : ::xml_schema::type (),
    catalogDetails_ (this),
    definition_ (this),
    displayLabel_ (this),
    identifier_ (this),
    name_ (this),
    Unit_has_UnitType_ (this)
  {
  }

  Unit::
  Unit (const Unit& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    catalogDetails_ (x.catalogDetails_, f, this),
    definition_ (x.definition_, f, this),
    displayLabel_ (x.displayLabel_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    Unit_has_UnitType_ (x.Unit_has_UnitType_, f, this)
  {
  }

  Unit::
  Unit (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    catalogDetails_ (this),
    definition_ (this),
    displayLabel_ (this),
    identifier_ (this),
    name_ (this),
    Unit_has_UnitType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Unit::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // catalogDetails
      //
      if (n.name () == "catalogDetails" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< catalogDetails_type > r (
          catalogDetails_traits::create (i, f, this));

        if (!this->catalogDetails_)
        {
          this->catalogDetails_.set (::std::move (r));
          continue;
        }
      }

      // definition
      //
      if (n.name () == "definition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< definition_type > r (
          definition_traits::create (i, f, this));

        if (!this->definition_)
        {
          this->definition_.set (::std::move (r));
          continue;
        }
      }

      // displayLabel
      //
      if (n.name () == "displayLabel" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< displayLabel_type > r (
          displayLabel_traits::create (i, f, this));

        this->displayLabel_.push_back (::std::move (r));
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // Unit_has_UnitType
      //
      if (n.name () == "Unit_has_UnitType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< Unit_has_UnitType_type > r (
          Unit_has_UnitType_traits::create (i, f, this));

        this->Unit_has_UnitType_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Unit* Unit::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Unit (*this, f, c);
  }

  Unit& Unit::
  operator= (const Unit& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->catalogDetails_ = x.catalogDetails_;
      this->definition_ = x.definition_;
      this->displayLabel_ = x.displayLabel_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->Unit_has_UnitType_ = x.Unit_has_UnitType_;
    }

    return *this;
  }

  Unit::
  ~Unit ()
  {
  }

  // UnitSegmentLayout
  //

  UnitSegmentLayout::
  UnitSegmentLayout (const allowsDuplicates_type& allowsDuplicates,
                     const isDelimited_type& isDelimited,
                     const isFixedWidth_type& isFixedWidth)
  : ::XMLSchema::PhysicalSegmentLayout (allowsDuplicates,
                                        isDelimited,
                                        isFixedWidth)
  {
  }

  UnitSegmentLayout::
  UnitSegmentLayout (const UnitSegmentLayout& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::PhysicalSegmentLayout (x, f, c)
  {
  }

  UnitSegmentLayout::
  UnitSegmentLayout (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::PhysicalSegmentLayout (e, f, c)
  {
  }

  UnitSegmentLayout* UnitSegmentLayout::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UnitSegmentLayout (*this, f, c);
  }

  UnitSegmentLayout::
  ~UnitSegmentLayout ()
  {
  }

  // ValueAndConceptDescription
  //

  ValueAndConceptDescription::
  ValueAndConceptDescription ()
  : ::xml_schema::type (),
    classificationLevel_ (this),
    description_ (this),
    formatPattern_ (this),
    identifier_ (this),
    logicalExpression_ (this),
    maximumValueExclusive_ (this),
    maximumValueInclusive_ (this),
    minimumValueExclusive_ (this),
    minimumValueInclusive_ (this),
    regularExpression_ (this)
  {
  }

  ValueAndConceptDescription::
  ValueAndConceptDescription (const ValueAndConceptDescription& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    classificationLevel_ (x.classificationLevel_, f, this),
    description_ (x.description_, f, this),
    formatPattern_ (x.formatPattern_, f, this),
    identifier_ (x.identifier_, f, this),
    logicalExpression_ (x.logicalExpression_, f, this),
    maximumValueExclusive_ (x.maximumValueExclusive_, f, this),
    maximumValueInclusive_ (x.maximumValueInclusive_, f, this),
    minimumValueExclusive_ (x.minimumValueExclusive_, f, this),
    minimumValueInclusive_ (x.minimumValueInclusive_, f, this),
    regularExpression_ (x.regularExpression_, f, this)
  {
  }

  ValueAndConceptDescription::
  ValueAndConceptDescription (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    classificationLevel_ (this),
    description_ (this),
    formatPattern_ (this),
    identifier_ (this),
    logicalExpression_ (this),
    maximumValueExclusive_ (this),
    maximumValueInclusive_ (this),
    minimumValueExclusive_ (this),
    minimumValueInclusive_ (this),
    regularExpression_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ValueAndConceptDescription::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // classificationLevel
      //
      if (n.name () == "classificationLevel" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< classificationLevel_type > r (
          classificationLevel_traits::create (i, f, this));

        if (!this->classificationLevel_)
        {
          this->classificationLevel_.set (::std::move (r));
          continue;
        }
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!this->description_)
        {
          this->description_.set (::std::move (r));
          continue;
        }
      }

      // formatPattern
      //
      if (n.name () == "formatPattern" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< formatPattern_type > r (
          formatPattern_traits::create (i, f, this));

        if (!this->formatPattern_)
        {
          this->formatPattern_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // logicalExpression
      //
      if (n.name () == "logicalExpression" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< logicalExpression_type > r (
          logicalExpression_traits::create (i, f, this));

        if (!this->logicalExpression_)
        {
          this->logicalExpression_.set (::std::move (r));
          continue;
        }
      }

      // maximumValueExclusive
      //
      if (n.name () == "maximumValueExclusive" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< maximumValueExclusive_type > r (
          maximumValueExclusive_traits::create (i, f, this));

        if (!this->maximumValueExclusive_)
        {
          this->maximumValueExclusive_.set (::std::move (r));
          continue;
        }
      }

      // maximumValueInclusive
      //
      if (n.name () == "maximumValueInclusive" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< maximumValueInclusive_type > r (
          maximumValueInclusive_traits::create (i, f, this));

        if (!this->maximumValueInclusive_)
        {
          this->maximumValueInclusive_.set (::std::move (r));
          continue;
        }
      }

      // minimumValueExclusive
      //
      if (n.name () == "minimumValueExclusive" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< minimumValueExclusive_type > r (
          minimumValueExclusive_traits::create (i, f, this));

        if (!this->minimumValueExclusive_)
        {
          this->minimumValueExclusive_.set (::std::move (r));
          continue;
        }
      }

      // minimumValueInclusive
      //
      if (n.name () == "minimumValueInclusive" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< minimumValueInclusive_type > r (
          minimumValueInclusive_traits::create (i, f, this));

        if (!this->minimumValueInclusive_)
        {
          this->minimumValueInclusive_.set (::std::move (r));
          continue;
        }
      }

      // regularExpression
      //
      if (n.name () == "regularExpression" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< regularExpression_type > r (
          regularExpression_traits::create (i, f, this));

        if (!this->regularExpression_)
        {
          this->regularExpression_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ValueAndConceptDescription* ValueAndConceptDescription::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ValueAndConceptDescription (*this, f, c);
  }

  ValueAndConceptDescription& ValueAndConceptDescription::
  operator= (const ValueAndConceptDescription& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->classificationLevel_ = x.classificationLevel_;
      this->description_ = x.description_;
      this->formatPattern_ = x.formatPattern_;
      this->identifier_ = x.identifier_;
      this->logicalExpression_ = x.logicalExpression_;
      this->maximumValueExclusive_ = x.maximumValueExclusive_;
      this->maximumValueInclusive_ = x.maximumValueInclusive_;
      this->minimumValueExclusive_ = x.minimumValueExclusive_;
      this->minimumValueInclusive_ = x.minimumValueInclusive_;
      this->regularExpression_ = x.regularExpression_;
    }

    return *this;
  }

  ValueAndConceptDescription::
  ~ValueAndConceptDescription ()
  {
  }

  // ValueMapping
  //

  ValueMapping::
  ValueMapping (const defaultValue_type& defaultValue)
  : ::xml_schema::type (),
    decimalPositions_ (this),
    defaultDecimalSeparator_ (this),
    defaultDigitGroupSeparator_ (this),
    defaultValue_ (defaultValue, this),
    format_ (this),
    identifier_ (this),
    isRequired_ (this),
    length_ (this),
    maximumLength_ (this),
    minimumLength_ (this),
    nullSequence_ (this),
    numberPattern_ (this),
    physicalDataType_ (this),
    scale_ (this),
    ValueMapping_formats_DataPoint_ (this),
    ValueMapping_uses_PhysicalSegmentLocation_ (this)
  {
  }

  ValueMapping::
  ValueMapping (const ValueMapping& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    decimalPositions_ (x.decimalPositions_, f, this),
    defaultDecimalSeparator_ (x.defaultDecimalSeparator_, f, this),
    defaultDigitGroupSeparator_ (x.defaultDigitGroupSeparator_, f, this),
    defaultValue_ (x.defaultValue_, f, this),
    format_ (x.format_, f, this),
    identifier_ (x.identifier_, f, this),
    isRequired_ (x.isRequired_, f, this),
    length_ (x.length_, f, this),
    maximumLength_ (x.maximumLength_, f, this),
    minimumLength_ (x.minimumLength_, f, this),
    nullSequence_ (x.nullSequence_, f, this),
    numberPattern_ (x.numberPattern_, f, this),
    physicalDataType_ (x.physicalDataType_, f, this),
    scale_ (x.scale_, f, this),
    ValueMapping_formats_DataPoint_ (x.ValueMapping_formats_DataPoint_, f, this),
    ValueMapping_uses_PhysicalSegmentLocation_ (x.ValueMapping_uses_PhysicalSegmentLocation_, f, this)
  {
  }

  ValueMapping::
  ValueMapping (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    decimalPositions_ (this),
    defaultDecimalSeparator_ (this),
    defaultDigitGroupSeparator_ (this),
    defaultValue_ (this),
    format_ (this),
    identifier_ (this),
    isRequired_ (this),
    length_ (this),
    maximumLength_ (this),
    minimumLength_ (this),
    nullSequence_ (this),
    numberPattern_ (this),
    physicalDataType_ (this),
    scale_ (this),
    ValueMapping_formats_DataPoint_ (this),
    ValueMapping_uses_PhysicalSegmentLocation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ValueMapping::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // decimalPositions
      //
      if (n.name () == "decimalPositions" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->decimalPositions_)
        {
          this->decimalPositions_.set (decimalPositions_traits::create (i, f, this));
          continue;
        }
      }

      // defaultDecimalSeparator
      //
      if (n.name () == "defaultDecimalSeparator" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< defaultDecimalSeparator_type > r (
          defaultDecimalSeparator_traits::create (i, f, this));

        if (!this->defaultDecimalSeparator_)
        {
          this->defaultDecimalSeparator_.set (::std::move (r));
          continue;
        }
      }

      // defaultDigitGroupSeparator
      //
      if (n.name () == "defaultDigitGroupSeparator" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< defaultDigitGroupSeparator_type > r (
          defaultDigitGroupSeparator_traits::create (i, f, this));

        if (!this->defaultDigitGroupSeparator_)
        {
          this->defaultDigitGroupSeparator_.set (::std::move (r));
          continue;
        }
      }

      // defaultValue
      //
      if (n.name () == "defaultValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< defaultValue_type > r (
          defaultValue_traits::create (i, f, this));

        if (!defaultValue_.present ())
        {
          this->defaultValue_.set (::std::move (r));
          continue;
        }
      }

      // format
      //
      if (n.name () == "format" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< format_type > r (
          format_traits::create (i, f, this));

        if (!this->format_)
        {
          this->format_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // isRequired
      //
      if (n.name () == "isRequired" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isRequired_)
        {
          this->isRequired_.set (isRequired_traits::create (i, f, this));
          continue;
        }
      }

      // length
      //
      if (n.name () == "length" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->length_)
        {
          this->length_.set (length_traits::create (i, f, this));
          continue;
        }
      }

      // maximumLength
      //
      if (n.name () == "maximumLength" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->maximumLength_)
        {
          this->maximumLength_.set (maximumLength_traits::create (i, f, this));
          continue;
        }
      }

      // minimumLength
      //
      if (n.name () == "minimumLength" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->minimumLength_)
        {
          this->minimumLength_.set (minimumLength_traits::create (i, f, this));
          continue;
        }
      }

      // nullSequence
      //
      if (n.name () == "nullSequence" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< nullSequence_type > r (
          nullSequence_traits::create (i, f, this));

        if (!this->nullSequence_)
        {
          this->nullSequence_.set (::std::move (r));
          continue;
        }
      }

      // numberPattern
      //
      if (n.name () == "numberPattern" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< numberPattern_type > r (
          numberPattern_traits::create (i, f, this));

        if (!this->numberPattern_)
        {
          this->numberPattern_.set (::std::move (r));
          continue;
        }
      }

      // physicalDataType
      //
      if (n.name () == "physicalDataType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< physicalDataType_type > r (
          physicalDataType_traits::create (i, f, this));

        if (!this->physicalDataType_)
        {
          this->physicalDataType_.set (::std::move (r));
          continue;
        }
      }

      // scale
      //
      if (n.name () == "scale" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->scale_)
        {
          this->scale_.set (scale_traits::create (i, f, this));
          continue;
        }
      }

      // ValueMapping_formats_DataPoint
      //
      if (n.name () == "ValueMapping_formats_DataPoint" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueMapping_formats_DataPoint_type > r (
          ValueMapping_formats_DataPoint_traits::create (i, f, this));

        this->ValueMapping_formats_DataPoint_.push_back (::std::move (r));
        continue;
      }

      // ValueMapping_uses_PhysicalSegmentLocation
      //
      if (n.name () == "ValueMapping_uses_PhysicalSegmentLocation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueMapping_uses_PhysicalSegmentLocation_type > r (
          ValueMapping_uses_PhysicalSegmentLocation_traits::create (i, f, this));

        if (!this->ValueMapping_uses_PhysicalSegmentLocation_)
        {
          this->ValueMapping_uses_PhysicalSegmentLocation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!defaultValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "defaultValue",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ValueMapping* ValueMapping::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ValueMapping (*this, f, c);
  }

  ValueMapping& ValueMapping::
  operator= (const ValueMapping& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->decimalPositions_ = x.decimalPositions_;
      this->defaultDecimalSeparator_ = x.defaultDecimalSeparator_;
      this->defaultDigitGroupSeparator_ = x.defaultDigitGroupSeparator_;
      this->defaultValue_ = x.defaultValue_;
      this->format_ = x.format_;
      this->identifier_ = x.identifier_;
      this->isRequired_ = x.isRequired_;
      this->length_ = x.length_;
      this->maximumLength_ = x.maximumLength_;
      this->minimumLength_ = x.minimumLength_;
      this->nullSequence_ = x.nullSequence_;
      this->numberPattern_ = x.numberPattern_;
      this->physicalDataType_ = x.physicalDataType_;
      this->scale_ = x.scale_;
      this->ValueMapping_formats_DataPoint_ = x.ValueMapping_formats_DataPoint_;
      this->ValueMapping_uses_PhysicalSegmentLocation_ = x.ValueMapping_uses_PhysicalSegmentLocation_;
    }

    return *this;
  }

  ValueMapping::
  ~ValueMapping ()
  {
  }

  // ValueMappingPosition
  //

  ValueMappingPosition::
  ValueMappingPosition (const value_type& value,
                        const ValueMappingPosition_indexes_ValueMapping_type& ValueMappingPosition_indexes_ValueMapping)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    ValueMappingPosition_indexes_ValueMapping_ (ValueMappingPosition_indexes_ValueMapping, this)
  {
  }

  ValueMappingPosition::
  ValueMappingPosition (const value_type& value,
                        ::std::unique_ptr< ValueMappingPosition_indexes_ValueMapping_type > ValueMappingPosition_indexes_ValueMapping)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    ValueMappingPosition_indexes_ValueMapping_ (std::move (ValueMappingPosition_indexes_ValueMapping), this)
  {
  }

  ValueMappingPosition::
  ValueMappingPosition (const ValueMappingPosition& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    value_ (x.value_, f, this),
    ValueMappingPosition_indexes_ValueMapping_ (x.ValueMappingPosition_indexes_ValueMapping_, f, this)
  {
  }

  ValueMappingPosition::
  ValueMappingPosition (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    value_ (this),
    ValueMappingPosition_indexes_ValueMapping_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ValueMappingPosition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      // ValueMappingPosition_indexes_ValueMapping
      //
      if (n.name () == "ValueMappingPosition_indexes_ValueMapping" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueMappingPosition_indexes_ValueMapping_type > r (
          ValueMappingPosition_indexes_ValueMapping_traits::create (i, f, this));

        if (!ValueMappingPosition_indexes_ValueMapping_.present ())
        {
          this->ValueMappingPosition_indexes_ValueMapping_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!ValueMappingPosition_indexes_ValueMapping_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ValueMappingPosition_indexes_ValueMapping",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ValueMappingPosition* ValueMappingPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ValueMappingPosition (*this, f, c);
  }

  ValueMappingPosition& ValueMappingPosition::
  operator= (const ValueMappingPosition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->value_ = x.value_;
      this->ValueMappingPosition_indexes_ValueMapping_ = x.ValueMappingPosition_indexes_ValueMapping_;
    }

    return *this;
  }

  ValueMappingPosition::
  ~ValueMappingPosition ()
  {
  }

  // ValueMappingRelationship
  //

  ValueMappingRelationship::
  ValueMappingRelationship ()
  : ::xml_schema::type (),
    identifier_ (this),
    semantics_ (this),
    ValueMappingRelationship_hasTarget_ValueMapping_ (this),
    ValueMappingRelationship_hasSource_ValueMapping_ (this)
  {
  }

  ValueMappingRelationship::
  ValueMappingRelationship (const ValueMappingRelationship& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    semantics_ (x.semantics_, f, this),
    ValueMappingRelationship_hasTarget_ValueMapping_ (x.ValueMappingRelationship_hasTarget_ValueMapping_, f, this),
    ValueMappingRelationship_hasSource_ValueMapping_ (x.ValueMappingRelationship_hasSource_ValueMapping_, f, this)
  {
  }

  ValueMappingRelationship::
  ValueMappingRelationship (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    semantics_ (this),
    ValueMappingRelationship_hasTarget_ValueMapping_ (this),
    ValueMappingRelationship_hasSource_ValueMapping_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ValueMappingRelationship::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // ValueMappingRelationship_hasTarget_ValueMapping
      //
      if (n.name () == "ValueMappingRelationship_hasTarget_ValueMapping" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueMappingRelationship_hasTarget_ValueMapping_type > r (
          ValueMappingRelationship_hasTarget_ValueMapping_traits::create (i, f, this));

        this->ValueMappingRelationship_hasTarget_ValueMapping_.push_back (::std::move (r));
        continue;
      }

      // ValueMappingRelationship_hasSource_ValueMapping
      //
      if (n.name () == "ValueMappingRelationship_hasSource_ValueMapping" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ValueMappingRelationship_hasSource_ValueMapping_type > r (
          ValueMappingRelationship_hasSource_ValueMapping_traits::create (i, f, this));

        this->ValueMappingRelationship_hasSource_ValueMapping_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ValueMappingRelationship* ValueMappingRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ValueMappingRelationship (*this, f, c);
  }

  ValueMappingRelationship& ValueMappingRelationship::
  operator= (const ValueMappingRelationship& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->semantics_ = x.semantics_;
      this->ValueMappingRelationship_hasTarget_ValueMapping_ = x.ValueMappingRelationship_hasTarget_ValueMapping_;
      this->ValueMappingRelationship_hasSource_ValueMapping_ = x.ValueMappingRelationship_hasSource_ValueMapping_;
    }

    return *this;
  }

  ValueMappingRelationship::
  ~ValueMappingRelationship ()
  {
  }

  // VariableCollection
  //

  VariableCollection::
  VariableCollection (const allowsDuplicates_type& allowsDuplicates)
  : ::xml_schema::type (),
    allowsDuplicates_ (allowsDuplicates, this),
    displayLabel_ (this),
    groupingSemantic_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    usage_ (this),
    VariableCollection_isDefinedBy_Concept_ (this),
    VariableCollection_has_ConceptualVariable_ (this),
    VariableCollection_has_VariablePosition_ (this)
  {
  }

  VariableCollection::
  VariableCollection (const VariableCollection& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    allowsDuplicates_ (x.allowsDuplicates_, f, this),
    displayLabel_ (x.displayLabel_, f, this),
    groupingSemantic_ (x.groupingSemantic_, f, this),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    usage_ (x.usage_, f, this),
    VariableCollection_isDefinedBy_Concept_ (x.VariableCollection_isDefinedBy_Concept_, f, this),
    VariableCollection_has_ConceptualVariable_ (x.VariableCollection_has_ConceptualVariable_, f, this),
    VariableCollection_has_VariablePosition_ (x.VariableCollection_has_VariablePosition_, f, this)
  {
  }

  VariableCollection::
  VariableCollection (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    allowsDuplicates_ (this),
    displayLabel_ (this),
    groupingSemantic_ (this),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    usage_ (this),
    VariableCollection_isDefinedBy_Concept_ (this),
    VariableCollection_has_ConceptualVariable_ (this),
    VariableCollection_has_VariablePosition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VariableCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // allowsDuplicates
      //
      if (n.name () == "allowsDuplicates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!allowsDuplicates_.present ())
        {
          this->allowsDuplicates_.set (allowsDuplicates_traits::create (i, f, this));
          continue;
        }
      }

      // displayLabel
      //
      if (n.name () == "displayLabel" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< displayLabel_type > r (
          displayLabel_traits::create (i, f, this));

        this->displayLabel_.push_back (::std::move (r));
        continue;
      }

      // groupingSemantic
      //
      if (n.name () == "groupingSemantic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< groupingSemantic_type > r (
          groupingSemantic_traits::create (i, f, this));

        if (!this->groupingSemantic_)
        {
          this->groupingSemantic_.set (::std::move (r));
          continue;
        }
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // usage
      //
      if (n.name () == "usage" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< usage_type > r (
          usage_traits::create (i, f, this));

        if (!this->usage_)
        {
          this->usage_.set (::std::move (r));
          continue;
        }
      }

      // VariableCollection_isDefinedBy_Concept
      //
      if (n.name () == "VariableCollection_isDefinedBy_Concept" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableCollection_isDefinedBy_Concept_type > r (
          VariableCollection_isDefinedBy_Concept_traits::create (i, f, this));

        this->VariableCollection_isDefinedBy_Concept_.push_back (::std::move (r));
        continue;
      }

      // VariableCollection_has_ConceptualVariable
      //
      if (n.name () == "VariableCollection_has_ConceptualVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableCollection_has_ConceptualVariable_type > r (
          VariableCollection_has_ConceptualVariable_traits::create (i, f, this));

        this->VariableCollection_has_ConceptualVariable_.push_back (::std::move (r));
        continue;
      }

      // VariableCollection_has_VariablePosition
      //
      if (n.name () == "VariableCollection_has_VariablePosition" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableCollection_has_VariablePosition_type > r (
          VariableCollection_has_VariablePosition_traits::create (i, f, this));

        this->VariableCollection_has_VariablePosition_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!allowsDuplicates_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "allowsDuplicates",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  VariableCollection* VariableCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableCollection (*this, f, c);
  }

  VariableCollection& VariableCollection::
  operator= (const VariableCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->allowsDuplicates_ = x.allowsDuplicates_;
      this->displayLabel_ = x.displayLabel_;
      this->groupingSemantic_ = x.groupingSemantic_;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->usage_ = x.usage_;
      this->VariableCollection_isDefinedBy_Concept_ = x.VariableCollection_isDefinedBy_Concept_;
      this->VariableCollection_has_ConceptualVariable_ = x.VariableCollection_has_ConceptualVariable_;
      this->VariableCollection_has_VariablePosition_ = x.VariableCollection_has_VariablePosition_;
    }

    return *this;
  }

  VariableCollection::
  ~VariableCollection ()
  {
  }

  // VariableDescriptorComponent
  //

  VariableDescriptorComponent::
  VariableDescriptorComponent (const VariableDescriptorComponent_refersTo_VariableValueComponent_type& VariableDescriptorComponent_refersTo_VariableValueComponent)
  : ::XMLSchema::DataStructureComponent (),
    VariableDescriptorComponent_isDefinedBy_DescriptorVariable_ (this),
    VariableDescriptorComponent_refersTo_VariableValueComponent_ (VariableDescriptorComponent_refersTo_VariableValueComponent, this)
  {
  }

  VariableDescriptorComponent::
  VariableDescriptorComponent (::std::unique_ptr< VariableDescriptorComponent_refersTo_VariableValueComponent_type > VariableDescriptorComponent_refersTo_VariableValueComponent)
  : ::XMLSchema::DataStructureComponent (),
    VariableDescriptorComponent_isDefinedBy_DescriptorVariable_ (this),
    VariableDescriptorComponent_refersTo_VariableValueComponent_ (std::move (VariableDescriptorComponent_refersTo_VariableValueComponent), this)
  {
  }

  VariableDescriptorComponent::
  VariableDescriptorComponent (const VariableDescriptorComponent& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (x, f, c),
    VariableDescriptorComponent_isDefinedBy_DescriptorVariable_ (x.VariableDescriptorComponent_isDefinedBy_DescriptorVariable_, f, this),
    VariableDescriptorComponent_refersTo_VariableValueComponent_ (x.VariableDescriptorComponent_refersTo_VariableValueComponent_, f, this)
  {
  }

  VariableDescriptorComponent::
  VariableDescriptorComponent (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (e, f | ::xml_schema::flags::base, c),
    VariableDescriptorComponent_isDefinedBy_DescriptorVariable_ (this),
    VariableDescriptorComponent_refersTo_VariableValueComponent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VariableDescriptorComponent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::DataStructureComponent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // VariableDescriptorComponent_isDefinedBy_DescriptorVariable
      //
      if (n.name () == "VariableDescriptorComponent_isDefinedBy_DescriptorVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableDescriptorComponent_isDefinedBy_DescriptorVariable_type > r (
          VariableDescriptorComponent_isDefinedBy_DescriptorVariable_traits::create (i, f, this));

        if (!this->VariableDescriptorComponent_isDefinedBy_DescriptorVariable_)
        {
          this->VariableDescriptorComponent_isDefinedBy_DescriptorVariable_.set (::std::move (r));
          continue;
        }
      }

      // VariableDescriptorComponent_refersTo_VariableValueComponent
      //
      if (n.name () == "VariableDescriptorComponent_refersTo_VariableValueComponent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableDescriptorComponent_refersTo_VariableValueComponent_type > r (
          VariableDescriptorComponent_refersTo_VariableValueComponent_traits::create (i, f, this));

        if (!VariableDescriptorComponent_refersTo_VariableValueComponent_.present ())
        {
          this->VariableDescriptorComponent_refersTo_VariableValueComponent_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!VariableDescriptorComponent_refersTo_VariableValueComponent_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "VariableDescriptorComponent_refersTo_VariableValueComponent",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  VariableDescriptorComponent* VariableDescriptorComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableDescriptorComponent (*this, f, c);
  }

  VariableDescriptorComponent& VariableDescriptorComponent::
  operator= (const VariableDescriptorComponent& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::DataStructureComponent& > (*this) = x;
      this->VariableDescriptorComponent_isDefinedBy_DescriptorVariable_ = x.VariableDescriptorComponent_isDefinedBy_DescriptorVariable_;
      this->VariableDescriptorComponent_refersTo_VariableValueComponent_ = x.VariableDescriptorComponent_refersTo_VariableValueComponent_;
    }

    return *this;
  }

  VariableDescriptorComponent::
  ~VariableDescriptorComponent ()
  {
  }

  // VariablePosition
  //

  VariablePosition::
  VariablePosition (const value_type& value,
                    const VariablePosition_indexes_ConceptualVariable_type& VariablePosition_indexes_ConceptualVariable)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    VariablePosition_indexes_ConceptualVariable_ (VariablePosition_indexes_ConceptualVariable, this)
  {
  }

  VariablePosition::
  VariablePosition (const value_type& value,
                    ::std::unique_ptr< VariablePosition_indexes_ConceptualVariable_type > VariablePosition_indexes_ConceptualVariable)
  : ::xml_schema::type (),
    identifier_ (this),
    value_ (value, this),
    VariablePosition_indexes_ConceptualVariable_ (std::move (VariablePosition_indexes_ConceptualVariable), this)
  {
  }

  VariablePosition::
  VariablePosition (const VariablePosition& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    value_ (x.value_, f, this),
    VariablePosition_indexes_ConceptualVariable_ (x.VariablePosition_indexes_ConceptualVariable_, f, this)
  {
  }

  VariablePosition::
  VariablePosition (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    value_ (this),
    VariablePosition_indexes_ConceptualVariable_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VariablePosition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      // VariablePosition_indexes_ConceptualVariable
      //
      if (n.name () == "VariablePosition_indexes_ConceptualVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariablePosition_indexes_ConceptualVariable_type > r (
          VariablePosition_indexes_ConceptualVariable_traits::create (i, f, this));

        if (!VariablePosition_indexes_ConceptualVariable_.present ())
        {
          this->VariablePosition_indexes_ConceptualVariable_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!VariablePosition_indexes_ConceptualVariable_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "VariablePosition_indexes_ConceptualVariable",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  VariablePosition* VariablePosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariablePosition (*this, f, c);
  }

  VariablePosition& VariablePosition::
  operator= (const VariablePosition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->value_ = x.value_;
      this->VariablePosition_indexes_ConceptualVariable_ = x.VariablePosition_indexes_ConceptualVariable_;
    }

    return *this;
  }

  VariablePosition::
  ~VariablePosition ()
  {
  }

  // VariableRelationship
  //

  VariableRelationship::
  VariableRelationship ()
  : ::xml_schema::type (),
    identifier_ (this),
    semantics_ (this),
    VariableRelationship_hasTarget_ConceptualVariable_ (this),
    VariableRelationship_hasSource_ConceptualVariable_ (this)
  {
  }

  VariableRelationship::
  VariableRelationship (const VariableRelationship& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    semantics_ (x.semantics_, f, this),
    VariableRelationship_hasTarget_ConceptualVariable_ (x.VariableRelationship_hasTarget_ConceptualVariable_, f, this),
    VariableRelationship_hasSource_ConceptualVariable_ (x.VariableRelationship_hasSource_ConceptualVariable_, f, this)
  {
  }

  VariableRelationship::
  VariableRelationship (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    semantics_ (this),
    VariableRelationship_hasTarget_ConceptualVariable_ (this),
    VariableRelationship_hasSource_ConceptualVariable_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VariableRelationship::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // VariableRelationship_hasTarget_ConceptualVariable
      //
      if (n.name () == "VariableRelationship_hasTarget_ConceptualVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableRelationship_hasTarget_ConceptualVariable_type > r (
          VariableRelationship_hasTarget_ConceptualVariable_traits::create (i, f, this));

        this->VariableRelationship_hasTarget_ConceptualVariable_.push_back (::std::move (r));
        continue;
      }

      // VariableRelationship_hasSource_ConceptualVariable
      //
      if (n.name () == "VariableRelationship_hasSource_ConceptualVariable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableRelationship_hasSource_ConceptualVariable_type > r (
          VariableRelationship_hasSource_ConceptualVariable_traits::create (i, f, this));

        this->VariableRelationship_hasSource_ConceptualVariable_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  VariableRelationship* VariableRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableRelationship (*this, f, c);
  }

  VariableRelationship& VariableRelationship::
  operator= (const VariableRelationship& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->semantics_ = x.semantics_;
      this->VariableRelationship_hasTarget_ConceptualVariable_ = x.VariableRelationship_hasTarget_ConceptualVariable_;
      this->VariableRelationship_hasSource_ConceptualVariable_ = x.VariableRelationship_hasSource_ConceptualVariable_;
    }

    return *this;
  }

  VariableRelationship::
  ~VariableRelationship ()
  {
  }

  // VariableStructure
  //

  VariableStructure::
  VariableStructure ()
  : ::xml_schema::type (),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    VariableStructure_structures_VariableCollection_ (this),
    VariableStructure_has_VariableRelationship_ (this)
  {
  }

  VariableStructure::
  VariableStructure (const VariableStructure& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    name_ (x.name_, f, this),
    purpose_ (x.purpose_, f, this),
    semantics_ (x.semantics_, f, this),
    specification_ (x.specification_, f, this),
    topology_ (x.topology_, f, this),
    totality_ (x.totality_, f, this),
    VariableStructure_structures_VariableCollection_ (x.VariableStructure_structures_VariableCollection_, f, this),
    VariableStructure_has_VariableRelationship_ (x.VariableStructure_has_VariableRelationship_, f, this)
  {
  }

  VariableStructure::
  VariableStructure (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (this),
    name_ (this),
    purpose_ (this),
    semantics_ (this),
    specification_ (this),
    topology_ (this),
    totality_ (this),
    VariableStructure_structures_VariableCollection_ (this),
    VariableStructure_has_VariableRelationship_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VariableStructure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (::std::move (r));
        continue;
      }

      // purpose
      //
      if (n.name () == "purpose" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        if (!this->purpose_)
        {
          this->purpose_.set (::std::move (r));
          continue;
        }
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      // specification
      //
      if (n.name () == "specification" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< specification_type > r (
          specification_traits::create (i, f, this));

        if (!this->specification_)
        {
          this->specification_.set (::std::move (r));
          continue;
        }
      }

      // topology
      //
      if (n.name () == "topology" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< topology_type > r (
          topology_traits::create (i, f, this));

        if (!this->topology_)
        {
          this->topology_.set (::std::move (r));
          continue;
        }
      }

      // totality
      //
      if (n.name () == "totality" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< totality_type > r (
          totality_traits::create (i, f, this));

        if (!this->totality_)
        {
          this->totality_.set (::std::move (r));
          continue;
        }
      }

      // VariableStructure_structures_VariableCollection
      //
      if (n.name () == "VariableStructure_structures_VariableCollection" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableStructure_structures_VariableCollection_type > r (
          VariableStructure_structures_VariableCollection_traits::create (i, f, this));

        if (!this->VariableStructure_structures_VariableCollection_)
        {
          this->VariableStructure_structures_VariableCollection_.set (::std::move (r));
          continue;
        }
      }

      // VariableStructure_has_VariableRelationship
      //
      if (n.name () == "VariableStructure_has_VariableRelationship" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< VariableStructure_has_VariableRelationship_type > r (
          VariableStructure_has_VariableRelationship_traits::create (i, f, this));

        this->VariableStructure_has_VariableRelationship_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  VariableStructure* VariableStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableStructure (*this, f, c);
  }

  VariableStructure& VariableStructure::
  operator= (const VariableStructure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifier_ = x.identifier_;
      this->name_ = x.name_;
      this->purpose_ = x.purpose_;
      this->semantics_ = x.semantics_;
      this->specification_ = x.specification_;
      this->topology_ = x.topology_;
      this->totality_ = x.totality_;
      this->VariableStructure_structures_VariableCollection_ = x.VariableStructure_structures_VariableCollection_;
      this->VariableStructure_has_VariableRelationship_ = x.VariableStructure_has_VariableRelationship_;
    }

    return *this;
  }

  VariableStructure::
  ~VariableStructure ()
  {
  }

  // VariableValueComponent
  //

  VariableValueComponent::
  VariableValueComponent ()
  : ::XMLSchema::DataStructureComponent ()
  {
  }

  VariableValueComponent::
  VariableValueComponent (const VariableValueComponent& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (x, f, c)
  {
  }

  VariableValueComponent::
  VariableValueComponent (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::XMLSchema::DataStructureComponent (e, f, c)
  {
  }

  VariableValueComponent* VariableValueComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableValueComponent (*this, f, c);
  }

  VariableValueComponent::
  ~VariableValueComponent ()
  {
  }

  // WideDataSet
  //

  WideDataSet::
  WideDataSet ()
  : ::XMLSchema::DataSet ()
  {
  }

  WideDataSet::
  WideDataSet (const WideDataSet& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::XMLSchema::DataSet (x, f, c)
  {
  }

  WideDataSet::
  WideDataSet (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::XMLSchema::DataSet (e, f, c)
  {
  }

  WideDataSet* WideDataSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class WideDataSet (*this, f, c);
  }

  WideDataSet::
  ~WideDataSet ()
  {
  }

  // WideDataStructure
  //

  WideDataStructure::
  WideDataStructure ()
  : ::XMLSchema::DataStructure ()
  {
  }

  WideDataStructure::
  WideDataStructure (const WideDataStructure& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::DataStructure (x, f, c)
  {
  }

  WideDataStructure::
  WideDataStructure (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::DataStructure (e, f, c)
  {
  }

  WideDataStructure* WideDataStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class WideDataStructure (*this, f, c);
  }

  WideDataStructure::
  ~WideDataStructure ()
  {
  }

  // WideKey
  //

  WideKey::
  WideKey ()
  : ::XMLSchema::Key ()
  {
  }

  WideKey::
  WideKey (const WideKey& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::XMLSchema::Key (x, f, c)
  {
  }

  WideKey::
  WideKey (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::XMLSchema::Key (e, f, c)
  {
  }

  WideKey* WideKey::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class WideKey (*this, f, c);
  }

  WideKey::
  ~WideKey ()
  {
  }

  // WideKeyMember
  //

  WideKeyMember::
  WideKeyMember (const InstanceValue_hasValueFrom_ValueDomain_type& InstanceValue_hasValueFrom_ValueDomain)
  : ::XMLSchema::KeyMember (InstanceValue_hasValueFrom_ValueDomain)
  {
  }

  WideKeyMember::
  WideKeyMember (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type > InstanceValue_hasValueFrom_ValueDomain)
  : ::XMLSchema::KeyMember (std::move (InstanceValue_hasValueFrom_ValueDomain))
  {
  }

  WideKeyMember::
  WideKeyMember (const WideKeyMember& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::XMLSchema::KeyMember (x, f, c)
  {
  }

  WideKeyMember::
  WideKeyMember (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::XMLSchema::KeyMember (e, f, c)
  {
  }

  WideKeyMember* WideKeyMember::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class WideKeyMember (*this, f, c);
  }

  WideKeyMember::
  ~WideKeyMember ()
  {
  }

  // CategoryRelationCode
  //

  CategoryRelationCode::
  CategoryRelationCode (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_CategoryRelationCode_convert ();
  }

  CategoryRelationCode::
  CategoryRelationCode (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_CategoryRelationCode_convert ();
  }

  CategoryRelationCode::
  CategoryRelationCode (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_CategoryRelationCode_convert ();
  }

  CategoryRelationCode* CategoryRelationCode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategoryRelationCode (*this, f, c);
  }

  CategoryRelationCode::value CategoryRelationCode::
  _xsd_CategoryRelationCode_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CategoryRelationCode_literals_);
    const value* i (::std::lower_bound (
                      _xsd_CategoryRelationCode_indexes_,
                      _xsd_CategoryRelationCode_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_CategoryRelationCode_indexes_ + 5 || _xsd_CategoryRelationCode_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const CategoryRelationCode::
  _xsd_CategoryRelationCode_literals_[5] =
  {
    "Continuous",
    "Interval",
    "Nominal",
    "Ordinal",
    "Ratio"
  };

  const CategoryRelationCode::value CategoryRelationCode::
  _xsd_CategoryRelationCode_indexes_[5] =
  {
    ::XMLSchema::CategoryRelationCode::Continuous,
    ::XMLSchema::CategoryRelationCode::Interval,
    ::XMLSchema::CategoryRelationCode::Nominal,
    ::XMLSchema::CategoryRelationCode::Ordinal,
    ::XMLSchema::CategoryRelationCode::Ratio
  };

  // ComparisonOperator
  //

  ComparisonOperator::
  ComparisonOperator (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_ComparisonOperator_convert ();
  }

  ComparisonOperator::
  ComparisonOperator (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_ComparisonOperator_convert ();
  }

  ComparisonOperator::
  ComparisonOperator (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_ComparisonOperator_convert ();
  }

  ComparisonOperator* ComparisonOperator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComparisonOperator (*this, f, c);
  }

  ComparisonOperator::value ComparisonOperator::
  _xsd_ComparisonOperator_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ComparisonOperator_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ComparisonOperator_indexes_,
                      _xsd_ComparisonOperator_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_ComparisonOperator_indexes_ + 6 || _xsd_ComparisonOperator_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ComparisonOperator::
  _xsd_ComparisonOperator_literals_[6] =
  {
    "Equal",
    "GreaterThan",
    "GreaterThanOrEqualTo",
    "LessThan",
    "LessThanOrEqualTo",
    "NotEqual"
  };

  const ComparisonOperator::value ComparisonOperator::
  _xsd_ComparisonOperator_indexes_[6] =
  {
    ::XMLSchema::ComparisonOperator::Equal,
    ::XMLSchema::ComparisonOperator::GreaterThan,
    ::XMLSchema::ComparisonOperator::GreaterThanOrEqualTo,
    ::XMLSchema::ComparisonOperator::LessThan,
    ::XMLSchema::ComparisonOperator::LessThanOrEqualTo,
    ::XMLSchema::ComparisonOperator::NotEqual
  };

  // ComputationBaseList
  //

  ComputationBaseList::
  ComputationBaseList (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_ComputationBaseList_convert ();
  }

  ComputationBaseList::
  ComputationBaseList (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_ComputationBaseList_convert ();
  }

  ComputationBaseList::
  ComputationBaseList (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_ComputationBaseList_convert ();
  }

  ComputationBaseList* ComputationBaseList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComputationBaseList (*this, f, c);
  }

  ComputationBaseList::value ComputationBaseList::
  _xsd_ComputationBaseList_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ComputationBaseList_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ComputationBaseList_indexes_,
                      _xsd_ComputationBaseList_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_ComputationBaseList_indexes_ + 3 || _xsd_ComputationBaseList_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ComputationBaseList::
  _xsd_ComputationBaseList_literals_[3] =
  {
    "MissingOnly",
    "Total",
    "ValidOnly"
  };

  const ComputationBaseList::value ComputationBaseList::
  _xsd_ComputationBaseList_indexes_[3] =
  {
    ::XMLSchema::ComputationBaseList::MissingOnly,
    ::XMLSchema::ComputationBaseList::Total,
    ::XMLSchema::ComputationBaseList::ValidOnly
  };

  // ControlConstruct
  //

  ControlConstruct::
  ControlConstruct (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_ControlConstruct_convert ();
  }

  ControlConstruct::
  ControlConstruct (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_ControlConstruct_convert ();
  }

  ControlConstruct::
  ControlConstruct (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_ControlConstruct_convert ();
  }

  ControlConstruct* ControlConstruct::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ControlConstruct (*this, f, c);
  }

  ControlConstruct::value ControlConstruct::
  _xsd_ControlConstruct_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ControlConstruct_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ControlConstruct_indexes_,
                      _xsd_ControlConstruct_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_ControlConstruct_indexes_ + 5 || _xsd_ControlConstruct_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ControlConstruct::
  _xsd_ControlConstruct_literals_[5] =
  {
    "Else",
    "IfThen",
    "Loop",
    "RepeatUntil",
    "RepeatWhile"
  };

  const ControlConstruct::value ControlConstruct::
  _xsd_ControlConstruct_indexes_[5] =
  {
    ::XMLSchema::ControlConstruct::Else,
    ::XMLSchema::ControlConstruct::IfThen,
    ::XMLSchema::ControlConstruct::Loop,
    ::XMLSchema::ControlConstruct::RepeatUntil,
    ::XMLSchema::ControlConstruct::RepeatWhile
  };

  // MatchingCriterion
  //

  MatchingCriterion::
  MatchingCriterion (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_MatchingCriterion_convert ();
  }

  MatchingCriterion::
  MatchingCriterion (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_MatchingCriterion_convert ();
  }

  MatchingCriterion::
  MatchingCriterion (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_MatchingCriterion_convert ();
  }

  MatchingCriterion* MatchingCriterion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MatchingCriterion (*this, f, c);
  }

  MatchingCriterion::value MatchingCriterion::
  _xsd_MatchingCriterion_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MatchingCriterion_literals_);
    const value* i (::std::lower_bound (
                      _xsd_MatchingCriterion_indexes_,
                      _xsd_MatchingCriterion_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_MatchingCriterion_indexes_ + 3 || _xsd_MatchingCriterion_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MatchingCriterion::
  _xsd_MatchingCriterion_literals_[3] =
  {
    "CloseMatch",
    "Disjoint",
    "ExactMatch"
  };

  const MatchingCriterion::value MatchingCriterion::
  _xsd_MatchingCriterion_indexes_[3] =
  {
    ::XMLSchema::MatchingCriterion::CloseMatch,
    ::XMLSchema::MatchingCriterion::Disjoint,
    ::XMLSchema::MatchingCriterion::ExactMatch
  };

  // MemberRelationshipScope
  //

  MemberRelationshipScope::
  MemberRelationshipScope (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_MemberRelationshipScope_convert ();
  }

  MemberRelationshipScope::
  MemberRelationshipScope (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_MemberRelationshipScope_convert ();
  }

  MemberRelationshipScope::
  MemberRelationshipScope (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_MemberRelationshipScope_convert ();
  }

  MemberRelationshipScope* MemberRelationshipScope::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MemberRelationshipScope (*this, f, c);
  }

  MemberRelationshipScope::value MemberRelationshipScope::
  _xsd_MemberRelationshipScope_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MemberRelationshipScope_literals_);
    const value* i (::std::lower_bound (
                      _xsd_MemberRelationshipScope_indexes_,
                      _xsd_MemberRelationshipScope_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_MemberRelationshipScope_indexes_ + 3 || _xsd_MemberRelationshipScope_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MemberRelationshipScope::
  _xsd_MemberRelationshipScope_literals_[3] =
  {
    "All",
    "None",
    "Some"
  };

  const MemberRelationshipScope::value MemberRelationshipScope::
  _xsd_MemberRelationshipScope_indexes_[3] =
  {
    ::XMLSchema::MemberRelationshipScope::All,
    ::XMLSchema::MemberRelationshipScope::None,
    ::XMLSchema::MemberRelationshipScope::Some
  };

  // PointFormat
  //

  PointFormat::
  PointFormat (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_PointFormat_convert ();
  }

  PointFormat::
  PointFormat (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_PointFormat_convert ();
  }

  PointFormat::
  PointFormat (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_PointFormat_convert ();
  }

  PointFormat* PointFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PointFormat (*this, f, c);
  }

  PointFormat::value PointFormat::
  _xsd_PointFormat_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PointFormat_literals_);
    const value* i (::std::lower_bound (
                      _xsd_PointFormat_indexes_,
                      _xsd_PointFormat_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_PointFormat_indexes_ + 5 || _xsd_PointFormat_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const PointFormat::
  _xsd_PointFormat_literals_[5] =
  {
    "DecimalDegree",
    "DecimalMinutes",
    "DegreesMinutesSeconds",
    "Feet",
    "Meters"
  };

  const PointFormat::value PointFormat::
  _xsd_PointFormat_indexes_[5] =
  {
    ::XMLSchema::PointFormat::DecimalDegree,
    ::XMLSchema::PointFormat::DecimalMinutes,
    ::XMLSchema::PointFormat::DegreesMinutesSeconds,
    ::XMLSchema::PointFormat::Feet,
    ::XMLSchema::PointFormat::Meters
  };

  // SchedulingStrategy
  //

  SchedulingStrategy::
  SchedulingStrategy (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_SchedulingStrategy_convert ();
  }

  SchedulingStrategy::
  SchedulingStrategy (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_SchedulingStrategy_convert ();
  }

  SchedulingStrategy::
  SchedulingStrategy (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_SchedulingStrategy_convert ();
  }

  SchedulingStrategy* SchedulingStrategy::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SchedulingStrategy (*this, f, c);
  }

  SchedulingStrategy::value SchedulingStrategy::
  _xsd_SchedulingStrategy_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SchedulingStrategy_literals_);
    const value* i (::std::lower_bound (
                      _xsd_SchedulingStrategy_indexes_,
                      _xsd_SchedulingStrategy_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_SchedulingStrategy_indexes_ + 2 || _xsd_SchedulingStrategy_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const SchedulingStrategy::
  _xsd_SchedulingStrategy_literals_[2] =
  {
    "BackwardChaining",
    "ForwardChaining"
  };

  const SchedulingStrategy::value SchedulingStrategy::
  _xsd_SchedulingStrategy_indexes_[2] =
  {
    ::XMLSchema::SchedulingStrategy::BackwardChaining,
    ::XMLSchema::SchedulingStrategy::ForwardChaining
  };

  // SexSpecification
  //

  SexSpecification::
  SexSpecification (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_SexSpecification_convert ();
  }

  SexSpecification::
  SexSpecification (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_SexSpecification_convert ();
  }

  SexSpecification::
  SexSpecification (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_SexSpecification_convert ();
  }

  SexSpecification* SexSpecification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SexSpecification (*this, f, c);
  }

  SexSpecification::value SexSpecification::
  _xsd_SexSpecification_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SexSpecification_literals_);
    const value* i (::std::lower_bound (
                      _xsd_SexSpecification_indexes_,
                      _xsd_SexSpecification_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_SexSpecification_indexes_ + 3 || _xsd_SexSpecification_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const SexSpecification::
  _xsd_SexSpecification_literals_[3] =
  {
    "Feminine",
    "GenderNeutral",
    "Masculine"
  };

  const SexSpecification::value SexSpecification::
  _xsd_SexSpecification_indexes_[3] =
  {
    ::XMLSchema::SexSpecification::Feminine,
    ::XMLSchema::SexSpecification::GenderNeutral,
    ::XMLSchema::SexSpecification::Masculine
  };

  // StructureExtent
  //

  StructureExtent::
  StructureExtent (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_StructureExtent_convert ();
  }

  StructureExtent::
  StructureExtent (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_StructureExtent_convert ();
  }

  StructureExtent::
  StructureExtent (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_StructureExtent_convert ();
  }

  StructureExtent* StructureExtent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StructureExtent (*this, f, c);
  }

  StructureExtent::value StructureExtent::
  _xsd_StructureExtent_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_StructureExtent_literals_);
    const value* i (::std::lower_bound (
                      _xsd_StructureExtent_indexes_,
                      _xsd_StructureExtent_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_StructureExtent_indexes_ + 2 || _xsd_StructureExtent_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const StructureExtent::
  _xsd_StructureExtent_literals_[2] =
  {
    "Partial",
    "Total"
  };

  const StructureExtent::value StructureExtent::
  _xsd_StructureExtent_indexes_[2] =
  {
    ::XMLSchema::StructureExtent::Partial,
    ::XMLSchema::StructureExtent::Total
  };

  // TableDirectionValues
  //

  TableDirectionValues::
  TableDirectionValues (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_TableDirectionValues_convert ();
  }

  TableDirectionValues::
  TableDirectionValues (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_TableDirectionValues_convert ();
  }

  TableDirectionValues::
  TableDirectionValues (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_TableDirectionValues_convert ();
  }

  TableDirectionValues* TableDirectionValues::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TableDirectionValues (*this, f, c);
  }

  TableDirectionValues::value TableDirectionValues::
  _xsd_TableDirectionValues_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TableDirectionValues_literals_);
    const value* i (::std::lower_bound (
                      _xsd_TableDirectionValues_indexes_,
                      _xsd_TableDirectionValues_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_TableDirectionValues_indexes_ + 3 || _xsd_TableDirectionValues_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const TableDirectionValues::
  _xsd_TableDirectionValues_literals_[3] =
  {
    "Auto",
    "Ltr",
    "Rtl"
  };

  const TableDirectionValues::value TableDirectionValues::
  _xsd_TableDirectionValues_indexes_[3] =
  {
    ::XMLSchema::TableDirectionValues::Auto,
    ::XMLSchema::TableDirectionValues::Ltr,
    ::XMLSchema::TableDirectionValues::Rtl
  };

  // TemporalOperator
  //

  TemporalOperator::
  TemporalOperator (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_TemporalOperator_convert ();
  }

  TemporalOperator::
  TemporalOperator (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_TemporalOperator_convert ();
  }

  TemporalOperator::
  TemporalOperator (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_TemporalOperator_convert ();
  }

  TemporalOperator* TemporalOperator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TemporalOperator (*this, f, c);
  }

  TemporalOperator::value TemporalOperator::
  _xsd_TemporalOperator_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TemporalOperator_literals_);
    const value* i (::std::lower_bound (
                      _xsd_TemporalOperator_indexes_,
                      _xsd_TemporalOperator_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_TemporalOperator_indexes_ + 4 || _xsd_TemporalOperator_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const TemporalOperator::
  _xsd_TemporalOperator_literals_[4] =
  {
    "AndJoin",
    "AndSplit",
    "XorJoin",
    "XorSplit"
  };

  const TemporalOperator::value TemporalOperator::
  _xsd_TemporalOperator_indexes_[4] =
  {
    ::XMLSchema::TemporalOperator::AndJoin,
    ::XMLSchema::TemporalOperator::AndSplit,
    ::XMLSchema::TemporalOperator::XorJoin,
    ::XMLSchema::TemporalOperator::XorSplit
  };

  // TemporalRelation
  //

  TemporalRelation::
  TemporalRelation (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_TemporalRelation_convert ();
  }

  TemporalRelation::
  TemporalRelation (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_TemporalRelation_convert ();
  }

  TemporalRelation::
  TemporalRelation (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_TemporalRelation_convert ();
  }

  TemporalRelation* TemporalRelation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TemporalRelation (*this, f, c);
  }

  TemporalRelation::value TemporalRelation::
  _xsd_TemporalRelation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TemporalRelation_literals_);
    const value* i (::std::lower_bound (
                      _xsd_TemporalRelation_indexes_,
                      _xsd_TemporalRelation_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_TemporalRelation_indexes_ + 7 || _xsd_TemporalRelation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const TemporalRelation::
  _xsd_TemporalRelation_literals_[7] =
  {
    "Contains",
    "Equals",
    "Finishes",
    "Meets",
    "Overlaps",
    "Precedes",
    "Starts"
  };

  const TemporalRelation::value TemporalRelation::
  _xsd_TemporalRelation_indexes_[7] =
  {
    ::XMLSchema::TemporalRelation::Contains,
    ::XMLSchema::TemporalRelation::Equals,
    ::XMLSchema::TemporalRelation::Finishes,
    ::XMLSchema::TemporalRelation::Meets,
    ::XMLSchema::TemporalRelation::Overlaps,
    ::XMLSchema::TemporalRelation::Precedes,
    ::XMLSchema::TemporalRelation::Starts
  };

  // TextDirectionValues
  //

  TextDirectionValues::
  TextDirectionValues (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_TextDirectionValues_convert ();
  }

  TextDirectionValues::
  TextDirectionValues (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_TextDirectionValues_convert ();
  }

  TextDirectionValues::
  TextDirectionValues (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_TextDirectionValues_convert ();
  }

  TextDirectionValues* TextDirectionValues::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TextDirectionValues (*this, f, c);
  }

  TextDirectionValues::value TextDirectionValues::
  _xsd_TextDirectionValues_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TextDirectionValues_literals_);
    const value* i (::std::lower_bound (
                      _xsd_TextDirectionValues_indexes_,
                      _xsd_TextDirectionValues_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_TextDirectionValues_indexes_ + 4 || _xsd_TextDirectionValues_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const TextDirectionValues::
  _xsd_TextDirectionValues_literals_[4] =
  {
    "Auto",
    "Inherit",
    "Ltr",
    "Rtl"
  };

  const TextDirectionValues::value TextDirectionValues::
  _xsd_TextDirectionValues_indexes_[4] =
  {
    ::XMLSchema::TextDirectionValues::Auto,
    ::XMLSchema::TextDirectionValues::Inherit,
    ::XMLSchema::TextDirectionValues::Ltr,
    ::XMLSchema::TextDirectionValues::Rtl
  };

  // TrimValues
  //

  TrimValues::
  TrimValues (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_TrimValues_convert ();
  }

  TrimValues::
  TrimValues (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_TrimValues_convert ();
  }

  TrimValues::
  TrimValues (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_TrimValues_convert ();
  }

  TrimValues* TrimValues::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TrimValues (*this, f, c);
  }

  TrimValues::value TrimValues::
  _xsd_TrimValues_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TrimValues_literals_);
    const value* i (::std::lower_bound (
                      _xsd_TrimValues_indexes_,
                      _xsd_TrimValues_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_TrimValues_indexes_ + 4 || _xsd_TrimValues_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const TrimValues::
  _xsd_TrimValues_literals_[4] =
  {
    "Both",
    "End",
    "Neither",
    "Start"
  };

  const TrimValues::value TrimValues::
  _xsd_TrimValues_indexes_[4] =
  {
    ::XMLSchema::TrimValues::Both,
    ::XMLSchema::TrimValues::End,
    ::XMLSchema::TrimValues::Neither,
    ::XMLSchema::TrimValues::Start
  };

  // WhiteSpaceRule
  //

  WhiteSpaceRule::
  WhiteSpaceRule (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_WhiteSpaceRule_convert ();
  }

  WhiteSpaceRule::
  WhiteSpaceRule (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_WhiteSpaceRule_convert ();
  }

  WhiteSpaceRule::
  WhiteSpaceRule (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_WhiteSpaceRule_convert ();
  }

  WhiteSpaceRule* WhiteSpaceRule::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class WhiteSpaceRule (*this, f, c);
  }

  WhiteSpaceRule::value WhiteSpaceRule::
  _xsd_WhiteSpaceRule_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_WhiteSpaceRule_literals_);
    const value* i (::std::lower_bound (
                      _xsd_WhiteSpaceRule_indexes_,
                      _xsd_WhiteSpaceRule_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_WhiteSpaceRule_indexes_ + 3 || _xsd_WhiteSpaceRule_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const WhiteSpaceRule::
  _xsd_WhiteSpaceRule_literals_[3] =
  {
    "Collapse",
    "Preserve",
    "Replace"
  };

  const WhiteSpaceRule::value WhiteSpaceRule::
  _xsd_WhiteSpaceRule_indexes_[3] =
  {
    ::XMLSchema::WhiteSpaceRule::Collapse,
    ::XMLSchema::WhiteSpaceRule::Preserve,
    ::XMLSchema::WhiteSpaceRule::Replace
  };

  // AccessInformation
  //

  AccessInformation::
  AccessInformation ()
  : ::xml_schema::type (),
    copyright_ (this),
    embargo_ (this),
    license_ (this),
    rights_ (this)
  {
  }

  AccessInformation::
  AccessInformation (const AccessInformation& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    copyright_ (x.copyright_, f, this),
    embargo_ (x.embargo_, f, this),
    license_ (x.license_, f, this),
    rights_ (x.rights_, f, this)
  {
  }

  AccessInformation::
  AccessInformation (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    copyright_ (this),
    embargo_ (this),
    license_ (this),
    rights_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AccessInformation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // copyright
      //
      if (n.name () == "copyright" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< copyright_type > r (
          copyright_traits::create (i, f, this));

        this->copyright_.push_back (::std::move (r));
        continue;
      }

      // embargo
      //
      if (n.name () == "embargo" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< embargo_type > r (
          embargo_traits::create (i, f, this));

        this->embargo_.push_back (::std::move (r));
        continue;
      }

      // license
      //
      if (n.name () == "license" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< license_type > r (
          license_traits::create (i, f, this));

        this->license_.push_back (::std::move (r));
        continue;
      }

      // rights
      //
      if (n.name () == "rights" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< rights_type > r (
          rights_traits::create (i, f, this));

        this->rights_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AccessInformation* AccessInformation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AccessInformation (*this, f, c);
  }

  AccessInformation& AccessInformation::
  operator= (const AccessInformation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->copyright_ = x.copyright_;
      this->embargo_ = x.embargo_;
      this->license_ = x.license_;
      this->rights_ = x.rights_;
    }

    return *this;
  }

  AccessInformation::
  ~AccessInformation ()
  {
  }

  // AccessLocation
  //

  AccessLocation::
  AccessLocation ()
  : ::xml_schema::type (),
    mimeType_ (this),
    physicalLocation_ (this),
    uri_ (this)
  {
  }

  AccessLocation::
  AccessLocation (const AccessLocation& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    mimeType_ (x.mimeType_, f, this),
    physicalLocation_ (x.physicalLocation_, f, this),
    uri_ (x.uri_, f, this)
  {
  }

  AccessLocation::
  AccessLocation (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    mimeType_ (this),
    physicalLocation_ (this),
    uri_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AccessLocation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // mimeType
      //
      if (n.name () == "mimeType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< mimeType_type > r (
          mimeType_traits::create (i, f, this));

        if (!this->mimeType_)
        {
          this->mimeType_.set (::std::move (r));
          continue;
        }
      }

      // physicalLocation
      //
      if (n.name () == "physicalLocation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< physicalLocation_type > r (
          physicalLocation_traits::create (i, f, this));

        this->physicalLocation_.push_back (::std::move (r));
        continue;
      }

      // uri
      //
      if (n.name () == "uri" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< uri_type > r (
          uri_traits::create (i, f, this));

        this->uri_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AccessLocation* AccessLocation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AccessLocation (*this, f, c);
  }

  AccessLocation& AccessLocation::
  operator= (const AccessLocation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->mimeType_ = x.mimeType_;
      this->physicalLocation_ = x.physicalLocation_;
      this->uri_ = x.uri_;
    }

    return *this;
  }

  AccessLocation::
  ~AccessLocation ()
  {
  }

  // Address
  //

  Address::
  Address ()
  : ::xml_schema::type (),
    cityPlaceLocal_ (this),
    countryCode_ (this),
    effectiveDates_ (this),
    geographicPoint_ (this),
    isPreferred_ (this),
    line_ (this),
    locationName_ (this),
    postalCode_ (this),
    privacy_ (this),
    regionalCoverage_ (this),
    stateProvince_ (this),
    timeZone_ (this),
    typeOfAddress_ (this),
    typeOfLocation_ (this)
  {
  }

  Address::
  Address (const Address& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cityPlaceLocal_ (x.cityPlaceLocal_, f, this),
    countryCode_ (x.countryCode_, f, this),
    effectiveDates_ (x.effectiveDates_, f, this),
    geographicPoint_ (x.geographicPoint_, f, this),
    isPreferred_ (x.isPreferred_, f, this),
    line_ (x.line_, f, this),
    locationName_ (x.locationName_, f, this),
    postalCode_ (x.postalCode_, f, this),
    privacy_ (x.privacy_, f, this),
    regionalCoverage_ (x.regionalCoverage_, f, this),
    stateProvince_ (x.stateProvince_, f, this),
    timeZone_ (x.timeZone_, f, this),
    typeOfAddress_ (x.typeOfAddress_, f, this),
    typeOfLocation_ (x.typeOfLocation_, f, this)
  {
  }

  Address::
  Address (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cityPlaceLocal_ (this),
    countryCode_ (this),
    effectiveDates_ (this),
    geographicPoint_ (this),
    isPreferred_ (this),
    line_ (this),
    locationName_ (this),
    postalCode_ (this),
    privacy_ (this),
    regionalCoverage_ (this),
    stateProvince_ (this),
    timeZone_ (this),
    typeOfAddress_ (this),
    typeOfLocation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Address::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cityPlaceLocal
      //
      if (n.name () == "cityPlaceLocal" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< cityPlaceLocal_type > r (
          cityPlaceLocal_traits::create (i, f, this));

        if (!this->cityPlaceLocal_)
        {
          this->cityPlaceLocal_.set (::std::move (r));
          continue;
        }
      }

      // countryCode
      //
      if (n.name () == "countryCode" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< countryCode_type > r (
          countryCode_traits::create (i, f, this));

        if (!this->countryCode_)
        {
          this->countryCode_.set (::std::move (r));
          continue;
        }
      }

      // effectiveDates
      //
      if (n.name () == "effectiveDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< effectiveDates_type > r (
          effectiveDates_traits::create (i, f, this));

        if (!this->effectiveDates_)
        {
          this->effectiveDates_.set (::std::move (r));
          continue;
        }
      }

      // geographicPoint
      //
      if (n.name () == "geographicPoint" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< geographicPoint_type > r (
          geographicPoint_traits::create (i, f, this));

        if (!this->geographicPoint_)
        {
          this->geographicPoint_.set (::std::move (r));
          continue;
        }
      }

      // isPreferred
      //
      if (n.name () == "isPreferred" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isPreferred_)
        {
          this->isPreferred_.set (isPreferred_traits::create (i, f, this));
          continue;
        }
      }

      // line
      //
      if (n.name () == "line" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< line_type > r (
          line_traits::create (i, f, this));

        this->line_.push_back (::std::move (r));
        continue;
      }

      // locationName
      //
      if (n.name () == "locationName" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< locationName_type > r (
          locationName_traits::create (i, f, this));

        if (!this->locationName_)
        {
          this->locationName_.set (::std::move (r));
          continue;
        }
      }

      // postalCode
      //
      if (n.name () == "postalCode" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< postalCode_type > r (
          postalCode_traits::create (i, f, this));

        if (!this->postalCode_)
        {
          this->postalCode_.set (::std::move (r));
          continue;
        }
      }

      // privacy
      //
      if (n.name () == "privacy" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< privacy_type > r (
          privacy_traits::create (i, f, this));

        if (!this->privacy_)
        {
          this->privacy_.set (::std::move (r));
          continue;
        }
      }

      // regionalCoverage
      //
      if (n.name () == "regionalCoverage" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< regionalCoverage_type > r (
          regionalCoverage_traits::create (i, f, this));

        if (!this->regionalCoverage_)
        {
          this->regionalCoverage_.set (::std::move (r));
          continue;
        }
      }

      // stateProvince
      //
      if (n.name () == "stateProvince" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< stateProvince_type > r (
          stateProvince_traits::create (i, f, this));

        if (!this->stateProvince_)
        {
          this->stateProvince_.set (::std::move (r));
          continue;
        }
      }

      // timeZone
      //
      if (n.name () == "timeZone" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< timeZone_type > r (
          timeZone_traits::create (i, f, this));

        if (!this->timeZone_)
        {
          this->timeZone_.set (::std::move (r));
          continue;
        }
      }

      // typeOfAddress
      //
      if (n.name () == "typeOfAddress" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< typeOfAddress_type > r (
          typeOfAddress_traits::create (i, f, this));

        if (!this->typeOfAddress_)
        {
          this->typeOfAddress_.set (::std::move (r));
          continue;
        }
      }

      // typeOfLocation
      //
      if (n.name () == "typeOfLocation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< typeOfLocation_type > r (
          typeOfLocation_traits::create (i, f, this));

        if (!this->typeOfLocation_)
        {
          this->typeOfLocation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Address* Address::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Address (*this, f, c);
  }

  Address& Address::
  operator= (const Address& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cityPlaceLocal_ = x.cityPlaceLocal_;
      this->countryCode_ = x.countryCode_;
      this->effectiveDates_ = x.effectiveDates_;
      this->geographicPoint_ = x.geographicPoint_;
      this->isPreferred_ = x.isPreferred_;
      this->line_ = x.line_;
      this->locationName_ = x.locationName_;
      this->postalCode_ = x.postalCode_;
      this->privacy_ = x.privacy_;
      this->regionalCoverage_ = x.regionalCoverage_;
      this->stateProvince_ = x.stateProvince_;
      this->timeZone_ = x.timeZone_;
      this->typeOfAddress_ = x.typeOfAddress_;
      this->typeOfLocation_ = x.typeOfLocation_;
    }

    return *this;
  }

  Address::
  ~Address ()
  {
  }

  // AgentInRole
  //

  AgentInRole::
  AgentInRole ()
  : ::xml_schema::type (),
    agentName_ (this),
    reference_ (this),
    role_ (this)
  {
  }

  AgentInRole::
  AgentInRole (const AgentInRole& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    agentName_ (x.agentName_, f, this),
    reference_ (x.reference_, f, this),
    role_ (x.role_, f, this)
  {
  }

  AgentInRole::
  AgentInRole (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    agentName_ (this),
    reference_ (this),
    role_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AgentInRole::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // agentName
      //
      if (n.name () == "agentName" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< agentName_type > r (
          agentName_traits::create (i, f, this));

        if (!this->agentName_)
        {
          this->agentName_.set (::std::move (r));
          continue;
        }
      }

      // reference
      //
      if (n.name () == "reference" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< reference_type > r (
          reference_traits::create (i, f, this));

        if (!this->reference_)
        {
          this->reference_.set (::std::move (r));
          continue;
        }
      }

      // role
      //
      if (n.name () == "role" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< role_type > r (
          role_traits::create (i, f, this));

        this->role_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AgentInRole* AgentInRole::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentInRole (*this, f, c);
  }

  AgentInRole& AgentInRole::
  operator= (const AgentInRole& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->agentName_ = x.agentName_;
      this->reference_ = x.reference_;
      this->role_ = x.role_;
    }

    return *this;
  }

  AgentInRole::
  ~AgentInRole ()
  {
  }

  // InternationalString
  //

  InternationalString::
  InternationalString ()
  : ::xml_schema::type (),
    languageSpecificString_ (this)
  {
  }

  InternationalString::
  InternationalString (const InternationalString& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    languageSpecificString_ (x.languageSpecificString_, f, this)
  {
  }

  InternationalString::
  InternationalString (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    languageSpecificString_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InternationalString::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // languageSpecificString
      //
      if (n.name () == "languageSpecificString" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< languageSpecificString_type > r (
          languageSpecificString_traits::create (i, f, this));

        this->languageSpecificString_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  InternationalString* InternationalString::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InternationalString (*this, f, c);
  }

  InternationalString& InternationalString::
  operator= (const InternationalString& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->languageSpecificString_ = x.languageSpecificString_;
    }

    return *this;
  }

  InternationalString::
  ~InternationalString ()
  {
  }

  // BibliographicName
  //

  BibliographicName::
  BibliographicName ()
  : ::XMLSchema::InternationalString (),
    affiliation_ (this)
  {
  }

  BibliographicName::
  BibliographicName (const BibliographicName& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::InternationalString (x, f, c),
    affiliation_ (x.affiliation_, f, this)
  {
  }

  BibliographicName::
  BibliographicName (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::InternationalString (e, f | ::xml_schema::flags::base, c),
    affiliation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void BibliographicName::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::InternationalString::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // affiliation
      //
      if (n.name () == "affiliation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< affiliation_type > r (
          affiliation_traits::create (i, f, this));

        if (!this->affiliation_)
        {
          this->affiliation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  BibliographicName* BibliographicName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BibliographicName (*this, f, c);
  }

  BibliographicName& BibliographicName::
  operator= (const BibliographicName& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::InternationalString& > (*this) = x;
      this->affiliation_ = x.affiliation_;
    }

    return *this;
  }

  BibliographicName::
  ~BibliographicName ()
  {
  }

  // CatalogDetails
  //

  CatalogDetails::
  CatalogDetails ()
  : ::xml_schema::type (),
    access_ (this),
    alternativeTitle_ (this),
    contributor_ (this),
    creator_ (this),
    date_ (this),
    identifier_ (this),
    informationSource_ (this),
    languageOfObject_ (this),
    provenance_ (this),
    publisher_ (this),
    relatedResource_ (this),
    subTitle_ (this),
    summary_ (this),
    title_ (this),
    typeOfResource_ (this)
  {
  }

  CatalogDetails::
  CatalogDetails (const CatalogDetails& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    access_ (x.access_, f, this),
    alternativeTitle_ (x.alternativeTitle_, f, this),
    contributor_ (x.contributor_, f, this),
    creator_ (x.creator_, f, this),
    date_ (x.date_, f, this),
    identifier_ (x.identifier_, f, this),
    informationSource_ (x.informationSource_, f, this),
    languageOfObject_ (x.languageOfObject_, f, this),
    provenance_ (x.provenance_, f, this),
    publisher_ (x.publisher_, f, this),
    relatedResource_ (x.relatedResource_, f, this),
    subTitle_ (x.subTitle_, f, this),
    summary_ (x.summary_, f, this),
    title_ (x.title_, f, this),
    typeOfResource_ (x.typeOfResource_, f, this)
  {
  }

  CatalogDetails::
  CatalogDetails (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    access_ (this),
    alternativeTitle_ (this),
    contributor_ (this),
    creator_ (this),
    date_ (this),
    identifier_ (this),
    informationSource_ (this),
    languageOfObject_ (this),
    provenance_ (this),
    publisher_ (this),
    relatedResource_ (this),
    subTitle_ (this),
    summary_ (this),
    title_ (this),
    typeOfResource_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CatalogDetails::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // access
      //
      if (n.name () == "access" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< access_type > r (
          access_traits::create (i, f, this));

        this->access_.push_back (::std::move (r));
        continue;
      }

      // alternativeTitle
      //
      if (n.name () == "alternativeTitle" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< alternativeTitle_type > r (
          alternativeTitle_traits::create (i, f, this));

        this->alternativeTitle_.push_back (::std::move (r));
        continue;
      }

      // contributor
      //
      if (n.name () == "contributor" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< contributor_type > r (
          contributor_traits::create (i, f, this));

        this->contributor_.push_back (::std::move (r));
        continue;
      }

      // creator
      //
      if (n.name () == "creator" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< creator_type > r (
          creator_traits::create (i, f, this));

        this->creator_.push_back (::std::move (r));
        continue;
      }

      // date
      //
      if (n.name () == "date" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< date_type > r (
          date_traits::create (i, f, this));

        this->date_.push_back (::std::move (r));
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!this->identifier_)
        {
          this->identifier_.set (::std::move (r));
          continue;
        }
      }

      // informationSource
      //
      if (n.name () == "informationSource" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< informationSource_type > r (
          informationSource_traits::create (i, f, this));

        this->informationSource_.push_back (::std::move (r));
        continue;
      }

      // languageOfObject
      //
      if (n.name () == "languageOfObject" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< languageOfObject_type > r (
          languageOfObject_traits::create (i, f, this));

        this->languageOfObject_.push_back (::std::move (r));
        continue;
      }

      // provenance
      //
      if (n.name () == "provenance" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< provenance_type > r (
          provenance_traits::create (i, f, this));

        if (!this->provenance_)
        {
          this->provenance_.set (::std::move (r));
          continue;
        }
      }

      // publisher
      //
      if (n.name () == "publisher" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< publisher_type > r (
          publisher_traits::create (i, f, this));

        this->publisher_.push_back (::std::move (r));
        continue;
      }

      // relatedResource
      //
      if (n.name () == "relatedResource" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< relatedResource_type > r (
          relatedResource_traits::create (i, f, this));

        this->relatedResource_.push_back (::std::move (r));
        continue;
      }

      // subTitle
      //
      if (n.name () == "subTitle" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< subTitle_type > r (
          subTitle_traits::create (i, f, this));

        this->subTitle_.push_back (::std::move (r));
        continue;
      }

      // summary
      //
      if (n.name () == "summary" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< summary_type > r (
          summary_traits::create (i, f, this));

        if (!this->summary_)
        {
          this->summary_.set (::std::move (r));
          continue;
        }
      }

      // title
      //
      if (n.name () == "title" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< title_type > r (
          title_traits::create (i, f, this));

        if (!this->title_)
        {
          this->title_.set (::std::move (r));
          continue;
        }
      }

      // typeOfResource
      //
      if (n.name () == "typeOfResource" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< typeOfResource_type > r (
          typeOfResource_traits::create (i, f, this));

        this->typeOfResource_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CatalogDetails* CatalogDetails::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CatalogDetails (*this, f, c);
  }

  CatalogDetails& CatalogDetails::
  operator= (const CatalogDetails& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->access_ = x.access_;
      this->alternativeTitle_ = x.alternativeTitle_;
      this->contributor_ = x.contributor_;
      this->creator_ = x.creator_;
      this->date_ = x.date_;
      this->identifier_ = x.identifier_;
      this->informationSource_ = x.informationSource_;
      this->languageOfObject_ = x.languageOfObject_;
      this->provenance_ = x.provenance_;
      this->publisher_ = x.publisher_;
      this->relatedResource_ = x.relatedResource_;
      this->subTitle_ = x.subTitle_;
      this->summary_ = x.summary_;
      this->title_ = x.title_;
      this->typeOfResource_ = x.typeOfResource_;
    }

    return *this;
  }

  CatalogDetails::
  ~CatalogDetails ()
  {
  }

  // CombinedDate
  //

  CombinedDate::
  CombinedDate ()
  : ::xml_schema::type (),
    isoDate_ (this),
    nonIsoDate_ (this),
    semantics_ (this)
  {
  }

  CombinedDate::
  CombinedDate (const CombinedDate& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    isoDate_ (x.isoDate_, f, this),
    nonIsoDate_ (x.nonIsoDate_, f, this),
    semantics_ (x.semantics_, f, this)
  {
  }

  CombinedDate::
  CombinedDate (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    isoDate_ (this),
    nonIsoDate_ (this),
    semantics_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CombinedDate::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // isoDate
      //
      if (n.name () == "isoDate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< isoDate_type > r (
          isoDate_traits::create (i, f, this));

        if (!this->isoDate_)
        {
          this->isoDate_.set (::std::move (r));
          continue;
        }
      }

      // nonIsoDate
      //
      if (n.name () == "nonIsoDate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< nonIsoDate_type > r (
          nonIsoDate_traits::create (i, f, this));

        this->nonIsoDate_.push_back (::std::move (r));
        continue;
      }

      // semantics
      //
      if (n.name () == "semantics" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantics_type > r (
          semantics_traits::create (i, f, this));

        if (!this->semantics_)
        {
          this->semantics_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  CombinedDate* CombinedDate::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CombinedDate (*this, f, c);
  }

  CombinedDate& CombinedDate::
  operator= (const CombinedDate& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->isoDate_ = x.isoDate_;
      this->nonIsoDate_ = x.nonIsoDate_;
      this->semantics_ = x.semantics_;
    }

    return *this;
  }

  CombinedDate::
  ~CombinedDate ()
  {
  }

  // Command
  //

  Command::
  Command ()
  : ::xml_schema::type (),
    commandContent_ (this),
    programLanguage_ (this)
  {
  }

  Command::
  Command (const Command& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    commandContent_ (x.commandContent_, f, this),
    programLanguage_ (x.programLanguage_, f, this)
  {
  }

  Command::
  Command (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    commandContent_ (this),
    programLanguage_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Command::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // commandContent
      //
      if (n.name () == "commandContent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< commandContent_type > r (
          commandContent_traits::create (i, f, this));

        if (!this->commandContent_)
        {
          this->commandContent_.set (::std::move (r));
          continue;
        }
      }

      // programLanguage
      //
      if (n.name () == "programLanguage" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< programLanguage_type > r (
          programLanguage_traits::create (i, f, this));

        if (!this->programLanguage_)
        {
          this->programLanguage_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Command* Command::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Command (*this, f, c);
  }

  Command& Command::
  operator= (const Command& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->commandContent_ = x.commandContent_;
      this->programLanguage_ = x.programLanguage_;
    }

    return *this;
  }

  Command::
  ~Command ()
  {
  }

  // CommandCode
  //

  CommandCode::
  CommandCode ()
  : ::xml_schema::type (),
    command_ (this),
    commandFile_ (this),
    description_ (this)
  {
  }

  CommandCode::
  CommandCode (const CommandCode& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    command_ (x.command_, f, this),
    commandFile_ (x.commandFile_, f, this),
    description_ (x.description_, f, this)
  {
  }

  CommandCode::
  CommandCode (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    command_ (this),
    commandFile_ (this),
    description_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CommandCode::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // command
      //
      if (n.name () == "command" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< command_type > r (
          command_traits::create (i, f, this));

        this->command_.push_back (::std::move (r));
        continue;
      }

      // commandFile
      //
      if (n.name () == "commandFile" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< commandFile_type > r (
          commandFile_traits::create (i, f, this));

        this->commandFile_.push_back (::std::move (r));
        continue;
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!this->description_)
        {
          this->description_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  CommandCode* CommandCode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CommandCode (*this, f, c);
  }

  CommandCode& CommandCode::
  operator= (const CommandCode& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->command_ = x.command_;
      this->commandFile_ = x.commandFile_;
      this->description_ = x.description_;
    }

    return *this;
  }

  CommandCode::
  ~CommandCode ()
  {
  }

  // CommandFile
  //

  CommandFile::
  CommandFile ()
  : ::xml_schema::type (),
    location_ (this),
    uri_ (this)
  {
  }

  CommandFile::
  CommandFile (const CommandFile& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    location_ (x.location_, f, this),
    uri_ (x.uri_, f, this)
  {
  }

  CommandFile::
  CommandFile (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    location_ (this),
    uri_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CommandFile::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // location
      //
      if (n.name () == "location" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< location_type > r (
          location_traits::create (i, f, this));

        if (!this->location_)
        {
          this->location_.set (::std::move (r));
          continue;
        }
      }

      // uri
      //
      if (n.name () == "uri" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< uri_type > r (
          uri_traits::create (i, f, this));

        if (!this->uri_)
        {
          this->uri_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  CommandFile* CommandFile::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CommandFile (*this, f, c);
  }

  CommandFile& CommandFile::
  operator= (const CommandFile& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->location_ = x.location_;
      this->uri_ = x.uri_;
    }

    return *this;
  }

  CommandFile::
  ~CommandFile ()
  {
  }

  // ContactInformation
  //

  ContactInformation::
  ContactInformation ()
  : ::xml_schema::type (),
    address_ (this),
    email_ (this),
    emessaging_ (this),
    telephone_ (this),
    website_ (this)
  {
  }

  ContactInformation::
  ContactInformation (const ContactInformation& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    address_ (x.address_, f, this),
    email_ (x.email_, f, this),
    emessaging_ (x.emessaging_, f, this),
    telephone_ (x.telephone_, f, this),
    website_ (x.website_, f, this)
  {
  }

  ContactInformation::
  ContactInformation (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    address_ (this),
    email_ (this),
    emessaging_ (this),
    telephone_ (this),
    website_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ContactInformation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // address
      //
      if (n.name () == "address" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< address_type > r (
          address_traits::create (i, f, this));

        this->address_.push_back (::std::move (r));
        continue;
      }

      // email
      //
      if (n.name () == "email" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< email_type > r (
          email_traits::create (i, f, this));

        this->email_.push_back (::std::move (r));
        continue;
      }

      // emessaging
      //
      if (n.name () == "emessaging" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< emessaging_type > r (
          emessaging_traits::create (i, f, this));

        this->emessaging_.push_back (::std::move (r));
        continue;
      }

      // telephone
      //
      if (n.name () == "telephone" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< telephone_type > r (
          telephone_traits::create (i, f, this));

        this->telephone_.push_back (::std::move (r));
        continue;
      }

      // website
      //
      if (n.name () == "website" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< website_type > r (
          website_traits::create (i, f, this));

        this->website_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ContactInformation* ContactInformation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ContactInformation (*this, f, c);
  }

  ContactInformation& ContactInformation::
  operator= (const ContactInformation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->address_ = x.address_;
      this->email_ = x.email_;
      this->emessaging_ = x.emessaging_;
      this->telephone_ = x.telephone_;
      this->website_ = x.website_;
    }

    return *this;
  }

  ContactInformation::
  ~ContactInformation ()
  {
  }

  // ControlledVocabularyEntry
  //

  ControlledVocabularyEntry::
  ControlledVocabularyEntry ()
  : ::xml_schema::type (),
    entryReference_ (this),
    entryValue_ (this),
    name_ (this),
    valueForOther_ (this),
    vocabulary_ (this)
  {
  }

  ControlledVocabularyEntry::
  ControlledVocabularyEntry (const ControlledVocabularyEntry& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    entryReference_ (x.entryReference_, f, this),
    entryValue_ (x.entryValue_, f, this),
    name_ (x.name_, f, this),
    valueForOther_ (x.valueForOther_, f, this),
    vocabulary_ (x.vocabulary_, f, this)
  {
  }

  ControlledVocabularyEntry::
  ControlledVocabularyEntry (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    entryReference_ (this),
    entryValue_ (this),
    name_ (this),
    valueForOther_ (this),
    vocabulary_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ControlledVocabularyEntry::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // entryReference
      //
      if (n.name () == "entryReference" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< entryReference_type > r (
          entryReference_traits::create (i, f, this));

        this->entryReference_.push_back (::std::move (r));
        continue;
      }

      // entryValue
      //
      if (n.name () == "entryValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< entryValue_type > r (
          entryValue_traits::create (i, f, this));

        this->entryValue_.push_back (::std::move (r));
        continue;
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!this->name_)
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // valueForOther
      //
      if (n.name () == "valueForOther" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< valueForOther_type > r (
          valueForOther_traits::create (i, f, this));

        if (!this->valueForOther_)
        {
          this->valueForOther_.set (::std::move (r));
          continue;
        }
      }

      // vocabulary
      //
      if (n.name () == "vocabulary" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< vocabulary_type > r (
          vocabulary_traits::create (i, f, this));

        if (!this->vocabulary_)
        {
          this->vocabulary_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ControlledVocabularyEntry* ControlledVocabularyEntry::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ControlledVocabularyEntry (*this, f, c);
  }

  ControlledVocabularyEntry& ControlledVocabularyEntry::
  operator= (const ControlledVocabularyEntry& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->entryReference_ = x.entryReference_;
      this->entryValue_ = x.entryValue_;
      this->name_ = x.name_;
      this->valueForOther_ = x.valueForOther_;
      this->vocabulary_ = x.vocabulary_;
    }

    return *this;
  }

  ControlledVocabularyEntry::
  ~ControlledVocabularyEntry ()
  {
  }

  // CorrespondenceDefinition
  //

  CorrespondenceDefinition::
  CorrespondenceDefinition ()
  : ::xml_schema::type (),
    commonality_ (this),
    commonalityCode_ (this),
    difference_ (this),
    matching_ (this)
  {
  }

  CorrespondenceDefinition::
  CorrespondenceDefinition (const CorrespondenceDefinition& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    commonality_ (x.commonality_, f, this),
    commonalityCode_ (x.commonalityCode_, f, this),
    difference_ (x.difference_, f, this),
    matching_ (x.matching_, f, this)
  {
  }

  CorrespondenceDefinition::
  CorrespondenceDefinition (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    commonality_ (this),
    commonalityCode_ (this),
    difference_ (this),
    matching_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CorrespondenceDefinition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // commonality
      //
      if (n.name () == "commonality" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< commonality_type > r (
          commonality_traits::create (i, f, this));

        if (!this->commonality_)
        {
          this->commonality_.set (::std::move (r));
          continue;
        }
      }

      // commonalityCode
      //
      if (n.name () == "commonalityCode" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< commonalityCode_type > r (
          commonalityCode_traits::create (i, f, this));

        this->commonalityCode_.push_back (::std::move (r));
        continue;
      }

      // difference
      //
      if (n.name () == "difference" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< difference_type > r (
          difference_traits::create (i, f, this));

        if (!this->difference_)
        {
          this->difference_.set (::std::move (r));
          continue;
        }
      }

      // matching
      //
      if (n.name () == "matching" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< matching_type > r (
          matching_traits::create (i, f, this));

        if (!this->matching_)
        {
          this->matching_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  CorrespondenceDefinition* CorrespondenceDefinition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CorrespondenceDefinition (*this, f, c);
  }

  CorrespondenceDefinition& CorrespondenceDefinition::
  operator= (const CorrespondenceDefinition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->commonality_ = x.commonality_;
      this->commonalityCode_ = x.commonalityCode_;
      this->difference_ = x.difference_;
      this->matching_ = x.matching_;
    }

    return *this;
  }

  CorrespondenceDefinition::
  ~CorrespondenceDefinition ()
  {
  }

  // DateRange
  //

  DateRange::
  DateRange ()
  : ::xml_schema::type (),
    endDate_ (this),
    startDate_ (this)
  {
  }

  DateRange::
  DateRange (const DateRange& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    endDate_ (x.endDate_, f, this),
    startDate_ (x.startDate_, f, this)
  {
  }

  DateRange::
  DateRange (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    endDate_ (this),
    startDate_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DateRange::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // endDate
      //
      if (n.name () == "endDate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        if (!this->endDate_)
        {
          this->endDate_.set (::std::move (r));
          continue;
        }
      }

      // startDate
      //
      if (n.name () == "startDate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        if (!this->startDate_)
        {
          this->startDate_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  DateRange* DateRange::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DateRange (*this, f, c);
  }

  DateRange& DateRange::
  operator= (const DateRange& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->endDate_ = x.endDate_;
      this->startDate_ = x.startDate_;
    }

    return *this;
  }

  DateRange::
  ~DateRange ()
  {
  }

  // ElectronicMessageSystem
  //

  ElectronicMessageSystem::
  ElectronicMessageSystem ()
  : ::xml_schema::type (),
    contactAddress_ (this),
    effectiveDates_ (this),
    isPreferred_ (this),
    privacy_ (this),
    typeOfService_ (this)
  {
  }

  ElectronicMessageSystem::
  ElectronicMessageSystem (const ElectronicMessageSystem& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    contactAddress_ (x.contactAddress_, f, this),
    effectiveDates_ (x.effectiveDates_, f, this),
    isPreferred_ (x.isPreferred_, f, this),
    privacy_ (x.privacy_, f, this),
    typeOfService_ (x.typeOfService_, f, this)
  {
  }

  ElectronicMessageSystem::
  ElectronicMessageSystem (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    contactAddress_ (this),
    effectiveDates_ (this),
    isPreferred_ (this),
    privacy_ (this),
    typeOfService_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ElectronicMessageSystem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // contactAddress
      //
      if (n.name () == "contactAddress" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< contactAddress_type > r (
          contactAddress_traits::create (i, f, this));

        if (!this->contactAddress_)
        {
          this->contactAddress_.set (::std::move (r));
          continue;
        }
      }

      // effectiveDates
      //
      if (n.name () == "effectiveDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< effectiveDates_type > r (
          effectiveDates_traits::create (i, f, this));

        if (!this->effectiveDates_)
        {
          this->effectiveDates_.set (::std::move (r));
          continue;
        }
      }

      // isPreferred
      //
      if (n.name () == "isPreferred" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isPreferred_)
        {
          this->isPreferred_.set (isPreferred_traits::create (i, f, this));
          continue;
        }
      }

      // privacy
      //
      if (n.name () == "privacy" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< privacy_type > r (
          privacy_traits::create (i, f, this));

        if (!this->privacy_)
        {
          this->privacy_.set (::std::move (r));
          continue;
        }
      }

      // typeOfService
      //
      if (n.name () == "typeOfService" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< typeOfService_type > r (
          typeOfService_traits::create (i, f, this));

        if (!this->typeOfService_)
        {
          this->typeOfService_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ElectronicMessageSystem* ElectronicMessageSystem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ElectronicMessageSystem (*this, f, c);
  }

  ElectronicMessageSystem& ElectronicMessageSystem::
  operator= (const ElectronicMessageSystem& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->contactAddress_ = x.contactAddress_;
      this->effectiveDates_ = x.effectiveDates_;
      this->isPreferred_ = x.isPreferred_;
      this->privacy_ = x.privacy_;
      this->typeOfService_ = x.typeOfService_;
    }

    return *this;
  }

  ElectronicMessageSystem::
  ~ElectronicMessageSystem ()
  {
  }

  // Email
  //

  Email::
  Email ()
  : ::xml_schema::type (),
    effectiveDates_ (this),
    internetEmail_ (this),
    isPreferred_ (this),
    privacy_ (this),
    typeOfEmail_ (this)
  {
  }

  Email::
  Email (const Email& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    effectiveDates_ (x.effectiveDates_, f, this),
    internetEmail_ (x.internetEmail_, f, this),
    isPreferred_ (x.isPreferred_, f, this),
    privacy_ (x.privacy_, f, this),
    typeOfEmail_ (x.typeOfEmail_, f, this)
  {
  }

  Email::
  Email (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    effectiveDates_ (this),
    internetEmail_ (this),
    isPreferred_ (this),
    privacy_ (this),
    typeOfEmail_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Email::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // effectiveDates
      //
      if (n.name () == "effectiveDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< effectiveDates_type > r (
          effectiveDates_traits::create (i, f, this));

        if (!this->effectiveDates_)
        {
          this->effectiveDates_.set (::std::move (r));
          continue;
        }
      }

      // internetEmail
      //
      if (n.name () == "internetEmail" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< internetEmail_type > r (
          internetEmail_traits::create (i, f, this));

        if (!this->internetEmail_)
        {
          this->internetEmail_.set (::std::move (r));
          continue;
        }
      }

      // isPreferred
      //
      if (n.name () == "isPreferred" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isPreferred_)
        {
          this->isPreferred_.set (isPreferred_traits::create (i, f, this));
          continue;
        }
      }

      // privacy
      //
      if (n.name () == "privacy" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< privacy_type > r (
          privacy_traits::create (i, f, this));

        if (!this->privacy_)
        {
          this->privacy_.set (::std::move (r));
          continue;
        }
      }

      // typeOfEmail
      //
      if (n.name () == "typeOfEmail" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< typeOfEmail_type > r (
          typeOfEmail_traits::create (i, f, this));

        if (!this->typeOfEmail_)
        {
          this->typeOfEmail_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Email* Email::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Email (*this, f, c);
  }

  Email& Email::
  operator= (const Email& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->effectiveDates_ = x.effectiveDates_;
      this->internetEmail_ = x.internetEmail_;
      this->isPreferred_ = x.isPreferred_;
      this->privacy_ = x.privacy_;
      this->typeOfEmail_ = x.typeOfEmail_;
    }

    return *this;
  }

  Email::
  ~Email ()
  {
  }

  // EmbargoInformation
  //

  EmbargoInformation::
  EmbargoInformation ()
  : ::xml_schema::type (),
    description_ (this),
    period_ (this)
  {
  }

  EmbargoInformation::
  EmbargoInformation (const EmbargoInformation& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    description_ (x.description_, f, this),
    period_ (x.period_, f, this)
  {
  }

  EmbargoInformation::
  EmbargoInformation (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    description_ (this),
    period_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void EmbargoInformation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!this->description_)
        {
          this->description_.set (::std::move (r));
          continue;
        }
      }

      // period
      //
      if (n.name () == "period" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< period_type > r (
          period_traits::create (i, f, this));

        this->period_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  EmbargoInformation* EmbargoInformation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EmbargoInformation (*this, f, c);
  }

  EmbargoInformation& EmbargoInformation::
  operator= (const EmbargoInformation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->description_ = x.description_;
      this->period_ = x.period_;
    }

    return *this;
  }

  EmbargoInformation::
  ~EmbargoInformation ()
  {
  }

  // FundingInformation
  //

  FundingInformation::
  FundingInformation ()
  : ::xml_schema::type (),
    fundingAgent_ (this),
    grantNumber_ (this)
  {
  }

  FundingInformation::
  FundingInformation (const FundingInformation& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    fundingAgent_ (x.fundingAgent_, f, this),
    grantNumber_ (x.grantNumber_, f, this)
  {
  }

  FundingInformation::
  FundingInformation (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    fundingAgent_ (this),
    grantNumber_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FundingInformation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // fundingAgent
      //
      if (n.name () == "fundingAgent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< fundingAgent_type > r (
          fundingAgent_traits::create (i, f, this));

        this->fundingAgent_.push_back (::std::move (r));
        continue;
      }

      // grantNumber
      //
      if (n.name () == "grantNumber" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< grantNumber_type > r (
          grantNumber_traits::create (i, f, this));

        if (!this->grantNumber_)
        {
          this->grantNumber_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  FundingInformation* FundingInformation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FundingInformation (*this, f, c);
  }

  FundingInformation& FundingInformation::
  operator= (const FundingInformation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->fundingAgent_ = x.fundingAgent_;
      this->grantNumber_ = x.grantNumber_;
    }

    return *this;
  }

  FundingInformation::
  ~FundingInformation ()
  {
  }

  // SpecializationRole
  //

  SpecializationRole::
  SpecializationRole ()
  : ::xml_schema::type ()
  {
  }

  SpecializationRole::
  SpecializationRole (const SpecializationRole& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  SpecializationRole::
  SpecializationRole (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  SpecializationRole::
  SpecializationRole (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  SpecializationRole::
  SpecializationRole (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  SpecializationRole* SpecializationRole::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpecializationRole (*this, f, c);
  }

  SpecializationRole::
  ~SpecializationRole ()
  {
  }

  // GeoRole
  //

  GeoRole::
  GeoRole ()
  : ::XMLSchema::SpecializationRole (),
    geography_ (this)
  {
  }

  GeoRole::
  GeoRole (const GeoRole& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::XMLSchema::SpecializationRole (x, f, c),
    geography_ (x.geography_, f, this)
  {
  }

  GeoRole::
  GeoRole (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::XMLSchema::SpecializationRole (e, f | ::xml_schema::flags::base, c),
    geography_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GeoRole::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // geography
      //
      if (n.name () == "geography" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< geography_type > r (
          geography_traits::create (i, f, this));

        if (!this->geography_)
        {
          this->geography_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GeoRole* GeoRole::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GeoRole (*this, f, c);
  }

  GeoRole& GeoRole::
  operator= (const GeoRole& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::SpecializationRole& > (*this) = x;
      this->geography_ = x.geography_;
    }

    return *this;
  }

  GeoRole::
  ~GeoRole ()
  {
  }

  // Identifier
  //

  Identifier::
  Identifier ()
  : ::xml_schema::type (),
    ddiIdentifier_ (this),
    isDdiIdentifierPersistent_ (this),
    isDdiIdentifierUniversallyUnique_ (this),
    nonDdiIdentifier_ (this),
    uri_ (this),
    versionDate_ (this),
    versionRationale_ (this),
    versionResponsibility_ (this)
  {
  }

  Identifier::
  Identifier (const Identifier& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ddiIdentifier_ (x.ddiIdentifier_, f, this),
    isDdiIdentifierPersistent_ (x.isDdiIdentifierPersistent_, f, this),
    isDdiIdentifierUniversallyUnique_ (x.isDdiIdentifierUniversallyUnique_, f, this),
    nonDdiIdentifier_ (x.nonDdiIdentifier_, f, this),
    uri_ (x.uri_, f, this),
    versionDate_ (x.versionDate_, f, this),
    versionRationale_ (x.versionRationale_, f, this),
    versionResponsibility_ (x.versionResponsibility_, f, this)
  {
  }

  Identifier::
  Identifier (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ddiIdentifier_ (this),
    isDdiIdentifierPersistent_ (this),
    isDdiIdentifierUniversallyUnique_ (this),
    nonDdiIdentifier_ (this),
    uri_ (this),
    versionDate_ (this),
    versionRationale_ (this),
    versionResponsibility_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Identifier::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ddiIdentifier
      //
      if (n.name () == "ddiIdentifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ddiIdentifier_type > r (
          ddiIdentifier_traits::create (i, f, this));

        if (!this->ddiIdentifier_)
        {
          this->ddiIdentifier_.set (::std::move (r));
          continue;
        }
      }

      // isDdiIdentifierPersistent
      //
      if (n.name () == "isDdiIdentifierPersistent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isDdiIdentifierPersistent_)
        {
          this->isDdiIdentifierPersistent_.set (isDdiIdentifierPersistent_traits::create (i, f, this));
          continue;
        }
      }

      // isDdiIdentifierUniversallyUnique
      //
      if (n.name () == "isDdiIdentifierUniversallyUnique" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isDdiIdentifierUniversallyUnique_)
        {
          this->isDdiIdentifierUniversallyUnique_.set (isDdiIdentifierUniversallyUnique_traits::create (i, f, this));
          continue;
        }
      }

      // nonDdiIdentifier
      //
      if (n.name () == "nonDdiIdentifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< nonDdiIdentifier_type > r (
          nonDdiIdentifier_traits::create (i, f, this));

        this->nonDdiIdentifier_.push_back (::std::move (r));
        continue;
      }

      // uri
      //
      if (n.name () == "uri" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< uri_type > r (
          uri_traits::create (i, f, this));

        if (!this->uri_)
        {
          this->uri_.set (::std::move (r));
          continue;
        }
      }

      // versionDate
      //
      if (n.name () == "versionDate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< versionDate_type > r (
          versionDate_traits::create (i, f, this));

        if (!this->versionDate_)
        {
          this->versionDate_.set (::std::move (r));
          continue;
        }
      }

      // versionRationale
      //
      if (n.name () == "versionRationale" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< versionRationale_type > r (
          versionRationale_traits::create (i, f, this));

        if (!this->versionRationale_)
        {
          this->versionRationale_.set (::std::move (r));
          continue;
        }
      }

      // versionResponsibility
      //
      if (n.name () == "versionResponsibility" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< versionResponsibility_type > r (
          versionResponsibility_traits::create (i, f, this));

        if (!this->versionResponsibility_)
        {
          this->versionResponsibility_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Identifier* Identifier::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Identifier (*this, f, c);
  }

  Identifier& Identifier::
  operator= (const Identifier& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ddiIdentifier_ = x.ddiIdentifier_;
      this->isDdiIdentifierPersistent_ = x.isDdiIdentifierPersistent_;
      this->isDdiIdentifierUniversallyUnique_ = x.isDdiIdentifierUniversallyUnique_;
      this->nonDdiIdentifier_ = x.nonDdiIdentifier_;
      this->uri_ = x.uri_;
      this->versionDate_ = x.versionDate_;
      this->versionRationale_ = x.versionRationale_;
      this->versionResponsibility_ = x.versionResponsibility_;
    }

    return *this;
  }

  Identifier::
  ~Identifier ()
  {
  }

  // IndividualName
  //

  IndividualName::
  IndividualName ()
  : ::xml_schema::type (),
    abbreviation_ (this),
    context_ (this),
    effectiveDates_ (this),
    firstGiven_ (this),
    fullName_ (this),
    isFormal_ (this),
    isPreferred_ (this),
    lastFamily_ (this),
    middle_ (this),
    prefix_ (this),
    sex_ (this),
    suffix_ (this),
    typeOfIndividualName_ (this)
  {
  }

  IndividualName::
  IndividualName (const IndividualName& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    abbreviation_ (x.abbreviation_, f, this),
    context_ (x.context_, f, this),
    effectiveDates_ (x.effectiveDates_, f, this),
    firstGiven_ (x.firstGiven_, f, this),
    fullName_ (x.fullName_, f, this),
    isFormal_ (x.isFormal_, f, this),
    isPreferred_ (x.isPreferred_, f, this),
    lastFamily_ (x.lastFamily_, f, this),
    middle_ (x.middle_, f, this),
    prefix_ (x.prefix_, f, this),
    sex_ (x.sex_, f, this),
    suffix_ (x.suffix_, f, this),
    typeOfIndividualName_ (x.typeOfIndividualName_, f, this)
  {
  }

  IndividualName::
  IndividualName (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    abbreviation_ (this),
    context_ (this),
    effectiveDates_ (this),
    firstGiven_ (this),
    fullName_ (this),
    isFormal_ (this),
    isPreferred_ (this),
    lastFamily_ (this),
    middle_ (this),
    prefix_ (this),
    sex_ (this),
    suffix_ (this),
    typeOfIndividualName_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void IndividualName::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // abbreviation
      //
      if (n.name () == "abbreviation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< abbreviation_type > r (
          abbreviation_traits::create (i, f, this));

        if (!this->abbreviation_)
        {
          this->abbreviation_.set (::std::move (r));
          continue;
        }
      }

      // context
      //
      if (n.name () == "context" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< context_type > r (
          context_traits::create (i, f, this));

        if (!this->context_)
        {
          this->context_.set (::std::move (r));
          continue;
        }
      }

      // effectiveDates
      //
      if (n.name () == "effectiveDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< effectiveDates_type > r (
          effectiveDates_traits::create (i, f, this));

        if (!this->effectiveDates_)
        {
          this->effectiveDates_.set (::std::move (r));
          continue;
        }
      }

      // firstGiven
      //
      if (n.name () == "firstGiven" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< firstGiven_type > r (
          firstGiven_traits::create (i, f, this));

        if (!this->firstGiven_)
        {
          this->firstGiven_.set (::std::move (r));
          continue;
        }
      }

      // fullName
      //
      if (n.name () == "fullName" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< fullName_type > r (
          fullName_traits::create (i, f, this));

        if (!this->fullName_)
        {
          this->fullName_.set (::std::move (r));
          continue;
        }
      }

      // isFormal
      //
      if (n.name () == "isFormal" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isFormal_)
        {
          this->isFormal_.set (isFormal_traits::create (i, f, this));
          continue;
        }
      }

      // isPreferred
      //
      if (n.name () == "isPreferred" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isPreferred_)
        {
          this->isPreferred_.set (isPreferred_traits::create (i, f, this));
          continue;
        }
      }

      // lastFamily
      //
      if (n.name () == "lastFamily" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< lastFamily_type > r (
          lastFamily_traits::create (i, f, this));

        if (!this->lastFamily_)
        {
          this->lastFamily_.set (::std::move (r));
          continue;
        }
      }

      // middle
      //
      if (n.name () == "middle" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< middle_type > r (
          middle_traits::create (i, f, this));

        this->middle_.push_back (::std::move (r));
        continue;
      }

      // prefix
      //
      if (n.name () == "prefix" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< prefix_type > r (
          prefix_traits::create (i, f, this));

        if (!this->prefix_)
        {
          this->prefix_.set (::std::move (r));
          continue;
        }
      }

      // sex
      //
      if (n.name () == "sex" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< sex_type > r (
          sex_traits::create (i, f, this));

        if (!this->sex_)
        {
          this->sex_.set (::std::move (r));
          continue;
        }
      }

      // suffix
      //
      if (n.name () == "suffix" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< suffix_type > r (
          suffix_traits::create (i, f, this));

        if (!this->suffix_)
        {
          this->suffix_.set (::std::move (r));
          continue;
        }
      }

      // typeOfIndividualName
      //
      if (n.name () == "typeOfIndividualName" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< typeOfIndividualName_type > r (
          typeOfIndividualName_traits::create (i, f, this));

        if (!this->typeOfIndividualName_)
        {
          this->typeOfIndividualName_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  IndividualName* IndividualName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IndividualName (*this, f, c);
  }

  IndividualName& IndividualName::
  operator= (const IndividualName& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->abbreviation_ = x.abbreviation_;
      this->context_ = x.context_;
      this->effectiveDates_ = x.effectiveDates_;
      this->firstGiven_ = x.firstGiven_;
      this->fullName_ = x.fullName_;
      this->isFormal_ = x.isFormal_;
      this->isPreferred_ = x.isPreferred_;
      this->lastFamily_ = x.lastFamily_;
      this->middle_ = x.middle_;
      this->prefix_ = x.prefix_;
      this->sex_ = x.sex_;
      this->suffix_ = x.suffix_;
      this->typeOfIndividualName_ = x.typeOfIndividualName_;
    }

    return *this;
  }

  IndividualName::
  ~IndividualName ()
  {
  }

  // InternationalIdentifier
  //

  InternationalIdentifier::
  InternationalIdentifier ()
  : ::xml_schema::type (),
    identifierContent_ (this),
    isURI_ (this),
    managingAgency_ (this)
  {
  }

  InternationalIdentifier::
  InternationalIdentifier (const InternationalIdentifier& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifierContent_ (x.identifierContent_, f, this),
    isURI_ (x.isURI_, f, this),
    managingAgency_ (x.managingAgency_, f, this)
  {
  }

  InternationalIdentifier::
  InternationalIdentifier (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifierContent_ (this),
    isURI_ (this),
    managingAgency_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InternationalIdentifier::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifierContent
      //
      if (n.name () == "identifierContent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< identifierContent_type > r (
          identifierContent_traits::create (i, f, this));

        if (!this->identifierContent_)
        {
          this->identifierContent_.set (::std::move (r));
          continue;
        }
      }

      // isURI
      //
      if (n.name () == "isURI" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isURI_)
        {
          this->isURI_.set (isURI_traits::create (i, f, this));
          continue;
        }
      }

      // managingAgency
      //
      if (n.name () == "managingAgency" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< managingAgency_type > r (
          managingAgency_traits::create (i, f, this));

        if (!this->managingAgency_)
        {
          this->managingAgency_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  InternationalIdentifier* InternationalIdentifier::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InternationalIdentifier (*this, f, c);
  }

  InternationalIdentifier& InternationalIdentifier::
  operator= (const InternationalIdentifier& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identifierContent_ = x.identifierContent_;
      this->isURI_ = x.isURI_;
      this->managingAgency_ = x.managingAgency_;
    }

    return *this;
  }

  InternationalIdentifier::
  ~InternationalIdentifier ()
  {
  }

  // InternationalRegistrationDataIdentifier
  //

  InternationalRegistrationDataIdentifier::
  InternationalRegistrationDataIdentifier (const dataIdentifier_type& dataIdentifier,
                                           const registrationAuthorityIdentifier_type& registrationAuthorityIdentifier,
                                           const versionIdentifier_type& versionIdentifier)
  : ::xml_schema::type (),
    dataIdentifier_ (dataIdentifier, this),
    registrationAuthorityIdentifier_ (registrationAuthorityIdentifier, this),
    versionIdentifier_ (versionIdentifier, this)
  {
  }

  InternationalRegistrationDataIdentifier::
  InternationalRegistrationDataIdentifier (const InternationalRegistrationDataIdentifier& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dataIdentifier_ (x.dataIdentifier_, f, this),
    registrationAuthorityIdentifier_ (x.registrationAuthorityIdentifier_, f, this),
    versionIdentifier_ (x.versionIdentifier_, f, this)
  {
  }

  InternationalRegistrationDataIdentifier::
  InternationalRegistrationDataIdentifier (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dataIdentifier_ (this),
    registrationAuthorityIdentifier_ (this),
    versionIdentifier_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InternationalRegistrationDataIdentifier::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dataIdentifier
      //
      if (n.name () == "dataIdentifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< dataIdentifier_type > r (
          dataIdentifier_traits::create (i, f, this));

        if (!dataIdentifier_.present ())
        {
          this->dataIdentifier_.set (::std::move (r));
          continue;
        }
      }

      // registrationAuthorityIdentifier
      //
      if (n.name () == "registrationAuthorityIdentifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< registrationAuthorityIdentifier_type > r (
          registrationAuthorityIdentifier_traits::create (i, f, this));

        if (!registrationAuthorityIdentifier_.present ())
        {
          this->registrationAuthorityIdentifier_.set (::std::move (r));
          continue;
        }
      }

      // versionIdentifier
      //
      if (n.name () == "versionIdentifier" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< versionIdentifier_type > r (
          versionIdentifier_traits::create (i, f, this));

        if (!versionIdentifier_.present ())
        {
          this->versionIdentifier_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!dataIdentifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dataIdentifier",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!registrationAuthorityIdentifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "registrationAuthorityIdentifier",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!versionIdentifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "versionIdentifier",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  InternationalRegistrationDataIdentifier* InternationalRegistrationDataIdentifier::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InternationalRegistrationDataIdentifier (*this, f, c);
  }

  InternationalRegistrationDataIdentifier& InternationalRegistrationDataIdentifier::
  operator= (const InternationalRegistrationDataIdentifier& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->dataIdentifier_ = x.dataIdentifier_;
      this->registrationAuthorityIdentifier_ = x.registrationAuthorityIdentifier_;
      this->versionIdentifier_ = x.versionIdentifier_;
    }

    return *this;
  }

  InternationalRegistrationDataIdentifier::
  ~InternationalRegistrationDataIdentifier ()
  {
  }

  // LabelForDisplay
  //

  LabelForDisplay::
  LabelForDisplay ()
  : ::XMLSchema::InternationalString (),
    locationVariant_ (this),
    maxLength_ (this),
    validDates_ (this)
  {
  }

  LabelForDisplay::
  LabelForDisplay (const LabelForDisplay& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::XMLSchema::InternationalString (x, f, c),
    locationVariant_ (x.locationVariant_, f, this),
    maxLength_ (x.maxLength_, f, this),
    validDates_ (x.validDates_, f, this)
  {
  }

  LabelForDisplay::
  LabelForDisplay (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::XMLSchema::InternationalString (e, f | ::xml_schema::flags::base, c),
    locationVariant_ (this),
    maxLength_ (this),
    validDates_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LabelForDisplay::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::InternationalString::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // locationVariant
      //
      if (n.name () == "locationVariant" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< locationVariant_type > r (
          locationVariant_traits::create (i, f, this));

        if (!this->locationVariant_)
        {
          this->locationVariant_.set (::std::move (r));
          continue;
        }
      }

      // maxLength
      //
      if (n.name () == "maxLength" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->maxLength_)
        {
          this->maxLength_.set (maxLength_traits::create (i, f, this));
          continue;
        }
      }

      // validDates
      //
      if (n.name () == "validDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< validDates_type > r (
          validDates_traits::create (i, f, this));

        if (!this->validDates_)
        {
          this->validDates_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  LabelForDisplay* LabelForDisplay::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LabelForDisplay (*this, f, c);
  }

  LabelForDisplay& LabelForDisplay::
  operator= (const LabelForDisplay& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::InternationalString& > (*this) = x;
      this->locationVariant_ = x.locationVariant_;
      this->maxLength_ = x.maxLength_;
      this->validDates_ = x.validDates_;
    }

    return *this;
  }

  LabelForDisplay::
  ~LabelForDisplay ()
  {
  }

  // LanguageString
  //

  LanguageString::
  LanguageString (const content_type& content)
  : ::xml_schema::type (),
    content_ (content, this),
    isTranslatable_ (this),
    isTranslated_ (this),
    scope_ (this),
    structureUsed_ (this),
    translationDate_ (this),
    translationSourceLanguage_ (this)
  {
  }

  LanguageString::
  LanguageString (const LanguageString& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_ (x.content_, f, this),
    isTranslatable_ (x.isTranslatable_, f, this),
    isTranslated_ (x.isTranslated_, f, this),
    scope_ (x.scope_, f, this),
    structureUsed_ (x.structureUsed_, f, this),
    translationDate_ (x.translationDate_, f, this),
    translationSourceLanguage_ (x.translationSourceLanguage_, f, this)
  {
  }

  LanguageString::
  LanguageString (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    content_ (this),
    isTranslatable_ (this),
    isTranslated_ (this),
    scope_ (this),
    structureUsed_ (this),
    translationDate_ (this),
    translationSourceLanguage_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LanguageString::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // content
      //
      if (n.name () == "content" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< content_type > r (
          content_traits::create (i, f, this));

        if (!content_.present ())
        {
          this->content_.set (::std::move (r));
          continue;
        }
      }

      // isTranslatable
      //
      if (n.name () == "isTranslatable" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isTranslatable_)
        {
          this->isTranslatable_.set (isTranslatable_traits::create (i, f, this));
          continue;
        }
      }

      // isTranslated
      //
      if (n.name () == "isTranslated" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isTranslated_)
        {
          this->isTranslated_.set (isTranslated_traits::create (i, f, this));
          continue;
        }
      }

      // scope
      //
      if (n.name () == "scope" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< scope_type > r (
          scope_traits::create (i, f, this));

        if (!this->scope_)
        {
          this->scope_.set (::std::move (r));
          continue;
        }
      }

      // structureUsed
      //
      if (n.name () == "structureUsed" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< structureUsed_type > r (
          structureUsed_traits::create (i, f, this));

        if (!this->structureUsed_)
        {
          this->structureUsed_.set (::std::move (r));
          continue;
        }
      }

      // translationDate
      //
      if (n.name () == "translationDate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< translationDate_type > r (
          translationDate_traits::create (i, f, this));

        if (!this->translationDate_)
        {
          this->translationDate_.set (::std::move (r));
          continue;
        }
      }

      // translationSourceLanguage
      //
      if (n.name () == "translationSourceLanguage" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< translationSourceLanguage_type > r (
          translationSourceLanguage_traits::create (i, f, this));

        this->translationSourceLanguage_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!content_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "content",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  LanguageString* LanguageString::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LanguageString (*this, f, c);
  }

  LanguageString& LanguageString::
  operator= (const LanguageString& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_ = x.content_;
      this->isTranslatable_ = x.isTranslatable_;
      this->isTranslated_ = x.isTranslated_;
      this->scope_ = x.scope_;
      this->structureUsed_ = x.structureUsed_;
      this->translationDate_ = x.translationDate_;
      this->translationSourceLanguage_ = x.translationSourceLanguage_;
    }

    return *this;
  }

  LanguageString::
  ~LanguageString ()
  {
  }

  // LicenseInformation
  //

  LicenseInformation::
  LicenseInformation ()
  : ::xml_schema::type (),
    contact_ (this),
    description_ (this),
    licenseAgent_ (this),
    licenseReference_ (this)
  {
  }

  LicenseInformation::
  LicenseInformation (const LicenseInformation& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    contact_ (x.contact_, f, this),
    description_ (x.description_, f, this),
    licenseAgent_ (x.licenseAgent_, f, this),
    licenseReference_ (x.licenseReference_, f, this)
  {
  }

  LicenseInformation::
  LicenseInformation (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    contact_ (this),
    description_ (this),
    licenseAgent_ (this),
    licenseReference_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LicenseInformation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // contact
      //
      if (n.name () == "contact" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< contact_type > r (
          contact_traits::create (i, f, this));

        this->contact_.push_back (::std::move (r));
        continue;
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< description_type > r (
          description_traits::create (i, f, this));

        this->description_.push_back (::std::move (r));
        continue;
      }

      // licenseAgent
      //
      if (n.name () == "licenseAgent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< licenseAgent_type > r (
          licenseAgent_traits::create (i, f, this));

        this->licenseAgent_.push_back (::std::move (r));
        continue;
      }

      // licenseReference
      //
      if (n.name () == "licenseReference" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< licenseReference_type > r (
          licenseReference_traits::create (i, f, this));

        this->licenseReference_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LicenseInformation* LicenseInformation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LicenseInformation (*this, f, c);
  }

  LicenseInformation& LicenseInformation::
  operator= (const LicenseInformation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->contact_ = x.contact_;
      this->description_ = x.description_;
      this->licenseAgent_ = x.licenseAgent_;
      this->licenseReference_ = x.licenseReference_;
    }

    return *this;
  }

  LicenseInformation::
  ~LicenseInformation ()
  {
  }

  // ModelIdentification
  //

  ModelIdentification::
  ModelIdentification (const acronym_type& acronym,
                       const language_type& language,
                       const majorVersion_type& majorVersion,
                       const minorVersion_type& minorVersion,
                       const subtitle_type& subtitle,
                       const title_type& title,
                       const uri_type& uri)
  : ::xml_schema::type (),
    acronym_ (acronym, this),
    language_ (language, this),
    majorVersion_ (majorVersion, this),
    minorVersion_ (minorVersion, this),
    subtitle_ (subtitle, this),
    title_ (title, this),
    uri_ (uri, this)
  {
  }

  ModelIdentification::
  ModelIdentification (const ModelIdentification& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    acronym_ (x.acronym_, f, this),
    language_ (x.language_, f, this),
    majorVersion_ (x.majorVersion_, f, this),
    minorVersion_ (x.minorVersion_, f, this),
    subtitle_ (x.subtitle_, f, this),
    title_ (x.title_, f, this),
    uri_ (x.uri_, f, this)
  {
  }

  ModelIdentification::
  ModelIdentification (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    acronym_ (this),
    language_ (this),
    majorVersion_ (this),
    minorVersion_ (this),
    subtitle_ (this),
    title_ (this),
    uri_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ModelIdentification::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // acronym
      //
      if (n.name () == "acronym" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< acronym_type > r (
          acronym_traits::create (i, f, this));

        if (!acronym_.present ())
        {
          this->acronym_.set (::std::move (r));
          continue;
        }
      }

      // language
      //
      if (n.name () == "language" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< language_type > r (
          language_traits::create (i, f, this));

        if (!language_.present ())
        {
          this->language_.set (::std::move (r));
          continue;
        }
      }

      // majorVersion
      //
      if (n.name () == "majorVersion" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!majorVersion_.present ())
        {
          this->majorVersion_.set (majorVersion_traits::create (i, f, this));
          continue;
        }
      }

      // minorVersion
      //
      if (n.name () == "minorVersion" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!minorVersion_.present ())
        {
          this->minorVersion_.set (minorVersion_traits::create (i, f, this));
          continue;
        }
      }

      // subtitle
      //
      if (n.name () == "subtitle" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< subtitle_type > r (
          subtitle_traits::create (i, f, this));

        if (!subtitle_.present ())
        {
          this->subtitle_.set (::std::move (r));
          continue;
        }
      }

      // title
      //
      if (n.name () == "title" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< title_type > r (
          title_traits::create (i, f, this));

        if (!title_.present ())
        {
          this->title_.set (::std::move (r));
          continue;
        }
      }

      // uri
      //
      if (n.name () == "uri" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< uri_type > r (
          uri_traits::create (i, f, this));

        if (!uri_.present ())
        {
          this->uri_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!acronym_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "acronym",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!language_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "language",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!majorVersion_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "majorVersion",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!minorVersion_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "minorVersion",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!subtitle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "subtitle",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!title_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "title",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!uri_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "uri",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  ModelIdentification* ModelIdentification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ModelIdentification (*this, f, c);
  }

  ModelIdentification& ModelIdentification::
  operator= (const ModelIdentification& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->acronym_ = x.acronym_;
      this->language_ = x.language_;
      this->majorVersion_ = x.majorVersion_;
      this->minorVersion_ = x.minorVersion_;
      this->subtitle_ = x.subtitle_;
      this->title_ = x.title_;
      this->uri_ = x.uri_;
    }

    return *this;
  }

  ModelIdentification::
  ~ModelIdentification ()
  {
  }

  // NonDdiIdentifier
  //

  NonDdiIdentifier::
  NonDdiIdentifier (const type_type& type,
                    const value_type& value)
  : ::xml_schema::type (),
    managingAgency_ (this),
    type_ (type, this),
    value_ (value, this),
    version_ (this)
  {
  }

  NonDdiIdentifier::
  NonDdiIdentifier (const NonDdiIdentifier& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    managingAgency_ (x.managingAgency_, f, this),
    type_ (x.type_, f, this),
    value_ (x.value_, f, this),
    version_ (x.version_, f, this)
  {
  }

  NonDdiIdentifier::
  NonDdiIdentifier (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    managingAgency_ (this),
    type_ (this),
    value_ (this),
    version_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void NonDdiIdentifier::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // managingAgency
      //
      if (n.name () == "managingAgency" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< managingAgency_type > r (
          managingAgency_traits::create (i, f, this));

        if (!this->managingAgency_)
        {
          this->managingAgency_.set (::std::move (r));
          continue;
        }
      }

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< type_type > r (
          type_traits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (::std::move (r));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< value_type > r (
          value_traits::create (i, f, this));

        if (!value_.present ())
        {
          this->value_.set (::std::move (r));
          continue;
        }
      }

      // version
      //
      if (n.name () == "version" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< version_type > r (
          version_traits::create (i, f, this));

        if (!this->version_)
        {
          this->version_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  NonDdiIdentifier* NonDdiIdentifier::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NonDdiIdentifier (*this, f, c);
  }

  NonDdiIdentifier& NonDdiIdentifier::
  operator= (const NonDdiIdentifier& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->managingAgency_ = x.managingAgency_;
      this->type_ = x.type_;
      this->value_ = x.value_;
      this->version_ = x.version_;
    }

    return *this;
  }

  NonDdiIdentifier::
  ~NonDdiIdentifier ()
  {
  }

  // NonIsoDate
  //

  NonIsoDate::
  NonIsoDate (const dateContent_type& dateContent)
  : ::xml_schema::type (),
    calendar_ (this),
    dateContent_ (dateContent, this),
    nonIsoDateFormat_ (this)
  {
  }

  NonIsoDate::
  NonIsoDate (const NonIsoDate& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    calendar_ (x.calendar_, f, this),
    dateContent_ (x.dateContent_, f, this),
    nonIsoDateFormat_ (x.nonIsoDateFormat_, f, this)
  {
  }

  NonIsoDate::
  NonIsoDate (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    calendar_ (this),
    dateContent_ (this),
    nonIsoDateFormat_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void NonIsoDate::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // calendar
      //
      if (n.name () == "calendar" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< calendar_type > r (
          calendar_traits::create (i, f, this));

        if (!this->calendar_)
        {
          this->calendar_.set (::std::move (r));
          continue;
        }
      }

      // dateContent
      //
      if (n.name () == "dateContent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< dateContent_type > r (
          dateContent_traits::create (i, f, this));

        if (!dateContent_.present ())
        {
          this->dateContent_.set (::std::move (r));
          continue;
        }
      }

      // nonIsoDateFormat
      //
      if (n.name () == "nonIsoDateFormat" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< nonIsoDateFormat_type > r (
          nonIsoDateFormat_traits::create (i, f, this));

        if (!this->nonIsoDateFormat_)
        {
          this->nonIsoDateFormat_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!dateContent_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dateContent",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  NonIsoDate* NonIsoDate::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NonIsoDate (*this, f, c);
  }

  NonIsoDate& NonIsoDate::
  operator= (const NonIsoDate& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->calendar_ = x.calendar_;
      this->dateContent_ = x.dateContent_;
      this->nonIsoDateFormat_ = x.nonIsoDateFormat_;
    }

    return *this;
  }

  NonIsoDate::
  ~NonIsoDate ()
  {
  }

  // Selector
  //

  Selector::
  Selector ()
  : ::xml_schema::type ()
  {
  }

  Selector::
  Selector (const Selector& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  Selector::
  Selector (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  Selector::
  Selector (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  Selector::
  Selector (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  Selector* Selector::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Selector (*this, f, c);
  }

  Selector::
  ~Selector ()
  {
  }

  // ObjectAttributeSelector
  //

  ObjectAttributeSelector::
  ObjectAttributeSelector ()
  : ::XMLSchema::Selector (),
    refinedBy_ (this),
    refinedByOrderNumber_ (this),
    value_ (this)
  {
  }

  ObjectAttributeSelector::
  ObjectAttributeSelector (const ObjectAttributeSelector& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::XMLSchema::Selector (x, f, c),
    refinedBy_ (x.refinedBy_, f, this),
    refinedByOrderNumber_ (x.refinedByOrderNumber_, f, this),
    value_ (x.value_, f, this)
  {
  }

  ObjectAttributeSelector::
  ObjectAttributeSelector (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::XMLSchema::Selector (e, f | ::xml_schema::flags::base, c),
    refinedBy_ (this),
    refinedByOrderNumber_ (this),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ObjectAttributeSelector::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // refinedBy
      //
      if (n.name () == "refinedBy" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< refinedBy_type > r (
          refinedBy_traits::create (i, f, this));

        if (!this->refinedBy_)
        {
          this->refinedBy_.set (::std::move (r));
          continue;
        }
      }

      // refinedByOrderNumber
      //
      if (n.name () == "refinedByOrderNumber" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->refinedByOrderNumber_)
        {
          this->refinedByOrderNumber_.set (refinedByOrderNumber_traits::create (i, f, this));
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< value_type > r (
          value_traits::create (i, f, this));

        if (!this->value_)
        {
          this->value_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ObjectAttributeSelector* ObjectAttributeSelector::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ObjectAttributeSelector (*this, f, c);
  }

  ObjectAttributeSelector& ObjectAttributeSelector::
  operator= (const ObjectAttributeSelector& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Selector& > (*this) = x;
      this->refinedBy_ = x.refinedBy_;
      this->refinedByOrderNumber_ = x.refinedByOrderNumber_;
      this->value_ = x.value_;
    }

    return *this;
  }

  ObjectAttributeSelector::
  ~ObjectAttributeSelector ()
  {
  }

  // ObjectName
  //

  ObjectName::
  ObjectName ()
  : ::xml_schema::type (),
    context_ (this),
    name_ (this)
  {
  }

  ObjectName::
  ObjectName (const ObjectName& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    context_ (x.context_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ObjectName::
  ObjectName (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    context_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ObjectName::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // context
      //
      if (n.name () == "context" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< context_type > r (
          context_traits::create (i, f, this));

        if (!this->context_)
        {
          this->context_.set (::std::move (r));
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!this->name_)
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ObjectName* ObjectName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ObjectName (*this, f, c);
  }

  ObjectName& ObjectName::
  operator= (const ObjectName& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->context_ = x.context_;
      this->name_ = x.name_;
    }

    return *this;
  }

  ObjectName::
  ~ObjectName ()
  {
  }

  // OrganizationName
  //

  OrganizationName::
  OrganizationName ()
  : ::XMLSchema::ObjectName (),
    abbreviation_ (this),
    effectiveDates_ (this),
    isFormal_ (this),
    typeOfOrganizationName_ (this)
  {
  }

  OrganizationName::
  OrganizationName (const OrganizationName& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::XMLSchema::ObjectName (x, f, c),
    abbreviation_ (x.abbreviation_, f, this),
    effectiveDates_ (x.effectiveDates_, f, this),
    isFormal_ (x.isFormal_, f, this),
    typeOfOrganizationName_ (x.typeOfOrganizationName_, f, this)
  {
  }

  OrganizationName::
  OrganizationName (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::XMLSchema::ObjectName (e, f | ::xml_schema::flags::base, c),
    abbreviation_ (this),
    effectiveDates_ (this),
    isFormal_ (this),
    typeOfOrganizationName_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OrganizationName::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSchema::ObjectName::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // abbreviation
      //
      if (n.name () == "abbreviation" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< abbreviation_type > r (
          abbreviation_traits::create (i, f, this));

        if (!this->abbreviation_)
        {
          this->abbreviation_.set (::std::move (r));
          continue;
        }
      }

      // effectiveDates
      //
      if (n.name () == "effectiveDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< effectiveDates_type > r (
          effectiveDates_traits::create (i, f, this));

        if (!this->effectiveDates_)
        {
          this->effectiveDates_.set (::std::move (r));
          continue;
        }
      }

      // isFormal
      //
      if (n.name () == "isFormal" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isFormal_)
        {
          this->isFormal_.set (isFormal_traits::create (i, f, this));
          continue;
        }
      }

      // typeOfOrganizationName
      //
      if (n.name () == "typeOfOrganizationName" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< typeOfOrganizationName_type > r (
          typeOfOrganizationName_traits::create (i, f, this));

        if (!this->typeOfOrganizationName_)
        {
          this->typeOfOrganizationName_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  OrganizationName* OrganizationName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OrganizationName (*this, f, c);
  }

  OrganizationName& OrganizationName::
  operator= (const OrganizationName& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::ObjectName& > (*this) = x;
      this->abbreviation_ = x.abbreviation_;
      this->effectiveDates_ = x.effectiveDates_;
      this->isFormal_ = x.isFormal_;
      this->typeOfOrganizationName_ = x.typeOfOrganizationName_;
    }

    return *this;
  }

  OrganizationName::
  ~OrganizationName ()
  {
  }

  // PairedControlledVocabularyEntry
  //

  PairedControlledVocabularyEntry::
  PairedControlledVocabularyEntry (const term_type& term)
  : ::xml_schema::type (),
    extent_ (this),
    term_ (term, this)
  {
  }

  PairedControlledVocabularyEntry::
  PairedControlledVocabularyEntry (::std::unique_ptr< term_type > term)
  : ::xml_schema::type (),
    extent_ (this),
    term_ (std::move (term), this)
  {
  }

  PairedControlledVocabularyEntry::
  PairedControlledVocabularyEntry (const PairedControlledVocabularyEntry& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    extent_ (x.extent_, f, this),
    term_ (x.term_, f, this)
  {
  }

  PairedControlledVocabularyEntry::
  PairedControlledVocabularyEntry (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    extent_ (this),
    term_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PairedControlledVocabularyEntry::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // extent
      //
      if (n.name () == "extent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< extent_type > r (
          extent_traits::create (i, f, this));

        if (!this->extent_)
        {
          this->extent_.set (::std::move (r));
          continue;
        }
      }

      // term
      //
      if (n.name () == "term" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< term_type > r (
          term_traits::create (i, f, this));

        if (!term_.present ())
        {
          this->term_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!term_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "term",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  PairedControlledVocabularyEntry* PairedControlledVocabularyEntry::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PairedControlledVocabularyEntry (*this, f, c);
  }

  PairedControlledVocabularyEntry& PairedControlledVocabularyEntry::
  operator= (const PairedControlledVocabularyEntry& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->extent_ = x.extent_;
      this->term_ = x.term_;
    }

    return *this;
  }

  PairedControlledVocabularyEntry::
  ~PairedControlledVocabularyEntry ()
  {
  }

  // PrivateImage
  //

  PrivateImage::
  PrivateImage ()
  : ::xml_schema::type (),
    effectiveDates_ (this),
    privacy_ (this)
  {
  }

  PrivateImage::
  PrivateImage (const PrivateImage& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    effectiveDates_ (x.effectiveDates_, f, this),
    privacy_ (x.privacy_, f, this)
  {
  }

  PrivateImage::
  PrivateImage (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    effectiveDates_ (this),
    privacy_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PrivateImage::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // effectiveDates
      //
      if (n.name () == "effectiveDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< effectiveDates_type > r (
          effectiveDates_traits::create (i, f, this));

        if (!this->effectiveDates_)
        {
          this->effectiveDates_.set (::std::move (r));
          continue;
        }
      }

      // privacy
      //
      if (n.name () == "privacy" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< privacy_type > r (
          privacy_traits::create (i, f, this));

        if (!this->privacy_)
        {
          this->privacy_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  PrivateImage* PrivateImage::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PrivateImage (*this, f, c);
  }

  PrivateImage& PrivateImage::
  operator= (const PrivateImage& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->effectiveDates_ = x.effectiveDates_;
      this->privacy_ = x.privacy_;
    }

    return *this;
  }

  PrivateImage::
  ~PrivateImage ()
  {
  }

  // ProvenanceInformation
  //

  ProvenanceInformation::
  ProvenanceInformation ()
  : ::xml_schema::type (),
    funding_ (this),
    provenanceStatement_ (this),
    recordCreationDate_ (this),
    recordLastRevisionDate_ (this)
  {
  }

  ProvenanceInformation::
  ProvenanceInformation (const ProvenanceInformation& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    funding_ (x.funding_, f, this),
    provenanceStatement_ (x.provenanceStatement_, f, this),
    recordCreationDate_ (x.recordCreationDate_, f, this),
    recordLastRevisionDate_ (x.recordLastRevisionDate_, f, this)
  {
  }

  ProvenanceInformation::
  ProvenanceInformation (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    funding_ (this),
    provenanceStatement_ (this),
    recordCreationDate_ (this),
    recordLastRevisionDate_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ProvenanceInformation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // funding
      //
      if (n.name () == "funding" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< funding_type > r (
          funding_traits::create (i, f, this));

        this->funding_.push_back (::std::move (r));
        continue;
      }

      // provenanceStatement
      //
      if (n.name () == "provenanceStatement" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< provenanceStatement_type > r (
          provenanceStatement_traits::create (i, f, this));

        this->provenanceStatement_.push_back (::std::move (r));
        continue;
      }

      // recordCreationDate
      //
      if (n.name () == "recordCreationDate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< recordCreationDate_type > r (
          recordCreationDate_traits::create (i, f, this));

        if (!this->recordCreationDate_)
        {
          this->recordCreationDate_.set (::std::move (r));
          continue;
        }
      }

      // recordLastRevisionDate
      //
      if (n.name () == "recordLastRevisionDate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< recordLastRevisionDate_type > r (
          recordLastRevisionDate_traits::create (i, f, this));

        if (!this->recordLastRevisionDate_)
        {
          this->recordLastRevisionDate_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ProvenanceInformation* ProvenanceInformation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProvenanceInformation (*this, f, c);
  }

  ProvenanceInformation& ProvenanceInformation::
  operator= (const ProvenanceInformation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->funding_ = x.funding_;
      this->provenanceStatement_ = x.provenanceStatement_;
      this->recordCreationDate_ = x.recordCreationDate_;
      this->recordLastRevisionDate_ = x.recordLastRevisionDate_;
    }

    return *this;
  }

  ProvenanceInformation::
  ~ProvenanceInformation ()
  {
  }

  // RationaleDefinition
  //

  RationaleDefinition::
  RationaleDefinition ()
  : ::xml_schema::type (),
    rationaleCode_ (this),
    rationaleDescription_ (this)
  {
  }

  RationaleDefinition::
  RationaleDefinition (const RationaleDefinition& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    rationaleCode_ (x.rationaleCode_, f, this),
    rationaleDescription_ (x.rationaleDescription_, f, this)
  {
  }

  RationaleDefinition::
  RationaleDefinition (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    rationaleCode_ (this),
    rationaleDescription_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RationaleDefinition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // rationaleCode
      //
      if (n.name () == "rationaleCode" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< rationaleCode_type > r (
          rationaleCode_traits::create (i, f, this));

        if (!this->rationaleCode_)
        {
          this->rationaleCode_.set (::std::move (r));
          continue;
        }
      }

      // rationaleDescription
      //
      if (n.name () == "rationaleDescription" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< rationaleDescription_type > r (
          rationaleDescription_traits::create (i, f, this));

        if (!this->rationaleDescription_)
        {
          this->rationaleDescription_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  RationaleDefinition* RationaleDefinition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RationaleDefinition (*this, f, c);
  }

  RationaleDefinition& RationaleDefinition::
  operator= (const RationaleDefinition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->rationaleCode_ = x.rationaleCode_;
      this->rationaleDescription_ = x.rationaleDescription_;
    }

    return *this;
  }

  RationaleDefinition::
  ~RationaleDefinition ()
  {
  }

  // Reference
  //

  Reference::
  Reference ()
  : ::xml_schema::type (),
    ddiReference_ (this),
    deepLink_ (this),
    description_ (this),
    location_ (this),
    nonDdiReference_ (this),
    semantic_ (this),
    uri_ (this),
    validType_ (this),
    isAssociationReference_ (this)
  {
  }

  Reference::
  Reference (const Reference& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ddiReference_ (x.ddiReference_, f, this),
    deepLink_ (x.deepLink_, f, this),
    description_ (x.description_, f, this),
    location_ (x.location_, f, this),
    nonDdiReference_ (x.nonDdiReference_, f, this),
    semantic_ (x.semantic_, f, this),
    uri_ (x.uri_, f, this),
    validType_ (x.validType_, f, this),
    isAssociationReference_ (x.isAssociationReference_, f, this)
  {
  }

  Reference::
  Reference (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ddiReference_ (this),
    deepLink_ (this),
    description_ (this),
    location_ (this),
    nonDdiReference_ (this),
    semantic_ (this),
    uri_ (this),
    validType_ (this),
    isAssociationReference_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Reference::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ddiReference
      //
      if (n.name () == "ddiReference" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< ddiReference_type > r (
          ddiReference_traits::create (i, f, this));

        if (!this->ddiReference_)
        {
          this->ddiReference_.set (::std::move (r));
          continue;
        }
      }

      // deepLink
      //
      if (n.name () == "deepLink" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< deepLink_type > r (
          deepLink_traits::create (i, f, this));

        if (!this->deepLink_)
        {
          this->deepLink_.set (::std::move (r));
          continue;
        }
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!this->description_)
        {
          this->description_.set (::std::move (r));
          continue;
        }
      }

      // location
      //
      if (n.name () == "location" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< location_type > r (
          location_traits::create (i, f, this));

        if (!this->location_)
        {
          this->location_.set (::std::move (r));
          continue;
        }
      }

      // nonDdiReference
      //
      if (n.name () == "nonDdiReference" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< nonDdiReference_type > r (
          nonDdiReference_traits::create (i, f, this));

        this->nonDdiReference_.push_back (::std::move (r));
        continue;
      }

      // semantic
      //
      if (n.name () == "semantic" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< semantic_type > r (
          semantic_traits::create (i, f, this));

        if (!this->semantic_)
        {
          this->semantic_.set (::std::move (r));
          continue;
        }
      }

      // uri
      //
      if (n.name () == "uri" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< uri_type > r (
          uri_traits::create (i, f, this));

        if (!this->uri_)
        {
          this->uri_.set (::std::move (r));
          continue;
        }
      }

      // validType
      //
      if (n.name () == "validType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< validType_type > r (
          validType_traits::create (i, f, this));

        this->validType_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "isAssociationReference" && n.namespace_ ().empty ())
      {
        this->isAssociationReference_.set (isAssociationReference_traits::create (i, f, this));
        continue;
      }
    }
  }

  Reference* Reference::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Reference (*this, f, c);
  }

  Reference& Reference::
  operator= (const Reference& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ddiReference_ = x.ddiReference_;
      this->deepLink_ = x.deepLink_;
      this->description_ = x.description_;
      this->location_ = x.location_;
      this->nonDdiReference_ = x.nonDdiReference_;
      this->semantic_ = x.semantic_;
      this->uri_ = x.uri_;
      this->validType_ = x.validType_;
      this->isAssociationReference_ = x.isAssociationReference_;
    }

    return *this;
  }

  Reference::
  ~Reference ()
  {
  }

  // SpatialCoordinate
  //

  SpatialCoordinate::
  SpatialCoordinate ()
  : ::xml_schema::type (),
    content_ (this),
    coordinateType_ (this)
  {
  }

  SpatialCoordinate::
  SpatialCoordinate (const SpatialCoordinate& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_ (x.content_, f, this),
    coordinateType_ (x.coordinateType_, f, this)
  {
  }

  SpatialCoordinate::
  SpatialCoordinate (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    content_ (this),
    coordinateType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SpatialCoordinate::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // content
      //
      if (n.name () == "content" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< content_type > r (
          content_traits::create (i, f, this));

        if (!this->content_)
        {
          this->content_.set (::std::move (r));
          continue;
        }
      }

      // coordinateType
      //
      if (n.name () == "coordinateType" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< coordinateType_type > r (
          coordinateType_traits::create (i, f, this));

        if (!this->coordinateType_)
        {
          this->coordinateType_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SpatialCoordinate* SpatialCoordinate::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpatialCoordinate (*this, f, c);
  }

  SpatialCoordinate& SpatialCoordinate::
  operator= (const SpatialCoordinate& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_ = x.content_;
      this->coordinateType_ = x.coordinateType_;
    }

    return *this;
  }

  SpatialCoordinate::
  ~SpatialCoordinate ()
  {
  }

  // SpatialPoint
  //

  SpatialPoint::
  SpatialPoint ()
  : ::xml_schema::type (),
    xCoordinate_ (this),
    yCoordinate_ (this)
  {
  }

  SpatialPoint::
  SpatialPoint (const SpatialPoint& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    xCoordinate_ (x.xCoordinate_, f, this),
    yCoordinate_ (x.yCoordinate_, f, this)
  {
  }

  SpatialPoint::
  SpatialPoint (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    xCoordinate_ (this),
    yCoordinate_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SpatialPoint::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // xCoordinate
      //
      if (n.name () == "xCoordinate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< xCoordinate_type > r (
          xCoordinate_traits::create (i, f, this));

        if (!this->xCoordinate_)
        {
          this->xCoordinate_.set (::std::move (r));
          continue;
        }
      }

      // yCoordinate
      //
      if (n.name () == "yCoordinate" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< yCoordinate_type > r (
          yCoordinate_traits::create (i, f, this));

        if (!this->yCoordinate_)
        {
          this->yCoordinate_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SpatialPoint* SpatialPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpatialPoint (*this, f, c);
  }

  SpatialPoint& SpatialPoint::
  operator= (const SpatialPoint& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->xCoordinate_ = x.xCoordinate_;
      this->yCoordinate_ = x.yCoordinate_;
    }

    return *this;
  }

  SpatialPoint::
  ~SpatialPoint ()
  {
  }

  // Statistic
  //

  Statistic::
  Statistic ()
  : ::xml_schema::type (),
    computationBase_ (this),
    content_ (this),
    isWeighted_ (this),
    typeOfNumericValue_ (this)
  {
  }

  Statistic::
  Statistic (const Statistic& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    computationBase_ (x.computationBase_, f, this),
    content_ (x.content_, f, this),
    isWeighted_ (x.isWeighted_, f, this),
    typeOfNumericValue_ (x.typeOfNumericValue_, f, this)
  {
  }

  Statistic::
  Statistic (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    computationBase_ (this),
    content_ (this),
    isWeighted_ (this),
    typeOfNumericValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Statistic::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // computationBase
      //
      if (n.name () == "computationBase" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< computationBase_type > r (
          computationBase_traits::create (i, f, this));

        if (!this->computationBase_)
        {
          this->computationBase_.set (::std::move (r));
          continue;
        }
      }

      // content
      //
      if (n.name () == "content" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->content_)
        {
          this->content_.set (content_traits::create (i, f, this));
          continue;
        }
      }

      // isWeighted
      //
      if (n.name () == "isWeighted" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isWeighted_)
        {
          this->isWeighted_.set (isWeighted_traits::create (i, f, this));
          continue;
        }
      }

      // typeOfNumericValue
      //
      if (n.name () == "typeOfNumericValue" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< typeOfNumericValue_type > r (
          typeOfNumericValue_traits::create (i, f, this));

        if (!this->typeOfNumericValue_)
        {
          this->typeOfNumericValue_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Statistic* Statistic::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Statistic (*this, f, c);
  }

  Statistic& Statistic::
  operator= (const Statistic& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->computationBase_ = x.computationBase_;
      this->content_ = x.content_;
      this->isWeighted_ = x.isWeighted_;
      this->typeOfNumericValue_ = x.typeOfNumericValue_;
    }

    return *this;
  }

  Statistic::
  ~Statistic ()
  {
  }

  // StructureSpecification
  //

  StructureSpecification::
  StructureSpecification ()
  : ::xml_schema::type (),
    reflexive_ (this),
    symmetric_ (this),
    transitive_ (this)
  {
  }

  StructureSpecification::
  StructureSpecification (const StructureSpecification& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    reflexive_ (x.reflexive_, f, this),
    symmetric_ (x.symmetric_, f, this),
    transitive_ (x.transitive_, f, this)
  {
  }

  StructureSpecification::
  StructureSpecification (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    reflexive_ (this),
    symmetric_ (this),
    transitive_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void StructureSpecification::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // reflexive
      //
      if (n.name () == "reflexive" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< reflexive_type > r (
          reflexive_traits::create (i, f, this));

        if (!this->reflexive_)
        {
          this->reflexive_.set (::std::move (r));
          continue;
        }
      }

      // symmetric
      //
      if (n.name () == "symmetric" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< symmetric_type > r (
          symmetric_traits::create (i, f, this));

        if (!this->symmetric_)
        {
          this->symmetric_.set (::std::move (r));
          continue;
        }
      }

      // transitive
      //
      if (n.name () == "transitive" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< transitive_type > r (
          transitive_traits::create (i, f, this));

        if (!this->transitive_)
        {
          this->transitive_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  StructureSpecification* StructureSpecification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StructureSpecification (*this, f, c);
  }

  StructureSpecification& StructureSpecification::
  operator= (const StructureSpecification& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->reflexive_ = x.reflexive_;
      this->symmetric_ = x.symmetric_;
      this->transitive_ = x.transitive_;
    }

    return *this;
  }

  StructureSpecification::
  ~StructureSpecification ()
  {
  }

  // Telephone
  //

  Telephone::
  Telephone ()
  : ::xml_schema::type (),
    effectiveDates_ (this),
    isPreferred_ (this),
    privacy_ (this),
    telephoneNumber_ (this),
    typeOfTelephone_ (this)
  {
  }

  Telephone::
  Telephone (const Telephone& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    effectiveDates_ (x.effectiveDates_, f, this),
    isPreferred_ (x.isPreferred_, f, this),
    privacy_ (x.privacy_, f, this),
    telephoneNumber_ (x.telephoneNumber_, f, this),
    typeOfTelephone_ (x.typeOfTelephone_, f, this)
  {
  }

  Telephone::
  Telephone (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    effectiveDates_ (this),
    isPreferred_ (this),
    privacy_ (this),
    telephoneNumber_ (this),
    typeOfTelephone_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Telephone::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // effectiveDates
      //
      if (n.name () == "effectiveDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< effectiveDates_type > r (
          effectiveDates_traits::create (i, f, this));

        if (!this->effectiveDates_)
        {
          this->effectiveDates_.set (::std::move (r));
          continue;
        }
      }

      // isPreferred
      //
      if (n.name () == "isPreferred" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isPreferred_)
        {
          this->isPreferred_.set (isPreferred_traits::create (i, f, this));
          continue;
        }
      }

      // privacy
      //
      if (n.name () == "privacy" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< privacy_type > r (
          privacy_traits::create (i, f, this));

        if (!this->privacy_)
        {
          this->privacy_.set (::std::move (r));
          continue;
        }
      }

      // telephoneNumber
      //
      if (n.name () == "telephoneNumber" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< telephoneNumber_type > r (
          telephoneNumber_traits::create (i, f, this));

        if (!this->telephoneNumber_)
        {
          this->telephoneNumber_.set (::std::move (r));
          continue;
        }
      }

      // typeOfTelephone
      //
      if (n.name () == "typeOfTelephone" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< typeOfTelephone_type > r (
          typeOfTelephone_traits::create (i, f, this));

        if (!this->typeOfTelephone_)
        {
          this->typeOfTelephone_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Telephone* Telephone::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Telephone (*this, f, c);
  }

  Telephone& Telephone::
  operator= (const Telephone& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->effectiveDates_ = x.effectiveDates_;
      this->isPreferred_ = x.isPreferred_;
      this->privacy_ = x.privacy_;
      this->telephoneNumber_ = x.telephoneNumber_;
      this->typeOfTelephone_ = x.typeOfTelephone_;
    }

    return *this;
  }

  Telephone::
  ~Telephone ()
  {
  }

  // TextPositionSelector
  //

  TextPositionSelector::
  TextPositionSelector (const end_type& end,
                        const start_type& start)
  : ::XMLSchema::Selector (),
    end_ (end, this),
    start_ (start, this)
  {
  }

  TextPositionSelector::
  TextPositionSelector (const TextPositionSelector& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::Selector (x, f, c),
    end_ (x.end_, f, this),
    start_ (x.start_, f, this)
  {
  }

  TextPositionSelector::
  TextPositionSelector (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::Selector (e, f | ::xml_schema::flags::base, c),
    end_ (this),
    start_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TextPositionSelector::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // end
      //
      if (n.name () == "end" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!end_.present ())
        {
          this->end_.set (end_traits::create (i, f, this));
          continue;
        }
      }

      // start
      //
      if (n.name () == "start" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!start_.present ())
        {
          this->start_.set (start_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!end_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "end",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }

    if (!start_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "start",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  TextPositionSelector* TextPositionSelector::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TextPositionSelector (*this, f, c);
  }

  TextPositionSelector& TextPositionSelector::
  operator= (const TextPositionSelector& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::Selector& > (*this) = x;
      this->end_ = x.end_;
      this->start_ = x.start_;
    }

    return *this;
  }

  TextPositionSelector::
  ~TextPositionSelector ()
  {
  }

  // TimeRole
  //

  TimeRole::
  TimeRole ()
  : ::XMLSchema::SpecializationRole (),
    time_ (this)
  {
  }

  TimeRole::
  TimeRole (const TimeRole& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::XMLSchema::SpecializationRole (x, f, c),
    time_ (x.time_, f, this)
  {
  }

  TimeRole::
  TimeRole (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::XMLSchema::SpecializationRole (e, f | ::xml_schema::flags::base, c),
    time_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TimeRole::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // time
      //
      if (n.name () == "time" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< time_type > r (
          time_traits::create (i, f, this));

        if (!this->time_)
        {
          this->time_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  TimeRole* TimeRole::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TimeRole (*this, f, c);
  }

  TimeRole& TimeRole::
  operator= (const TimeRole& x)
  {
    if (this != &x)
    {
      static_cast< ::XMLSchema::SpecializationRole& > (*this) = x;
      this->time_ = x.time_;
    }

    return *this;
  }

  TimeRole::
  ~TimeRole ()
  {
  }

  // TypedString
  //

  TypedString::
  TypedString (const content_type& content)
  : ::xml_schema::type (),
    content_ (content, this),
    typeOfContent_ (this)
  {
  }

  TypedString::
  TypedString (const TypedString& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_ (x.content_, f, this),
    typeOfContent_ (x.typeOfContent_, f, this)
  {
  }

  TypedString::
  TypedString (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    content_ (this),
    typeOfContent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TypedString::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // content
      //
      if (n.name () == "content" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< content_type > r (
          content_traits::create (i, f, this));

        if (!content_.present ())
        {
          this->content_.set (::std::move (r));
          continue;
        }
      }

      // typeOfContent
      //
      if (n.name () == "typeOfContent" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< typeOfContent_type > r (
          typeOfContent_traits::create (i, f, this));

        if (!this->typeOfContent_)
        {
          this->typeOfContent_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!content_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "content",
        "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
    }
  }

  TypedString* TypedString::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TypedString (*this, f, c);
  }

  TypedString& TypedString::
  operator= (const TypedString& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_ = x.content_;
      this->typeOfContent_ = x.typeOfContent_;
    }

    return *this;
  }

  TypedString::
  ~TypedString ()
  {
  }

  // WebLink
  //

  WebLink::
  WebLink ()
  : ::xml_schema::type (),
    effectiveDates_ (this),
    isPreferred_ (this),
    privacy_ (this),
    typeOfWebsite_ (this),
    uri_ (this)
  {
  }

  WebLink::
  WebLink (const WebLink& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    effectiveDates_ (x.effectiveDates_, f, this),
    isPreferred_ (x.isPreferred_, f, this),
    privacy_ (x.privacy_, f, this),
    typeOfWebsite_ (x.typeOfWebsite_, f, this),
    uri_ (x.uri_, f, this)
  {
  }

  WebLink::
  WebLink (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    effectiveDates_ (this),
    isPreferred_ (this),
    privacy_ (this),
    typeOfWebsite_ (this),
    uri_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void WebLink::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // effectiveDates
      //
      if (n.name () == "effectiveDates" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< effectiveDates_type > r (
          effectiveDates_traits::create (i, f, this));

        if (!this->effectiveDates_)
        {
          this->effectiveDates_.set (::std::move (r));
          continue;
        }
      }

      // isPreferred
      //
      if (n.name () == "isPreferred" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        if (!this->isPreferred_)
        {
          this->isPreferred_.set (isPreferred_traits::create (i, f, this));
          continue;
        }
      }

      // privacy
      //
      if (n.name () == "privacy" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< privacy_type > r (
          privacy_traits::create (i, f, this));

        if (!this->privacy_)
        {
          this->privacy_.set (::std::move (r));
          continue;
        }
      }

      // typeOfWebsite
      //
      if (n.name () == "typeOfWebsite" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< typeOfWebsite_type > r (
          typeOfWebsite_traits::create (i, f, this));

        if (!this->typeOfWebsite_)
        {
          this->typeOfWebsite_.set (::std::move (r));
          continue;
        }
      }

      // uri
      //
      if (n.name () == "uri" && n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
      {
        ::std::unique_ptr< uri_type > r (
          uri_traits::create (i, f, this));

        if (!this->uri_)
        {
          this->uri_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  WebLink* WebLink::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class WebLink (*this, f, c);
  }

  WebLink& WebLink::
  operator= (const WebLink& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->effectiveDates_ = x.effectiveDates_;
      this->isPreferred_ = x.isPreferred_;
      this->privacy_ = x.privacy_;
      this->typeOfWebsite_ = x.typeOfWebsite_;
      this->uri_ = x.uri_;
    }

    return *this;
  }

  WebLink::
  ~WebLink ()
  {
  }

  // entityProduced
  //

  entityProduced::
  entityProduced ()
  : ::XMLSchema::Reference ()
  {
  }

  entityProduced::
  entityProduced (const entityProduced& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  entityProduced::
  entityProduced (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  entityProduced* entityProduced::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class entityProduced (*this, f, c);
  }

  entityProduced::
  ~entityProduced ()
  {
  }

  // entityUsed
  //

  entityUsed::
  entityUsed ()
  : ::XMLSchema::Reference ()
  {
  }

  entityUsed::
  entityUsed (const entityUsed& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  entityUsed::
  entityUsed (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  entityUsed* entityUsed::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class entityUsed (*this, f, c);
  }

  entityUsed::
  ~entityUsed ()
  {
  }

  // standardModelMapping
  //

  standardModelMapping::
  standardModelMapping ()
  : ::XMLSchema::Reference ()
  {
  }

  standardModelMapping::
  standardModelMapping (const standardModelMapping& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  standardModelMapping::
  standardModelMapping (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  standardModelMapping* standardModelMapping::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class standardModelMapping (*this, f, c);
  }

  standardModelMapping::
  ~standardModelMapping ()
  {
  }

  // Activity_hasInternal_ControlLogic
  //

  Activity_hasInternal_ControlLogic::
  Activity_hasInternal_ControlLogic ()
  : ::XMLSchema::Reference ()
  {
  }

  Activity_hasInternal_ControlLogic::
  Activity_hasInternal_ControlLogic (const Activity_hasInternal_ControlLogic& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Activity_hasInternal_ControlLogic::
  Activity_hasInternal_ControlLogic (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Activity_hasInternal_ControlLogic* Activity_hasInternal_ControlLogic::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Activity_hasInternal_ControlLogic (*this, f, c);
  }

  Activity_hasInternal_ControlLogic::
  ~Activity_hasInternal_ControlLogic ()
  {
  }

  // Activity_hasSubActivity_Activity
  //

  Activity_hasSubActivity_Activity::
  Activity_hasSubActivity_Activity ()
  : ::XMLSchema::Reference ()
  {
  }

  Activity_hasSubActivity_Activity::
  Activity_hasSubActivity_Activity (const Activity_hasSubActivity_Activity& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Activity_hasSubActivity_Activity::
  Activity_hasSubActivity_Activity (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Activity_hasSubActivity_Activity* Activity_hasSubActivity_Activity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Activity_hasSubActivity_Activity (*this, f, c);
  }

  Activity_hasSubActivity_Activity::
  ~Activity_hasSubActivity_Activity ()
  {
  }

  // Activity_has_Step
  //

  Activity_has_Step::
  Activity_has_Step ()
  : ::XMLSchema::Reference ()
  {
  }

  Activity_has_Step::
  Activity_has_Step (const Activity_has_Step& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Activity_has_Step::
  Activity_has_Step (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Activity_has_Step* Activity_has_Step::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Activity_has_Step (*this, f, c);
  }

  Activity_has_Step::
  ~Activity_has_Step ()
  {
  }

  // AgentListing_isDefinedBy_Concept
  //

  AgentListing_isDefinedBy_Concept::
  AgentListing_isDefinedBy_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  AgentListing_isDefinedBy_Concept::
  AgentListing_isDefinedBy_Concept (const AgentListing_isDefinedBy_Concept& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  AgentListing_isDefinedBy_Concept::
  AgentListing_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  AgentListing_isDefinedBy_Concept* AgentListing_isDefinedBy_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentListing_isDefinedBy_Concept (*this, f, c);
  }

  AgentListing_isDefinedBy_Concept::
  ~AgentListing_isDefinedBy_Concept ()
  {
  }

  // AgentListing_isMaintainedBy_Agent
  //

  AgentListing_isMaintainedBy_Agent::
  AgentListing_isMaintainedBy_Agent ()
  : ::XMLSchema::Reference ()
  {
  }

  AgentListing_isMaintainedBy_Agent::
  AgentListing_isMaintainedBy_Agent (const AgentListing_isMaintainedBy_Agent& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  AgentListing_isMaintainedBy_Agent::
  AgentListing_isMaintainedBy_Agent (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  AgentListing_isMaintainedBy_Agent* AgentListing_isMaintainedBy_Agent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentListing_isMaintainedBy_Agent (*this, f, c);
  }

  AgentListing_isMaintainedBy_Agent::
  ~AgentListing_isMaintainedBy_Agent ()
  {
  }

  // AgentListing_has_AgentPosition
  //

  AgentListing_has_AgentPosition::
  AgentListing_has_AgentPosition ()
  : ::XMLSchema::Reference ()
  {
  }

  AgentListing_has_AgentPosition::
  AgentListing_has_AgentPosition (const AgentListing_has_AgentPosition& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  AgentListing_has_AgentPosition::
  AgentListing_has_AgentPosition (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  AgentListing_has_AgentPosition* AgentListing_has_AgentPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentListing_has_AgentPosition (*this, f, c);
  }

  AgentListing_has_AgentPosition::
  ~AgentListing_has_AgentPosition ()
  {
  }

  // AgentListing_has_Agent
  //

  AgentListing_has_Agent::
  AgentListing_has_Agent ()
  : ::XMLSchema::Reference ()
  {
  }

  AgentListing_has_Agent::
  AgentListing_has_Agent (const AgentListing_has_Agent& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  AgentListing_has_Agent::
  AgentListing_has_Agent (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  AgentListing_has_Agent* AgentListing_has_Agent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentListing_has_Agent (*this, f, c);
  }

  AgentListing_has_Agent::
  ~AgentListing_has_Agent ()
  {
  }

  // AgentPosition_indexes_Agent
  //

  AgentPosition_indexes_Agent::
  AgentPosition_indexes_Agent ()
  : ::XMLSchema::Reference ()
  {
  }

  AgentPosition_indexes_Agent::
  AgentPosition_indexes_Agent (const AgentPosition_indexes_Agent& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  AgentPosition_indexes_Agent::
  AgentPosition_indexes_Agent (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  AgentPosition_indexes_Agent* AgentPosition_indexes_Agent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentPosition_indexes_Agent (*this, f, c);
  }

  AgentPosition_indexes_Agent::
  ~AgentPosition_indexes_Agent ()
  {
  }

  // AgentRelationship_hasSource_Agent
  //

  AgentRelationship_hasSource_Agent::
  AgentRelationship_hasSource_Agent ()
  : ::XMLSchema::Reference ()
  {
  }

  AgentRelationship_hasSource_Agent::
  AgentRelationship_hasSource_Agent (const AgentRelationship_hasSource_Agent& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  AgentRelationship_hasSource_Agent::
  AgentRelationship_hasSource_Agent (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  AgentRelationship_hasSource_Agent* AgentRelationship_hasSource_Agent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentRelationship_hasSource_Agent (*this, f, c);
  }

  AgentRelationship_hasSource_Agent::
  ~AgentRelationship_hasSource_Agent ()
  {
  }

  // AgentRelationship_hasTarget_Agent
  //

  AgentRelationship_hasTarget_Agent::
  AgentRelationship_hasTarget_Agent ()
  : ::XMLSchema::Reference ()
  {
  }

  AgentRelationship_hasTarget_Agent::
  AgentRelationship_hasTarget_Agent (const AgentRelationship_hasTarget_Agent& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  AgentRelationship_hasTarget_Agent::
  AgentRelationship_hasTarget_Agent (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  AgentRelationship_hasTarget_Agent* AgentRelationship_hasTarget_Agent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentRelationship_hasTarget_Agent (*this, f, c);
  }

  AgentRelationship_hasTarget_Agent::
  ~AgentRelationship_hasTarget_Agent ()
  {
  }

  // AgentStructure_structures_AgentListing
  //

  AgentStructure_structures_AgentListing::
  AgentStructure_structures_AgentListing ()
  : ::XMLSchema::Reference ()
  {
  }

  AgentStructure_structures_AgentListing::
  AgentStructure_structures_AgentListing (const AgentStructure_structures_AgentListing& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  AgentStructure_structures_AgentListing::
  AgentStructure_structures_AgentListing (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  AgentStructure_structures_AgentListing* AgentStructure_structures_AgentListing::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentStructure_structures_AgentListing (*this, f, c);
  }

  AgentStructure_structures_AgentListing::
  ~AgentStructure_structures_AgentListing ()
  {
  }

  // AgentStructure_has_AgentRelationship
  //

  AgentStructure_has_AgentRelationship::
  AgentStructure_has_AgentRelationship ()
  : ::XMLSchema::Reference ()
  {
  }

  AgentStructure_has_AgentRelationship::
  AgentStructure_has_AgentRelationship (const AgentStructure_has_AgentRelationship& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  AgentStructure_has_AgentRelationship::
  AgentStructure_has_AgentRelationship (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  AgentStructure_has_AgentRelationship* AgentStructure_has_AgentRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AgentStructure_has_AgentRelationship (*this, f, c);
  }

  AgentStructure_has_AgentRelationship::
  ~AgentStructure_has_AgentRelationship ()
  {
  }

  // AttributeComponent_qualifies_DataStructureComponent
  //

  AttributeComponent_qualifies_DataStructureComponent::
  AttributeComponent_qualifies_DataStructureComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  AttributeComponent_qualifies_DataStructureComponent::
  AttributeComponent_qualifies_DataStructureComponent (const AttributeComponent_qualifies_DataStructureComponent& x,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  AttributeComponent_qualifies_DataStructureComponent::
  AttributeComponent_qualifies_DataStructureComponent (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  AttributeComponent_qualifies_DataStructureComponent* AttributeComponent_qualifies_DataStructureComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AttributeComponent_qualifies_DataStructureComponent (*this, f, c);
  }

  AttributeComponent_qualifies_DataStructureComponent::
  ~AttributeComponent_qualifies_DataStructureComponent ()
  {
  }

  // AuthorizationSource_has_Agent
  //

  AuthorizationSource_has_Agent::
  AuthorizationSource_has_Agent ()
  : ::XMLSchema::Reference ()
  {
  }

  AuthorizationSource_has_Agent::
  AuthorizationSource_has_Agent (const AuthorizationSource_has_Agent& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  AuthorizationSource_has_Agent::
  AuthorizationSource_has_Agent (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  AuthorizationSource_has_Agent* AuthorizationSource_has_Agent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AuthorizationSource_has_Agent (*this, f, c);
  }

  AuthorizationSource_has_Agent::
  ~AuthorizationSource_has_Agent ()
  {
  }

  // CategoryPosition_indexes_Category
  //

  CategoryPosition_indexes_Category::
  CategoryPosition_indexes_Category ()
  : ::XMLSchema::Reference ()
  {
  }

  CategoryPosition_indexes_Category::
  CategoryPosition_indexes_Category (const CategoryPosition_indexes_Category& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CategoryPosition_indexes_Category::
  CategoryPosition_indexes_Category (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CategoryPosition_indexes_Category* CategoryPosition_indexes_Category::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategoryPosition_indexes_Category (*this, f, c);
  }

  CategoryPosition_indexes_Category::
  ~CategoryPosition_indexes_Category ()
  {
  }

  // CategoryRelationStructure_structures_CategorySet
  //

  CategoryRelationStructure_structures_CategorySet::
  CategoryRelationStructure_structures_CategorySet ()
  : ::XMLSchema::Reference ()
  {
  }

  CategoryRelationStructure_structures_CategorySet::
  CategoryRelationStructure_structures_CategorySet (const CategoryRelationStructure_structures_CategorySet& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CategoryRelationStructure_structures_CategorySet::
  CategoryRelationStructure_structures_CategorySet (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CategoryRelationStructure_structures_CategorySet* CategoryRelationStructure_structures_CategorySet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategoryRelationStructure_structures_CategorySet (*this, f, c);
  }

  CategoryRelationStructure_structures_CategorySet::
  ~CategoryRelationStructure_structures_CategorySet ()
  {
  }

  // CategoryRelationStructure_has_CategoryRelationship
  //

  CategoryRelationStructure_has_CategoryRelationship::
  CategoryRelationStructure_has_CategoryRelationship ()
  : ::XMLSchema::Reference ()
  {
  }

  CategoryRelationStructure_has_CategoryRelationship::
  CategoryRelationStructure_has_CategoryRelationship (const CategoryRelationStructure_has_CategoryRelationship& x,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CategoryRelationStructure_has_CategoryRelationship::
  CategoryRelationStructure_has_CategoryRelationship (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CategoryRelationStructure_has_CategoryRelationship* CategoryRelationStructure_has_CategoryRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategoryRelationStructure_has_CategoryRelationship (*this, f, c);
  }

  CategoryRelationStructure_has_CategoryRelationship::
  ~CategoryRelationStructure_has_CategoryRelationship ()
  {
  }

  // CategoryRelationship_hasSource_Category
  //

  CategoryRelationship_hasSource_Category::
  CategoryRelationship_hasSource_Category ()
  : ::XMLSchema::Reference ()
  {
  }

  CategoryRelationship_hasSource_Category::
  CategoryRelationship_hasSource_Category (const CategoryRelationship_hasSource_Category& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CategoryRelationship_hasSource_Category::
  CategoryRelationship_hasSource_Category (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CategoryRelationship_hasSource_Category* CategoryRelationship_hasSource_Category::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategoryRelationship_hasSource_Category (*this, f, c);
  }

  CategoryRelationship_hasSource_Category::
  ~CategoryRelationship_hasSource_Category ()
  {
  }

  // CategoryRelationship_hasTarget_Category
  //

  CategoryRelationship_hasTarget_Category::
  CategoryRelationship_hasTarget_Category ()
  : ::XMLSchema::Reference ()
  {
  }

  CategoryRelationship_hasTarget_Category::
  CategoryRelationship_hasTarget_Category (const CategoryRelationship_hasTarget_Category& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CategoryRelationship_hasTarget_Category::
  CategoryRelationship_hasTarget_Category (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CategoryRelationship_hasTarget_Category* CategoryRelationship_hasTarget_Category::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategoryRelationship_hasTarget_Category (*this, f, c);
  }

  CategoryRelationship_hasTarget_Category::
  ~CategoryRelationship_hasTarget_Category ()
  {
  }

  // CategorySet_has_Category
  //

  CategorySet_has_Category::
  CategorySet_has_Category ()
  : ::XMLSchema::Reference ()
  {
  }

  CategorySet_has_Category::
  CategorySet_has_Category (const CategorySet_has_Category& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CategorySet_has_Category::
  CategorySet_has_Category (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CategorySet_has_Category* CategorySet_has_Category::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategorySet_has_Category (*this, f, c);
  }

  CategorySet_has_Category::
  ~CategorySet_has_Category ()
  {
  }

  // CategorySet_has_CategoryPosition
  //

  CategorySet_has_CategoryPosition::
  CategorySet_has_CategoryPosition ()
  : ::XMLSchema::Reference ()
  {
  }

  CategorySet_has_CategoryPosition::
  CategorySet_has_CategoryPosition (const CategorySet_has_CategoryPosition& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CategorySet_has_CategoryPosition::
  CategorySet_has_CategoryPosition (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CategorySet_has_CategoryPosition* CategorySet_has_CategoryPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategorySet_has_CategoryPosition (*this, f, c);
  }

  CategorySet_has_CategoryPosition::
  ~CategorySet_has_CategoryPosition ()
  {
  }

  // CategoryStatistic_appliesTo_InstanceVariable
  //

  CategoryStatistic_appliesTo_InstanceVariable::
  CategoryStatistic_appliesTo_InstanceVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  CategoryStatistic_appliesTo_InstanceVariable::
  CategoryStatistic_appliesTo_InstanceVariable (const CategoryStatistic_appliesTo_InstanceVariable& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CategoryStatistic_appliesTo_InstanceVariable::
  CategoryStatistic_appliesTo_InstanceVariable (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CategoryStatistic_appliesTo_InstanceVariable* CategoryStatistic_appliesTo_InstanceVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategoryStatistic_appliesTo_InstanceVariable (*this, f, c);
  }

  CategoryStatistic_appliesTo_InstanceVariable::
  ~CategoryStatistic_appliesTo_InstanceVariable ()
  {
  }

  // CategoryStatistic_for_Category
  //

  CategoryStatistic_for_Category::
  CategoryStatistic_for_Category ()
  : ::XMLSchema::Reference ()
  {
  }

  CategoryStatistic_for_Category::
  CategoryStatistic_for_Category (const CategoryStatistic_for_Category& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CategoryStatistic_for_Category::
  CategoryStatistic_for_Category (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CategoryStatistic_for_Category* CategoryStatistic_for_Category::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CategoryStatistic_for_Category (*this, f, c);
  }

  CategoryStatistic_for_Category::
  ~CategoryStatistic_for_Category ()
  {
  }

  // ClassificationFamily_uses_ClassificationIndex
  //

  ClassificationFamily_uses_ClassificationIndex::
  ClassificationFamily_uses_ClassificationIndex ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationFamily_uses_ClassificationIndex::
  ClassificationFamily_uses_ClassificationIndex (const ClassificationFamily_uses_ClassificationIndex& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationFamily_uses_ClassificationIndex::
  ClassificationFamily_uses_ClassificationIndex (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationFamily_uses_ClassificationIndex* ClassificationFamily_uses_ClassificationIndex::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationFamily_uses_ClassificationIndex (*this, f, c);
  }

  ClassificationFamily_uses_ClassificationIndex::
  ~ClassificationFamily_uses_ClassificationIndex ()
  {
  }

  // ClassificationFamily_isDefinedBy_Concept
  //

  ClassificationFamily_isDefinedBy_Concept::
  ClassificationFamily_isDefinedBy_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationFamily_isDefinedBy_Concept::
  ClassificationFamily_isDefinedBy_Concept (const ClassificationFamily_isDefinedBy_Concept& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationFamily_isDefinedBy_Concept::
  ClassificationFamily_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationFamily_isDefinedBy_Concept* ClassificationFamily_isDefinedBy_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationFamily_isDefinedBy_Concept (*this, f, c);
  }

  ClassificationFamily_isDefinedBy_Concept::
  ~ClassificationFamily_isDefinedBy_Concept ()
  {
  }

  // ClassificationFamily_groups_ClassificationSeries
  //

  ClassificationFamily_groups_ClassificationSeries::
  ClassificationFamily_groups_ClassificationSeries ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationFamily_groups_ClassificationSeries::
  ClassificationFamily_groups_ClassificationSeries (const ClassificationFamily_groups_ClassificationSeries& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationFamily_groups_ClassificationSeries::
  ClassificationFamily_groups_ClassificationSeries (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationFamily_groups_ClassificationSeries* ClassificationFamily_groups_ClassificationSeries::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationFamily_groups_ClassificationSeries (*this, f, c);
  }

  ClassificationFamily_groups_ClassificationSeries::
  ~ClassificationFamily_groups_ClassificationSeries ()
  {
  }

  // ClassificationIndex_isMaintainedBy_Agent
  //

  ClassificationIndex_isMaintainedBy_Agent::
  ClassificationIndex_isMaintainedBy_Agent ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationIndex_isMaintainedBy_Agent::
  ClassificationIndex_isMaintainedBy_Agent (const ClassificationIndex_isMaintainedBy_Agent& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationIndex_isMaintainedBy_Agent::
  ClassificationIndex_isMaintainedBy_Agent (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationIndex_isMaintainedBy_Agent* ClassificationIndex_isMaintainedBy_Agent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationIndex_isMaintainedBy_Agent (*this, f, c);
  }

  ClassificationIndex_isMaintainedBy_Agent::
  ~ClassificationIndex_isMaintainedBy_Agent ()
  {
  }

  // ClassificationIndex_hasContact_Agent
  //

  ClassificationIndex_hasContact_Agent::
  ClassificationIndex_hasContact_Agent ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationIndex_hasContact_Agent::
  ClassificationIndex_hasContact_Agent (const ClassificationIndex_hasContact_Agent& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationIndex_hasContact_Agent::
  ClassificationIndex_hasContact_Agent (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationIndex_hasContact_Agent* ClassificationIndex_hasContact_Agent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationIndex_hasContact_Agent (*this, f, c);
  }

  ClassificationIndex_hasContact_Agent::
  ~ClassificationIndex_hasContact_Agent ()
  {
  }

  // ClassificationIndex_isDefinedBy_Concept
  //

  ClassificationIndex_isDefinedBy_Concept::
  ClassificationIndex_isDefinedBy_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationIndex_isDefinedBy_Concept::
  ClassificationIndex_isDefinedBy_Concept (const ClassificationIndex_isDefinedBy_Concept& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationIndex_isDefinedBy_Concept::
  ClassificationIndex_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationIndex_isDefinedBy_Concept* ClassificationIndex_isDefinedBy_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationIndex_isDefinedBy_Concept (*this, f, c);
  }

  ClassificationIndex_isDefinedBy_Concept::
  ~ClassificationIndex_isDefinedBy_Concept ()
  {
  }

  // ClassificationIndex_has_ClassificationIndexEntryPosition
  //

  ClassificationIndex_has_ClassificationIndexEntryPosition::
  ClassificationIndex_has_ClassificationIndexEntryPosition ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationIndex_has_ClassificationIndexEntryPosition::
  ClassificationIndex_has_ClassificationIndexEntryPosition (const ClassificationIndex_has_ClassificationIndexEntryPosition& x,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationIndex_has_ClassificationIndexEntryPosition::
  ClassificationIndex_has_ClassificationIndexEntryPosition (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationIndex_has_ClassificationIndexEntryPosition* ClassificationIndex_has_ClassificationIndexEntryPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationIndex_has_ClassificationIndexEntryPosition (*this, f, c);
  }

  ClassificationIndex_has_ClassificationIndexEntryPosition::
  ~ClassificationIndex_has_ClassificationIndexEntryPosition ()
  {
  }

  // ClassificationIndex_has_ClassificationIndexEntry
  //

  ClassificationIndex_has_ClassificationIndexEntry::
  ClassificationIndex_has_ClassificationIndexEntry ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationIndex_has_ClassificationIndexEntry::
  ClassificationIndex_has_ClassificationIndexEntry (const ClassificationIndex_has_ClassificationIndexEntry& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationIndex_has_ClassificationIndexEntry::
  ClassificationIndex_has_ClassificationIndexEntry (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationIndex_has_ClassificationIndexEntry* ClassificationIndex_has_ClassificationIndexEntry::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationIndex_has_ClassificationIndexEntry (*this, f, c);
  }

  ClassificationIndex_has_ClassificationIndexEntry::
  ~ClassificationIndex_has_ClassificationIndexEntry ()
  {
  }

  // ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry
  //

  ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry::
  ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry::
  ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry (const ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry& x,
                                                                     ::xml_schema::flags f,
                                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry::
  ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry (const ::xercesc::DOMElement& e,
                                                                     ::xml_schema::flags f,
                                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry* ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry (*this, f, c);
  }

  ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry::
  ~ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry ()
  {
  }

  // ClassificationItem_excludes_ClassificationItem
  //

  ClassificationItem_excludes_ClassificationItem::
  ClassificationItem_excludes_ClassificationItem ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationItem_excludes_ClassificationItem::
  ClassificationItem_excludes_ClassificationItem (const ClassificationItem_excludes_ClassificationItem& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationItem_excludes_ClassificationItem::
  ClassificationItem_excludes_ClassificationItem (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationItem_excludes_ClassificationItem* ClassificationItem_excludes_ClassificationItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationItem_excludes_ClassificationItem (*this, f, c);
  }

  ClassificationItem_excludes_ClassificationItem::
  ~ClassificationItem_excludes_ClassificationItem ()
  {
  }

  // ClassificationItem_denotes_Category
  //

  ClassificationItem_denotes_Category::
  ClassificationItem_denotes_Category ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationItem_denotes_Category::
  ClassificationItem_denotes_Category (const ClassificationItem_denotes_Category& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationItem_denotes_Category::
  ClassificationItem_denotes_Category (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationItem_denotes_Category* ClassificationItem_denotes_Category::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationItem_denotes_Category (*this, f, c);
  }

  ClassificationItem_denotes_Category::
  ~ClassificationItem_denotes_Category ()
  {
  }

  // ClassificationItem_uses_Notation
  //

  ClassificationItem_uses_Notation::
  ClassificationItem_uses_Notation ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationItem_uses_Notation::
  ClassificationItem_uses_Notation (const ClassificationItem_uses_Notation& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationItem_uses_Notation::
  ClassificationItem_uses_Notation (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationItem_uses_Notation* ClassificationItem_uses_Notation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationItem_uses_Notation (*this, f, c);
  }

  ClassificationItem_uses_Notation::
  ~ClassificationItem_uses_Notation ()
  {
  }

  // ClassificationItem_hasRulingBy_AuthorizationSource
  //

  ClassificationItem_hasRulingBy_AuthorizationSource::
  ClassificationItem_hasRulingBy_AuthorizationSource ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationItem_hasRulingBy_AuthorizationSource::
  ClassificationItem_hasRulingBy_AuthorizationSource (const ClassificationItem_hasRulingBy_AuthorizationSource& x,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationItem_hasRulingBy_AuthorizationSource::
  ClassificationItem_hasRulingBy_AuthorizationSource (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationItem_hasRulingBy_AuthorizationSource* ClassificationItem_hasRulingBy_AuthorizationSource::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationItem_hasRulingBy_AuthorizationSource (*this, f, c);
  }

  ClassificationItem_hasRulingBy_AuthorizationSource::
  ~ClassificationItem_hasRulingBy_AuthorizationSource ()
  {
  }

  // ClassificationItemPosition_indexes_ClassificationItem
  //

  ClassificationItemPosition_indexes_ClassificationItem::
  ClassificationItemPosition_indexes_ClassificationItem ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationItemPosition_indexes_ClassificationItem::
  ClassificationItemPosition_indexes_ClassificationItem (const ClassificationItemPosition_indexes_ClassificationItem& x,
                                                         ::xml_schema::flags f,
                                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationItemPosition_indexes_ClassificationItem::
  ClassificationItemPosition_indexes_ClassificationItem (const ::xercesc::DOMElement& e,
                                                         ::xml_schema::flags f,
                                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationItemPosition_indexes_ClassificationItem* ClassificationItemPosition_indexes_ClassificationItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationItemPosition_indexes_ClassificationItem (*this, f, c);
  }

  ClassificationItemPosition_indexes_ClassificationItem::
  ~ClassificationItemPosition_indexes_ClassificationItem ()
  {
  }

  // ClassificationItemRelationship_hasSource_ClassificationItem
  //

  ClassificationItemRelationship_hasSource_ClassificationItem::
  ClassificationItemRelationship_hasSource_ClassificationItem ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationItemRelationship_hasSource_ClassificationItem::
  ClassificationItemRelationship_hasSource_ClassificationItem (const ClassificationItemRelationship_hasSource_ClassificationItem& x,
                                                               ::xml_schema::flags f,
                                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationItemRelationship_hasSource_ClassificationItem::
  ClassificationItemRelationship_hasSource_ClassificationItem (const ::xercesc::DOMElement& e,
                                                               ::xml_schema::flags f,
                                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationItemRelationship_hasSource_ClassificationItem* ClassificationItemRelationship_hasSource_ClassificationItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationItemRelationship_hasSource_ClassificationItem (*this, f, c);
  }

  ClassificationItemRelationship_hasSource_ClassificationItem::
  ~ClassificationItemRelationship_hasSource_ClassificationItem ()
  {
  }

  // ClassificationItemRelationship_hasTarget_ClassificationItem
  //

  ClassificationItemRelationship_hasTarget_ClassificationItem::
  ClassificationItemRelationship_hasTarget_ClassificationItem ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationItemRelationship_hasTarget_ClassificationItem::
  ClassificationItemRelationship_hasTarget_ClassificationItem (const ClassificationItemRelationship_hasTarget_ClassificationItem& x,
                                                               ::xml_schema::flags f,
                                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationItemRelationship_hasTarget_ClassificationItem::
  ClassificationItemRelationship_hasTarget_ClassificationItem (const ::xercesc::DOMElement& e,
                                                               ::xml_schema::flags f,
                                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationItemRelationship_hasTarget_ClassificationItem* ClassificationItemRelationship_hasTarget_ClassificationItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationItemRelationship_hasTarget_ClassificationItem (*this, f, c);
  }

  ClassificationItemRelationship_hasTarget_ClassificationItem::
  ~ClassificationItemRelationship_hasTarget_ClassificationItem ()
  {
  }

  // ClassificationItemStructure_structures_StatisticalClassification
  //

  ClassificationItemStructure_structures_StatisticalClassification::
  ClassificationItemStructure_structures_StatisticalClassification ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationItemStructure_structures_StatisticalClassification::
  ClassificationItemStructure_structures_StatisticalClassification (const ClassificationItemStructure_structures_StatisticalClassification& x,
                                                                    ::xml_schema::flags f,
                                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationItemStructure_structures_StatisticalClassification::
  ClassificationItemStructure_structures_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                                    ::xml_schema::flags f,
                                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationItemStructure_structures_StatisticalClassification* ClassificationItemStructure_structures_StatisticalClassification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationItemStructure_structures_StatisticalClassification (*this, f, c);
  }

  ClassificationItemStructure_structures_StatisticalClassification::
  ~ClassificationItemStructure_structures_StatisticalClassification ()
  {
  }

  // ClassificationItemStructure_has_ClassificationItemRelationship
  //

  ClassificationItemStructure_has_ClassificationItemRelationship::
  ClassificationItemStructure_has_ClassificationItemRelationship ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationItemStructure_has_ClassificationItemRelationship::
  ClassificationItemStructure_has_ClassificationItemRelationship (const ClassificationItemStructure_has_ClassificationItemRelationship& x,
                                                                  ::xml_schema::flags f,
                                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationItemStructure_has_ClassificationItemRelationship::
  ClassificationItemStructure_has_ClassificationItemRelationship (const ::xercesc::DOMElement& e,
                                                                  ::xml_schema::flags f,
                                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationItemStructure_has_ClassificationItemRelationship* ClassificationItemStructure_has_ClassificationItemRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationItemStructure_has_ClassificationItemRelationship (*this, f, c);
  }

  ClassificationItemStructure_has_ClassificationItemRelationship::
  ~ClassificationItemStructure_has_ClassificationItemRelationship ()
  {
  }

  // ClassificationPosition_indexes_StatisticalClassification
  //

  ClassificationPosition_indexes_StatisticalClassification::
  ClassificationPosition_indexes_StatisticalClassification ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationPosition_indexes_StatisticalClassification::
  ClassificationPosition_indexes_StatisticalClassification (const ClassificationPosition_indexes_StatisticalClassification& x,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationPosition_indexes_StatisticalClassification::
  ClassificationPosition_indexes_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationPosition_indexes_StatisticalClassification* ClassificationPosition_indexes_StatisticalClassification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationPosition_indexes_StatisticalClassification (*this, f, c);
  }

  ClassificationPosition_indexes_StatisticalClassification::
  ~ClassificationPosition_indexes_StatisticalClassification ()
  {
  }

  // ClassificationSeries_isOwnedBy_Agent
  //

  ClassificationSeries_isOwnedBy_Agent::
  ClassificationSeries_isOwnedBy_Agent ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationSeries_isOwnedBy_Agent::
  ClassificationSeries_isOwnedBy_Agent (const ClassificationSeries_isOwnedBy_Agent& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationSeries_isOwnedBy_Agent::
  ClassificationSeries_isOwnedBy_Agent (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationSeries_isOwnedBy_Agent* ClassificationSeries_isOwnedBy_Agent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationSeries_isOwnedBy_Agent (*this, f, c);
  }

  ClassificationSeries_isOwnedBy_Agent::
  ~ClassificationSeries_isOwnedBy_Agent ()
  {
  }

  // ClassificationSeries_isDefinedBy_Concept
  //

  ClassificationSeries_isDefinedBy_Concept::
  ClassificationSeries_isDefinedBy_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationSeries_isDefinedBy_Concept::
  ClassificationSeries_isDefinedBy_Concept (const ClassificationSeries_isDefinedBy_Concept& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationSeries_isDefinedBy_Concept::
  ClassificationSeries_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationSeries_isDefinedBy_Concept* ClassificationSeries_isDefinedBy_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationSeries_isDefinedBy_Concept (*this, f, c);
  }

  ClassificationSeries_isDefinedBy_Concept::
  ~ClassificationSeries_isDefinedBy_Concept ()
  {
  }

  // ClassificationSeries_has_StatisticalClassification
  //

  ClassificationSeries_has_StatisticalClassification::
  ClassificationSeries_has_StatisticalClassification ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationSeries_has_StatisticalClassification::
  ClassificationSeries_has_StatisticalClassification (const ClassificationSeries_has_StatisticalClassification& x,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationSeries_has_StatisticalClassification::
  ClassificationSeries_has_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationSeries_has_StatisticalClassification* ClassificationSeries_has_StatisticalClassification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationSeries_has_StatisticalClassification (*this, f, c);
  }

  ClassificationSeries_has_StatisticalClassification::
  ~ClassificationSeries_has_StatisticalClassification ()
  {
  }

  // ClassificationSeries_has_ClassificationPosition
  //

  ClassificationSeries_has_ClassificationPosition::
  ClassificationSeries_has_ClassificationPosition ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationSeries_has_ClassificationPosition::
  ClassificationSeries_has_ClassificationPosition (const ClassificationSeries_has_ClassificationPosition& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationSeries_has_ClassificationPosition::
  ClassificationSeries_has_ClassificationPosition (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationSeries_has_ClassificationPosition* ClassificationSeries_has_ClassificationPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationSeries_has_ClassificationPosition (*this, f, c);
  }

  ClassificationSeries_has_ClassificationPosition::
  ~ClassificationSeries_has_ClassificationPosition ()
  {
  }

  // ClassificationSeriesStructure_structures_ClassificationSeries
  //

  ClassificationSeriesStructure_structures_ClassificationSeries::
  ClassificationSeriesStructure_structures_ClassificationSeries ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationSeriesStructure_structures_ClassificationSeries::
  ClassificationSeriesStructure_structures_ClassificationSeries (const ClassificationSeriesStructure_structures_ClassificationSeries& x,
                                                                 ::xml_schema::flags f,
                                                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationSeriesStructure_structures_ClassificationSeries::
  ClassificationSeriesStructure_structures_ClassificationSeries (const ::xercesc::DOMElement& e,
                                                                 ::xml_schema::flags f,
                                                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationSeriesStructure_structures_ClassificationSeries* ClassificationSeriesStructure_structures_ClassificationSeries::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationSeriesStructure_structures_ClassificationSeries (*this, f, c);
  }

  ClassificationSeriesStructure_structures_ClassificationSeries::
  ~ClassificationSeriesStructure_structures_ClassificationSeries ()
  {
  }

  // ClassificationSeriesStructure_has_StatisticalClassificationRelationship
  //

  ClassificationSeriesStructure_has_StatisticalClassificationRelationship::
  ClassificationSeriesStructure_has_StatisticalClassificationRelationship ()
  : ::XMLSchema::Reference ()
  {
  }

  ClassificationSeriesStructure_has_StatisticalClassificationRelationship::
  ClassificationSeriesStructure_has_StatisticalClassificationRelationship (const ClassificationSeriesStructure_has_StatisticalClassificationRelationship& x,
                                                                           ::xml_schema::flags f,
                                                                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ClassificationSeriesStructure_has_StatisticalClassificationRelationship::
  ClassificationSeriesStructure_has_StatisticalClassificationRelationship (const ::xercesc::DOMElement& e,
                                                                           ::xml_schema::flags f,
                                                                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ClassificationSeriesStructure_has_StatisticalClassificationRelationship* ClassificationSeriesStructure_has_StatisticalClassificationRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClassificationSeriesStructure_has_StatisticalClassificationRelationship (*this, f, c);
  }

  ClassificationSeriesStructure_has_StatisticalClassificationRelationship::
  ~ClassificationSeriesStructure_has_StatisticalClassificationRelationship ()
  {
  }

  // Code_denotes_Category
  //

  Code_denotes_Category::
  Code_denotes_Category ()
  : ::XMLSchema::Reference ()
  {
  }

  Code_denotes_Category::
  Code_denotes_Category (const Code_denotes_Category& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Code_denotes_Category::
  Code_denotes_Category (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Code_denotes_Category* Code_denotes_Category::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Code_denotes_Category (*this, f, c);
  }

  Code_denotes_Category::
  ~Code_denotes_Category ()
  {
  }

  // Code_uses_Notation
  //

  Code_uses_Notation::
  Code_uses_Notation ()
  : ::XMLSchema::Reference ()
  {
  }

  Code_uses_Notation::
  Code_uses_Notation (const Code_uses_Notation& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Code_uses_Notation::
  Code_uses_Notation (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Code_uses_Notation* Code_uses_Notation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Code_uses_Notation (*this, f, c);
  }

  Code_uses_Notation::
  ~Code_uses_Notation ()
  {
  }

  // CodeList_has_CodePosition
  //

  CodeList_has_CodePosition::
  CodeList_has_CodePosition ()
  : ::XMLSchema::Reference ()
  {
  }

  CodeList_has_CodePosition::
  CodeList_has_CodePosition (const CodeList_has_CodePosition& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CodeList_has_CodePosition::
  CodeList_has_CodePosition (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CodeList_has_CodePosition* CodeList_has_CodePosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CodeList_has_CodePosition (*this, f, c);
  }

  CodeList_has_CodePosition::
  ~CodeList_has_CodePosition ()
  {
  }

  // CodeList_has_Code
  //

  CodeList_has_Code::
  CodeList_has_Code ()
  : ::XMLSchema::Reference ()
  {
  }

  CodeList_has_Code::
  CodeList_has_Code (const CodeList_has_Code& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CodeList_has_Code::
  CodeList_has_Code (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CodeList_has_Code* CodeList_has_Code::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CodeList_has_Code (*this, f, c);
  }

  CodeList_has_Code::
  ~CodeList_has_Code ()
  {
  }

  // CodeListStructure_structures_CodeList
  //

  CodeListStructure_structures_CodeList::
  CodeListStructure_structures_CodeList ()
  : ::XMLSchema::Reference ()
  {
  }

  CodeListStructure_structures_CodeList::
  CodeListStructure_structures_CodeList (const CodeListStructure_structures_CodeList& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CodeListStructure_structures_CodeList::
  CodeListStructure_structures_CodeList (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CodeListStructure_structures_CodeList* CodeListStructure_structures_CodeList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CodeListStructure_structures_CodeList (*this, f, c);
  }

  CodeListStructure_structures_CodeList::
  ~CodeListStructure_structures_CodeList ()
  {
  }

  // CodeListStructure_has_CodeRelationship
  //

  CodeListStructure_has_CodeRelationship::
  CodeListStructure_has_CodeRelationship ()
  : ::XMLSchema::Reference ()
  {
  }

  CodeListStructure_has_CodeRelationship::
  CodeListStructure_has_CodeRelationship (const CodeListStructure_has_CodeRelationship& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CodeListStructure_has_CodeRelationship::
  CodeListStructure_has_CodeRelationship (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CodeListStructure_has_CodeRelationship* CodeListStructure_has_CodeRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CodeListStructure_has_CodeRelationship (*this, f, c);
  }

  CodeListStructure_has_CodeRelationship::
  ~CodeListStructure_has_CodeRelationship ()
  {
  }

  // CodePosition_indexes_Code
  //

  CodePosition_indexes_Code::
  CodePosition_indexes_Code ()
  : ::XMLSchema::Reference ()
  {
  }

  CodePosition_indexes_Code::
  CodePosition_indexes_Code (const CodePosition_indexes_Code& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CodePosition_indexes_Code::
  CodePosition_indexes_Code (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CodePosition_indexes_Code* CodePosition_indexes_Code::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CodePosition_indexes_Code (*this, f, c);
  }

  CodePosition_indexes_Code::
  ~CodePosition_indexes_Code ()
  {
  }

  // CodeRelationship_hasTarget_Code
  //

  CodeRelationship_hasTarget_Code::
  CodeRelationship_hasTarget_Code ()
  : ::XMLSchema::Reference ()
  {
  }

  CodeRelationship_hasTarget_Code::
  CodeRelationship_hasTarget_Code (const CodeRelationship_hasTarget_Code& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CodeRelationship_hasTarget_Code::
  CodeRelationship_hasTarget_Code (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CodeRelationship_hasTarget_Code* CodeRelationship_hasTarget_Code::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CodeRelationship_hasTarget_Code (*this, f, c);
  }

  CodeRelationship_hasTarget_Code::
  ~CodeRelationship_hasTarget_Code ()
  {
  }

  // CodeRelationship_hasSource_Code
  //

  CodeRelationship_hasSource_Code::
  CodeRelationship_hasSource_Code ()
  : ::XMLSchema::Reference ()
  {
  }

  CodeRelationship_hasSource_Code::
  CodeRelationship_hasSource_Code (const CodeRelationship_hasSource_Code& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CodeRelationship_hasSource_Code::
  CodeRelationship_hasSource_Code (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CodeRelationship_hasSource_Code* CodeRelationship_hasSource_Code::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CodeRelationship_hasSource_Code (*this, f, c);
  }

  CodeRelationship_hasSource_Code::
  ~CodeRelationship_hasSource_Code ()
  {
  }

  // ComponentPosition_indexes_DataStructureComponent
  //

  ComponentPosition_indexes_DataStructureComponent::
  ComponentPosition_indexes_DataStructureComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  ComponentPosition_indexes_DataStructureComponent::
  ComponentPosition_indexes_DataStructureComponent (const ComponentPosition_indexes_DataStructureComponent& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ComponentPosition_indexes_DataStructureComponent::
  ComponentPosition_indexes_DataStructureComponent (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ComponentPosition_indexes_DataStructureComponent* ComponentPosition_indexes_DataStructureComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComponentPosition_indexes_DataStructureComponent (*this, f, c);
  }

  ComponentPosition_indexes_DataStructureComponent::
  ~ComponentPosition_indexes_DataStructureComponent ()
  {
  }

  // externalDefinition
  //

  externalDefinition::
  externalDefinition ()
  : ::XMLSchema::Reference ()
  {
  }

  externalDefinition::
  externalDefinition (const externalDefinition& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  externalDefinition::
  externalDefinition (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  externalDefinition* externalDefinition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class externalDefinition (*this, f, c);
  }

  externalDefinition::
  ~externalDefinition ()
  {
  }

  // Concept_uses_Concept
  //

  Concept_uses_Concept::
  Concept_uses_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  Concept_uses_Concept::
  Concept_uses_Concept (const Concept_uses_Concept& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Concept_uses_Concept::
  Concept_uses_Concept (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Concept_uses_Concept* Concept_uses_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Concept_uses_Concept (*this, f, c);
  }

  Concept_uses_Concept::
  ~Concept_uses_Concept ()
  {
  }

  // ConceptMap_hasSource_Concept
  //

  ConceptMap_hasSource_Concept::
  ConceptMap_hasSource_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptMap_hasSource_Concept::
  ConceptMap_hasSource_Concept (const ConceptMap_hasSource_Concept& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptMap_hasSource_Concept::
  ConceptMap_hasSource_Concept (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptMap_hasSource_Concept* ConceptMap_hasSource_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptMap_hasSource_Concept (*this, f, c);
  }

  ConceptMap_hasSource_Concept::
  ~ConceptMap_hasSource_Concept ()
  {
  }

  // ConceptMap_hasTarget_Concept
  //

  ConceptMap_hasTarget_Concept::
  ConceptMap_hasTarget_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptMap_hasTarget_Concept::
  ConceptMap_hasTarget_Concept (const ConceptMap_hasTarget_Concept& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptMap_hasTarget_Concept::
  ConceptMap_hasTarget_Concept (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptMap_hasTarget_Concept* ConceptMap_hasTarget_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptMap_hasTarget_Concept (*this, f, c);
  }

  ConceptMap_hasTarget_Concept::
  ~ConceptMap_hasTarget_Concept ()
  {
  }

  // ConceptRelationship_hasSource_Concept
  //

  ConceptRelationship_hasSource_Concept::
  ConceptRelationship_hasSource_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptRelationship_hasSource_Concept::
  ConceptRelationship_hasSource_Concept (const ConceptRelationship_hasSource_Concept& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptRelationship_hasSource_Concept::
  ConceptRelationship_hasSource_Concept (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptRelationship_hasSource_Concept* ConceptRelationship_hasSource_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptRelationship_hasSource_Concept (*this, f, c);
  }

  ConceptRelationship_hasSource_Concept::
  ~ConceptRelationship_hasSource_Concept ()
  {
  }

  // ConceptRelationship_hasTarget_Concept
  //

  ConceptRelationship_hasTarget_Concept::
  ConceptRelationship_hasTarget_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptRelationship_hasTarget_Concept::
  ConceptRelationship_hasTarget_Concept (const ConceptRelationship_hasTarget_Concept& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptRelationship_hasTarget_Concept::
  ConceptRelationship_hasTarget_Concept (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptRelationship_hasTarget_Concept* ConceptRelationship_hasTarget_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptRelationship_hasTarget_Concept (*this, f, c);
  }

  ConceptRelationship_hasTarget_Concept::
  ~ConceptRelationship_hasTarget_Concept ()
  {
  }

  // ConceptStructure_structures_ConceptSystem
  //

  ConceptStructure_structures_ConceptSystem::
  ConceptStructure_structures_ConceptSystem ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptStructure_structures_ConceptSystem::
  ConceptStructure_structures_ConceptSystem (const ConceptStructure_structures_ConceptSystem& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptStructure_structures_ConceptSystem::
  ConceptStructure_structures_ConceptSystem (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptStructure_structures_ConceptSystem* ConceptStructure_structures_ConceptSystem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptStructure_structures_ConceptSystem (*this, f, c);
  }

  ConceptStructure_structures_ConceptSystem::
  ~ConceptStructure_structures_ConceptSystem ()
  {
  }

  // ConceptStructure_has_ConceptRelationship
  //

  ConceptStructure_has_ConceptRelationship::
  ConceptStructure_has_ConceptRelationship ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptStructure_has_ConceptRelationship::
  ConceptStructure_has_ConceptRelationship (const ConceptStructure_has_ConceptRelationship& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptStructure_has_ConceptRelationship::
  ConceptStructure_has_ConceptRelationship (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptStructure_has_ConceptRelationship* ConceptStructure_has_ConceptRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptStructure_has_ConceptRelationship (*this, f, c);
  }

  ConceptStructure_has_ConceptRelationship::
  ~ConceptStructure_has_ConceptRelationship ()
  {
  }

  // ConceptSystem_isDefinedBy_Concept
  //

  ConceptSystem_isDefinedBy_Concept::
  ConceptSystem_isDefinedBy_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptSystem_isDefinedBy_Concept::
  ConceptSystem_isDefinedBy_Concept (const ConceptSystem_isDefinedBy_Concept& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptSystem_isDefinedBy_Concept::
  ConceptSystem_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptSystem_isDefinedBy_Concept* ConceptSystem_isDefinedBy_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptSystem_isDefinedBy_Concept (*this, f, c);
  }

  ConceptSystem_isDefinedBy_Concept::
  ~ConceptSystem_isDefinedBy_Concept ()
  {
  }

  // ConceptSystem_has_Concept
  //

  ConceptSystem_has_Concept::
  ConceptSystem_has_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptSystem_has_Concept::
  ConceptSystem_has_Concept (const ConceptSystem_has_Concept& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptSystem_has_Concept::
  ConceptSystem_has_Concept (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptSystem_has_Concept* ConceptSystem_has_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptSystem_has_Concept (*this, f, c);
  }

  ConceptSystem_has_Concept::
  ~ConceptSystem_has_Concept ()
  {
  }

  // ConceptSystemCorrespondence_maps_ConceptSystem
  //

  ConceptSystemCorrespondence_maps_ConceptSystem::
  ConceptSystemCorrespondence_maps_ConceptSystem ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptSystemCorrespondence_maps_ConceptSystem::
  ConceptSystemCorrespondence_maps_ConceptSystem (const ConceptSystemCorrespondence_maps_ConceptSystem& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptSystemCorrespondence_maps_ConceptSystem::
  ConceptSystemCorrespondence_maps_ConceptSystem (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptSystemCorrespondence_maps_ConceptSystem* ConceptSystemCorrespondence_maps_ConceptSystem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptSystemCorrespondence_maps_ConceptSystem (*this, f, c);
  }

  ConceptSystemCorrespondence_maps_ConceptSystem::
  ~ConceptSystemCorrespondence_maps_ConceptSystem ()
  {
  }

  // ConceptSystemCorrespondence_has_ConceptMap
  //

  ConceptSystemCorrespondence_has_ConceptMap::
  ConceptSystemCorrespondence_has_ConceptMap ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptSystemCorrespondence_has_ConceptMap::
  ConceptSystemCorrespondence_has_ConceptMap (const ConceptSystemCorrespondence_has_ConceptMap& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptSystemCorrespondence_has_ConceptMap::
  ConceptSystemCorrespondence_has_ConceptMap (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptSystemCorrespondence_has_ConceptMap* ConceptSystemCorrespondence_has_ConceptMap::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptSystemCorrespondence_has_ConceptMap (*this, f, c);
  }

  ConceptSystemCorrespondence_has_ConceptMap::
  ~ConceptSystemCorrespondence_has_ConceptMap ()
  {
  }

  // ConceptualDomain_isDescribedBy_ValueAndConceptDescription
  //

  ConceptualDomain_isDescribedBy_ValueAndConceptDescription::
  ConceptualDomain_isDescribedBy_ValueAndConceptDescription ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptualDomain_isDescribedBy_ValueAndConceptDescription::
  ConceptualDomain_isDescribedBy_ValueAndConceptDescription (const ConceptualDomain_isDescribedBy_ValueAndConceptDescription& x,
                                                             ::xml_schema::flags f,
                                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptualDomain_isDescribedBy_ValueAndConceptDescription::
  ConceptualDomain_isDescribedBy_ValueAndConceptDescription (const ::xercesc::DOMElement& e,
                                                             ::xml_schema::flags f,
                                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptualDomain_isDescribedBy_ValueAndConceptDescription* ConceptualDomain_isDescribedBy_ValueAndConceptDescription::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptualDomain_isDescribedBy_ValueAndConceptDescription (*this, f, c);
  }

  ConceptualDomain_isDescribedBy_ValueAndConceptDescription::
  ~ConceptualDomain_isDescribedBy_ValueAndConceptDescription ()
  {
  }

  // ConceptualDomain_takesConceptsFrom_ConceptSystem
  //

  ConceptualDomain_takesConceptsFrom_ConceptSystem::
  ConceptualDomain_takesConceptsFrom_ConceptSystem ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptualDomain_takesConceptsFrom_ConceptSystem::
  ConceptualDomain_takesConceptsFrom_ConceptSystem (const ConceptualDomain_takesConceptsFrom_ConceptSystem& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptualDomain_takesConceptsFrom_ConceptSystem::
  ConceptualDomain_takesConceptsFrom_ConceptSystem (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptualDomain_takesConceptsFrom_ConceptSystem* ConceptualDomain_takesConceptsFrom_ConceptSystem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptualDomain_takesConceptsFrom_ConceptSystem (*this, f, c);
  }

  ConceptualDomain_takesConceptsFrom_ConceptSystem::
  ~ConceptualDomain_takesConceptsFrom_ConceptSystem ()
  {
  }

  // ConceptualValue_hasConceptFrom_ConceptualDomain
  //

  ConceptualValue_hasConceptFrom_ConceptualDomain::
  ConceptualValue_hasConceptFrom_ConceptualDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptualValue_hasConceptFrom_ConceptualDomain::
  ConceptualValue_hasConceptFrom_ConceptualDomain (const ConceptualValue_hasConceptFrom_ConceptualDomain& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptualValue_hasConceptFrom_ConceptualDomain::
  ConceptualValue_hasConceptFrom_ConceptualDomain (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptualValue_hasConceptFrom_ConceptualDomain* ConceptualValue_hasConceptFrom_ConceptualDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptualValue_hasConceptFrom_ConceptualDomain (*this, f, c);
  }

  ConceptualValue_hasConceptFrom_ConceptualDomain::
  ~ConceptualValue_hasConceptFrom_ConceptualDomain ()
  {
  }

  // ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain
  //

  ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain::
  ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain::
  ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain (const ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain& x,
                                                                         ::xml_schema::flags f,
                                                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain::
  ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain (const ::xercesc::DOMElement& e,
                                                                         ::xml_schema::flags f,
                                                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain* ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain (*this, f, c);
  }

  ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain::
  ~ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain ()
  {
  }

  // ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain
  //

  ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain::
  ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain::
  ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain (const ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain& x,
                                                                               ::xml_schema::flags f,
                                                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain::
  ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain (const ::xercesc::DOMElement& e,
                                                                               ::xml_schema::flags f,
                                                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain* ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain (*this, f, c);
  }

  ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain::
  ~ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain ()
  {
  }

  // ConceptualVariable_measures_UnitType
  //

  ConceptualVariable_measures_UnitType::
  ConceptualVariable_measures_UnitType ()
  : ::XMLSchema::Reference ()
  {
  }

  ConceptualVariable_measures_UnitType::
  ConceptualVariable_measures_UnitType (const ConceptualVariable_measures_UnitType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ConceptualVariable_measures_UnitType::
  ConceptualVariable_measures_UnitType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ConceptualVariable_measures_UnitType* ConceptualVariable_measures_UnitType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConceptualVariable_measures_UnitType (*this, f, c);
  }

  ConceptualVariable_measures_UnitType::
  ~ConceptualVariable_measures_UnitType ()
  {
  }

  // ControlLogic_informs_ProcessingAgent
  //

  ControlLogic_informs_ProcessingAgent::
  ControlLogic_informs_ProcessingAgent ()
  : ::XMLSchema::Reference ()
  {
  }

  ControlLogic_informs_ProcessingAgent::
  ControlLogic_informs_ProcessingAgent (const ControlLogic_informs_ProcessingAgent& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ControlLogic_informs_ProcessingAgent::
  ControlLogic_informs_ProcessingAgent (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ControlLogic_informs_ProcessingAgent* ControlLogic_informs_ProcessingAgent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ControlLogic_informs_ProcessingAgent (*this, f, c);
  }

  ControlLogic_informs_ProcessingAgent::
  ~ControlLogic_informs_ProcessingAgent ()
  {
  }

  // ControlLogic_invokes_Activity
  //

  ControlLogic_invokes_Activity::
  ControlLogic_invokes_Activity ()
  : ::XMLSchema::Reference ()
  {
  }

  ControlLogic_invokes_Activity::
  ControlLogic_invokes_Activity (const ControlLogic_invokes_Activity& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ControlLogic_invokes_Activity::
  ControlLogic_invokes_Activity (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ControlLogic_invokes_Activity* ControlLogic_invokes_Activity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ControlLogic_invokes_Activity (*this, f, c);
  }

  ControlLogic_invokes_Activity::
  ~ControlLogic_invokes_Activity ()
  {
  }

  // ControlLogic_hasSubControlLogic_ControlLogic
  //

  ControlLogic_hasSubControlLogic_ControlLogic::
  ControlLogic_hasSubControlLogic_ControlLogic ()
  : ::XMLSchema::Reference ()
  {
  }

  ControlLogic_hasSubControlLogic_ControlLogic::
  ControlLogic_hasSubControlLogic_ControlLogic (const ControlLogic_hasSubControlLogic_ControlLogic& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ControlLogic_hasSubControlLogic_ControlLogic::
  ControlLogic_hasSubControlLogic_ControlLogic (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ControlLogic_hasSubControlLogic_ControlLogic* ControlLogic_hasSubControlLogic_ControlLogic::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ControlLogic_hasSubControlLogic_ControlLogic (*this, f, c);
  }

  ControlLogic_hasSubControlLogic_ControlLogic::
  ~ControlLogic_hasSubControlLogic_ControlLogic ()
  {
  }

  // ControlLogic_has_InformationFlowDefinition
  //

  ControlLogic_has_InformationFlowDefinition::
  ControlLogic_has_InformationFlowDefinition ()
  : ::XMLSchema::Reference ()
  {
  }

  ControlLogic_has_InformationFlowDefinition::
  ControlLogic_has_InformationFlowDefinition (const ControlLogic_has_InformationFlowDefinition& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ControlLogic_has_InformationFlowDefinition::
  ControlLogic_has_InformationFlowDefinition (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ControlLogic_has_InformationFlowDefinition* ControlLogic_has_InformationFlowDefinition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ControlLogic_has_InformationFlowDefinition (*this, f, c);
  }

  ControlLogic_has_InformationFlowDefinition::
  ~ControlLogic_has_InformationFlowDefinition ()
  {
  }

  // CorrespondenceTable_hasSource_Level
  //

  CorrespondenceTable_hasSource_Level::
  CorrespondenceTable_hasSource_Level ()
  : ::XMLSchema::Reference ()
  {
  }

  CorrespondenceTable_hasSource_Level::
  CorrespondenceTable_hasSource_Level (const CorrespondenceTable_hasSource_Level& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CorrespondenceTable_hasSource_Level::
  CorrespondenceTable_hasSource_Level (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CorrespondenceTable_hasSource_Level* CorrespondenceTable_hasSource_Level::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CorrespondenceTable_hasSource_Level (*this, f, c);
  }

  CorrespondenceTable_hasSource_Level::
  ~CorrespondenceTable_hasSource_Level ()
  {
  }

  // CorrespondenceTable_hasTarget_Level
  //

  CorrespondenceTable_hasTarget_Level::
  CorrespondenceTable_hasTarget_Level ()
  : ::XMLSchema::Reference ()
  {
  }

  CorrespondenceTable_hasTarget_Level::
  CorrespondenceTable_hasTarget_Level (const CorrespondenceTable_hasTarget_Level& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CorrespondenceTable_hasTarget_Level::
  CorrespondenceTable_hasTarget_Level (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CorrespondenceTable_hasTarget_Level* CorrespondenceTable_hasTarget_Level::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CorrespondenceTable_hasTarget_Level (*this, f, c);
  }

  CorrespondenceTable_hasTarget_Level::
  ~CorrespondenceTable_hasTarget_Level ()
  {
  }

  // CorrespondenceTable_isOwnedBy_Agent
  //

  CorrespondenceTable_isOwnedBy_Agent::
  CorrespondenceTable_isOwnedBy_Agent ()
  : ::XMLSchema::Reference ()
  {
  }

  CorrespondenceTable_isOwnedBy_Agent::
  CorrespondenceTable_isOwnedBy_Agent (const CorrespondenceTable_isOwnedBy_Agent& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CorrespondenceTable_isOwnedBy_Agent::
  CorrespondenceTable_isOwnedBy_Agent (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CorrespondenceTable_isOwnedBy_Agent* CorrespondenceTable_isOwnedBy_Agent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CorrespondenceTable_isOwnedBy_Agent (*this, f, c);
  }

  CorrespondenceTable_isOwnedBy_Agent::
  ~CorrespondenceTable_isOwnedBy_Agent ()
  {
  }

  // CorrespondenceTable_mapsTo_StatisticalClassification
  //

  CorrespondenceTable_mapsTo_StatisticalClassification::
  CorrespondenceTable_mapsTo_StatisticalClassification ()
  : ::XMLSchema::Reference ()
  {
  }

  CorrespondenceTable_mapsTo_StatisticalClassification::
  CorrespondenceTable_mapsTo_StatisticalClassification (const CorrespondenceTable_mapsTo_StatisticalClassification& x,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CorrespondenceTable_mapsTo_StatisticalClassification::
  CorrespondenceTable_mapsTo_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CorrespondenceTable_mapsTo_StatisticalClassification* CorrespondenceTable_mapsTo_StatisticalClassification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CorrespondenceTable_mapsTo_StatisticalClassification (*this, f, c);
  }

  CorrespondenceTable_mapsTo_StatisticalClassification::
  ~CorrespondenceTable_mapsTo_StatisticalClassification ()
  {
  }

  // CorrespondenceTable_hasContact_Agent
  //

  CorrespondenceTable_hasContact_Agent::
  CorrespondenceTable_hasContact_Agent ()
  : ::XMLSchema::Reference ()
  {
  }

  CorrespondenceTable_hasContact_Agent::
  CorrespondenceTable_hasContact_Agent (const CorrespondenceTable_hasContact_Agent& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CorrespondenceTable_hasContact_Agent::
  CorrespondenceTable_hasContact_Agent (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CorrespondenceTable_hasContact_Agent* CorrespondenceTable_hasContact_Agent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CorrespondenceTable_hasContact_Agent (*this, f, c);
  }

  CorrespondenceTable_hasContact_Agent::
  ~CorrespondenceTable_hasContact_Agent ()
  {
  }

  // CorrespondenceTable_isMaintainedBy_Agent
  //

  CorrespondenceTable_isMaintainedBy_Agent::
  CorrespondenceTable_isMaintainedBy_Agent ()
  : ::XMLSchema::Reference ()
  {
  }

  CorrespondenceTable_isMaintainedBy_Agent::
  CorrespondenceTable_isMaintainedBy_Agent (const CorrespondenceTable_isMaintainedBy_Agent& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CorrespondenceTable_isMaintainedBy_Agent::
  CorrespondenceTable_isMaintainedBy_Agent (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CorrespondenceTable_isMaintainedBy_Agent* CorrespondenceTable_isMaintainedBy_Agent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CorrespondenceTable_isMaintainedBy_Agent (*this, f, c);
  }

  CorrespondenceTable_isMaintainedBy_Agent::
  ~CorrespondenceTable_isMaintainedBy_Agent ()
  {
  }

  // CorrespondenceTable_has_ConceptMap
  //

  CorrespondenceTable_has_ConceptMap::
  CorrespondenceTable_has_ConceptMap ()
  : ::XMLSchema::Reference ()
  {
  }

  CorrespondenceTable_has_ConceptMap::
  CorrespondenceTable_has_ConceptMap (const CorrespondenceTable_has_ConceptMap& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  CorrespondenceTable_has_ConceptMap::
  CorrespondenceTable_has_ConceptMap (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  CorrespondenceTable_has_ConceptMap* CorrespondenceTable_has_ConceptMap::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CorrespondenceTable_has_ConceptMap (*this, f, c);
  }

  CorrespondenceTable_has_ConceptMap::
  ~CorrespondenceTable_has_ConceptMap ()
  {
  }

  // DataPoint_correspondsTo_DataStructureComponent
  //

  DataPoint_correspondsTo_DataStructureComponent::
  DataPoint_correspondsTo_DataStructureComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  DataPoint_correspondsTo_DataStructureComponent::
  DataPoint_correspondsTo_DataStructureComponent (const DataPoint_correspondsTo_DataStructureComponent& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataPoint_correspondsTo_DataStructureComponent::
  DataPoint_correspondsTo_DataStructureComponent (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataPoint_correspondsTo_DataStructureComponent* DataPoint_correspondsTo_DataStructureComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataPoint_correspondsTo_DataStructureComponent (*this, f, c);
  }

  DataPoint_correspondsTo_DataStructureComponent::
  ~DataPoint_correspondsTo_DataStructureComponent ()
  {
  }

  // DataPoint_isDescribedBy_InstanceVariable
  //

  DataPoint_isDescribedBy_InstanceVariable::
  DataPoint_isDescribedBy_InstanceVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  DataPoint_isDescribedBy_InstanceVariable::
  DataPoint_isDescribedBy_InstanceVariable (const DataPoint_isDescribedBy_InstanceVariable& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataPoint_isDescribedBy_InstanceVariable::
  DataPoint_isDescribedBy_InstanceVariable (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataPoint_isDescribedBy_InstanceVariable* DataPoint_isDescribedBy_InstanceVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataPoint_isDescribedBy_InstanceVariable (*this, f, c);
  }

  DataPoint_isDescribedBy_InstanceVariable::
  ~DataPoint_isDescribedBy_InstanceVariable ()
  {
  }

  // DataPointPosition_indexes_DataPoint
  //

  DataPointPosition_indexes_DataPoint::
  DataPointPosition_indexes_DataPoint ()
  : ::XMLSchema::Reference ()
  {
  }

  DataPointPosition_indexes_DataPoint::
  DataPointPosition_indexes_DataPoint (const DataPointPosition_indexes_DataPoint& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataPointPosition_indexes_DataPoint::
  DataPointPosition_indexes_DataPoint (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataPointPosition_indexes_DataPoint* DataPointPosition_indexes_DataPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataPointPosition_indexes_DataPoint (*this, f, c);
  }

  DataPointPosition_indexes_DataPoint::
  ~DataPointPosition_indexes_DataPoint ()
  {
  }

  // DataPointRelationship_hasTarget_DataPoint
  //

  DataPointRelationship_hasTarget_DataPoint::
  DataPointRelationship_hasTarget_DataPoint ()
  : ::XMLSchema::Reference ()
  {
  }

  DataPointRelationship_hasTarget_DataPoint::
  DataPointRelationship_hasTarget_DataPoint (const DataPointRelationship_hasTarget_DataPoint& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataPointRelationship_hasTarget_DataPoint::
  DataPointRelationship_hasTarget_DataPoint (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataPointRelationship_hasTarget_DataPoint* DataPointRelationship_hasTarget_DataPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataPointRelationship_hasTarget_DataPoint (*this, f, c);
  }

  DataPointRelationship_hasTarget_DataPoint::
  ~DataPointRelationship_hasTarget_DataPoint ()
  {
  }

  // DataPointRelationship_hasSource_DataPoint
  //

  DataPointRelationship_hasSource_DataPoint::
  DataPointRelationship_hasSource_DataPoint ()
  : ::XMLSchema::Reference ()
  {
  }

  DataPointRelationship_hasSource_DataPoint::
  DataPointRelationship_hasSource_DataPoint (const DataPointRelationship_hasSource_DataPoint& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataPointRelationship_hasSource_DataPoint::
  DataPointRelationship_hasSource_DataPoint (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataPointRelationship_hasSource_DataPoint* DataPointRelationship_hasSource_DataPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataPointRelationship_hasSource_DataPoint (*this, f, c);
  }

  DataPointRelationship_hasSource_DataPoint::
  ~DataPointRelationship_hasSource_DataPoint ()
  {
  }

  // DataSet_isStructuredBy_DataStructure
  //

  DataSet_isStructuredBy_DataStructure::
  DataSet_isStructuredBy_DataStructure ()
  : ::XMLSchema::Reference ()
  {
  }

  DataSet_isStructuredBy_DataStructure::
  DataSet_isStructuredBy_DataStructure (const DataSet_isStructuredBy_DataStructure& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataSet_isStructuredBy_DataStructure::
  DataSet_isStructuredBy_DataStructure (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataSet_isStructuredBy_DataStructure* DataSet_isStructuredBy_DataStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataSet_isStructuredBy_DataStructure (*this, f, c);
  }

  DataSet_isStructuredBy_DataStructure::
  ~DataSet_isStructuredBy_DataStructure ()
  {
  }

  // DataSet_has_DataPoint
  //

  DataSet_has_DataPoint::
  DataSet_has_DataPoint ()
  : ::XMLSchema::Reference ()
  {
  }

  DataSet_has_DataPoint::
  DataSet_has_DataPoint (const DataSet_has_DataPoint& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataSet_has_DataPoint::
  DataSet_has_DataPoint (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataSet_has_DataPoint* DataSet_has_DataPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataSet_has_DataPoint (*this, f, c);
  }

  DataSet_has_DataPoint::
  ~DataSet_has_DataPoint ()
  {
  }

  // DataSet_has_Key
  //

  DataSet_has_Key::
  DataSet_has_Key ()
  : ::XMLSchema::Reference ()
  {
  }

  DataSet_has_Key::
  DataSet_has_Key (const DataSet_has_Key& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataSet_has_Key::
  DataSet_has_Key (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataSet_has_Key* DataSet_has_Key::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataSet_has_Key (*this, f, c);
  }

  DataSet_has_Key::
  ~DataSet_has_Key ()
  {
  }

  // DataStore_isDefinedBy_Concept
  //

  DataStore_isDefinedBy_Concept::
  DataStore_isDefinedBy_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  DataStore_isDefinedBy_Concept::
  DataStore_isDefinedBy_Concept (const DataStore_isDefinedBy_Concept& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataStore_isDefinedBy_Concept::
  DataStore_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataStore_isDefinedBy_Concept* DataStore_isDefinedBy_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataStore_isDefinedBy_Concept (*this, f, c);
  }

  DataStore_isDefinedBy_Concept::
  ~DataStore_isDefinedBy_Concept ()
  {
  }

  // DataStore_has_LogicalRecordPosition
  //

  DataStore_has_LogicalRecordPosition::
  DataStore_has_LogicalRecordPosition ()
  : ::XMLSchema::Reference ()
  {
  }

  DataStore_has_LogicalRecordPosition::
  DataStore_has_LogicalRecordPosition (const DataStore_has_LogicalRecordPosition& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataStore_has_LogicalRecordPosition::
  DataStore_has_LogicalRecordPosition (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataStore_has_LogicalRecordPosition* DataStore_has_LogicalRecordPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataStore_has_LogicalRecordPosition (*this, f, c);
  }

  DataStore_has_LogicalRecordPosition::
  ~DataStore_has_LogicalRecordPosition ()
  {
  }

  // DataStore_has_LogicalRecord
  //

  DataStore_has_LogicalRecord::
  DataStore_has_LogicalRecord ()
  : ::XMLSchema::Reference ()
  {
  }

  DataStore_has_LogicalRecord::
  DataStore_has_LogicalRecord (const DataStore_has_LogicalRecord& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataStore_has_LogicalRecord::
  DataStore_has_LogicalRecord (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataStore_has_LogicalRecord* DataStore_has_LogicalRecord::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataStore_has_LogicalRecord (*this, f, c);
  }

  DataStore_has_LogicalRecord::
  ~DataStore_has_LogicalRecord ()
  {
  }

  // DataStore_has_RecordRelation
  //

  DataStore_has_RecordRelation::
  DataStore_has_RecordRelation ()
  : ::XMLSchema::Reference ()
  {
  }

  DataStore_has_RecordRelation::
  DataStore_has_RecordRelation (const DataStore_has_RecordRelation& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataStore_has_RecordRelation::
  DataStore_has_RecordRelation (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataStore_has_RecordRelation* DataStore_has_RecordRelation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataStore_has_RecordRelation (*this, f, c);
  }

  DataStore_has_RecordRelation::
  ~DataStore_has_RecordRelation ()
  {
  }

  // DataStructure_has_ForeignKey
  //

  DataStructure_has_ForeignKey::
  DataStructure_has_ForeignKey ()
  : ::XMLSchema::Reference ()
  {
  }

  DataStructure_has_ForeignKey::
  DataStructure_has_ForeignKey (const DataStructure_has_ForeignKey& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataStructure_has_ForeignKey::
  DataStructure_has_ForeignKey (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataStructure_has_ForeignKey* DataStructure_has_ForeignKey::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataStructure_has_ForeignKey (*this, f, c);
  }

  DataStructure_has_ForeignKey::
  ~DataStructure_has_ForeignKey ()
  {
  }

  // DataStructure_has_DataStructureComponent
  //

  DataStructure_has_DataStructureComponent::
  DataStructure_has_DataStructureComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  DataStructure_has_DataStructureComponent::
  DataStructure_has_DataStructureComponent (const DataStructure_has_DataStructureComponent& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataStructure_has_DataStructureComponent::
  DataStructure_has_DataStructureComponent (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataStructure_has_DataStructureComponent* DataStructure_has_DataStructureComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataStructure_has_DataStructureComponent (*this, f, c);
  }

  DataStructure_has_DataStructureComponent::
  ~DataStructure_has_DataStructureComponent ()
  {
  }

  // DataStructure_has_ComponentPosition
  //

  DataStructure_has_ComponentPosition::
  DataStructure_has_ComponentPosition ()
  : ::XMLSchema::Reference ()
  {
  }

  DataStructure_has_ComponentPosition::
  DataStructure_has_ComponentPosition (const DataStructure_has_ComponentPosition& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataStructure_has_ComponentPosition::
  DataStructure_has_ComponentPosition (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataStructure_has_ComponentPosition* DataStructure_has_ComponentPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataStructure_has_ComponentPosition (*this, f, c);
  }

  DataStructure_has_ComponentPosition::
  ~DataStructure_has_ComponentPosition ()
  {
  }

  // DataStructure_has_PrimaryKey
  //

  DataStructure_has_PrimaryKey::
  DataStructure_has_PrimaryKey ()
  : ::XMLSchema::Reference ()
  {
  }

  DataStructure_has_PrimaryKey::
  DataStructure_has_PrimaryKey (const DataStructure_has_PrimaryKey& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataStructure_has_PrimaryKey::
  DataStructure_has_PrimaryKey (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataStructure_has_PrimaryKey* DataStructure_has_PrimaryKey::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataStructure_has_PrimaryKey (*this, f, c);
  }

  DataStructure_has_PrimaryKey::
  ~DataStructure_has_PrimaryKey ()
  {
  }

  // DataStructureComponent_isDefinedBy_RepresentedVariable
  //

  DataStructureComponent_isDefinedBy_RepresentedVariable::
  DataStructureComponent_isDefinedBy_RepresentedVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  DataStructureComponent_isDefinedBy_RepresentedVariable::
  DataStructureComponent_isDefinedBy_RepresentedVariable (const DataStructureComponent_isDefinedBy_RepresentedVariable& x,
                                                          ::xml_schema::flags f,
                                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DataStructureComponent_isDefinedBy_RepresentedVariable::
  DataStructureComponent_isDefinedBy_RepresentedVariable (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::flags f,
                                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DataStructureComponent_isDefinedBy_RepresentedVariable* DataStructureComponent_isDefinedBy_RepresentedVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataStructureComponent_isDefinedBy_RepresentedVariable (*this, f, c);
  }

  DataStructureComponent_isDefinedBy_RepresentedVariable::
  ~DataStructureComponent_isDefinedBy_RepresentedVariable ()
  {
  }

  // Datum_uses_Notation
  //

  Datum_uses_Notation::
  Datum_uses_Notation ()
  : ::XMLSchema::Reference ()
  {
  }

  Datum_uses_Notation::
  Datum_uses_Notation (const Datum_uses_Notation& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Datum_uses_Notation::
  Datum_uses_Notation (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Datum_uses_Notation* Datum_uses_Notation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Datum_uses_Notation (*this, f, c);
  }

  Datum_uses_Notation::
  ~Datum_uses_Notation ()
  {
  }

  // Datum_denotes_ConceptualValue
  //

  Datum_denotes_ConceptualValue::
  Datum_denotes_ConceptualValue ()
  : ::XMLSchema::Reference ()
  {
  }

  Datum_denotes_ConceptualValue::
  Datum_denotes_ConceptualValue (const Datum_denotes_ConceptualValue& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Datum_denotes_ConceptualValue::
  Datum_denotes_ConceptualValue (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Datum_denotes_ConceptualValue* Datum_denotes_ConceptualValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Datum_denotes_ConceptualValue (*this, f, c);
  }

  Datum_denotes_ConceptualValue::
  ~Datum_denotes_ConceptualValue ()
  {
  }

  // Datum_uses_InstanceValue
  //

  Datum_uses_InstanceValue::
  Datum_uses_InstanceValue ()
  : ::XMLSchema::Reference ()
  {
  }

  Datum_uses_InstanceValue::
  Datum_uses_InstanceValue (const Datum_uses_InstanceValue& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Datum_uses_InstanceValue::
  Datum_uses_InstanceValue (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Datum_uses_InstanceValue* Datum_uses_InstanceValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Datum_uses_InstanceValue (*this, f, c);
  }

  Datum_uses_InstanceValue::
  ~Datum_uses_InstanceValue ()
  {
  }

  // Datum_isBoundedBy_InstanceVariable
  //

  Datum_isBoundedBy_InstanceVariable::
  Datum_isBoundedBy_InstanceVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  Datum_isBoundedBy_InstanceVariable::
  Datum_isBoundedBy_InstanceVariable (const Datum_isBoundedBy_InstanceVariable& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Datum_isBoundedBy_InstanceVariable::
  Datum_isBoundedBy_InstanceVariable (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Datum_isBoundedBy_InstanceVariable* Datum_isBoundedBy_InstanceVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Datum_isBoundedBy_InstanceVariable (*this, f, c);
  }

  Datum_isBoundedBy_InstanceVariable::
  ~Datum_isBoundedBy_InstanceVariable ()
  {
  }

  // Descriptor_refersTo_ReferenceValue
  //

  Descriptor_refersTo_ReferenceValue::
  Descriptor_refersTo_ReferenceValue ()
  : ::XMLSchema::Reference ()
  {
  }

  Descriptor_refersTo_ReferenceValue::
  Descriptor_refersTo_ReferenceValue (const Descriptor_refersTo_ReferenceValue& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Descriptor_refersTo_ReferenceValue::
  Descriptor_refersTo_ReferenceValue (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Descriptor_refersTo_ReferenceValue* Descriptor_refersTo_ReferenceValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Descriptor_refersTo_ReferenceValue (*this, f, c);
  }

  Descriptor_refersTo_ReferenceValue::
  ~Descriptor_refersTo_ReferenceValue ()
  {
  }

  // Descriptor_identifies_ReferenceVariable
  //

  Descriptor_identifies_ReferenceVariable::
  Descriptor_identifies_ReferenceVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  Descriptor_identifies_ReferenceVariable::
  Descriptor_identifies_ReferenceVariable (const Descriptor_identifies_ReferenceVariable& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Descriptor_identifies_ReferenceVariable::
  Descriptor_identifies_ReferenceVariable (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Descriptor_identifies_ReferenceVariable* Descriptor_identifies_ReferenceVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Descriptor_identifies_ReferenceVariable (*this, f, c);
  }

  Descriptor_identifies_ReferenceVariable::
  ~Descriptor_identifies_ReferenceVariable ()
  {
  }

  // Descriptor_hasValueFrom_DescriptorValueDomain
  //

  Descriptor_hasValueFrom_DescriptorValueDomain::
  Descriptor_hasValueFrom_DescriptorValueDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  Descriptor_hasValueFrom_DescriptorValueDomain::
  Descriptor_hasValueFrom_DescriptorValueDomain (const Descriptor_hasValueFrom_DescriptorValueDomain& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Descriptor_hasValueFrom_DescriptorValueDomain::
  Descriptor_hasValueFrom_DescriptorValueDomain (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Descriptor_hasValueFrom_DescriptorValueDomain* Descriptor_hasValueFrom_DescriptorValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Descriptor_hasValueFrom_DescriptorValueDomain (*this, f, c);
  }

  Descriptor_hasValueFrom_DescriptorValueDomain::
  ~Descriptor_hasValueFrom_DescriptorValueDomain ()
  {
  }

  // DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain
  //

  DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain::
  DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain::
  DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain (const DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain& x,
                                                                       ::xml_schema::flags f,
                                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain::
  DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain (const ::xercesc::DOMElement& e,
                                                                       ::xml_schema::flags f,
                                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain* DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain (*this, f, c);
  }

  DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain::
  ~DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain ()
  {
  }

  // DimensionComponent_isStructuredBy_ValueDomain
  //

  DimensionComponent_isStructuredBy_ValueDomain::
  DimensionComponent_isStructuredBy_ValueDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  DimensionComponent_isStructuredBy_ValueDomain::
  DimensionComponent_isStructuredBy_ValueDomain (const DimensionComponent_isStructuredBy_ValueDomain& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DimensionComponent_isStructuredBy_ValueDomain::
  DimensionComponent_isStructuredBy_ValueDomain (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DimensionComponent_isStructuredBy_ValueDomain* DimensionComponent_isStructuredBy_ValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionComponent_isStructuredBy_ValueDomain (*this, f, c);
  }

  DimensionComponent_isStructuredBy_ValueDomain::
  ~DimensionComponent_isStructuredBy_ValueDomain ()
  {
  }

  // DimensionGroup_has_DimensionComponent
  //

  DimensionGroup_has_DimensionComponent::
  DimensionGroup_has_DimensionComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  DimensionGroup_has_DimensionComponent::
  DimensionGroup_has_DimensionComponent (const DimensionGroup_has_DimensionComponent& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DimensionGroup_has_DimensionComponent::
  DimensionGroup_has_DimensionComponent (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DimensionGroup_has_DimensionComponent* DimensionGroup_has_DimensionComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionGroup_has_DimensionComponent (*this, f, c);
  }

  DimensionGroup_has_DimensionComponent::
  ~DimensionGroup_has_DimensionComponent ()
  {
  }

  // DimensionalDataSet_represents_ScopedMeasure
  //

  DimensionalDataSet_represents_ScopedMeasure::
  DimensionalDataSet_represents_ScopedMeasure ()
  : ::XMLSchema::Reference ()
  {
  }

  DimensionalDataSet_represents_ScopedMeasure::
  DimensionalDataSet_represents_ScopedMeasure (const DimensionalDataSet_represents_ScopedMeasure& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DimensionalDataSet_represents_ScopedMeasure::
  DimensionalDataSet_represents_ScopedMeasure (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DimensionalDataSet_represents_ScopedMeasure* DimensionalDataSet_represents_ScopedMeasure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionalDataSet_represents_ScopedMeasure (*this, f, c);
  }

  DimensionalDataSet_represents_ScopedMeasure::
  ~DimensionalDataSet_represents_ScopedMeasure ()
  {
  }

  // DimensionalDataStructure_uses_DimensionGroup
  //

  DimensionalDataStructure_uses_DimensionGroup::
  DimensionalDataStructure_uses_DimensionGroup ()
  : ::XMLSchema::Reference ()
  {
  }

  DimensionalDataStructure_uses_DimensionGroup::
  DimensionalDataStructure_uses_DimensionGroup (const DimensionalDataStructure_uses_DimensionGroup& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DimensionalDataStructure_uses_DimensionGroup::
  DimensionalDataStructure_uses_DimensionGroup (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DimensionalDataStructure_uses_DimensionGroup* DimensionalDataStructure_uses_DimensionGroup::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionalDataStructure_uses_DimensionGroup (*this, f, c);
  }

  DimensionalDataStructure_uses_DimensionGroup::
  ~DimensionalDataStructure_uses_DimensionGroup ()
  {
  }

  // DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember
  //

  DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember::
  DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember ()
  : ::XMLSchema::Reference ()
  {
  }

  DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember::
  DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember (const DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember& x,
                                                                       ::xml_schema::flags f,
                                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember::
  DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember (const ::xercesc::DOMElement& e,
                                                                       ::xml_schema::flags f,
                                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember* DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember (*this, f, c);
  }

  DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember::
  ~DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember ()
  {
  }

  // DimensionalKeyMember_hasValueFrom_CodeList
  //

  DimensionalKeyMember_hasValueFrom_CodeList::
  DimensionalKeyMember_hasValueFrom_CodeList ()
  : ::XMLSchema::Reference ()
  {
  }

  DimensionalKeyMember_hasValueFrom_CodeList::
  DimensionalKeyMember_hasValueFrom_CodeList (const DimensionalKeyMember_hasValueFrom_CodeList& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  DimensionalKeyMember_hasValueFrom_CodeList::
  DimensionalKeyMember_hasValueFrom_CodeList (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  DimensionalKeyMember_hasValueFrom_CodeList* DimensionalKeyMember_hasValueFrom_CodeList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DimensionalKeyMember_hasValueFrom_CodeList (*this, f, c);
  }

  DimensionalKeyMember_hasValueFrom_CodeList::
  ~DimensionalKeyMember_hasValueFrom_CodeList ()
  {
  }

  // EnumerationDomain_uses_LevelStructure
  //

  EnumerationDomain_uses_LevelStructure::
  EnumerationDomain_uses_LevelStructure ()
  : ::XMLSchema::Reference ()
  {
  }

  EnumerationDomain_uses_LevelStructure::
  EnumerationDomain_uses_LevelStructure (const EnumerationDomain_uses_LevelStructure& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  EnumerationDomain_uses_LevelStructure::
  EnumerationDomain_uses_LevelStructure (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  EnumerationDomain_uses_LevelStructure* EnumerationDomain_uses_LevelStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EnumerationDomain_uses_LevelStructure (*this, f, c);
  }

  EnumerationDomain_uses_LevelStructure::
  ~EnumerationDomain_uses_LevelStructure ()
  {
  }

  // EnumerationDomain_references_CategorySet
  //

  EnumerationDomain_references_CategorySet::
  EnumerationDomain_references_CategorySet ()
  : ::XMLSchema::Reference ()
  {
  }

  EnumerationDomain_references_CategorySet::
  EnumerationDomain_references_CategorySet (const EnumerationDomain_references_CategorySet& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  EnumerationDomain_references_CategorySet::
  EnumerationDomain_references_CategorySet (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  EnumerationDomain_references_CategorySet* EnumerationDomain_references_CategorySet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EnumerationDomain_references_CategorySet (*this, f, c);
  }

  EnumerationDomain_references_CategorySet::
  ~EnumerationDomain_references_CategorySet ()
  {
  }

  // EnumerationDomain_isDefinedBy_Concept
  //

  EnumerationDomain_isDefinedBy_Concept::
  EnumerationDomain_isDefinedBy_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  EnumerationDomain_isDefinedBy_Concept::
  EnumerationDomain_isDefinedBy_Concept (const EnumerationDomain_isDefinedBy_Concept& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  EnumerationDomain_isDefinedBy_Concept::
  EnumerationDomain_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  EnumerationDomain_isDefinedBy_Concept* EnumerationDomain_isDefinedBy_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EnumerationDomain_isDefinedBy_Concept (*this, f, c);
  }

  EnumerationDomain_isDefinedBy_Concept::
  ~EnumerationDomain_isDefinedBy_Concept ()
  {
  }

  // ForeignKey_isComposedOf_ForeignKeyComponent
  //

  ForeignKey_isComposedOf_ForeignKeyComponent::
  ForeignKey_isComposedOf_ForeignKeyComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  ForeignKey_isComposedOf_ForeignKeyComponent::
  ForeignKey_isComposedOf_ForeignKeyComponent (const ForeignKey_isComposedOf_ForeignKeyComponent& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ForeignKey_isComposedOf_ForeignKeyComponent::
  ForeignKey_isComposedOf_ForeignKeyComponent (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ForeignKey_isComposedOf_ForeignKeyComponent* ForeignKey_isComposedOf_ForeignKeyComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ForeignKey_isComposedOf_ForeignKeyComponent (*this, f, c);
  }

  ForeignKey_isComposedOf_ForeignKeyComponent::
  ~ForeignKey_isComposedOf_ForeignKeyComponent ()
  {
  }

  // ForeignKeyComponent_references_PrimaryKeyComponent
  //

  ForeignKeyComponent_references_PrimaryKeyComponent::
  ForeignKeyComponent_references_PrimaryKeyComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  ForeignKeyComponent_references_PrimaryKeyComponent::
  ForeignKeyComponent_references_PrimaryKeyComponent (const ForeignKeyComponent_references_PrimaryKeyComponent& x,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ForeignKeyComponent_references_PrimaryKeyComponent::
  ForeignKeyComponent_references_PrimaryKeyComponent (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ForeignKeyComponent_references_PrimaryKeyComponent* ForeignKeyComponent_references_PrimaryKeyComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ForeignKeyComponent_references_PrimaryKeyComponent (*this, f, c);
  }

  ForeignKeyComponent_references_PrimaryKeyComponent::
  ~ForeignKeyComponent_references_PrimaryKeyComponent ()
  {
  }

  // ForeignKeyComponent_correspondsTo_DataStructureComponent
  //

  ForeignKeyComponent_correspondsTo_DataStructureComponent::
  ForeignKeyComponent_correspondsTo_DataStructureComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  ForeignKeyComponent_correspondsTo_DataStructureComponent::
  ForeignKeyComponent_correspondsTo_DataStructureComponent (const ForeignKeyComponent_correspondsTo_DataStructureComponent& x,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ForeignKeyComponent_correspondsTo_DataStructureComponent::
  ForeignKeyComponent_correspondsTo_DataStructureComponent (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ForeignKeyComponent_correspondsTo_DataStructureComponent* ForeignKeyComponent_correspondsTo_DataStructureComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ForeignKeyComponent_correspondsTo_DataStructureComponent (*this, f, c);
  }

  ForeignKeyComponent_correspondsTo_DataStructureComponent::
  ~ForeignKeyComponent_correspondsTo_DataStructureComponent ()
  {
  }

  // InformationFlowDefinition_from_Parameter
  //

  InformationFlowDefinition_from_Parameter::
  InformationFlowDefinition_from_Parameter ()
  : ::XMLSchema::Reference ()
  {
  }

  InformationFlowDefinition_from_Parameter::
  InformationFlowDefinition_from_Parameter (const InformationFlowDefinition_from_Parameter& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  InformationFlowDefinition_from_Parameter::
  InformationFlowDefinition_from_Parameter (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  InformationFlowDefinition_from_Parameter* InformationFlowDefinition_from_Parameter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InformationFlowDefinition_from_Parameter (*this, f, c);
  }

  InformationFlowDefinition_from_Parameter::
  ~InformationFlowDefinition_from_Parameter ()
  {
  }

  // InformationFlowDefinition_to_Parameter
  //

  InformationFlowDefinition_to_Parameter::
  InformationFlowDefinition_to_Parameter ()
  : ::XMLSchema::Reference ()
  {
  }

  InformationFlowDefinition_to_Parameter::
  InformationFlowDefinition_to_Parameter (const InformationFlowDefinition_to_Parameter& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  InformationFlowDefinition_to_Parameter::
  InformationFlowDefinition_to_Parameter (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  InformationFlowDefinition_to_Parameter* InformationFlowDefinition_to_Parameter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InformationFlowDefinition_to_Parameter (*this, f, c);
  }

  InformationFlowDefinition_to_Parameter::
  ~InformationFlowDefinition_to_Parameter ()
  {
  }

  // InstanceKey_has_InstanceValue
  //

  InstanceKey_has_InstanceValue::
  InstanceKey_has_InstanceValue ()
  : ::XMLSchema::Reference ()
  {
  }

  InstanceKey_has_InstanceValue::
  InstanceKey_has_InstanceValue (const InstanceKey_has_InstanceValue& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  InstanceKey_has_InstanceValue::
  InstanceKey_has_InstanceValue (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  InstanceKey_has_InstanceValue* InstanceKey_has_InstanceValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstanceKey_has_InstanceValue (*this, f, c);
  }

  InstanceKey_has_InstanceValue::
  ~InstanceKey_has_InstanceValue ()
  {
  }

  // InstanceKey_refersTo_ReferenceValue
  //

  InstanceKey_refersTo_ReferenceValue::
  InstanceKey_refersTo_ReferenceValue ()
  : ::XMLSchema::Reference ()
  {
  }

  InstanceKey_refersTo_ReferenceValue::
  InstanceKey_refersTo_ReferenceValue (const InstanceKey_refersTo_ReferenceValue& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  InstanceKey_refersTo_ReferenceValue::
  InstanceKey_refersTo_ReferenceValue (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  InstanceKey_refersTo_ReferenceValue* InstanceKey_refersTo_ReferenceValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstanceKey_refersTo_ReferenceValue (*this, f, c);
  }

  InstanceKey_refersTo_ReferenceValue::
  ~InstanceKey_refersTo_ReferenceValue ()
  {
  }

  // InstanceValue_hasValueFrom_ValueDomain
  //

  InstanceValue_hasValueFrom_ValueDomain::
  InstanceValue_hasValueFrom_ValueDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  InstanceValue_hasValueFrom_ValueDomain::
  InstanceValue_hasValueFrom_ValueDomain (const InstanceValue_hasValueFrom_ValueDomain& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  InstanceValue_hasValueFrom_ValueDomain::
  InstanceValue_hasValueFrom_ValueDomain (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  InstanceValue_hasValueFrom_ValueDomain* InstanceValue_hasValueFrom_ValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstanceValue_hasValueFrom_ValueDomain (*this, f, c);
  }

  InstanceValue_hasValueFrom_ValueDomain::
  ~InstanceValue_hasValueFrom_ValueDomain ()
  {
  }

  // InstanceValue_isStoredIn_DataPoint
  //

  InstanceValue_isStoredIn_DataPoint::
  InstanceValue_isStoredIn_DataPoint ()
  : ::XMLSchema::Reference ()
  {
  }

  InstanceValue_isStoredIn_DataPoint::
  InstanceValue_isStoredIn_DataPoint (const InstanceValue_isStoredIn_DataPoint& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  InstanceValue_isStoredIn_DataPoint::
  InstanceValue_isStoredIn_DataPoint (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  InstanceValue_isStoredIn_DataPoint* InstanceValue_isStoredIn_DataPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstanceValue_isStoredIn_DataPoint (*this, f, c);
  }

  InstanceValue_isStoredIn_DataPoint::
  ~InstanceValue_isStoredIn_DataPoint ()
  {
  }

  // InstanceValue_represents_ConceptualValue
  //

  InstanceValue_represents_ConceptualValue::
  InstanceValue_represents_ConceptualValue ()
  : ::XMLSchema::Reference ()
  {
  }

  InstanceValue_represents_ConceptualValue::
  InstanceValue_represents_ConceptualValue (const InstanceValue_represents_ConceptualValue& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  InstanceValue_represents_ConceptualValue::
  InstanceValue_represents_ConceptualValue (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  InstanceValue_represents_ConceptualValue* InstanceValue_represents_ConceptualValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstanceValue_represents_ConceptualValue (*this, f, c);
  }

  InstanceValue_represents_ConceptualValue::
  ~InstanceValue_represents_ConceptualValue ()
  {
  }

  // source
  //

  source::
  source ()
  : ::XMLSchema::Reference ()
  {
  }

  source::
  source (const source& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  source::
  source (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  source* source::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class source (*this, f, c);
  }

  source::
  ~source ()
  {
  }

  // InstanceVariableMap_hasTarget_InstanceVariable
  //

  InstanceVariableMap_hasTarget_InstanceVariable::
  InstanceVariableMap_hasTarget_InstanceVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  InstanceVariableMap_hasTarget_InstanceVariable::
  InstanceVariableMap_hasTarget_InstanceVariable (const InstanceVariableMap_hasTarget_InstanceVariable& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  InstanceVariableMap_hasTarget_InstanceVariable::
  InstanceVariableMap_hasTarget_InstanceVariable (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  InstanceVariableMap_hasTarget_InstanceVariable* InstanceVariableMap_hasTarget_InstanceVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstanceVariableMap_hasTarget_InstanceVariable (*this, f, c);
  }

  InstanceVariableMap_hasTarget_InstanceVariable::
  ~InstanceVariableMap_hasTarget_InstanceVariable ()
  {
  }

  // InstanceVariableMap_hasSource_InstanceVariable
  //

  InstanceVariableMap_hasSource_InstanceVariable::
  InstanceVariableMap_hasSource_InstanceVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  InstanceVariableMap_hasSource_InstanceVariable::
  InstanceVariableMap_hasSource_InstanceVariable (const InstanceVariableMap_hasSource_InstanceVariable& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  InstanceVariableMap_hasSource_InstanceVariable::
  InstanceVariableMap_hasSource_InstanceVariable (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  InstanceVariableMap_hasSource_InstanceVariable* InstanceVariableMap_hasSource_InstanceVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InstanceVariableMap_hasSource_InstanceVariable (*this, f, c);
  }

  InstanceVariableMap_hasSource_InstanceVariable::
  ~InstanceVariableMap_hasSource_InstanceVariable ()
  {
  }

  // Key_correspondsTo_Unit
  //

  Key_correspondsTo_Unit::
  Key_correspondsTo_Unit ()
  : ::XMLSchema::Reference ()
  {
  }

  Key_correspondsTo_Unit::
  Key_correspondsTo_Unit (const Key_correspondsTo_Unit& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Key_correspondsTo_Unit::
  Key_correspondsTo_Unit (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Key_correspondsTo_Unit* Key_correspondsTo_Unit::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Key_correspondsTo_Unit (*this, f, c);
  }

  Key_correspondsTo_Unit::
  ~Key_correspondsTo_Unit ()
  {
  }

  // Key_represents_KeyDefinition
  //

  Key_represents_KeyDefinition::
  Key_represents_KeyDefinition ()
  : ::XMLSchema::Reference ()
  {
  }

  Key_represents_KeyDefinition::
  Key_represents_KeyDefinition (const Key_represents_KeyDefinition& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Key_represents_KeyDefinition::
  Key_represents_KeyDefinition (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Key_represents_KeyDefinition* Key_represents_KeyDefinition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Key_represents_KeyDefinition (*this, f, c);
  }

  Key_represents_KeyDefinition::
  ~Key_represents_KeyDefinition ()
  {
  }

  // Key_identifies_DataPoint
  //

  Key_identifies_DataPoint::
  Key_identifies_DataPoint ()
  : ::XMLSchema::Reference ()
  {
  }

  Key_identifies_DataPoint::
  Key_identifies_DataPoint (const Key_identifies_DataPoint& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Key_identifies_DataPoint::
  Key_identifies_DataPoint (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Key_identifies_DataPoint* Key_identifies_DataPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Key_identifies_DataPoint (*this, f, c);
  }

  Key_identifies_DataPoint::
  ~Key_identifies_DataPoint ()
  {
  }

  // Key_correspondsTo_Universe
  //

  Key_correspondsTo_Universe::
  Key_correspondsTo_Universe ()
  : ::XMLSchema::Reference ()
  {
  }

  Key_correspondsTo_Universe::
  Key_correspondsTo_Universe (const Key_correspondsTo_Universe& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Key_correspondsTo_Universe::
  Key_correspondsTo_Universe (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Key_correspondsTo_Universe* Key_correspondsTo_Universe::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Key_correspondsTo_Universe (*this, f, c);
  }

  Key_correspondsTo_Universe::
  ~Key_correspondsTo_Universe ()
  {
  }

  // Key_has_KeyMember
  //

  Key_has_KeyMember::
  Key_has_KeyMember ()
  : ::XMLSchema::Reference ()
  {
  }

  Key_has_KeyMember::
  Key_has_KeyMember (const Key_has_KeyMember& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Key_has_KeyMember::
  Key_has_KeyMember (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Key_has_KeyMember* Key_has_KeyMember::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Key_has_KeyMember (*this, f, c);
  }

  Key_has_KeyMember::
  ~Key_has_KeyMember ()
  {
  }

  // KeyDefinition_correspondsTo_Universe
  //

  KeyDefinition_correspondsTo_Universe::
  KeyDefinition_correspondsTo_Universe ()
  : ::XMLSchema::Reference ()
  {
  }

  KeyDefinition_correspondsTo_Universe::
  KeyDefinition_correspondsTo_Universe (const KeyDefinition_correspondsTo_Universe& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  KeyDefinition_correspondsTo_Universe::
  KeyDefinition_correspondsTo_Universe (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  KeyDefinition_correspondsTo_Universe* KeyDefinition_correspondsTo_Universe::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class KeyDefinition_correspondsTo_Universe (*this, f, c);
  }

  KeyDefinition_correspondsTo_Universe::
  ~KeyDefinition_correspondsTo_Universe ()
  {
  }

  // KeyDefinition_correspondsTo_Unit
  //

  KeyDefinition_correspondsTo_Unit::
  KeyDefinition_correspondsTo_Unit ()
  : ::XMLSchema::Reference ()
  {
  }

  KeyDefinition_correspondsTo_Unit::
  KeyDefinition_correspondsTo_Unit (const KeyDefinition_correspondsTo_Unit& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  KeyDefinition_correspondsTo_Unit::
  KeyDefinition_correspondsTo_Unit (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  KeyDefinition_correspondsTo_Unit* KeyDefinition_correspondsTo_Unit::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class KeyDefinition_correspondsTo_Unit (*this, f, c);
  }

  KeyDefinition_correspondsTo_Unit::
  ~KeyDefinition_correspondsTo_Unit ()
  {
  }

  // KeyDefinition_has_KeyDefinitionMember
  //

  KeyDefinition_has_KeyDefinitionMember::
  KeyDefinition_has_KeyDefinitionMember ()
  : ::XMLSchema::Reference ()
  {
  }

  KeyDefinition_has_KeyDefinitionMember::
  KeyDefinition_has_KeyDefinitionMember (const KeyDefinition_has_KeyDefinitionMember& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  KeyDefinition_has_KeyDefinitionMember::
  KeyDefinition_has_KeyDefinitionMember (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  KeyDefinition_has_KeyDefinitionMember* KeyDefinition_has_KeyDefinitionMember::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class KeyDefinition_has_KeyDefinitionMember (*this, f, c);
  }

  KeyDefinition_has_KeyDefinitionMember::
  ~KeyDefinition_has_KeyDefinitionMember ()
  {
  }

  // KeyMember_isBasedOn_DataStructureComponent
  //

  KeyMember_isBasedOn_DataStructureComponent::
  KeyMember_isBasedOn_DataStructureComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  KeyMember_isBasedOn_DataStructureComponent::
  KeyMember_isBasedOn_DataStructureComponent (const KeyMember_isBasedOn_DataStructureComponent& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  KeyMember_isBasedOn_DataStructureComponent::
  KeyMember_isBasedOn_DataStructureComponent (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  KeyMember_isBasedOn_DataStructureComponent* KeyMember_isBasedOn_DataStructureComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class KeyMember_isBasedOn_DataStructureComponent (*this, f, c);
  }

  KeyMember_isBasedOn_DataStructureComponent::
  ~KeyMember_isBasedOn_DataStructureComponent ()
  {
  }

  // Level_isDefinedBy_Concept
  //

  Level_isDefinedBy_Concept::
  Level_isDefinedBy_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  Level_isDefinedBy_Concept::
  Level_isDefinedBy_Concept (const Level_isDefinedBy_Concept& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Level_isDefinedBy_Concept::
  Level_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Level_isDefinedBy_Concept* Level_isDefinedBy_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Level_isDefinedBy_Concept (*this, f, c);
  }

  Level_isDefinedBy_Concept::
  ~Level_isDefinedBy_Concept ()
  {
  }

  // Level_groups_ClassificationItem
  //

  Level_groups_ClassificationItem::
  Level_groups_ClassificationItem ()
  : ::XMLSchema::Reference ()
  {
  }

  Level_groups_ClassificationItem::
  Level_groups_ClassificationItem (const Level_groups_ClassificationItem& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Level_groups_ClassificationItem::
  Level_groups_ClassificationItem (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Level_groups_ClassificationItem* Level_groups_ClassificationItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Level_groups_ClassificationItem (*this, f, c);
  }

  Level_groups_ClassificationItem::
  ~Level_groups_ClassificationItem ()
  {
  }

  // LevelStructure_has_Level
  //

  LevelStructure_has_Level::
  LevelStructure_has_Level ()
  : ::XMLSchema::Reference ()
  {
  }

  LevelStructure_has_Level::
  LevelStructure_has_Level (const LevelStructure_has_Level& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  LevelStructure_has_Level::
  LevelStructure_has_Level (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  LevelStructure_has_Level* LevelStructure_has_Level::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LevelStructure_has_Level (*this, f, c);
  }

  LevelStructure_has_Level::
  ~LevelStructure_has_Level ()
  {
  }

  // LogicalRecord_organizes_DataSet
  //

  LogicalRecord_organizes_DataSet::
  LogicalRecord_organizes_DataSet ()
  : ::XMLSchema::Reference ()
  {
  }

  LogicalRecord_organizes_DataSet::
  LogicalRecord_organizes_DataSet (const LogicalRecord_organizes_DataSet& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  LogicalRecord_organizes_DataSet::
  LogicalRecord_organizes_DataSet (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  LogicalRecord_organizes_DataSet* LogicalRecord_organizes_DataSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalRecord_organizes_DataSet (*this, f, c);
  }

  LogicalRecord_organizes_DataSet::
  ~LogicalRecord_organizes_DataSet ()
  {
  }

  // LogicalRecord_isDefinedBy_Concept
  //

  LogicalRecord_isDefinedBy_Concept::
  LogicalRecord_isDefinedBy_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  LogicalRecord_isDefinedBy_Concept::
  LogicalRecord_isDefinedBy_Concept (const LogicalRecord_isDefinedBy_Concept& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  LogicalRecord_isDefinedBy_Concept::
  LogicalRecord_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  LogicalRecord_isDefinedBy_Concept* LogicalRecord_isDefinedBy_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalRecord_isDefinedBy_Concept (*this, f, c);
  }

  LogicalRecord_isDefinedBy_Concept::
  ~LogicalRecord_isDefinedBy_Concept ()
  {
  }

  // LogicalRecord_has_InstanceVariable
  //

  LogicalRecord_has_InstanceVariable::
  LogicalRecord_has_InstanceVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  LogicalRecord_has_InstanceVariable::
  LogicalRecord_has_InstanceVariable (const LogicalRecord_has_InstanceVariable& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  LogicalRecord_has_InstanceVariable::
  LogicalRecord_has_InstanceVariable (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  LogicalRecord_has_InstanceVariable* LogicalRecord_has_InstanceVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalRecord_has_InstanceVariable (*this, f, c);
  }

  LogicalRecord_has_InstanceVariable::
  ~LogicalRecord_has_InstanceVariable ()
  {
  }

  // LogicalRecordPosition_indexes_LogicalRecord
  //

  LogicalRecordPosition_indexes_LogicalRecord::
  LogicalRecordPosition_indexes_LogicalRecord ()
  : ::XMLSchema::Reference ()
  {
  }

  LogicalRecordPosition_indexes_LogicalRecord::
  LogicalRecordPosition_indexes_LogicalRecord (const LogicalRecordPosition_indexes_LogicalRecord& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  LogicalRecordPosition_indexes_LogicalRecord::
  LogicalRecordPosition_indexes_LogicalRecord (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  LogicalRecordPosition_indexes_LogicalRecord* LogicalRecordPosition_indexes_LogicalRecord::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalRecordPosition_indexes_LogicalRecord (*this, f, c);
  }

  LogicalRecordPosition_indexes_LogicalRecord::
  ~LogicalRecordPosition_indexes_LogicalRecord ()
  {
  }

  // LogicalRecordRelationStructure_structures_DataStore
  //

  LogicalRecordRelationStructure_structures_DataStore::
  LogicalRecordRelationStructure_structures_DataStore ()
  : ::XMLSchema::Reference ()
  {
  }

  LogicalRecordRelationStructure_structures_DataStore::
  LogicalRecordRelationStructure_structures_DataStore (const LogicalRecordRelationStructure_structures_DataStore& x,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  LogicalRecordRelationStructure_structures_DataStore::
  LogicalRecordRelationStructure_structures_DataStore (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  LogicalRecordRelationStructure_structures_DataStore* LogicalRecordRelationStructure_structures_DataStore::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalRecordRelationStructure_structures_DataStore (*this, f, c);
  }

  LogicalRecordRelationStructure_structures_DataStore::
  ~LogicalRecordRelationStructure_structures_DataStore ()
  {
  }

  // LogicalRecordRelationStructure_has_LogicalRecordRelationship
  //

  LogicalRecordRelationStructure_has_LogicalRecordRelationship::
  LogicalRecordRelationStructure_has_LogicalRecordRelationship ()
  : ::XMLSchema::Reference ()
  {
  }

  LogicalRecordRelationStructure_has_LogicalRecordRelationship::
  LogicalRecordRelationStructure_has_LogicalRecordRelationship (const LogicalRecordRelationStructure_has_LogicalRecordRelationship& x,
                                                                ::xml_schema::flags f,
                                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  LogicalRecordRelationStructure_has_LogicalRecordRelationship::
  LogicalRecordRelationStructure_has_LogicalRecordRelationship (const ::xercesc::DOMElement& e,
                                                                ::xml_schema::flags f,
                                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  LogicalRecordRelationStructure_has_LogicalRecordRelationship* LogicalRecordRelationStructure_has_LogicalRecordRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalRecordRelationStructure_has_LogicalRecordRelationship (*this, f, c);
  }

  LogicalRecordRelationStructure_has_LogicalRecordRelationship::
  ~LogicalRecordRelationStructure_has_LogicalRecordRelationship ()
  {
  }

  // LogicalRecordRelationship_hasTarget_LogicalRecord
  //

  LogicalRecordRelationship_hasTarget_LogicalRecord::
  LogicalRecordRelationship_hasTarget_LogicalRecord ()
  : ::XMLSchema::Reference ()
  {
  }

  LogicalRecordRelationship_hasTarget_LogicalRecord::
  LogicalRecordRelationship_hasTarget_LogicalRecord (const LogicalRecordRelationship_hasTarget_LogicalRecord& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  LogicalRecordRelationship_hasTarget_LogicalRecord::
  LogicalRecordRelationship_hasTarget_LogicalRecord (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  LogicalRecordRelationship_hasTarget_LogicalRecord* LogicalRecordRelationship_hasTarget_LogicalRecord::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalRecordRelationship_hasTarget_LogicalRecord (*this, f, c);
  }

  LogicalRecordRelationship_hasTarget_LogicalRecord::
  ~LogicalRecordRelationship_hasTarget_LogicalRecord ()
  {
  }

  // LogicalRecordRelationship_hasSource_LogicalRecord
  //

  LogicalRecordRelationship_hasSource_LogicalRecord::
  LogicalRecordRelationship_hasSource_LogicalRecord ()
  : ::XMLSchema::Reference ()
  {
  }

  LogicalRecordRelationship_hasSource_LogicalRecord::
  LogicalRecordRelationship_hasSource_LogicalRecord (const LogicalRecordRelationship_hasSource_LogicalRecord& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  LogicalRecordRelationship_hasSource_LogicalRecord::
  LogicalRecordRelationship_hasSource_LogicalRecord (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  LogicalRecordRelationship_hasSource_LogicalRecord* LogicalRecordRelationship_hasSource_LogicalRecord::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalRecordRelationship_hasSource_LogicalRecord (*this, f, c);
  }

  LogicalRecordRelationship_hasSource_LogicalRecord::
  ~LogicalRecordRelationship_hasSource_LogicalRecord ()
  {
  }

  // MainKeyMember_hasValueFrom_SubstantiveValueDomain
  //

  MainKeyMember_hasValueFrom_SubstantiveValueDomain::
  MainKeyMember_hasValueFrom_SubstantiveValueDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  MainKeyMember_hasValueFrom_SubstantiveValueDomain::
  MainKeyMember_hasValueFrom_SubstantiveValueDomain (const MainKeyMember_hasValueFrom_SubstantiveValueDomain& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  MainKeyMember_hasValueFrom_SubstantiveValueDomain::
  MainKeyMember_hasValueFrom_SubstantiveValueDomain (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  MainKeyMember_hasValueFrom_SubstantiveValueDomain* MainKeyMember_hasValueFrom_SubstantiveValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MainKeyMember_hasValueFrom_SubstantiveValueDomain (*this, f, c);
  }

  MainKeyMember_hasValueFrom_SubstantiveValueDomain::
  ~MainKeyMember_hasValueFrom_SubstantiveValueDomain ()
  {
  }

  // Notation_represents_Category
  //

  Notation_represents_Category::
  Notation_represents_Category ()
  : ::XMLSchema::Reference ()
  {
  }

  Notation_represents_Category::
  Notation_represents_Category (const Notation_represents_Category& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Notation_represents_Category::
  Notation_represents_Category (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Notation_represents_Category* Notation_represents_Category::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Notation_represents_Category (*this, f, c);
  }

  Notation_represents_Category::
  ~Notation_represents_Category ()
  {
  }

  // entityBound
  //

  entityBound::
  entityBound ()
  : ::XMLSchema::Reference ()
  {
  }

  entityBound::
  entityBound (const entityBound& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  entityBound::
  entityBound (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  entityBound* entityBound::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class entityBound (*this, f, c);
  }

  entityBound::
  ~entityBound ()
  {
  }

  // PhysicalDataSet_isDefinedBy_Concept
  //

  PhysicalDataSet_isDefinedBy_Concept::
  PhysicalDataSet_isDefinedBy_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalDataSet_isDefinedBy_Concept::
  PhysicalDataSet_isDefinedBy_Concept (const PhysicalDataSet_isDefinedBy_Concept& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalDataSet_isDefinedBy_Concept::
  PhysicalDataSet_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalDataSet_isDefinedBy_Concept* PhysicalDataSet_isDefinedBy_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalDataSet_isDefinedBy_Concept (*this, f, c);
  }

  PhysicalDataSet_isDefinedBy_Concept::
  ~PhysicalDataSet_isDefinedBy_Concept ()
  {
  }

  // PhysicalDataSet_formats_DataStore
  //

  PhysicalDataSet_formats_DataStore::
  PhysicalDataSet_formats_DataStore ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalDataSet_formats_DataStore::
  PhysicalDataSet_formats_DataStore (const PhysicalDataSet_formats_DataStore& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalDataSet_formats_DataStore::
  PhysicalDataSet_formats_DataStore (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalDataSet_formats_DataStore* PhysicalDataSet_formats_DataStore::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalDataSet_formats_DataStore (*this, f, c);
  }

  PhysicalDataSet_formats_DataStore::
  ~PhysicalDataSet_formats_DataStore ()
  {
  }

  // PhysicalDataSet_has_InstanceVariable
  //

  PhysicalDataSet_has_InstanceVariable::
  PhysicalDataSet_has_InstanceVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalDataSet_has_InstanceVariable::
  PhysicalDataSet_has_InstanceVariable (const PhysicalDataSet_has_InstanceVariable& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalDataSet_has_InstanceVariable::
  PhysicalDataSet_has_InstanceVariable (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalDataSet_has_InstanceVariable* PhysicalDataSet_has_InstanceVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalDataSet_has_InstanceVariable (*this, f, c);
  }

  PhysicalDataSet_has_InstanceVariable::
  ~PhysicalDataSet_has_InstanceVariable ()
  {
  }

  // PhysicalDataSet_has_PhysicalRecordSegment
  //

  PhysicalDataSet_has_PhysicalRecordSegment::
  PhysicalDataSet_has_PhysicalRecordSegment ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalDataSet_has_PhysicalRecordSegment::
  PhysicalDataSet_has_PhysicalRecordSegment (const PhysicalDataSet_has_PhysicalRecordSegment& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalDataSet_has_PhysicalRecordSegment::
  PhysicalDataSet_has_PhysicalRecordSegment (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalDataSet_has_PhysicalRecordSegment* PhysicalDataSet_has_PhysicalRecordSegment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalDataSet_has_PhysicalRecordSegment (*this, f, c);
  }

  PhysicalDataSet_has_PhysicalRecordSegment::
  ~PhysicalDataSet_has_PhysicalRecordSegment ()
  {
  }

  // PhysicalDataSet_has_PhysicalRecordSegmentPosition
  //

  PhysicalDataSet_has_PhysicalRecordSegmentPosition::
  PhysicalDataSet_has_PhysicalRecordSegmentPosition ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalDataSet_has_PhysicalRecordSegmentPosition::
  PhysicalDataSet_has_PhysicalRecordSegmentPosition (const PhysicalDataSet_has_PhysicalRecordSegmentPosition& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalDataSet_has_PhysicalRecordSegmentPosition::
  PhysicalDataSet_has_PhysicalRecordSegmentPosition (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalDataSet_has_PhysicalRecordSegmentPosition* PhysicalDataSet_has_PhysicalRecordSegmentPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalDataSet_has_PhysicalRecordSegmentPosition (*this, f, c);
  }

  PhysicalDataSet_has_PhysicalRecordSegmentPosition::
  ~PhysicalDataSet_has_PhysicalRecordSegmentPosition ()
  {
  }

  // PhysicalDataSetStructure_structures_PhysicalDataSet
  //

  PhysicalDataSetStructure_structures_PhysicalDataSet::
  PhysicalDataSetStructure_structures_PhysicalDataSet ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalDataSetStructure_structures_PhysicalDataSet::
  PhysicalDataSetStructure_structures_PhysicalDataSet (const PhysicalDataSetStructure_structures_PhysicalDataSet& x,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalDataSetStructure_structures_PhysicalDataSet::
  PhysicalDataSetStructure_structures_PhysicalDataSet (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalDataSetStructure_structures_PhysicalDataSet* PhysicalDataSetStructure_structures_PhysicalDataSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalDataSetStructure_structures_PhysicalDataSet (*this, f, c);
  }

  PhysicalDataSetStructure_structures_PhysicalDataSet::
  ~PhysicalDataSetStructure_structures_PhysicalDataSet ()
  {
  }

  // PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship
  //

  PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship::
  PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship::
  PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship (const PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship& x,
                                                                  ::xml_schema::flags f,
                                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship::
  PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship (const ::xercesc::DOMElement& e,
                                                                  ::xml_schema::flags f,
                                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship* PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship (*this, f, c);
  }

  PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship::
  ~PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship ()
  {
  }

  // PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout
  //

  PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout::
  PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout::
  PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout (const PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout& x,
                                                                    ::xml_schema::flags f,
                                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout::
  PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout (const ::xercesc::DOMElement& e,
                                                                    ::xml_schema::flags f,
                                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout* PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout (*this, f, c);
  }

  PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout::
  ~PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout ()
  {
  }

  // PhysicalLayoutRelationStructure_has_ValueMappingRelationship
  //

  PhysicalLayoutRelationStructure_has_ValueMappingRelationship::
  PhysicalLayoutRelationStructure_has_ValueMappingRelationship ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalLayoutRelationStructure_has_ValueMappingRelationship::
  PhysicalLayoutRelationStructure_has_ValueMappingRelationship (const PhysicalLayoutRelationStructure_has_ValueMappingRelationship& x,
                                                                ::xml_schema::flags f,
                                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalLayoutRelationStructure_has_ValueMappingRelationship::
  PhysicalLayoutRelationStructure_has_ValueMappingRelationship (const ::xercesc::DOMElement& e,
                                                                ::xml_schema::flags f,
                                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalLayoutRelationStructure_has_ValueMappingRelationship* PhysicalLayoutRelationStructure_has_ValueMappingRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalLayoutRelationStructure_has_ValueMappingRelationship (*this, f, c);
  }

  PhysicalLayoutRelationStructure_has_ValueMappingRelationship::
  ~PhysicalLayoutRelationStructure_has_ValueMappingRelationship ()
  {
  }

  // PhysicalRecordSegment_represents_Population
  //

  PhysicalRecordSegment_represents_Population::
  PhysicalRecordSegment_represents_Population ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalRecordSegment_represents_Population::
  PhysicalRecordSegment_represents_Population (const PhysicalRecordSegment_represents_Population& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalRecordSegment_represents_Population::
  PhysicalRecordSegment_represents_Population (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalRecordSegment_represents_Population* PhysicalRecordSegment_represents_Population::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegment_represents_Population (*this, f, c);
  }

  PhysicalRecordSegment_represents_Population::
  ~PhysicalRecordSegment_represents_Population ()
  {
  }

  // PhysicalRecordSegment_isDefinedBy_Concept
  //

  PhysicalRecordSegment_isDefinedBy_Concept::
  PhysicalRecordSegment_isDefinedBy_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalRecordSegment_isDefinedBy_Concept::
  PhysicalRecordSegment_isDefinedBy_Concept (const PhysicalRecordSegment_isDefinedBy_Concept& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalRecordSegment_isDefinedBy_Concept::
  PhysicalRecordSegment_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalRecordSegment_isDefinedBy_Concept* PhysicalRecordSegment_isDefinedBy_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegment_isDefinedBy_Concept (*this, f, c);
  }

  PhysicalRecordSegment_isDefinedBy_Concept::
  ~PhysicalRecordSegment_isDefinedBy_Concept ()
  {
  }

  // PhysicalRecordSegment_has_PhysicalSegmentLayout
  //

  PhysicalRecordSegment_has_PhysicalSegmentLayout::
  PhysicalRecordSegment_has_PhysicalSegmentLayout ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalRecordSegment_has_PhysicalSegmentLayout::
  PhysicalRecordSegment_has_PhysicalSegmentLayout (const PhysicalRecordSegment_has_PhysicalSegmentLayout& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalRecordSegment_has_PhysicalSegmentLayout::
  PhysicalRecordSegment_has_PhysicalSegmentLayout (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalRecordSegment_has_PhysicalSegmentLayout* PhysicalRecordSegment_has_PhysicalSegmentLayout::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegment_has_PhysicalSegmentLayout (*this, f, c);
  }

  PhysicalRecordSegment_has_PhysicalSegmentLayout::
  ~PhysicalRecordSegment_has_PhysicalSegmentLayout ()
  {
  }

  // PhysicalRecordSegment_mapsTo_LogicalRecord
  //

  PhysicalRecordSegment_mapsTo_LogicalRecord::
  PhysicalRecordSegment_mapsTo_LogicalRecord ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalRecordSegment_mapsTo_LogicalRecord::
  PhysicalRecordSegment_mapsTo_LogicalRecord (const PhysicalRecordSegment_mapsTo_LogicalRecord& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalRecordSegment_mapsTo_LogicalRecord::
  PhysicalRecordSegment_mapsTo_LogicalRecord (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalRecordSegment_mapsTo_LogicalRecord* PhysicalRecordSegment_mapsTo_LogicalRecord::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegment_mapsTo_LogicalRecord (*this, f, c);
  }

  PhysicalRecordSegment_mapsTo_LogicalRecord::
  ~PhysicalRecordSegment_mapsTo_LogicalRecord ()
  {
  }

  // PhysicalRecordSegment_has_DataPointPosition
  //

  PhysicalRecordSegment_has_DataPointPosition::
  PhysicalRecordSegment_has_DataPointPosition ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalRecordSegment_has_DataPointPosition::
  PhysicalRecordSegment_has_DataPointPosition (const PhysicalRecordSegment_has_DataPointPosition& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalRecordSegment_has_DataPointPosition::
  PhysicalRecordSegment_has_DataPointPosition (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalRecordSegment_has_DataPointPosition* PhysicalRecordSegment_has_DataPointPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegment_has_DataPointPosition (*this, f, c);
  }

  PhysicalRecordSegment_has_DataPointPosition::
  ~PhysicalRecordSegment_has_DataPointPosition ()
  {
  }

  // PhysicalRecordSegment_has_DataPoint
  //

  PhysicalRecordSegment_has_DataPoint::
  PhysicalRecordSegment_has_DataPoint ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalRecordSegment_has_DataPoint::
  PhysicalRecordSegment_has_DataPoint (const PhysicalRecordSegment_has_DataPoint& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalRecordSegment_has_DataPoint::
  PhysicalRecordSegment_has_DataPoint (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalRecordSegment_has_DataPoint* PhysicalRecordSegment_has_DataPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegment_has_DataPoint (*this, f, c);
  }

  PhysicalRecordSegment_has_DataPoint::
  ~PhysicalRecordSegment_has_DataPoint ()
  {
  }

  // PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment
  //

  PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment::
  PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment::
  PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment (const PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment& x,
                                                               ::xml_schema::flags f,
                                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment::
  PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment (const ::xercesc::DOMElement& e,
                                                               ::xml_schema::flags f,
                                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment* PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment (*this, f, c);
  }

  PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment::
  ~PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment ()
  {
  }

  // PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment
  //

  PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment::
  PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment::
  PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment (const PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment& x,
                                                                     ::xml_schema::flags f,
                                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment::
  PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment (const ::xercesc::DOMElement& e,
                                                                     ::xml_schema::flags f,
                                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment* PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment (*this, f, c);
  }

  PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment::
  ~PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment ()
  {
  }

  // PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment
  //

  PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment::
  PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment::
  PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment (const PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment& x,
                                                                     ::xml_schema::flags f,
                                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment::
  PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment (const ::xercesc::DOMElement& e,
                                                                     ::xml_schema::flags f,
                                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment* PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment (*this, f, c);
  }

  PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment::
  ~PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment ()
  {
  }

  // PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment
  //

  PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment::
  PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment::
  PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment (const PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment& x,
                                                                   ::xml_schema::flags f,
                                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment::
  PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment (const ::xercesc::DOMElement& e,
                                                                   ::xml_schema::flags f,
                                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment* PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment (*this, f, c);
  }

  PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment::
  ~PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment ()
  {
  }

  // PhysicalRecordSegmentStructure_has_DataPointRelationship
  //

  PhysicalRecordSegmentStructure_has_DataPointRelationship::
  PhysicalRecordSegmentStructure_has_DataPointRelationship ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalRecordSegmentStructure_has_DataPointRelationship::
  PhysicalRecordSegmentStructure_has_DataPointRelationship (const PhysicalRecordSegmentStructure_has_DataPointRelationship& x,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalRecordSegmentStructure_has_DataPointRelationship::
  PhysicalRecordSegmentStructure_has_DataPointRelationship (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalRecordSegmentStructure_has_DataPointRelationship* PhysicalRecordSegmentStructure_has_DataPointRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalRecordSegmentStructure_has_DataPointRelationship (*this, f, c);
  }

  PhysicalRecordSegmentStructure_has_DataPointRelationship::
  ~PhysicalRecordSegmentStructure_has_DataPointRelationship ()
  {
  }

  // PhysicalSegmentLayout_isDefinedBy_Concept
  //

  PhysicalSegmentLayout_isDefinedBy_Concept::
  PhysicalSegmentLayout_isDefinedBy_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalSegmentLayout_isDefinedBy_Concept::
  PhysicalSegmentLayout_isDefinedBy_Concept (const PhysicalSegmentLayout_isDefinedBy_Concept& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalSegmentLayout_isDefinedBy_Concept::
  PhysicalSegmentLayout_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalSegmentLayout_isDefinedBy_Concept* PhysicalSegmentLayout_isDefinedBy_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalSegmentLayout_isDefinedBy_Concept (*this, f, c);
  }

  PhysicalSegmentLayout_isDefinedBy_Concept::
  ~PhysicalSegmentLayout_isDefinedBy_Concept ()
  {
  }

  // PhysicalSegmentLayout_formats_LogicalRecord
  //

  PhysicalSegmentLayout_formats_LogicalRecord::
  PhysicalSegmentLayout_formats_LogicalRecord ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalSegmentLayout_formats_LogicalRecord::
  PhysicalSegmentLayout_formats_LogicalRecord (const PhysicalSegmentLayout_formats_LogicalRecord& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalSegmentLayout_formats_LogicalRecord::
  PhysicalSegmentLayout_formats_LogicalRecord (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalSegmentLayout_formats_LogicalRecord* PhysicalSegmentLayout_formats_LogicalRecord::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalSegmentLayout_formats_LogicalRecord (*this, f, c);
  }

  PhysicalSegmentLayout_formats_LogicalRecord::
  ~PhysicalSegmentLayout_formats_LogicalRecord ()
  {
  }

  // PhysicalSegmentLayout_has_ValueMapping
  //

  PhysicalSegmentLayout_has_ValueMapping::
  PhysicalSegmentLayout_has_ValueMapping ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalSegmentLayout_has_ValueMapping::
  PhysicalSegmentLayout_has_ValueMapping (const PhysicalSegmentLayout_has_ValueMapping& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalSegmentLayout_has_ValueMapping::
  PhysicalSegmentLayout_has_ValueMapping (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalSegmentLayout_has_ValueMapping* PhysicalSegmentLayout_has_ValueMapping::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalSegmentLayout_has_ValueMapping (*this, f, c);
  }

  PhysicalSegmentLayout_has_ValueMapping::
  ~PhysicalSegmentLayout_has_ValueMapping ()
  {
  }

  // PhysicalSegmentLayout_has_ValueMappingPosition
  //

  PhysicalSegmentLayout_has_ValueMappingPosition::
  PhysicalSegmentLayout_has_ValueMappingPosition ()
  : ::XMLSchema::Reference ()
  {
  }

  PhysicalSegmentLayout_has_ValueMappingPosition::
  PhysicalSegmentLayout_has_ValueMappingPosition (const PhysicalSegmentLayout_has_ValueMappingPosition& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PhysicalSegmentLayout_has_ValueMappingPosition::
  PhysicalSegmentLayout_has_ValueMappingPosition (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PhysicalSegmentLayout_has_ValueMappingPosition* PhysicalSegmentLayout_has_ValueMappingPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalSegmentLayout_has_ValueMappingPosition (*this, f, c);
  }

  PhysicalSegmentLayout_has_ValueMappingPosition::
  ~PhysicalSegmentLayout_has_ValueMappingPosition ()
  {
  }

  // Population_isComposedOf_Unit
  //

  Population_isComposedOf_Unit::
  Population_isComposedOf_Unit ()
  : ::XMLSchema::Reference ()
  {
  }

  Population_isComposedOf_Unit::
  Population_isComposedOf_Unit (const Population_isComposedOf_Unit& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Population_isComposedOf_Unit::
  Population_isComposedOf_Unit (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Population_isComposedOf_Unit* Population_isComposedOf_Unit::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Population_isComposedOf_Unit (*this, f, c);
  }

  Population_isComposedOf_Unit::
  ~Population_isComposedOf_Unit ()
  {
  }

  // PrimaryKey_isComposedOf_PrimaryKeyComponent
  //

  PrimaryKey_isComposedOf_PrimaryKeyComponent::
  PrimaryKey_isComposedOf_PrimaryKeyComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  PrimaryKey_isComposedOf_PrimaryKeyComponent::
  PrimaryKey_isComposedOf_PrimaryKeyComponent (const PrimaryKey_isComposedOf_PrimaryKeyComponent& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PrimaryKey_isComposedOf_PrimaryKeyComponent::
  PrimaryKey_isComposedOf_PrimaryKeyComponent (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PrimaryKey_isComposedOf_PrimaryKeyComponent* PrimaryKey_isComposedOf_PrimaryKeyComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PrimaryKey_isComposedOf_PrimaryKeyComponent (*this, f, c);
  }

  PrimaryKey_isComposedOf_PrimaryKeyComponent::
  ~PrimaryKey_isComposedOf_PrimaryKeyComponent ()
  {
  }

  // PrimaryKeyComponent_correspondsTo_DataStructureComponent
  //

  PrimaryKeyComponent_correspondsTo_DataStructureComponent::
  PrimaryKeyComponent_correspondsTo_DataStructureComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  PrimaryKeyComponent_correspondsTo_DataStructureComponent::
  PrimaryKeyComponent_correspondsTo_DataStructureComponent (const PrimaryKeyComponent_correspondsTo_DataStructureComponent& x,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  PrimaryKeyComponent_correspondsTo_DataStructureComponent::
  PrimaryKeyComponent_correspondsTo_DataStructureComponent (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  PrimaryKeyComponent_correspondsTo_DataStructureComponent* PrimaryKeyComponent_correspondsTo_DataStructureComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PrimaryKeyComponent_correspondsTo_DataStructureComponent (*this, f, c);
  }

  PrimaryKeyComponent_correspondsTo_DataStructureComponent::
  ~PrimaryKeyComponent_correspondsTo_DataStructureComponent ()
  {
  }

  // ProcessingAgent_performs_Activity
  //

  ProcessingAgent_performs_Activity::
  ProcessingAgent_performs_Activity ()
  : ::XMLSchema::Reference ()
  {
  }

  ProcessingAgent_performs_Activity::
  ProcessingAgent_performs_Activity (const ProcessingAgent_performs_Activity& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ProcessingAgent_performs_Activity::
  ProcessingAgent_performs_Activity (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ProcessingAgent_performs_Activity* ProcessingAgent_performs_Activity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProcessingAgent_performs_Activity (*this, f, c);
  }

  ProcessingAgent_performs_Activity::
  ~ProcessingAgent_performs_Activity ()
  {
  }

  // ProcessingAgent_operatesOn_ProductionEnvironment
  //

  ProcessingAgent_operatesOn_ProductionEnvironment::
  ProcessingAgent_operatesOn_ProductionEnvironment ()
  : ::XMLSchema::Reference ()
  {
  }

  ProcessingAgent_operatesOn_ProductionEnvironment::
  ProcessingAgent_operatesOn_ProductionEnvironment (const ProcessingAgent_operatesOn_ProductionEnvironment& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ProcessingAgent_operatesOn_ProductionEnvironment::
  ProcessingAgent_operatesOn_ProductionEnvironment (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ProcessingAgent_operatesOn_ProductionEnvironment* ProcessingAgent_operatesOn_ProductionEnvironment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProcessingAgent_operatesOn_ProductionEnvironment (*this, f, c);
  }

  ProcessingAgent_operatesOn_ProductionEnvironment::
  ~ProcessingAgent_operatesOn_ProductionEnvironment ()
  {
  }

  // QualifiedMeasure_refines_MeasureComponent
  //

  QualifiedMeasure_refines_MeasureComponent::
  QualifiedMeasure_refines_MeasureComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  QualifiedMeasure_refines_MeasureComponent::
  QualifiedMeasure_refines_MeasureComponent (const QualifiedMeasure_refines_MeasureComponent& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  QualifiedMeasure_refines_MeasureComponent::
  QualifiedMeasure_refines_MeasureComponent (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  QualifiedMeasure_refines_MeasureComponent* QualifiedMeasure_refines_MeasureComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class QualifiedMeasure_refines_MeasureComponent (*this, f, c);
  }

  QualifiedMeasure_refines_MeasureComponent::
  ~QualifiedMeasure_refines_MeasureComponent ()
  {
  }

  // RecordRelation_maps_LogicalRecord
  //

  RecordRelation_maps_LogicalRecord::
  RecordRelation_maps_LogicalRecord ()
  : ::XMLSchema::Reference ()
  {
  }

  RecordRelation_maps_LogicalRecord::
  RecordRelation_maps_LogicalRecord (const RecordRelation_maps_LogicalRecord& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  RecordRelation_maps_LogicalRecord::
  RecordRelation_maps_LogicalRecord (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  RecordRelation_maps_LogicalRecord* RecordRelation_maps_LogicalRecord::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RecordRelation_maps_LogicalRecord (*this, f, c);
  }

  RecordRelation_maps_LogicalRecord::
  ~RecordRelation_maps_LogicalRecord ()
  {
  }

  // RecordRelation_has_InstanceVariableMap
  //

  RecordRelation_has_InstanceVariableMap::
  RecordRelation_has_InstanceVariableMap ()
  : ::XMLSchema::Reference ()
  {
  }

  RecordRelation_has_InstanceVariableMap::
  RecordRelation_has_InstanceVariableMap (const RecordRelation_has_InstanceVariableMap& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  RecordRelation_has_InstanceVariableMap::
  RecordRelation_has_InstanceVariableMap (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  RecordRelation_has_InstanceVariableMap* RecordRelation_has_InstanceVariableMap::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RecordRelation_has_InstanceVariableMap (*this, f, c);
  }

  RecordRelation_has_InstanceVariableMap::
  ~RecordRelation_has_InstanceVariableMap ()
  {
  }

  // ReferenceValue_correspondsTo_VariableValueComponent
  //

  ReferenceValue_correspondsTo_VariableValueComponent::
  ReferenceValue_correspondsTo_VariableValueComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  ReferenceValue_correspondsTo_VariableValueComponent::
  ReferenceValue_correspondsTo_VariableValueComponent (const ReferenceValue_correspondsTo_VariableValueComponent& x,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ReferenceValue_correspondsTo_VariableValueComponent::
  ReferenceValue_correspondsTo_VariableValueComponent (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ReferenceValue_correspondsTo_VariableValueComponent* ReferenceValue_correspondsTo_VariableValueComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ReferenceValue_correspondsTo_VariableValueComponent (*this, f, c);
  }

  ReferenceValue_correspondsTo_VariableValueComponent::
  ~ReferenceValue_correspondsTo_VariableValueComponent ()
  {
  }

  // ReferenceValue_hasValueFrom_ReferenceValueDomain
  //

  ReferenceValue_hasValueFrom_ReferenceValueDomain::
  ReferenceValue_hasValueFrom_ReferenceValueDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  ReferenceValue_hasValueFrom_ReferenceValueDomain::
  ReferenceValue_hasValueFrom_ReferenceValueDomain (const ReferenceValue_hasValueFrom_ReferenceValueDomain& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ReferenceValue_hasValueFrom_ReferenceValueDomain::
  ReferenceValue_hasValueFrom_ReferenceValueDomain (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ReferenceValue_hasValueFrom_ReferenceValueDomain* ReferenceValue_hasValueFrom_ReferenceValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ReferenceValue_hasValueFrom_ReferenceValueDomain (*this, f, c);
  }

  ReferenceValue_hasValueFrom_ReferenceValueDomain::
  ~ReferenceValue_hasValueFrom_ReferenceValueDomain ()
  {
  }

  // ReferenceVariable_takesValuesFrom_ReferenceValueDomain
  //

  ReferenceVariable_takesValuesFrom_ReferenceValueDomain::
  ReferenceVariable_takesValuesFrom_ReferenceValueDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  ReferenceVariable_takesValuesFrom_ReferenceValueDomain::
  ReferenceVariable_takesValuesFrom_ReferenceValueDomain (const ReferenceVariable_takesValuesFrom_ReferenceValueDomain& x,
                                                          ::xml_schema::flags f,
                                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ReferenceVariable_takesValuesFrom_ReferenceValueDomain::
  ReferenceVariable_takesValuesFrom_ReferenceValueDomain (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::flags f,
                                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ReferenceVariable_takesValuesFrom_ReferenceValueDomain* ReferenceVariable_takesValuesFrom_ReferenceValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ReferenceVariable_takesValuesFrom_ReferenceValueDomain (*this, f, c);
  }

  ReferenceVariable_takesValuesFrom_ReferenceValueDomain::
  ~ReferenceVariable_takesValuesFrom_ReferenceValueDomain ()
  {
  }

  // RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain
  //

  RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain::
  RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain::
  RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain (const RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain& x,
                                                                   ::xml_schema::flags f,
                                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain::
  RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain (const ::xercesc::DOMElement& e,
                                                                   ::xml_schema::flags f,
                                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain* RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain (*this, f, c);
  }

  RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain::
  ~RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain ()
  {
  }

  // RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain
  //

  RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain::
  RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain::
  RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain (const RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain& x,
                                                                         ::xml_schema::flags f,
                                                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain::
  RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain (const ::xercesc::DOMElement& e,
                                                                         ::xml_schema::flags f,
                                                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain* RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain (*this, f, c);
  }

  RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain::
  ~RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain ()
  {
  }

  // RevisableDatum_correspondsTo_Revision
  //

  RevisableDatum_correspondsTo_Revision::
  RevisableDatum_correspondsTo_Revision ()
  : ::XMLSchema::Reference ()
  {
  }

  RevisableDatum_correspondsTo_Revision::
  RevisableDatum_correspondsTo_Revision (const RevisableDatum_correspondsTo_Revision& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  RevisableDatum_correspondsTo_Revision::
  RevisableDatum_correspondsTo_Revision (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  RevisableDatum_correspondsTo_Revision* RevisableDatum_correspondsTo_Revision::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RevisableDatum_correspondsTo_Revision (*this, f, c);
  }

  RevisableDatum_correspondsTo_Revision::
  ~RevisableDatum_correspondsTo_Revision ()
  {
  }

  // Rule_hasPrecondition_ConditionalControlLogic
  //

  Rule_hasPrecondition_ConditionalControlLogic::
  Rule_hasPrecondition_ConditionalControlLogic ()
  : ::XMLSchema::Reference ()
  {
  }

  Rule_hasPrecondition_ConditionalControlLogic::
  Rule_hasPrecondition_ConditionalControlLogic (const Rule_hasPrecondition_ConditionalControlLogic& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Rule_hasPrecondition_ConditionalControlLogic::
  Rule_hasPrecondition_ConditionalControlLogic (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Rule_hasPrecondition_ConditionalControlLogic* Rule_hasPrecondition_ConditionalControlLogic::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Rule_hasPrecondition_ConditionalControlLogic (*this, f, c);
  }

  Rule_hasPrecondition_ConditionalControlLogic::
  ~Rule_hasPrecondition_ConditionalControlLogic ()
  {
  }

  // RuleBasedScheduling_has_RuleSet
  //

  RuleBasedScheduling_has_RuleSet::
  RuleBasedScheduling_has_RuleSet ()
  : ::XMLSchema::Reference ()
  {
  }

  RuleBasedScheduling_has_RuleSet::
  RuleBasedScheduling_has_RuleSet (const RuleBasedScheduling_has_RuleSet& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  RuleBasedScheduling_has_RuleSet::
  RuleBasedScheduling_has_RuleSet (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  RuleBasedScheduling_has_RuleSet* RuleBasedScheduling_has_RuleSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RuleBasedScheduling_has_RuleSet (*this, f, c);
  }

  RuleBasedScheduling_has_RuleSet::
  ~RuleBasedScheduling_has_RuleSet ()
  {
  }

  // RuleBasedScheduling_has_Curator
  //

  RuleBasedScheduling_has_Curator::
  RuleBasedScheduling_has_Curator ()
  : ::XMLSchema::Reference ()
  {
  }

  RuleBasedScheduling_has_Curator::
  RuleBasedScheduling_has_Curator (const RuleBasedScheduling_has_Curator& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  RuleBasedScheduling_has_Curator::
  RuleBasedScheduling_has_Curator (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  RuleBasedScheduling_has_Curator* RuleBasedScheduling_has_Curator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RuleBasedScheduling_has_Curator (*this, f, c);
  }

  RuleBasedScheduling_has_Curator::
  ~RuleBasedScheduling_has_Curator ()
  {
  }

  // RuleSet_has_Rule
  //

  RuleSet_has_Rule::
  RuleSet_has_Rule ()
  : ::XMLSchema::Reference ()
  {
  }

  RuleSet_has_Rule::
  RuleSet_has_Rule (const RuleSet_has_Rule& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  RuleSet_has_Rule::
  RuleSet_has_Rule (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  RuleSet_has_Rule* RuleSet_has_Rule::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RuleSet_has_Rule (*this, f, c);
  }

  RuleSet_has_Rule::
  ~RuleSet_has_Rule ()
  {
  }

  // ScopedMeasure_circumscribes_DimensionalKeyDefinition
  //

  ScopedMeasure_circumscribes_DimensionalKeyDefinition::
  ScopedMeasure_circumscribes_DimensionalKeyDefinition ()
  : ::XMLSchema::Reference ()
  {
  }

  ScopedMeasure_circumscribes_DimensionalKeyDefinition::
  ScopedMeasure_circumscribes_DimensionalKeyDefinition (const ScopedMeasure_circumscribes_DimensionalKeyDefinition& x,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ScopedMeasure_circumscribes_DimensionalKeyDefinition::
  ScopedMeasure_circumscribes_DimensionalKeyDefinition (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ScopedMeasure_circumscribes_DimensionalKeyDefinition* ScopedMeasure_circumscribes_DimensionalKeyDefinition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ScopedMeasure_circumscribes_DimensionalKeyDefinition (*this, f, c);
  }

  ScopedMeasure_circumscribes_DimensionalKeyDefinition::
  ~ScopedMeasure_circumscribes_DimensionalKeyDefinition ()
  {
  }

  // ScopedMeasure_restricts_QualifiedMeasure
  //

  ScopedMeasure_restricts_QualifiedMeasure::
  ScopedMeasure_restricts_QualifiedMeasure ()
  : ::XMLSchema::Reference ()
  {
  }

  ScopedMeasure_restricts_QualifiedMeasure::
  ScopedMeasure_restricts_QualifiedMeasure (const ScopedMeasure_restricts_QualifiedMeasure& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ScopedMeasure_restricts_QualifiedMeasure::
  ScopedMeasure_restricts_QualifiedMeasure (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ScopedMeasure_restricts_QualifiedMeasure* ScopedMeasure_restricts_QualifiedMeasure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ScopedMeasure_restricts_QualifiedMeasure (*this, f, c);
  }

  ScopedMeasure_restricts_QualifiedMeasure::
  ~ScopedMeasure_restricts_QualifiedMeasure ()
  {
  }

  // ScopedMeasure_generates_RevisableDatum
  //

  ScopedMeasure_generates_RevisableDatum::
  ScopedMeasure_generates_RevisableDatum ()
  : ::XMLSchema::Reference ()
  {
  }

  ScopedMeasure_generates_RevisableDatum::
  ScopedMeasure_generates_RevisableDatum (const ScopedMeasure_generates_RevisableDatum& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ScopedMeasure_generates_RevisableDatum::
  ScopedMeasure_generates_RevisableDatum (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ScopedMeasure_generates_RevisableDatum* ScopedMeasure_generates_RevisableDatum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ScopedMeasure_generates_RevisableDatum (*this, f, c);
  }

  ScopedMeasure_generates_RevisableDatum::
  ~ScopedMeasure_generates_RevisableDatum ()
  {
  }

  // SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain
  //

  SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain::
  SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain::
  SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain (const SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain& x,
                                                                  ::xml_schema::flags f,
                                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain::
  SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain (const ::xercesc::DOMElement& e,
                                                                  ::xml_schema::flags f,
                                                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain* SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain (*this, f, c);
  }

  SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain::
  ~SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain ()
  {
  }

  // SentinelValueDomain_takesValuesFrom_EnumerationDomain
  //

  SentinelValueDomain_takesValuesFrom_EnumerationDomain::
  SentinelValueDomain_takesValuesFrom_EnumerationDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  SentinelValueDomain_takesValuesFrom_EnumerationDomain::
  SentinelValueDomain_takesValuesFrom_EnumerationDomain (const SentinelValueDomain_takesValuesFrom_EnumerationDomain& x,
                                                         ::xml_schema::flags f,
                                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  SentinelValueDomain_takesValuesFrom_EnumerationDomain::
  SentinelValueDomain_takesValuesFrom_EnumerationDomain (const ::xercesc::DOMElement& e,
                                                         ::xml_schema::flags f,
                                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  SentinelValueDomain_takesValuesFrom_EnumerationDomain* SentinelValueDomain_takesValuesFrom_EnumerationDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SentinelValueDomain_takesValuesFrom_EnumerationDomain (*this, f, c);
  }

  SentinelValueDomain_takesValuesFrom_EnumerationDomain::
  ~SentinelValueDomain_takesValuesFrom_EnumerationDomain ()
  {
  }

  // SentinelValueDomain_isDescribedBy_ValueAndConceptDescription
  //

  SentinelValueDomain_isDescribedBy_ValueAndConceptDescription::
  SentinelValueDomain_isDescribedBy_ValueAndConceptDescription ()
  : ::XMLSchema::Reference ()
  {
  }

  SentinelValueDomain_isDescribedBy_ValueAndConceptDescription::
  SentinelValueDomain_isDescribedBy_ValueAndConceptDescription (const SentinelValueDomain_isDescribedBy_ValueAndConceptDescription& x,
                                                                ::xml_schema::flags f,
                                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  SentinelValueDomain_isDescribedBy_ValueAndConceptDescription::
  SentinelValueDomain_isDescribedBy_ValueAndConceptDescription (const ::xercesc::DOMElement& e,
                                                                ::xml_schema::flags f,
                                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  SentinelValueDomain_isDescribedBy_ValueAndConceptDescription* SentinelValueDomain_isDescribedBy_ValueAndConceptDescription::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SentinelValueDomain_isDescribedBy_ValueAndConceptDescription (*this, f, c);
  }

  SentinelValueDomain_isDescribedBy_ValueAndConceptDescription::
  ~SentinelValueDomain_isDescribedBy_ValueAndConceptDescription ()
  {
  }

  // Sequence_has_SequencePosition
  //

  Sequence_has_SequencePosition::
  Sequence_has_SequencePosition ()
  : ::XMLSchema::Reference ()
  {
  }

  Sequence_has_SequencePosition::
  Sequence_has_SequencePosition (const Sequence_has_SequencePosition& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Sequence_has_SequencePosition::
  Sequence_has_SequencePosition (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Sequence_has_SequencePosition* Sequence_has_SequencePosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Sequence_has_SequencePosition (*this, f, c);
  }

  Sequence_has_SequencePosition::
  ~Sequence_has_SequencePosition ()
  {
  }

  // StatisticalClassification_isMaintainedBy_Organization
  //

  StatisticalClassification_isMaintainedBy_Organization::
  StatisticalClassification_isMaintainedBy_Organization ()
  : ::XMLSchema::Reference ()
  {
  }

  StatisticalClassification_isMaintainedBy_Organization::
  StatisticalClassification_isMaintainedBy_Organization (const StatisticalClassification_isMaintainedBy_Organization& x,
                                                         ::xml_schema::flags f,
                                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  StatisticalClassification_isMaintainedBy_Organization::
  StatisticalClassification_isMaintainedBy_Organization (const ::xercesc::DOMElement& e,
                                                         ::xml_schema::flags f,
                                                         ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  StatisticalClassification_isMaintainedBy_Organization* StatisticalClassification_isMaintainedBy_Organization::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StatisticalClassification_isMaintainedBy_Organization (*this, f, c);
  }

  StatisticalClassification_isMaintainedBy_Organization::
  ~StatisticalClassification_isMaintainedBy_Organization ()
  {
  }

  // StatisticalClassification_isIndexedBy_ClassificationIndex
  //

  StatisticalClassification_isIndexedBy_ClassificationIndex::
  StatisticalClassification_isIndexedBy_ClassificationIndex ()
  : ::XMLSchema::Reference ()
  {
  }

  StatisticalClassification_isIndexedBy_ClassificationIndex::
  StatisticalClassification_isIndexedBy_ClassificationIndex (const StatisticalClassification_isIndexedBy_ClassificationIndex& x,
                                                             ::xml_schema::flags f,
                                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  StatisticalClassification_isIndexedBy_ClassificationIndex::
  StatisticalClassification_isIndexedBy_ClassificationIndex (const ::xercesc::DOMElement& e,
                                                             ::xml_schema::flags f,
                                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  StatisticalClassification_isIndexedBy_ClassificationIndex* StatisticalClassification_isIndexedBy_ClassificationIndex::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StatisticalClassification_isIndexedBy_ClassificationIndex (*this, f, c);
  }

  StatisticalClassification_isIndexedBy_ClassificationIndex::
  ~StatisticalClassification_isIndexedBy_ClassificationIndex ()
  {
  }

  // StatisticalClassification_isVariantOf_StatisticalClassification
  //

  StatisticalClassification_isVariantOf_StatisticalClassification::
  StatisticalClassification_isVariantOf_StatisticalClassification ()
  : ::XMLSchema::Reference ()
  {
  }

  StatisticalClassification_isVariantOf_StatisticalClassification::
  StatisticalClassification_isVariantOf_StatisticalClassification (const StatisticalClassification_isVariantOf_StatisticalClassification& x,
                                                                   ::xml_schema::flags f,
                                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  StatisticalClassification_isVariantOf_StatisticalClassification::
  StatisticalClassification_isVariantOf_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                                   ::xml_schema::flags f,
                                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  StatisticalClassification_isVariantOf_StatisticalClassification* StatisticalClassification_isVariantOf_StatisticalClassification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StatisticalClassification_isVariantOf_StatisticalClassification (*this, f, c);
  }

  StatisticalClassification_isVariantOf_StatisticalClassification::
  ~StatisticalClassification_isVariantOf_StatisticalClassification ()
  {
  }

  // StatisticalClassification_isSuccessorOf_StatisticalClassification
  //

  StatisticalClassification_isSuccessorOf_StatisticalClassification::
  StatisticalClassification_isSuccessorOf_StatisticalClassification ()
  : ::XMLSchema::Reference ()
  {
  }

  StatisticalClassification_isSuccessorOf_StatisticalClassification::
  StatisticalClassification_isSuccessorOf_StatisticalClassification (const StatisticalClassification_isSuccessorOf_StatisticalClassification& x,
                                                                     ::xml_schema::flags f,
                                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  StatisticalClassification_isSuccessorOf_StatisticalClassification::
  StatisticalClassification_isSuccessorOf_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                                     ::xml_schema::flags f,
                                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  StatisticalClassification_isSuccessorOf_StatisticalClassification* StatisticalClassification_isSuccessorOf_StatisticalClassification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StatisticalClassification_isSuccessorOf_StatisticalClassification (*this, f, c);
  }

  StatisticalClassification_isSuccessorOf_StatisticalClassification::
  ~StatisticalClassification_isSuccessorOf_StatisticalClassification ()
  {
  }

  // StatisticalClassification_isPredecessorOf_StatisticalClassification
  //

  StatisticalClassification_isPredecessorOf_StatisticalClassification::
  StatisticalClassification_isPredecessorOf_StatisticalClassification ()
  : ::XMLSchema::Reference ()
  {
  }

  StatisticalClassification_isPredecessorOf_StatisticalClassification::
  StatisticalClassification_isPredecessorOf_StatisticalClassification (const StatisticalClassification_isPredecessorOf_StatisticalClassification& x,
                                                                       ::xml_schema::flags f,
                                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  StatisticalClassification_isPredecessorOf_StatisticalClassification::
  StatisticalClassification_isPredecessorOf_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                                       ::xml_schema::flags f,
                                                                       ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  StatisticalClassification_isPredecessorOf_StatisticalClassification* StatisticalClassification_isPredecessorOf_StatisticalClassification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StatisticalClassification_isPredecessorOf_StatisticalClassification (*this, f, c);
  }

  StatisticalClassification_isPredecessorOf_StatisticalClassification::
  ~StatisticalClassification_isPredecessorOf_StatisticalClassification ()
  {
  }

  // StatisticalClassification_has_ClassificationItemPosition
  //

  StatisticalClassification_has_ClassificationItemPosition::
  StatisticalClassification_has_ClassificationItemPosition ()
  : ::XMLSchema::Reference ()
  {
  }

  StatisticalClassification_has_ClassificationItemPosition::
  StatisticalClassification_has_ClassificationItemPosition (const StatisticalClassification_has_ClassificationItemPosition& x,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  StatisticalClassification_has_ClassificationItemPosition::
  StatisticalClassification_has_ClassificationItemPosition (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  StatisticalClassification_has_ClassificationItemPosition* StatisticalClassification_has_ClassificationItemPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StatisticalClassification_has_ClassificationItemPosition (*this, f, c);
  }

  StatisticalClassification_has_ClassificationItemPosition::
  ~StatisticalClassification_has_ClassificationItemPosition ()
  {
  }

  // StatisticalClassification_has_ClassificationItem
  //

  StatisticalClassification_has_ClassificationItem::
  StatisticalClassification_has_ClassificationItem ()
  : ::XMLSchema::Reference ()
  {
  }

  StatisticalClassification_has_ClassificationItem::
  StatisticalClassification_has_ClassificationItem (const StatisticalClassification_has_ClassificationItem& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  StatisticalClassification_has_ClassificationItem::
  StatisticalClassification_has_ClassificationItem (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  StatisticalClassification_has_ClassificationItem* StatisticalClassification_has_ClassificationItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StatisticalClassification_has_ClassificationItem (*this, f, c);
  }

  StatisticalClassification_has_ClassificationItem::
  ~StatisticalClassification_has_ClassificationItem ()
  {
  }

  // StatisticalClassification_has_LevelStructure
  //

  StatisticalClassification_has_LevelStructure::
  StatisticalClassification_has_LevelStructure ()
  : ::XMLSchema::Reference ()
  {
  }

  StatisticalClassification_has_LevelStructure::
  StatisticalClassification_has_LevelStructure (const StatisticalClassification_has_LevelStructure& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  StatisticalClassification_has_LevelStructure::
  StatisticalClassification_has_LevelStructure (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  StatisticalClassification_has_LevelStructure* StatisticalClassification_has_LevelStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StatisticalClassification_has_LevelStructure (*this, f, c);
  }

  StatisticalClassification_has_LevelStructure::
  ~StatisticalClassification_has_LevelStructure ()
  {
  }

  // StatisticalClassificationRelationship_hasTarget_StatisticalClassification
  //

  StatisticalClassificationRelationship_hasTarget_StatisticalClassification::
  StatisticalClassificationRelationship_hasTarget_StatisticalClassification ()
  : ::XMLSchema::Reference ()
  {
  }

  StatisticalClassificationRelationship_hasTarget_StatisticalClassification::
  StatisticalClassificationRelationship_hasTarget_StatisticalClassification (const StatisticalClassificationRelationship_hasTarget_StatisticalClassification& x,
                                                                             ::xml_schema::flags f,
                                                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  StatisticalClassificationRelationship_hasTarget_StatisticalClassification::
  StatisticalClassificationRelationship_hasTarget_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                                             ::xml_schema::flags f,
                                                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  StatisticalClassificationRelationship_hasTarget_StatisticalClassification* StatisticalClassificationRelationship_hasTarget_StatisticalClassification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StatisticalClassificationRelationship_hasTarget_StatisticalClassification (*this, f, c);
  }

  StatisticalClassificationRelationship_hasTarget_StatisticalClassification::
  ~StatisticalClassificationRelationship_hasTarget_StatisticalClassification ()
  {
  }

  // StatisticalClassificationRelationship_hasSource_StatisticalClassification
  //

  StatisticalClassificationRelationship_hasSource_StatisticalClassification::
  StatisticalClassificationRelationship_hasSource_StatisticalClassification ()
  : ::XMLSchema::Reference ()
  {
  }

  StatisticalClassificationRelationship_hasSource_StatisticalClassification::
  StatisticalClassificationRelationship_hasSource_StatisticalClassification (const StatisticalClassificationRelationship_hasSource_StatisticalClassification& x,
                                                                             ::xml_schema::flags f,
                                                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  StatisticalClassificationRelationship_hasSource_StatisticalClassification::
  StatisticalClassificationRelationship_hasSource_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                                             ::xml_schema::flags f,
                                                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  StatisticalClassificationRelationship_hasSource_StatisticalClassification* StatisticalClassificationRelationship_hasSource_StatisticalClassification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StatisticalClassificationRelationship_hasSource_StatisticalClassification (*this, f, c);
  }

  StatisticalClassificationRelationship_hasSource_StatisticalClassification::
  ~StatisticalClassificationRelationship_hasSource_StatisticalClassification ()
  {
  }

  // Step_produces_Parameter
  //

  Step_produces_Parameter::
  Step_produces_Parameter ()
  : ::XMLSchema::Reference ()
  {
  }

  Step_produces_Parameter::
  Step_produces_Parameter (const Step_produces_Parameter& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Step_produces_Parameter::
  Step_produces_Parameter (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Step_produces_Parameter* Step_produces_Parameter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Step_produces_Parameter (*this, f, c);
  }

  Step_produces_Parameter::
  ~Step_produces_Parameter ()
  {
  }

  // Step_receives_Parameter
  //

  Step_receives_Parameter::
  Step_receives_Parameter ()
  : ::XMLSchema::Reference ()
  {
  }

  Step_receives_Parameter::
  Step_receives_Parameter (const Step_receives_Parameter& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Step_receives_Parameter::
  Step_receives_Parameter (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Step_receives_Parameter* Step_receives_Parameter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Step_receives_Parameter (*this, f, c);
  }

  Step_receives_Parameter::
  ~Step_receives_Parameter ()
  {
  }

  // Step_hasSubStep_Step
  //

  Step_hasSubStep_Step::
  Step_hasSubStep_Step ()
  : ::XMLSchema::Reference ()
  {
  }

  Step_hasSubStep_Step::
  Step_hasSubStep_Step (const Step_hasSubStep_Step& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Step_hasSubStep_Step::
  Step_hasSubStep_Step (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Step_hasSubStep_Step* Step_hasSubStep_Step::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Step_hasSubStep_Step (*this, f, c);
  }

  Step_hasSubStep_Step::
  ~Step_hasSubStep_Step ()
  {
  }

  // SubstantiveValueDomain_takesValuesFrom_EnumerationDomain
  //

  SubstantiveValueDomain_takesValuesFrom_EnumerationDomain::
  SubstantiveValueDomain_takesValuesFrom_EnumerationDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  SubstantiveValueDomain_takesValuesFrom_EnumerationDomain::
  SubstantiveValueDomain_takesValuesFrom_EnumerationDomain (const SubstantiveValueDomain_takesValuesFrom_EnumerationDomain& x,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  SubstantiveValueDomain_takesValuesFrom_EnumerationDomain::
  SubstantiveValueDomain_takesValuesFrom_EnumerationDomain (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  SubstantiveValueDomain_takesValuesFrom_EnumerationDomain* SubstantiveValueDomain_takesValuesFrom_EnumerationDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SubstantiveValueDomain_takesValuesFrom_EnumerationDomain (*this, f, c);
  }

  SubstantiveValueDomain_takesValuesFrom_EnumerationDomain::
  ~SubstantiveValueDomain_takesValuesFrom_EnumerationDomain ()
  {
  }

  // SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription
  //

  SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription::
  SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription ()
  : ::XMLSchema::Reference ()
  {
  }

  SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription::
  SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription (const SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription& x,
                                                                   ::xml_schema::flags f,
                                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription::
  SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription (const ::xercesc::DOMElement& e,
                                                                   ::xml_schema::flags f,
                                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription* SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription (*this, f, c);
  }

  SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription::
  ~SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription ()
  {
  }

  // SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain
  //

  SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain::
  SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain ()
  : ::XMLSchema::Reference ()
  {
  }

  SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain::
  SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain (const SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain& x,
                                                                        ::xml_schema::flags f,
                                                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain::
  SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain (const ::xercesc::DOMElement& e,
                                                                        ::xml_schema::flags f,
                                                                        ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain* SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain (*this, f, c);
  }

  SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain::
  ~SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain ()
  {
  }

  // Unit_has_UnitType
  //

  Unit_has_UnitType::
  Unit_has_UnitType ()
  : ::XMLSchema::Reference ()
  {
  }

  Unit_has_UnitType::
  Unit_has_UnitType (const Unit_has_UnitType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  Unit_has_UnitType::
  Unit_has_UnitType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  Unit_has_UnitType* Unit_has_UnitType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Unit_has_UnitType (*this, f, c);
  }

  Unit_has_UnitType::
  ~Unit_has_UnitType ()
  {
  }

  // ValueMapping_formats_DataPoint
  //

  ValueMapping_formats_DataPoint::
  ValueMapping_formats_DataPoint ()
  : ::XMLSchema::Reference ()
  {
  }

  ValueMapping_formats_DataPoint::
  ValueMapping_formats_DataPoint (const ValueMapping_formats_DataPoint& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ValueMapping_formats_DataPoint::
  ValueMapping_formats_DataPoint (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ValueMapping_formats_DataPoint* ValueMapping_formats_DataPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ValueMapping_formats_DataPoint (*this, f, c);
  }

  ValueMapping_formats_DataPoint::
  ~ValueMapping_formats_DataPoint ()
  {
  }

  // ValueMapping_uses_PhysicalSegmentLocation
  //

  ValueMapping_uses_PhysicalSegmentLocation::
  ValueMapping_uses_PhysicalSegmentLocation ()
  : ::XMLSchema::Reference ()
  {
  }

  ValueMapping_uses_PhysicalSegmentLocation::
  ValueMapping_uses_PhysicalSegmentLocation (const ValueMapping_uses_PhysicalSegmentLocation& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ValueMapping_uses_PhysicalSegmentLocation::
  ValueMapping_uses_PhysicalSegmentLocation (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ValueMapping_uses_PhysicalSegmentLocation* ValueMapping_uses_PhysicalSegmentLocation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ValueMapping_uses_PhysicalSegmentLocation (*this, f, c);
  }

  ValueMapping_uses_PhysicalSegmentLocation::
  ~ValueMapping_uses_PhysicalSegmentLocation ()
  {
  }

  // ValueMappingPosition_indexes_ValueMapping
  //

  ValueMappingPosition_indexes_ValueMapping::
  ValueMappingPosition_indexes_ValueMapping ()
  : ::XMLSchema::Reference ()
  {
  }

  ValueMappingPosition_indexes_ValueMapping::
  ValueMappingPosition_indexes_ValueMapping (const ValueMappingPosition_indexes_ValueMapping& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ValueMappingPosition_indexes_ValueMapping::
  ValueMappingPosition_indexes_ValueMapping (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ValueMappingPosition_indexes_ValueMapping* ValueMappingPosition_indexes_ValueMapping::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ValueMappingPosition_indexes_ValueMapping (*this, f, c);
  }

  ValueMappingPosition_indexes_ValueMapping::
  ~ValueMappingPosition_indexes_ValueMapping ()
  {
  }

  // ValueMappingRelationship_hasTarget_ValueMapping
  //

  ValueMappingRelationship_hasTarget_ValueMapping::
  ValueMappingRelationship_hasTarget_ValueMapping ()
  : ::XMLSchema::Reference ()
  {
  }

  ValueMappingRelationship_hasTarget_ValueMapping::
  ValueMappingRelationship_hasTarget_ValueMapping (const ValueMappingRelationship_hasTarget_ValueMapping& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ValueMappingRelationship_hasTarget_ValueMapping::
  ValueMappingRelationship_hasTarget_ValueMapping (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ValueMappingRelationship_hasTarget_ValueMapping* ValueMappingRelationship_hasTarget_ValueMapping::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ValueMappingRelationship_hasTarget_ValueMapping (*this, f, c);
  }

  ValueMappingRelationship_hasTarget_ValueMapping::
  ~ValueMappingRelationship_hasTarget_ValueMapping ()
  {
  }

  // ValueMappingRelationship_hasSource_ValueMapping
  //

  ValueMappingRelationship_hasSource_ValueMapping::
  ValueMappingRelationship_hasSource_ValueMapping ()
  : ::XMLSchema::Reference ()
  {
  }

  ValueMappingRelationship_hasSource_ValueMapping::
  ValueMappingRelationship_hasSource_ValueMapping (const ValueMappingRelationship_hasSource_ValueMapping& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  ValueMappingRelationship_hasSource_ValueMapping::
  ValueMappingRelationship_hasSource_ValueMapping (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  ValueMappingRelationship_hasSource_ValueMapping* ValueMappingRelationship_hasSource_ValueMapping::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ValueMappingRelationship_hasSource_ValueMapping (*this, f, c);
  }

  ValueMappingRelationship_hasSource_ValueMapping::
  ~ValueMappingRelationship_hasSource_ValueMapping ()
  {
  }

  // VariableCollection_isDefinedBy_Concept
  //

  VariableCollection_isDefinedBy_Concept::
  VariableCollection_isDefinedBy_Concept ()
  : ::XMLSchema::Reference ()
  {
  }

  VariableCollection_isDefinedBy_Concept::
  VariableCollection_isDefinedBy_Concept (const VariableCollection_isDefinedBy_Concept& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  VariableCollection_isDefinedBy_Concept::
  VariableCollection_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  VariableCollection_isDefinedBy_Concept* VariableCollection_isDefinedBy_Concept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableCollection_isDefinedBy_Concept (*this, f, c);
  }

  VariableCollection_isDefinedBy_Concept::
  ~VariableCollection_isDefinedBy_Concept ()
  {
  }

  // VariableCollection_has_ConceptualVariable
  //

  VariableCollection_has_ConceptualVariable::
  VariableCollection_has_ConceptualVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  VariableCollection_has_ConceptualVariable::
  VariableCollection_has_ConceptualVariable (const VariableCollection_has_ConceptualVariable& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  VariableCollection_has_ConceptualVariable::
  VariableCollection_has_ConceptualVariable (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  VariableCollection_has_ConceptualVariable* VariableCollection_has_ConceptualVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableCollection_has_ConceptualVariable (*this, f, c);
  }

  VariableCollection_has_ConceptualVariable::
  ~VariableCollection_has_ConceptualVariable ()
  {
  }

  // VariableCollection_has_VariablePosition
  //

  VariableCollection_has_VariablePosition::
  VariableCollection_has_VariablePosition ()
  : ::XMLSchema::Reference ()
  {
  }

  VariableCollection_has_VariablePosition::
  VariableCollection_has_VariablePosition (const VariableCollection_has_VariablePosition& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  VariableCollection_has_VariablePosition::
  VariableCollection_has_VariablePosition (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  VariableCollection_has_VariablePosition* VariableCollection_has_VariablePosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableCollection_has_VariablePosition (*this, f, c);
  }

  VariableCollection_has_VariablePosition::
  ~VariableCollection_has_VariablePosition ()
  {
  }

  // VariableDescriptorComponent_isDefinedBy_DescriptorVariable
  //

  VariableDescriptorComponent_isDefinedBy_DescriptorVariable::
  VariableDescriptorComponent_isDefinedBy_DescriptorVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  VariableDescriptorComponent_isDefinedBy_DescriptorVariable::
  VariableDescriptorComponent_isDefinedBy_DescriptorVariable (const VariableDescriptorComponent_isDefinedBy_DescriptorVariable& x,
                                                              ::xml_schema::flags f,
                                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  VariableDescriptorComponent_isDefinedBy_DescriptorVariable::
  VariableDescriptorComponent_isDefinedBy_DescriptorVariable (const ::xercesc::DOMElement& e,
                                                              ::xml_schema::flags f,
                                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  VariableDescriptorComponent_isDefinedBy_DescriptorVariable* VariableDescriptorComponent_isDefinedBy_DescriptorVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableDescriptorComponent_isDefinedBy_DescriptorVariable (*this, f, c);
  }

  VariableDescriptorComponent_isDefinedBy_DescriptorVariable::
  ~VariableDescriptorComponent_isDefinedBy_DescriptorVariable ()
  {
  }

  // VariableDescriptorComponent_refersTo_VariableValueComponent
  //

  VariableDescriptorComponent_refersTo_VariableValueComponent::
  VariableDescriptorComponent_refersTo_VariableValueComponent ()
  : ::XMLSchema::Reference ()
  {
  }

  VariableDescriptorComponent_refersTo_VariableValueComponent::
  VariableDescriptorComponent_refersTo_VariableValueComponent (const VariableDescriptorComponent_refersTo_VariableValueComponent& x,
                                                               ::xml_schema::flags f,
                                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  VariableDescriptorComponent_refersTo_VariableValueComponent::
  VariableDescriptorComponent_refersTo_VariableValueComponent (const ::xercesc::DOMElement& e,
                                                               ::xml_schema::flags f,
                                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  VariableDescriptorComponent_refersTo_VariableValueComponent* VariableDescriptorComponent_refersTo_VariableValueComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableDescriptorComponent_refersTo_VariableValueComponent (*this, f, c);
  }

  VariableDescriptorComponent_refersTo_VariableValueComponent::
  ~VariableDescriptorComponent_refersTo_VariableValueComponent ()
  {
  }

  // VariablePosition_indexes_ConceptualVariable
  //

  VariablePosition_indexes_ConceptualVariable::
  VariablePosition_indexes_ConceptualVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  VariablePosition_indexes_ConceptualVariable::
  VariablePosition_indexes_ConceptualVariable (const VariablePosition_indexes_ConceptualVariable& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  VariablePosition_indexes_ConceptualVariable::
  VariablePosition_indexes_ConceptualVariable (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  VariablePosition_indexes_ConceptualVariable* VariablePosition_indexes_ConceptualVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariablePosition_indexes_ConceptualVariable (*this, f, c);
  }

  VariablePosition_indexes_ConceptualVariable::
  ~VariablePosition_indexes_ConceptualVariable ()
  {
  }

  // VariableRelationship_hasTarget_ConceptualVariable
  //

  VariableRelationship_hasTarget_ConceptualVariable::
  VariableRelationship_hasTarget_ConceptualVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  VariableRelationship_hasTarget_ConceptualVariable::
  VariableRelationship_hasTarget_ConceptualVariable (const VariableRelationship_hasTarget_ConceptualVariable& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  VariableRelationship_hasTarget_ConceptualVariable::
  VariableRelationship_hasTarget_ConceptualVariable (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  VariableRelationship_hasTarget_ConceptualVariable* VariableRelationship_hasTarget_ConceptualVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableRelationship_hasTarget_ConceptualVariable (*this, f, c);
  }

  VariableRelationship_hasTarget_ConceptualVariable::
  ~VariableRelationship_hasTarget_ConceptualVariable ()
  {
  }

  // VariableRelationship_hasSource_ConceptualVariable
  //

  VariableRelationship_hasSource_ConceptualVariable::
  VariableRelationship_hasSource_ConceptualVariable ()
  : ::XMLSchema::Reference ()
  {
  }

  VariableRelationship_hasSource_ConceptualVariable::
  VariableRelationship_hasSource_ConceptualVariable (const VariableRelationship_hasSource_ConceptualVariable& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  VariableRelationship_hasSource_ConceptualVariable::
  VariableRelationship_hasSource_ConceptualVariable (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  VariableRelationship_hasSource_ConceptualVariable* VariableRelationship_hasSource_ConceptualVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableRelationship_hasSource_ConceptualVariable (*this, f, c);
  }

  VariableRelationship_hasSource_ConceptualVariable::
  ~VariableRelationship_hasSource_ConceptualVariable ()
  {
  }

  // VariableStructure_structures_VariableCollection
  //

  VariableStructure_structures_VariableCollection::
  VariableStructure_structures_VariableCollection ()
  : ::XMLSchema::Reference ()
  {
  }

  VariableStructure_structures_VariableCollection::
  VariableStructure_structures_VariableCollection (const VariableStructure_structures_VariableCollection& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  VariableStructure_structures_VariableCollection::
  VariableStructure_structures_VariableCollection (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  VariableStructure_structures_VariableCollection* VariableStructure_structures_VariableCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableStructure_structures_VariableCollection (*this, f, c);
  }

  VariableStructure_structures_VariableCollection::
  ~VariableStructure_structures_VariableCollection ()
  {
  }

  // VariableStructure_has_VariableRelationship
  //

  VariableStructure_has_VariableRelationship::
  VariableStructure_has_VariableRelationship ()
  : ::XMLSchema::Reference ()
  {
  }

  VariableStructure_has_VariableRelationship::
  VariableStructure_has_VariableRelationship (const VariableStructure_has_VariableRelationship& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  VariableStructure_has_VariableRelationship::
  VariableStructure_has_VariableRelationship (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  VariableStructure_has_VariableRelationship* VariableStructure_has_VariableRelationship::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VariableStructure_has_VariableRelationship (*this, f, c);
  }

  VariableStructure_has_VariableRelationship::
  ~VariableStructure_has_VariableRelationship ()
  {
  }

  // reference
  //

  reference::
  reference ()
  : ::XMLSchema::Reference ()
  {
  }

  reference::
  reference (const reference& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  reference::
  reference (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  reference* reference::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class reference (*this, f, c);
  }

  reference::
  ~reference ()
  {
  }

  // relatedResource
  //

  relatedResource::
  relatedResource ()
  : ::XMLSchema::Reference ()
  {
  }

  relatedResource::
  relatedResource (const relatedResource& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  relatedResource::
  relatedResource (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  relatedResource* relatedResource::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class relatedResource (*this, f, c);
  }

  relatedResource::
  ~relatedResource ()
  {
  }

  // entryReference
  //

  entryReference::
  entryReference ()
  : ::XMLSchema::Reference ()
  {
  }

  entryReference::
  entryReference (const entryReference& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  entryReference::
  entryReference (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  entryReference* entryReference::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class entryReference (*this, f, c);
  }

  entryReference::
  ~entryReference ()
  {
  }

  // vocabulary
  //

  vocabulary::
  vocabulary ()
  : ::XMLSchema::Reference ()
  {
  }

  vocabulary::
  vocabulary (const vocabulary& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  vocabulary::
  vocabulary (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  vocabulary* vocabulary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class vocabulary (*this, f, c);
  }

  vocabulary::
  ~vocabulary ()
  {
  }

  // licenseReference
  //

  licenseReference::
  licenseReference ()
  : ::XMLSchema::Reference ()
  {
  }

  licenseReference::
  licenseReference (const licenseReference& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (x, f, c)
  {
  }

  licenseReference::
  licenseReference (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::XMLSchema::Reference (e, f, c)
  {
  }

  licenseReference* licenseReference::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class licenseReference (*this, f, c);
  }

  licenseReference::
  ~licenseReference ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace XMLSchema
{
  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::XMLSchema::DDICDIModels > (
      ::XMLSchema::DDICDIModels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::XMLSchema::DDICDIModels > (
      ::XMLSchema::DDICDIModels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::XMLSchema::DDICDIModels > (
      ::XMLSchema::DDICDIModels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLSchema::DDICDIModels_ (isrc, f, p);
  }

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLSchema::DDICDIModels_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLSchema::DDICDIModels_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLSchema::DDICDIModels_ (isrc, f, p);
  }

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLSchema::DDICDIModels_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLSchema::DDICDIModels_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::XMLSchema::DDICDIModels > (
      ::XMLSchema::DDICDIModels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::XMLSchema::DDICDIModels > (
      ::XMLSchema::DDICDIModels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::XMLSchema::DDICDIModels > (
      ::XMLSchema::DDICDIModels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::XMLSchema::DDICDIModels > (
        ::XMLSchema::DDICDIModels_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DDICDIModels" &&
        n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
    {
      ::std::unique_ptr< ::XMLSchema::DDICDIModels > r (
        ::xsd::cxx::tree::traits< ::XMLSchema::DDICDIModels, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DDICDIModels",
      "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
  }

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DDICDIModels" &&
        n.namespace_ () == "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/")
    {
      ::std::unique_ptr< ::XMLSchema::DDICDIModels > r (
        ::xsd::cxx::tree::traits< ::XMLSchema::DDICDIModels, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DDICDIModels",
      "http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

