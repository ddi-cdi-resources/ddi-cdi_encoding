// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX______MODEL_BASED_XSD_VARIANTS_DDI_CDI_42_NO_XSD_TYPE_IN_NAME_HXX
#define CXX______MODEL_BASED_XSD_VARIANTS_DDI_CDI_42_NO_XSD_TYPE_IN_NAME_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace XMLSchema
{
  class DDICDIModels;
  class Wrapper;
  class Activity;
  class Agent;
  class AgentListing;
  class AgentPosition;
  class AgentRelationship;
  class AgentStructure;
  class ControlLogic;
  class NonDeterministicDeclarative;
  class TemporalConstraints;
  class AllenIntervalAlgebra;
  class DataStructureComponent;
  class AttributeComponent;
  class AuthorizationSource;
  class Concept;
  class Category;
  class CategoryPosition;
  class CategoryRelationStructure;
  class CategoryRelationship;
  class ConceptSystem;
  class CategorySet;
  class CategoryStatistic;
  class ClassificationFamily;
  class ClassificationIndex;
  class ClassificationIndexEntry;
  class ClassificationIndexEntryPosition;
  class ClassificationItem;
  class ClassificationItemPosition;
  class ClassificationItemRelationship;
  class ClassificationItemStructure;
  class ClassificationPosition;
  class ClassificationSeries;
  class ClassificationSeriesStructure;
  class Code;
  class EnumerationDomain;
  class CodeList;
  class CodeListStructure;
  class CodePosition;
  class CodeRelationship;
  class ComponentPosition;
  class ConceptMap;
  class ConceptRelationship;
  class ConceptStructure;
  class ConceptSystemCorrespondence;
  class ConceptualDomain;
  class ConceptualValue;
  class ConceptualVariable;
  class DeterministicImperative;
  class ConditionalControlLogic;
  class ContextualComponent;
  class CorrespondenceTable;
  class ProcessingAgent;
  class Curator;
  class DataPoint;
  class DataPointPosition;
  class DataPointRelationship;
  class DataSet;
  class DataStore;
  class DataStructure;
  class Datum;
  class InstanceValue;
  class KeyMember;
  class Descriptor;
  class ValueDomain;
  class SubstantiveValueDomain;
  class DescriptorValueDomain;
  class RepresentedVariable;
  class DescriptorVariable;
  class DimensionComponent;
  class DimensionGroup;
  class DimensionalDataSet;
  class DimensionalDataStructure;
  class Key;
  class DimensionalKey;
  class KeyDefinition;
  class DimensionalKeyDefinition;
  class DimensionalKeyDefinitionMember;
  class DimensionalKeyMember;
  class ForeignKey;
  class ForeignKeyComponent;
  class IdentifierComponent;
  class Individual;
  class InformationFlowDefinition;
  class InstanceKey;
  class InstanceVariable;
  class InstanceVariableMap;
  class KeyDefinitionMember;
  class KeyValueDataStore;
  class KeyValueStructure;
  class Level;
  class LevelStructure;
  class LogicalRecord;
  class LogicalRecordPosition;
  class LogicalRecordRelationStructure;
  class LogicalRecordRelationship;
  class LongDataSet;
  class LongDataStructure;
  class LongKey;
  class LongMainKeyMember;
  class Machine;
  class MainKeyMember;
  class MeasureComponent;
  class Notation;
  class Organization;
  class Parameter;
  class PhysicalDataSet;
  class PhysicalDataSetStructure;
  class PhysicalLayoutRelationStructure;
  class PhysicalRecordSegment;
  class PhysicalRecordSegmentPosition;
  class PhysicalRecordSegmentRelationship;
  class PhysicalRecordSegmentStructure;
  class PhysicalSegmentLayout;
  class PhysicalSegmentLocation;
  class UnitType;
  class Universe;
  class Population;
  class PrimaryKey;
  class PrimaryKeyComponent;
  class ProductionEnvironment;
  class QualifiedMeasure;
  class RecordRelation;
  class ReferenceValue;
  class ReferenceValueDomain;
  class ReferenceVariable;
  class RevisableDatum;
  class Revision;
  class Rule;
  class RuleBasedScheduling;
  class RuleSet;
  class ScopedMeasure;
  class SegmentByText;
  class SentinelConceptualDomain;
  class SentinelValueDomain;
  class Sequence;
  class SequencePosition;
  class Service;
  class StatisticalClassification;
  class StatisticalClassificationRelationship;
  class Step;
  class SubstantiveConceptualDomain;
  class SyntheticIdComponent;
  class TemporalControlConstruct;
  class Unit;
  class UnitSegmentLayout;
  class ValueAndConceptDescription;
  class ValueMapping;
  class ValueMappingPosition;
  class ValueMappingRelationship;
  class VariableCollection;
  class VariableDescriptorComponent;
  class VariablePosition;
  class VariableRelationship;
  class VariableStructure;
  class VariableValueComponent;
  class WideDataSet;
  class WideDataStructure;
  class WideKey;
  class WideKeyMember;
  class CategoryRelationCode;
  class ComparisonOperator;
  class ComputationBaseList;
  class ControlConstruct;
  class MatchingCriterion;
  class MemberRelationshipScope;
  class PointFormat;
  class SchedulingStrategy;
  class SexSpecification;
  class StructureExtent;
  class TableDirectionValues;
  class TemporalOperator;
  class TemporalRelation;
  class TextDirectionValues;
  class TrimValues;
  class WhiteSpaceRule;
  class AccessInformation;
  class AccessLocation;
  class Address;
  class AgentInRole;
  class InternationalString;
  class BibliographicName;
  class CatalogDetails;
  class CombinedDate;
  class Command;
  class CommandCode;
  class CommandFile;
  class ContactInformation;
  class ControlledVocabularyEntry;
  class CorrespondenceDefinition;
  class DateRange;
  class ElectronicMessageSystem;
  class Email;
  class EmbargoInformation;
  class FundingInformation;
  class SpecializationRole;
  class GeoRole;
  class Identifier;
  class IndividualName;
  class InternationalIdentifier;
  class InternationalRegistrationDataIdentifier;
  class LabelForDisplay;
  class LanguageString;
  class LicenseInformation;
  class ModelIdentification;
  class NonDdiIdentifier;
  class NonIsoDate;
  class Selector;
  class ObjectAttributeSelector;
  class ObjectName;
  class OrganizationName;
  class PairedControlledVocabularyEntry;
  class PrivateImage;
  class ProvenanceInformation;
  class RationaleDefinition;
  class Reference;
  class SpatialCoordinate;
  class SpatialPoint;
  class Statistic;
  class StructureSpecification;
  class Telephone;
  class TextPositionSelector;
  class TimeRole;
  class TypedString;
  class WebLink;
  class entityProduced;
  class entityUsed;
  class standardModelMapping;
  class Activity_hasInternal_ControlLogic;
  class Activity_hasSubActivity_Activity;
  class Activity_has_Step;
  class AgentListing_isDefinedBy_Concept;
  class AgentListing_isMaintainedBy_Agent;
  class AgentListing_has_AgentPosition;
  class AgentListing_has_Agent;
  class AgentPosition_indexes_Agent;
  class AgentRelationship_hasSource_Agent;
  class AgentRelationship_hasTarget_Agent;
  class AgentStructure_structures_AgentListing;
  class AgentStructure_has_AgentRelationship;
  class AttributeComponent_qualifies_DataStructureComponent;
  class AuthorizationSource_has_Agent;
  class CategoryPosition_indexes_Category;
  class CategoryRelationStructure_structures_CategorySet;
  class CategoryRelationStructure_has_CategoryRelationship;
  class CategoryRelationship_hasSource_Category;
  class CategoryRelationship_hasTarget_Category;
  class CategorySet_has_Category;
  class CategorySet_has_CategoryPosition;
  class CategoryStatistic_appliesTo_InstanceVariable;
  class CategoryStatistic_for_Category;
  class ClassificationFamily_uses_ClassificationIndex;
  class ClassificationFamily_isDefinedBy_Concept;
  class ClassificationFamily_groups_ClassificationSeries;
  class ClassificationIndex_isMaintainedBy_Agent;
  class ClassificationIndex_hasContact_Agent;
  class ClassificationIndex_isDefinedBy_Concept;
  class ClassificationIndex_has_ClassificationIndexEntryPosition;
  class ClassificationIndex_has_ClassificationIndexEntry;
  class ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry;
  class ClassificationItem_excludes_ClassificationItem;
  class ClassificationItem_denotes_Category;
  class ClassificationItem_uses_Notation;
  class ClassificationItem_hasRulingBy_AuthorizationSource;
  class ClassificationItemPosition_indexes_ClassificationItem;
  class ClassificationItemRelationship_hasSource_ClassificationItem;
  class ClassificationItemRelationship_hasTarget_ClassificationItem;
  class ClassificationItemStructure_structures_StatisticalClassification;
  class ClassificationItemStructure_has_ClassificationItemRelationship;
  class ClassificationPosition_indexes_StatisticalClassification;
  class ClassificationSeries_isOwnedBy_Agent;
  class ClassificationSeries_isDefinedBy_Concept;
  class ClassificationSeries_has_StatisticalClassification;
  class ClassificationSeries_has_ClassificationPosition;
  class ClassificationSeriesStructure_structures_ClassificationSeries;
  class ClassificationSeriesStructure_has_StatisticalClassificationRelationship;
  class Code_denotes_Category;
  class Code_uses_Notation;
  class CodeList_has_CodePosition;
  class CodeList_has_Code;
  class CodeListStructure_structures_CodeList;
  class CodeListStructure_has_CodeRelationship;
  class CodePosition_indexes_Code;
  class CodeRelationship_hasTarget_Code;
  class CodeRelationship_hasSource_Code;
  class ComponentPosition_indexes_DataStructureComponent;
  class externalDefinition;
  class Concept_uses_Concept;
  class ConceptMap_hasSource_Concept;
  class ConceptMap_hasTarget_Concept;
  class ConceptRelationship_hasSource_Concept;
  class ConceptRelationship_hasTarget_Concept;
  class ConceptStructure_structures_ConceptSystem;
  class ConceptStructure_has_ConceptRelationship;
  class ConceptSystem_isDefinedBy_Concept;
  class ConceptSystem_has_Concept;
  class ConceptSystemCorrespondence_maps_ConceptSystem;
  class ConceptSystemCorrespondence_has_ConceptMap;
  class ConceptualDomain_isDescribedBy_ValueAndConceptDescription;
  class ConceptualDomain_takesConceptsFrom_ConceptSystem;
  class ConceptualValue_hasConceptFrom_ConceptualDomain;
  class ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain;
  class ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain;
  class ConceptualVariable_measures_UnitType;
  class ControlLogic_informs_ProcessingAgent;
  class ControlLogic_invokes_Activity;
  class ControlLogic_hasSubControlLogic_ControlLogic;
  class ControlLogic_has_InformationFlowDefinition;
  class CorrespondenceTable_hasSource_Level;
  class CorrespondenceTable_hasTarget_Level;
  class CorrespondenceTable_isOwnedBy_Agent;
  class CorrespondenceTable_mapsTo_StatisticalClassification;
  class CorrespondenceTable_hasContact_Agent;
  class CorrespondenceTable_isMaintainedBy_Agent;
  class CorrespondenceTable_has_ConceptMap;
  class DataPoint_correspondsTo_DataStructureComponent;
  class DataPoint_isDescribedBy_InstanceVariable;
  class DataPointPosition_indexes_DataPoint;
  class DataPointRelationship_hasTarget_DataPoint;
  class DataPointRelationship_hasSource_DataPoint;
  class DataSet_isStructuredBy_DataStructure;
  class DataSet_has_DataPoint;
  class DataSet_has_Key;
  class DataStore_isDefinedBy_Concept;
  class DataStore_has_LogicalRecordPosition;
  class DataStore_has_LogicalRecord;
  class DataStore_has_RecordRelation;
  class DataStructure_has_ForeignKey;
  class DataStructure_has_DataStructureComponent;
  class DataStructure_has_ComponentPosition;
  class DataStructure_has_PrimaryKey;
  class DataStructureComponent_isDefinedBy_RepresentedVariable;
  class Datum_uses_Notation;
  class Datum_denotes_ConceptualValue;
  class Datum_uses_InstanceValue;
  class Datum_isBoundedBy_InstanceVariable;
  class Descriptor_refersTo_ReferenceValue;
  class Descriptor_identifies_ReferenceVariable;
  class Descriptor_hasValueFrom_DescriptorValueDomain;
  class DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain;
  class DimensionComponent_isStructuredBy_ValueDomain;
  class DimensionGroup_has_DimensionComponent;
  class DimensionalDataSet_represents_ScopedMeasure;
  class DimensionalDataStructure_uses_DimensionGroup;
  class DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember;
  class DimensionalKeyMember_hasValueFrom_CodeList;
  class EnumerationDomain_uses_LevelStructure;
  class EnumerationDomain_references_CategorySet;
  class EnumerationDomain_isDefinedBy_Concept;
  class ForeignKey_isComposedOf_ForeignKeyComponent;
  class ForeignKeyComponent_references_PrimaryKeyComponent;
  class ForeignKeyComponent_correspondsTo_DataStructureComponent;
  class InformationFlowDefinition_from_Parameter;
  class InformationFlowDefinition_to_Parameter;
  class InstanceKey_has_InstanceValue;
  class InstanceKey_refersTo_ReferenceValue;
  class InstanceValue_hasValueFrom_ValueDomain;
  class InstanceValue_isStoredIn_DataPoint;
  class InstanceValue_represents_ConceptualValue;
  class source;
  class InstanceVariableMap_hasTarget_InstanceVariable;
  class InstanceVariableMap_hasSource_InstanceVariable;
  class Key_correspondsTo_Unit;
  class Key_represents_KeyDefinition;
  class Key_identifies_DataPoint;
  class Key_correspondsTo_Universe;
  class Key_has_KeyMember;
  class KeyDefinition_correspondsTo_Universe;
  class KeyDefinition_correspondsTo_Unit;
  class KeyDefinition_has_KeyDefinitionMember;
  class KeyMember_isBasedOn_DataStructureComponent;
  class Level_isDefinedBy_Concept;
  class Level_groups_ClassificationItem;
  class LevelStructure_has_Level;
  class LogicalRecord_organizes_DataSet;
  class LogicalRecord_isDefinedBy_Concept;
  class LogicalRecord_has_InstanceVariable;
  class LogicalRecordPosition_indexes_LogicalRecord;
  class LogicalRecordRelationStructure_structures_DataStore;
  class LogicalRecordRelationStructure_has_LogicalRecordRelationship;
  class LogicalRecordRelationship_hasTarget_LogicalRecord;
  class LogicalRecordRelationship_hasSource_LogicalRecord;
  class MainKeyMember_hasValueFrom_SubstantiveValueDomain;
  class Notation_represents_Category;
  class entityBound;
  class PhysicalDataSet_isDefinedBy_Concept;
  class PhysicalDataSet_formats_DataStore;
  class PhysicalDataSet_has_InstanceVariable;
  class PhysicalDataSet_has_PhysicalRecordSegment;
  class PhysicalDataSet_has_PhysicalRecordSegmentPosition;
  class PhysicalDataSetStructure_structures_PhysicalDataSet;
  class PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship;
  class PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout;
  class PhysicalLayoutRelationStructure_has_ValueMappingRelationship;
  class PhysicalRecordSegment_represents_Population;
  class PhysicalRecordSegment_isDefinedBy_Concept;
  class PhysicalRecordSegment_has_PhysicalSegmentLayout;
  class PhysicalRecordSegment_mapsTo_LogicalRecord;
  class PhysicalRecordSegment_has_DataPointPosition;
  class PhysicalRecordSegment_has_DataPoint;
  class PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment;
  class PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment;
  class PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment;
  class PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment;
  class PhysicalRecordSegmentStructure_has_DataPointRelationship;
  class PhysicalSegmentLayout_isDefinedBy_Concept;
  class PhysicalSegmentLayout_formats_LogicalRecord;
  class PhysicalSegmentLayout_has_ValueMapping;
  class PhysicalSegmentLayout_has_ValueMappingPosition;
  class Population_isComposedOf_Unit;
  class PrimaryKey_isComposedOf_PrimaryKeyComponent;
  class PrimaryKeyComponent_correspondsTo_DataStructureComponent;
  class ProcessingAgent_performs_Activity;
  class ProcessingAgent_operatesOn_ProductionEnvironment;
  class QualifiedMeasure_refines_MeasureComponent;
  class RecordRelation_maps_LogicalRecord;
  class RecordRelation_has_InstanceVariableMap;
  class ReferenceValue_correspondsTo_VariableValueComponent;
  class ReferenceValue_hasValueFrom_ReferenceValueDomain;
  class ReferenceVariable_takesValuesFrom_ReferenceValueDomain;
  class RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain;
  class RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain;
  class RevisableDatum_correspondsTo_Revision;
  class Rule_hasPrecondition_ConditionalControlLogic;
  class RuleBasedScheduling_has_RuleSet;
  class RuleBasedScheduling_has_Curator;
  class RuleSet_has_Rule;
  class ScopedMeasure_circumscribes_DimensionalKeyDefinition;
  class ScopedMeasure_restricts_QualifiedMeasure;
  class ScopedMeasure_generates_RevisableDatum;
  class SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain;
  class SentinelValueDomain_takesValuesFrom_EnumerationDomain;
  class SentinelValueDomain_isDescribedBy_ValueAndConceptDescription;
  class Sequence_has_SequencePosition;
  class StatisticalClassification_isMaintainedBy_Organization;
  class StatisticalClassification_isIndexedBy_ClassificationIndex;
  class StatisticalClassification_isVariantOf_StatisticalClassification;
  class StatisticalClassification_isSuccessorOf_StatisticalClassification;
  class StatisticalClassification_isPredecessorOf_StatisticalClassification;
  class StatisticalClassification_has_ClassificationItemPosition;
  class StatisticalClassification_has_ClassificationItem;
  class StatisticalClassification_has_LevelStructure;
  class StatisticalClassificationRelationship_hasTarget_StatisticalClassification;
  class StatisticalClassificationRelationship_hasSource_StatisticalClassification;
  class Step_produces_Parameter;
  class Step_receives_Parameter;
  class Step_hasSubStep_Step;
  class SubstantiveValueDomain_takesValuesFrom_EnumerationDomain;
  class SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription;
  class SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain;
  class Unit_has_UnitType;
  class ValueMapping_formats_DataPoint;
  class ValueMapping_uses_PhysicalSegmentLocation;
  class ValueMappingPosition_indexes_ValueMapping;
  class ValueMappingRelationship_hasTarget_ValueMapping;
  class ValueMappingRelationship_hasSource_ValueMapping;
  class VariableCollection_isDefinedBy_Concept;
  class VariableCollection_has_ConceptualVariable;
  class VariableCollection_has_VariablePosition;
  class VariableDescriptorComponent_isDefinedBy_DescriptorVariable;
  class VariableDescriptorComponent_refersTo_VariableValueComponent;
  class VariablePosition_indexes_ConceptualVariable;
  class VariableRelationship_hasTarget_ConceptualVariable;
  class VariableRelationship_hasSource_ConceptualVariable;
  class VariableStructure_structures_VariableCollection;
  class VariableStructure_has_VariableRelationship;
  class reference;
  class relatedResource;
  class entryReference;
  class vocabulary;
  class licenseReference;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "xml.hxx"

namespace XMLSchema
{
  class DDICDIModels: public ::xml_schema::type
  {
    public:
    // Activity
    //
    typedef ::XMLSchema::Activity Activity_type;
    typedef ::xsd::cxx::tree::sequence< Activity_type > Activity_sequence;
    typedef Activity_sequence::iterator Activity_iterator;
    typedef Activity_sequence::const_iterator Activity_const_iterator;
    typedef ::xsd::cxx::tree::traits< Activity_type, char > Activity_traits;

    const Activity_sequence&
    Activity () const;

    Activity_sequence&
    Activity ();

    void
    Activity (const Activity_sequence& s);

    // Agent
    //
    typedef ::XMLSchema::Agent Agent_type;
    typedef ::xsd::cxx::tree::sequence< Agent_type > Agent_sequence;
    typedef Agent_sequence::iterator Agent_iterator;
    typedef Agent_sequence::const_iterator Agent_const_iterator;
    typedef ::xsd::cxx::tree::traits< Agent_type, char > Agent_traits;

    const Agent_sequence&
    Agent () const;

    Agent_sequence&
    Agent ();

    void
    Agent (const Agent_sequence& s);

    // AgentListing
    //
    typedef ::XMLSchema::AgentListing AgentListing_type;
    typedef ::xsd::cxx::tree::sequence< AgentListing_type > AgentListing_sequence;
    typedef AgentListing_sequence::iterator AgentListing_iterator;
    typedef AgentListing_sequence::const_iterator AgentListing_const_iterator;
    typedef ::xsd::cxx::tree::traits< AgentListing_type, char > AgentListing_traits;

    const AgentListing_sequence&
    AgentListing () const;

    AgentListing_sequence&
    AgentListing ();

    void
    AgentListing (const AgentListing_sequence& s);

    // AgentPosition
    //
    typedef ::XMLSchema::AgentPosition AgentPosition_type;
    typedef ::xsd::cxx::tree::sequence< AgentPosition_type > AgentPosition_sequence;
    typedef AgentPosition_sequence::iterator AgentPosition_iterator;
    typedef AgentPosition_sequence::const_iterator AgentPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< AgentPosition_type, char > AgentPosition_traits;

    const AgentPosition_sequence&
    AgentPosition () const;

    AgentPosition_sequence&
    AgentPosition ();

    void
    AgentPosition (const AgentPosition_sequence& s);

    // AgentRelationship
    //
    typedef ::XMLSchema::AgentRelationship AgentRelationship_type;
    typedef ::xsd::cxx::tree::sequence< AgentRelationship_type > AgentRelationship_sequence;
    typedef AgentRelationship_sequence::iterator AgentRelationship_iterator;
    typedef AgentRelationship_sequence::const_iterator AgentRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< AgentRelationship_type, char > AgentRelationship_traits;

    const AgentRelationship_sequence&
    AgentRelationship () const;

    AgentRelationship_sequence&
    AgentRelationship ();

    void
    AgentRelationship (const AgentRelationship_sequence& s);

    // AgentStructure
    //
    typedef ::XMLSchema::AgentStructure AgentStructure_type;
    typedef ::xsd::cxx::tree::sequence< AgentStructure_type > AgentStructure_sequence;
    typedef AgentStructure_sequence::iterator AgentStructure_iterator;
    typedef AgentStructure_sequence::const_iterator AgentStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< AgentStructure_type, char > AgentStructure_traits;

    const AgentStructure_sequence&
    AgentStructure () const;

    AgentStructure_sequence&
    AgentStructure ();

    void
    AgentStructure (const AgentStructure_sequence& s);

    // AllenIntervalAlgebra
    //
    typedef ::XMLSchema::AllenIntervalAlgebra AllenIntervalAlgebra_type;
    typedef ::xsd::cxx::tree::sequence< AllenIntervalAlgebra_type > AllenIntervalAlgebra_sequence;
    typedef AllenIntervalAlgebra_sequence::iterator AllenIntervalAlgebra_iterator;
    typedef AllenIntervalAlgebra_sequence::const_iterator AllenIntervalAlgebra_const_iterator;
    typedef ::xsd::cxx::tree::traits< AllenIntervalAlgebra_type, char > AllenIntervalAlgebra_traits;

    const AllenIntervalAlgebra_sequence&
    AllenIntervalAlgebra () const;

    AllenIntervalAlgebra_sequence&
    AllenIntervalAlgebra ();

    void
    AllenIntervalAlgebra (const AllenIntervalAlgebra_sequence& s);

    // AttributeComponent
    //
    typedef ::XMLSchema::AttributeComponent AttributeComponent_type;
    typedef ::xsd::cxx::tree::sequence< AttributeComponent_type > AttributeComponent_sequence;
    typedef AttributeComponent_sequence::iterator AttributeComponent_iterator;
    typedef AttributeComponent_sequence::const_iterator AttributeComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< AttributeComponent_type, char > AttributeComponent_traits;

    const AttributeComponent_sequence&
    AttributeComponent () const;

    AttributeComponent_sequence&
    AttributeComponent ();

    void
    AttributeComponent (const AttributeComponent_sequence& s);

    // AuthorizationSource
    //
    typedef ::XMLSchema::AuthorizationSource AuthorizationSource_type;
    typedef ::xsd::cxx::tree::sequence< AuthorizationSource_type > AuthorizationSource_sequence;
    typedef AuthorizationSource_sequence::iterator AuthorizationSource_iterator;
    typedef AuthorizationSource_sequence::const_iterator AuthorizationSource_const_iterator;
    typedef ::xsd::cxx::tree::traits< AuthorizationSource_type, char > AuthorizationSource_traits;

    const AuthorizationSource_sequence&
    AuthorizationSource () const;

    AuthorizationSource_sequence&
    AuthorizationSource ();

    void
    AuthorizationSource (const AuthorizationSource_sequence& s);

    // Category
    //
    typedef ::XMLSchema::Category Category_type;
    typedef ::xsd::cxx::tree::sequence< Category_type > Category_sequence;
    typedef Category_sequence::iterator Category_iterator;
    typedef Category_sequence::const_iterator Category_const_iterator;
    typedef ::xsd::cxx::tree::traits< Category_type, char > Category_traits;

    const Category_sequence&
    Category () const;

    Category_sequence&
    Category ();

    void
    Category (const Category_sequence& s);

    // CategoryPosition
    //
    typedef ::XMLSchema::CategoryPosition CategoryPosition_type;
    typedef ::xsd::cxx::tree::sequence< CategoryPosition_type > CategoryPosition_sequence;
    typedef CategoryPosition_sequence::iterator CategoryPosition_iterator;
    typedef CategoryPosition_sequence::const_iterator CategoryPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategoryPosition_type, char > CategoryPosition_traits;

    const CategoryPosition_sequence&
    CategoryPosition () const;

    CategoryPosition_sequence&
    CategoryPosition ();

    void
    CategoryPosition (const CategoryPosition_sequence& s);

    // CategoryRelationStructure
    //
    typedef ::XMLSchema::CategoryRelationStructure CategoryRelationStructure_type;
    typedef ::xsd::cxx::tree::sequence< CategoryRelationStructure_type > CategoryRelationStructure_sequence;
    typedef CategoryRelationStructure_sequence::iterator CategoryRelationStructure_iterator;
    typedef CategoryRelationStructure_sequence::const_iterator CategoryRelationStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategoryRelationStructure_type, char > CategoryRelationStructure_traits;

    const CategoryRelationStructure_sequence&
    CategoryRelationStructure () const;

    CategoryRelationStructure_sequence&
    CategoryRelationStructure ();

    void
    CategoryRelationStructure (const CategoryRelationStructure_sequence& s);

    // CategoryRelationship
    //
    typedef ::XMLSchema::CategoryRelationship CategoryRelationship_type;
    typedef ::xsd::cxx::tree::sequence< CategoryRelationship_type > CategoryRelationship_sequence;
    typedef CategoryRelationship_sequence::iterator CategoryRelationship_iterator;
    typedef CategoryRelationship_sequence::const_iterator CategoryRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategoryRelationship_type, char > CategoryRelationship_traits;

    const CategoryRelationship_sequence&
    CategoryRelationship () const;

    CategoryRelationship_sequence&
    CategoryRelationship ();

    void
    CategoryRelationship (const CategoryRelationship_sequence& s);

    // CategorySet
    //
    typedef ::XMLSchema::CategorySet CategorySet_type;
    typedef ::xsd::cxx::tree::sequence< CategorySet_type > CategorySet_sequence;
    typedef CategorySet_sequence::iterator CategorySet_iterator;
    typedef CategorySet_sequence::const_iterator CategorySet_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategorySet_type, char > CategorySet_traits;

    const CategorySet_sequence&
    CategorySet () const;

    CategorySet_sequence&
    CategorySet ();

    void
    CategorySet (const CategorySet_sequence& s);

    // CategoryStatistic
    //
    typedef ::XMLSchema::CategoryStatistic CategoryStatistic_type;
    typedef ::xsd::cxx::tree::sequence< CategoryStatistic_type > CategoryStatistic_sequence;
    typedef CategoryStatistic_sequence::iterator CategoryStatistic_iterator;
    typedef CategoryStatistic_sequence::const_iterator CategoryStatistic_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategoryStatistic_type, char > CategoryStatistic_traits;

    const CategoryStatistic_sequence&
    CategoryStatistic () const;

    CategoryStatistic_sequence&
    CategoryStatistic ();

    void
    CategoryStatistic (const CategoryStatistic_sequence& s);

    // ClassificationFamily
    //
    typedef ::XMLSchema::ClassificationFamily ClassificationFamily_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationFamily_type > ClassificationFamily_sequence;
    typedef ClassificationFamily_sequence::iterator ClassificationFamily_iterator;
    typedef ClassificationFamily_sequence::const_iterator ClassificationFamily_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationFamily_type, char > ClassificationFamily_traits;

    const ClassificationFamily_sequence&
    ClassificationFamily () const;

    ClassificationFamily_sequence&
    ClassificationFamily ();

    void
    ClassificationFamily (const ClassificationFamily_sequence& s);

    // ClassificationIndex
    //
    typedef ::XMLSchema::ClassificationIndex ClassificationIndex_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationIndex_type > ClassificationIndex_sequence;
    typedef ClassificationIndex_sequence::iterator ClassificationIndex_iterator;
    typedef ClassificationIndex_sequence::const_iterator ClassificationIndex_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationIndex_type, char > ClassificationIndex_traits;

    const ClassificationIndex_sequence&
    ClassificationIndex () const;

    ClassificationIndex_sequence&
    ClassificationIndex ();

    void
    ClassificationIndex (const ClassificationIndex_sequence& s);

    // ClassificationIndexEntry
    //
    typedef ::XMLSchema::ClassificationIndexEntry ClassificationIndexEntry_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationIndexEntry_type > ClassificationIndexEntry_sequence;
    typedef ClassificationIndexEntry_sequence::iterator ClassificationIndexEntry_iterator;
    typedef ClassificationIndexEntry_sequence::const_iterator ClassificationIndexEntry_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationIndexEntry_type, char > ClassificationIndexEntry_traits;

    const ClassificationIndexEntry_sequence&
    ClassificationIndexEntry () const;

    ClassificationIndexEntry_sequence&
    ClassificationIndexEntry ();

    void
    ClassificationIndexEntry (const ClassificationIndexEntry_sequence& s);

    // ClassificationIndexEntryPosition
    //
    typedef ::XMLSchema::ClassificationIndexEntryPosition ClassificationIndexEntryPosition_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationIndexEntryPosition_type > ClassificationIndexEntryPosition_sequence;
    typedef ClassificationIndexEntryPosition_sequence::iterator ClassificationIndexEntryPosition_iterator;
    typedef ClassificationIndexEntryPosition_sequence::const_iterator ClassificationIndexEntryPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationIndexEntryPosition_type, char > ClassificationIndexEntryPosition_traits;

    const ClassificationIndexEntryPosition_sequence&
    ClassificationIndexEntryPosition () const;

    ClassificationIndexEntryPosition_sequence&
    ClassificationIndexEntryPosition ();

    void
    ClassificationIndexEntryPosition (const ClassificationIndexEntryPosition_sequence& s);

    // ClassificationItem
    //
    typedef ::XMLSchema::ClassificationItem ClassificationItem_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationItem_type > ClassificationItem_sequence;
    typedef ClassificationItem_sequence::iterator ClassificationItem_iterator;
    typedef ClassificationItem_sequence::const_iterator ClassificationItem_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationItem_type, char > ClassificationItem_traits;

    const ClassificationItem_sequence&
    ClassificationItem () const;

    ClassificationItem_sequence&
    ClassificationItem ();

    void
    ClassificationItem (const ClassificationItem_sequence& s);

    // ClassificationItemPosition
    //
    typedef ::XMLSchema::ClassificationItemPosition ClassificationItemPosition_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationItemPosition_type > ClassificationItemPosition_sequence;
    typedef ClassificationItemPosition_sequence::iterator ClassificationItemPosition_iterator;
    typedef ClassificationItemPosition_sequence::const_iterator ClassificationItemPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationItemPosition_type, char > ClassificationItemPosition_traits;

    const ClassificationItemPosition_sequence&
    ClassificationItemPosition () const;

    ClassificationItemPosition_sequence&
    ClassificationItemPosition ();

    void
    ClassificationItemPosition (const ClassificationItemPosition_sequence& s);

    // ClassificationItemRelationship
    //
    typedef ::XMLSchema::ClassificationItemRelationship ClassificationItemRelationship_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationItemRelationship_type > ClassificationItemRelationship_sequence;
    typedef ClassificationItemRelationship_sequence::iterator ClassificationItemRelationship_iterator;
    typedef ClassificationItemRelationship_sequence::const_iterator ClassificationItemRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationItemRelationship_type, char > ClassificationItemRelationship_traits;

    const ClassificationItemRelationship_sequence&
    ClassificationItemRelationship () const;

    ClassificationItemRelationship_sequence&
    ClassificationItemRelationship ();

    void
    ClassificationItemRelationship (const ClassificationItemRelationship_sequence& s);

    // ClassificationItemStructure
    //
    typedef ::XMLSchema::ClassificationItemStructure ClassificationItemStructure_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationItemStructure_type > ClassificationItemStructure_sequence;
    typedef ClassificationItemStructure_sequence::iterator ClassificationItemStructure_iterator;
    typedef ClassificationItemStructure_sequence::const_iterator ClassificationItemStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationItemStructure_type, char > ClassificationItemStructure_traits;

    const ClassificationItemStructure_sequence&
    ClassificationItemStructure () const;

    ClassificationItemStructure_sequence&
    ClassificationItemStructure ();

    void
    ClassificationItemStructure (const ClassificationItemStructure_sequence& s);

    // ClassificationPosition
    //
    typedef ::XMLSchema::ClassificationPosition ClassificationPosition_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationPosition_type > ClassificationPosition_sequence;
    typedef ClassificationPosition_sequence::iterator ClassificationPosition_iterator;
    typedef ClassificationPosition_sequence::const_iterator ClassificationPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationPosition_type, char > ClassificationPosition_traits;

    const ClassificationPosition_sequence&
    ClassificationPosition () const;

    ClassificationPosition_sequence&
    ClassificationPosition ();

    void
    ClassificationPosition (const ClassificationPosition_sequence& s);

    // ClassificationSeries
    //
    typedef ::XMLSchema::ClassificationSeries ClassificationSeries_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationSeries_type > ClassificationSeries_sequence;
    typedef ClassificationSeries_sequence::iterator ClassificationSeries_iterator;
    typedef ClassificationSeries_sequence::const_iterator ClassificationSeries_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationSeries_type, char > ClassificationSeries_traits;

    const ClassificationSeries_sequence&
    ClassificationSeries () const;

    ClassificationSeries_sequence&
    ClassificationSeries ();

    void
    ClassificationSeries (const ClassificationSeries_sequence& s);

    // ClassificationSeriesStructure
    //
    typedef ::XMLSchema::ClassificationSeriesStructure ClassificationSeriesStructure_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationSeriesStructure_type > ClassificationSeriesStructure_sequence;
    typedef ClassificationSeriesStructure_sequence::iterator ClassificationSeriesStructure_iterator;
    typedef ClassificationSeriesStructure_sequence::const_iterator ClassificationSeriesStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationSeriesStructure_type, char > ClassificationSeriesStructure_traits;

    const ClassificationSeriesStructure_sequence&
    ClassificationSeriesStructure () const;

    ClassificationSeriesStructure_sequence&
    ClassificationSeriesStructure ();

    void
    ClassificationSeriesStructure (const ClassificationSeriesStructure_sequence& s);

    // Code
    //
    typedef ::XMLSchema::Code Code_type;
    typedef ::xsd::cxx::tree::sequence< Code_type > Code_sequence;
    typedef Code_sequence::iterator Code_iterator;
    typedef Code_sequence::const_iterator Code_const_iterator;
    typedef ::xsd::cxx::tree::traits< Code_type, char > Code_traits;

    const Code_sequence&
    Code () const;

    Code_sequence&
    Code ();

    void
    Code (const Code_sequence& s);

    // CodeList
    //
    typedef ::XMLSchema::CodeList CodeList_type;
    typedef ::xsd::cxx::tree::sequence< CodeList_type > CodeList_sequence;
    typedef CodeList_sequence::iterator CodeList_iterator;
    typedef CodeList_sequence::const_iterator CodeList_const_iterator;
    typedef ::xsd::cxx::tree::traits< CodeList_type, char > CodeList_traits;

    const CodeList_sequence&
    CodeList () const;

    CodeList_sequence&
    CodeList ();

    void
    CodeList (const CodeList_sequence& s);

    // CodeListStructure
    //
    typedef ::XMLSchema::CodeListStructure CodeListStructure_type;
    typedef ::xsd::cxx::tree::sequence< CodeListStructure_type > CodeListStructure_sequence;
    typedef CodeListStructure_sequence::iterator CodeListStructure_iterator;
    typedef CodeListStructure_sequence::const_iterator CodeListStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< CodeListStructure_type, char > CodeListStructure_traits;

    const CodeListStructure_sequence&
    CodeListStructure () const;

    CodeListStructure_sequence&
    CodeListStructure ();

    void
    CodeListStructure (const CodeListStructure_sequence& s);

    // CodePosition
    //
    typedef ::XMLSchema::CodePosition CodePosition_type;
    typedef ::xsd::cxx::tree::sequence< CodePosition_type > CodePosition_sequence;
    typedef CodePosition_sequence::iterator CodePosition_iterator;
    typedef CodePosition_sequence::const_iterator CodePosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< CodePosition_type, char > CodePosition_traits;

    const CodePosition_sequence&
    CodePosition () const;

    CodePosition_sequence&
    CodePosition ();

    void
    CodePosition (const CodePosition_sequence& s);

    // CodeRelationship
    //
    typedef ::XMLSchema::CodeRelationship CodeRelationship_type;
    typedef ::xsd::cxx::tree::sequence< CodeRelationship_type > CodeRelationship_sequence;
    typedef CodeRelationship_sequence::iterator CodeRelationship_iterator;
    typedef CodeRelationship_sequence::const_iterator CodeRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< CodeRelationship_type, char > CodeRelationship_traits;

    const CodeRelationship_sequence&
    CodeRelationship () const;

    CodeRelationship_sequence&
    CodeRelationship ();

    void
    CodeRelationship (const CodeRelationship_sequence& s);

    // ComponentPosition
    //
    typedef ::XMLSchema::ComponentPosition ComponentPosition_type;
    typedef ::xsd::cxx::tree::sequence< ComponentPosition_type > ComponentPosition_sequence;
    typedef ComponentPosition_sequence::iterator ComponentPosition_iterator;
    typedef ComponentPosition_sequence::const_iterator ComponentPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< ComponentPosition_type, char > ComponentPosition_traits;

    const ComponentPosition_sequence&
    ComponentPosition () const;

    ComponentPosition_sequence&
    ComponentPosition ();

    void
    ComponentPosition (const ComponentPosition_sequence& s);

    // Concept
    //
    typedef ::XMLSchema::Concept Concept_type;
    typedef ::xsd::cxx::tree::sequence< Concept_type > Concept_sequence;
    typedef Concept_sequence::iterator Concept_iterator;
    typedef Concept_sequence::const_iterator Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< Concept_type, char > Concept_traits;

    const Concept_sequence&
    Concept () const;

    Concept_sequence&
    Concept ();

    void
    Concept (const Concept_sequence& s);

    // ConceptMap
    //
    typedef ::XMLSchema::ConceptMap ConceptMap_type;
    typedef ::xsd::cxx::tree::sequence< ConceptMap_type > ConceptMap_sequence;
    typedef ConceptMap_sequence::iterator ConceptMap_iterator;
    typedef ConceptMap_sequence::const_iterator ConceptMap_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptMap_type, char > ConceptMap_traits;

    const ConceptMap_sequence&
    ConceptMap () const;

    ConceptMap_sequence&
    ConceptMap ();

    void
    ConceptMap (const ConceptMap_sequence& s);

    // ConceptRelationship
    //
    typedef ::XMLSchema::ConceptRelationship ConceptRelationship_type;
    typedef ::xsd::cxx::tree::sequence< ConceptRelationship_type > ConceptRelationship_sequence;
    typedef ConceptRelationship_sequence::iterator ConceptRelationship_iterator;
    typedef ConceptRelationship_sequence::const_iterator ConceptRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptRelationship_type, char > ConceptRelationship_traits;

    const ConceptRelationship_sequence&
    ConceptRelationship () const;

    ConceptRelationship_sequence&
    ConceptRelationship ();

    void
    ConceptRelationship (const ConceptRelationship_sequence& s);

    // ConceptStructure
    //
    typedef ::XMLSchema::ConceptStructure ConceptStructure_type;
    typedef ::xsd::cxx::tree::sequence< ConceptStructure_type > ConceptStructure_sequence;
    typedef ConceptStructure_sequence::iterator ConceptStructure_iterator;
    typedef ConceptStructure_sequence::const_iterator ConceptStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptStructure_type, char > ConceptStructure_traits;

    const ConceptStructure_sequence&
    ConceptStructure () const;

    ConceptStructure_sequence&
    ConceptStructure ();

    void
    ConceptStructure (const ConceptStructure_sequence& s);

    // ConceptSystem
    //
    typedef ::XMLSchema::ConceptSystem ConceptSystem_type;
    typedef ::xsd::cxx::tree::sequence< ConceptSystem_type > ConceptSystem_sequence;
    typedef ConceptSystem_sequence::iterator ConceptSystem_iterator;
    typedef ConceptSystem_sequence::const_iterator ConceptSystem_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptSystem_type, char > ConceptSystem_traits;

    const ConceptSystem_sequence&
    ConceptSystem () const;

    ConceptSystem_sequence&
    ConceptSystem ();

    void
    ConceptSystem (const ConceptSystem_sequence& s);

    // ConceptSystemCorrespondence
    //
    typedef ::XMLSchema::ConceptSystemCorrespondence ConceptSystemCorrespondence_type;
    typedef ::xsd::cxx::tree::sequence< ConceptSystemCorrespondence_type > ConceptSystemCorrespondence_sequence;
    typedef ConceptSystemCorrespondence_sequence::iterator ConceptSystemCorrespondence_iterator;
    typedef ConceptSystemCorrespondence_sequence::const_iterator ConceptSystemCorrespondence_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptSystemCorrespondence_type, char > ConceptSystemCorrespondence_traits;

    const ConceptSystemCorrespondence_sequence&
    ConceptSystemCorrespondence () const;

    ConceptSystemCorrespondence_sequence&
    ConceptSystemCorrespondence ();

    void
    ConceptSystemCorrespondence (const ConceptSystemCorrespondence_sequence& s);

    // ConceptualDomain
    //
    typedef ::XMLSchema::ConceptualDomain ConceptualDomain_type;
    typedef ::xsd::cxx::tree::sequence< ConceptualDomain_type > ConceptualDomain_sequence;
    typedef ConceptualDomain_sequence::iterator ConceptualDomain_iterator;
    typedef ConceptualDomain_sequence::const_iterator ConceptualDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptualDomain_type, char > ConceptualDomain_traits;

    const ConceptualDomain_sequence&
    ConceptualDomain () const;

    ConceptualDomain_sequence&
    ConceptualDomain ();

    void
    ConceptualDomain (const ConceptualDomain_sequence& s);

    // ConceptualValue
    //
    typedef ::XMLSchema::ConceptualValue ConceptualValue_type;
    typedef ::xsd::cxx::tree::sequence< ConceptualValue_type > ConceptualValue_sequence;
    typedef ConceptualValue_sequence::iterator ConceptualValue_iterator;
    typedef ConceptualValue_sequence::const_iterator ConceptualValue_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptualValue_type, char > ConceptualValue_traits;

    const ConceptualValue_sequence&
    ConceptualValue () const;

    ConceptualValue_sequence&
    ConceptualValue ();

    void
    ConceptualValue (const ConceptualValue_sequence& s);

    // ConceptualVariable
    //
    typedef ::XMLSchema::ConceptualVariable ConceptualVariable_type;
    typedef ::xsd::cxx::tree::sequence< ConceptualVariable_type > ConceptualVariable_sequence;
    typedef ConceptualVariable_sequence::iterator ConceptualVariable_iterator;
    typedef ConceptualVariable_sequence::const_iterator ConceptualVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptualVariable_type, char > ConceptualVariable_traits;

    const ConceptualVariable_sequence&
    ConceptualVariable () const;

    ConceptualVariable_sequence&
    ConceptualVariable ();

    void
    ConceptualVariable (const ConceptualVariable_sequence& s);

    // ConditionalControlLogic
    //
    typedef ::XMLSchema::ConditionalControlLogic ConditionalControlLogic_type;
    typedef ::xsd::cxx::tree::sequence< ConditionalControlLogic_type > ConditionalControlLogic_sequence;
    typedef ConditionalControlLogic_sequence::iterator ConditionalControlLogic_iterator;
    typedef ConditionalControlLogic_sequence::const_iterator ConditionalControlLogic_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConditionalControlLogic_type, char > ConditionalControlLogic_traits;

    const ConditionalControlLogic_sequence&
    ConditionalControlLogic () const;

    ConditionalControlLogic_sequence&
    ConditionalControlLogic ();

    void
    ConditionalControlLogic (const ConditionalControlLogic_sequence& s);

    // ContextualComponent
    //
    typedef ::XMLSchema::ContextualComponent ContextualComponent_type;
    typedef ::xsd::cxx::tree::sequence< ContextualComponent_type > ContextualComponent_sequence;
    typedef ContextualComponent_sequence::iterator ContextualComponent_iterator;
    typedef ContextualComponent_sequence::const_iterator ContextualComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< ContextualComponent_type, char > ContextualComponent_traits;

    const ContextualComponent_sequence&
    ContextualComponent () const;

    ContextualComponent_sequence&
    ContextualComponent ();

    void
    ContextualComponent (const ContextualComponent_sequence& s);

    // ControlLogic
    //
    typedef ::XMLSchema::ControlLogic ControlLogic_type;
    typedef ::xsd::cxx::tree::sequence< ControlLogic_type > ControlLogic_sequence;
    typedef ControlLogic_sequence::iterator ControlLogic_iterator;
    typedef ControlLogic_sequence::const_iterator ControlLogic_const_iterator;
    typedef ::xsd::cxx::tree::traits< ControlLogic_type, char > ControlLogic_traits;

    const ControlLogic_sequence&
    ControlLogic () const;

    ControlLogic_sequence&
    ControlLogic ();

    void
    ControlLogic (const ControlLogic_sequence& s);

    // CorrespondenceTable
    //
    typedef ::XMLSchema::CorrespondenceTable CorrespondenceTable_type;
    typedef ::xsd::cxx::tree::sequence< CorrespondenceTable_type > CorrespondenceTable_sequence;
    typedef CorrespondenceTable_sequence::iterator CorrespondenceTable_iterator;
    typedef CorrespondenceTable_sequence::const_iterator CorrespondenceTable_const_iterator;
    typedef ::xsd::cxx::tree::traits< CorrespondenceTable_type, char > CorrespondenceTable_traits;

    const CorrespondenceTable_sequence&
    CorrespondenceTable () const;

    CorrespondenceTable_sequence&
    CorrespondenceTable ();

    void
    CorrespondenceTable (const CorrespondenceTable_sequence& s);

    // Curator
    //
    typedef ::XMLSchema::Curator Curator_type;
    typedef ::xsd::cxx::tree::sequence< Curator_type > Curator_sequence;
    typedef Curator_sequence::iterator Curator_iterator;
    typedef Curator_sequence::const_iterator Curator_const_iterator;
    typedef ::xsd::cxx::tree::traits< Curator_type, char > Curator_traits;

    const Curator_sequence&
    Curator () const;

    Curator_sequence&
    Curator ();

    void
    Curator (const Curator_sequence& s);

    // DataPoint
    //
    typedef ::XMLSchema::DataPoint DataPoint_type;
    typedef ::xsd::cxx::tree::sequence< DataPoint_type > DataPoint_sequence;
    typedef DataPoint_sequence::iterator DataPoint_iterator;
    typedef DataPoint_sequence::const_iterator DataPoint_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataPoint_type, char > DataPoint_traits;

    const DataPoint_sequence&
    DataPoint () const;

    DataPoint_sequence&
    DataPoint ();

    void
    DataPoint (const DataPoint_sequence& s);

    // DataPointPosition
    //
    typedef ::XMLSchema::DataPointPosition DataPointPosition_type;
    typedef ::xsd::cxx::tree::sequence< DataPointPosition_type > DataPointPosition_sequence;
    typedef DataPointPosition_sequence::iterator DataPointPosition_iterator;
    typedef DataPointPosition_sequence::const_iterator DataPointPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataPointPosition_type, char > DataPointPosition_traits;

    const DataPointPosition_sequence&
    DataPointPosition () const;

    DataPointPosition_sequence&
    DataPointPosition ();

    void
    DataPointPosition (const DataPointPosition_sequence& s);

    // DataPointRelationship
    //
    typedef ::XMLSchema::DataPointRelationship DataPointRelationship_type;
    typedef ::xsd::cxx::tree::sequence< DataPointRelationship_type > DataPointRelationship_sequence;
    typedef DataPointRelationship_sequence::iterator DataPointRelationship_iterator;
    typedef DataPointRelationship_sequence::const_iterator DataPointRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataPointRelationship_type, char > DataPointRelationship_traits;

    const DataPointRelationship_sequence&
    DataPointRelationship () const;

    DataPointRelationship_sequence&
    DataPointRelationship ();

    void
    DataPointRelationship (const DataPointRelationship_sequence& s);

    // DataSet
    //
    typedef ::XMLSchema::DataSet DataSet_type;
    typedef ::xsd::cxx::tree::sequence< DataSet_type > DataSet_sequence;
    typedef DataSet_sequence::iterator DataSet_iterator;
    typedef DataSet_sequence::const_iterator DataSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataSet_type, char > DataSet_traits;

    const DataSet_sequence&
    DataSet () const;

    DataSet_sequence&
    DataSet ();

    void
    DataSet (const DataSet_sequence& s);

    // DataStore
    //
    typedef ::XMLSchema::DataStore DataStore_type;
    typedef ::xsd::cxx::tree::sequence< DataStore_type > DataStore_sequence;
    typedef DataStore_sequence::iterator DataStore_iterator;
    typedef DataStore_sequence::const_iterator DataStore_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataStore_type, char > DataStore_traits;

    const DataStore_sequence&
    DataStore () const;

    DataStore_sequence&
    DataStore ();

    void
    DataStore (const DataStore_sequence& s);

    // DataStructure
    //
    typedef ::XMLSchema::DataStructure DataStructure_type;
    typedef ::xsd::cxx::tree::sequence< DataStructure_type > DataStructure_sequence;
    typedef DataStructure_sequence::iterator DataStructure_iterator;
    typedef DataStructure_sequence::const_iterator DataStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataStructure_type, char > DataStructure_traits;

    const DataStructure_sequence&
    DataStructure () const;

    DataStructure_sequence&
    DataStructure ();

    void
    DataStructure (const DataStructure_sequence& s);

    // DataStructureComponent
    //
    typedef ::XMLSchema::DataStructureComponent DataStructureComponent_type;
    typedef ::xsd::cxx::tree::sequence< DataStructureComponent_type > DataStructureComponent_sequence;
    typedef DataStructureComponent_sequence::iterator DataStructureComponent_iterator;
    typedef DataStructureComponent_sequence::const_iterator DataStructureComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataStructureComponent_type, char > DataStructureComponent_traits;

    const DataStructureComponent_sequence&
    DataStructureComponent () const;

    DataStructureComponent_sequence&
    DataStructureComponent ();

    void
    DataStructureComponent (const DataStructureComponent_sequence& s);

    // Datum
    //
    typedef ::XMLSchema::Datum Datum_type;
    typedef ::xsd::cxx::tree::sequence< Datum_type > Datum_sequence;
    typedef Datum_sequence::iterator Datum_iterator;
    typedef Datum_sequence::const_iterator Datum_const_iterator;
    typedef ::xsd::cxx::tree::traits< Datum_type, char > Datum_traits;

    const Datum_sequence&
    Datum () const;

    Datum_sequence&
    Datum ();

    void
    Datum (const Datum_sequence& s);

    // Descriptor
    //
    typedef ::XMLSchema::Descriptor Descriptor_type;
    typedef ::xsd::cxx::tree::sequence< Descriptor_type > Descriptor_sequence;
    typedef Descriptor_sequence::iterator Descriptor_iterator;
    typedef Descriptor_sequence::const_iterator Descriptor_const_iterator;
    typedef ::xsd::cxx::tree::traits< Descriptor_type, char > Descriptor_traits;

    const Descriptor_sequence&
    Descriptor () const;

    Descriptor_sequence&
    Descriptor ();

    void
    Descriptor (const Descriptor_sequence& s);

    // DescriptorValueDomain
    //
    typedef ::XMLSchema::DescriptorValueDomain DescriptorValueDomain_type;
    typedef ::xsd::cxx::tree::sequence< DescriptorValueDomain_type > DescriptorValueDomain_sequence;
    typedef DescriptorValueDomain_sequence::iterator DescriptorValueDomain_iterator;
    typedef DescriptorValueDomain_sequence::const_iterator DescriptorValueDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< DescriptorValueDomain_type, char > DescriptorValueDomain_traits;

    const DescriptorValueDomain_sequence&
    DescriptorValueDomain () const;

    DescriptorValueDomain_sequence&
    DescriptorValueDomain ();

    void
    DescriptorValueDomain (const DescriptorValueDomain_sequence& s);

    // DescriptorVariable
    //
    typedef ::XMLSchema::DescriptorVariable DescriptorVariable_type;
    typedef ::xsd::cxx::tree::sequence< DescriptorVariable_type > DescriptorVariable_sequence;
    typedef DescriptorVariable_sequence::iterator DescriptorVariable_iterator;
    typedef DescriptorVariable_sequence::const_iterator DescriptorVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< DescriptorVariable_type, char > DescriptorVariable_traits;

    const DescriptorVariable_sequence&
    DescriptorVariable () const;

    DescriptorVariable_sequence&
    DescriptorVariable ();

    void
    DescriptorVariable (const DescriptorVariable_sequence& s);

    // DeterministicImperative
    //
    typedef ::XMLSchema::DeterministicImperative DeterministicImperative_type;
    typedef ::xsd::cxx::tree::sequence< DeterministicImperative_type > DeterministicImperative_sequence;
    typedef DeterministicImperative_sequence::iterator DeterministicImperative_iterator;
    typedef DeterministicImperative_sequence::const_iterator DeterministicImperative_const_iterator;
    typedef ::xsd::cxx::tree::traits< DeterministicImperative_type, char > DeterministicImperative_traits;

    const DeterministicImperative_sequence&
    DeterministicImperative () const;

    DeterministicImperative_sequence&
    DeterministicImperative ();

    void
    DeterministicImperative (const DeterministicImperative_sequence& s);

    // DimensionComponent
    //
    typedef ::XMLSchema::DimensionComponent DimensionComponent_type;
    typedef ::xsd::cxx::tree::sequence< DimensionComponent_type > DimensionComponent_sequence;
    typedef DimensionComponent_sequence::iterator DimensionComponent_iterator;
    typedef DimensionComponent_sequence::const_iterator DimensionComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionComponent_type, char > DimensionComponent_traits;

    const DimensionComponent_sequence&
    DimensionComponent () const;

    DimensionComponent_sequence&
    DimensionComponent ();

    void
    DimensionComponent (const DimensionComponent_sequence& s);

    // DimensionGroup
    //
    typedef ::XMLSchema::DimensionGroup DimensionGroup_type;
    typedef ::xsd::cxx::tree::sequence< DimensionGroup_type > DimensionGroup_sequence;
    typedef DimensionGroup_sequence::iterator DimensionGroup_iterator;
    typedef DimensionGroup_sequence::const_iterator DimensionGroup_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionGroup_type, char > DimensionGroup_traits;

    const DimensionGroup_sequence&
    DimensionGroup () const;

    DimensionGroup_sequence&
    DimensionGroup ();

    void
    DimensionGroup (const DimensionGroup_sequence& s);

    // DimensionalDataSet
    //
    typedef ::XMLSchema::DimensionalDataSet DimensionalDataSet_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalDataSet_type > DimensionalDataSet_sequence;
    typedef DimensionalDataSet_sequence::iterator DimensionalDataSet_iterator;
    typedef DimensionalDataSet_sequence::const_iterator DimensionalDataSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalDataSet_type, char > DimensionalDataSet_traits;

    const DimensionalDataSet_sequence&
    DimensionalDataSet () const;

    DimensionalDataSet_sequence&
    DimensionalDataSet ();

    void
    DimensionalDataSet (const DimensionalDataSet_sequence& s);

    // DimensionalDataStructure
    //
    typedef ::XMLSchema::DimensionalDataStructure DimensionalDataStructure_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalDataStructure_type > DimensionalDataStructure_sequence;
    typedef DimensionalDataStructure_sequence::iterator DimensionalDataStructure_iterator;
    typedef DimensionalDataStructure_sequence::const_iterator DimensionalDataStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalDataStructure_type, char > DimensionalDataStructure_traits;

    const DimensionalDataStructure_sequence&
    DimensionalDataStructure () const;

    DimensionalDataStructure_sequence&
    DimensionalDataStructure ();

    void
    DimensionalDataStructure (const DimensionalDataStructure_sequence& s);

    // DimensionalKey
    //
    typedef ::XMLSchema::DimensionalKey DimensionalKey_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalKey_type > DimensionalKey_sequence;
    typedef DimensionalKey_sequence::iterator DimensionalKey_iterator;
    typedef DimensionalKey_sequence::const_iterator DimensionalKey_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalKey_type, char > DimensionalKey_traits;

    const DimensionalKey_sequence&
    DimensionalKey () const;

    DimensionalKey_sequence&
    DimensionalKey ();

    void
    DimensionalKey (const DimensionalKey_sequence& s);

    // DimensionalKeyDefinition
    //
    typedef ::XMLSchema::DimensionalKeyDefinition DimensionalKeyDefinition_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalKeyDefinition_type > DimensionalKeyDefinition_sequence;
    typedef DimensionalKeyDefinition_sequence::iterator DimensionalKeyDefinition_iterator;
    typedef DimensionalKeyDefinition_sequence::const_iterator DimensionalKeyDefinition_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalKeyDefinition_type, char > DimensionalKeyDefinition_traits;

    const DimensionalKeyDefinition_sequence&
    DimensionalKeyDefinition () const;

    DimensionalKeyDefinition_sequence&
    DimensionalKeyDefinition ();

    void
    DimensionalKeyDefinition (const DimensionalKeyDefinition_sequence& s);

    // DimensionalKeyDefinitionMember
    //
    typedef ::XMLSchema::DimensionalKeyDefinitionMember DimensionalKeyDefinitionMember_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalKeyDefinitionMember_type > DimensionalKeyDefinitionMember_sequence;
    typedef DimensionalKeyDefinitionMember_sequence::iterator DimensionalKeyDefinitionMember_iterator;
    typedef DimensionalKeyDefinitionMember_sequence::const_iterator DimensionalKeyDefinitionMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalKeyDefinitionMember_type, char > DimensionalKeyDefinitionMember_traits;

    const DimensionalKeyDefinitionMember_sequence&
    DimensionalKeyDefinitionMember () const;

    DimensionalKeyDefinitionMember_sequence&
    DimensionalKeyDefinitionMember ();

    void
    DimensionalKeyDefinitionMember (const DimensionalKeyDefinitionMember_sequence& s);

    // DimensionalKeyMember
    //
    typedef ::XMLSchema::DimensionalKeyMember DimensionalKeyMember_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalKeyMember_type > DimensionalKeyMember_sequence;
    typedef DimensionalKeyMember_sequence::iterator DimensionalKeyMember_iterator;
    typedef DimensionalKeyMember_sequence::const_iterator DimensionalKeyMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalKeyMember_type, char > DimensionalKeyMember_traits;

    const DimensionalKeyMember_sequence&
    DimensionalKeyMember () const;

    DimensionalKeyMember_sequence&
    DimensionalKeyMember ();

    void
    DimensionalKeyMember (const DimensionalKeyMember_sequence& s);

    // EnumerationDomain
    //
    typedef ::XMLSchema::EnumerationDomain EnumerationDomain_type;
    typedef ::xsd::cxx::tree::sequence< EnumerationDomain_type > EnumerationDomain_sequence;
    typedef EnumerationDomain_sequence::iterator EnumerationDomain_iterator;
    typedef EnumerationDomain_sequence::const_iterator EnumerationDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< EnumerationDomain_type, char > EnumerationDomain_traits;

    const EnumerationDomain_sequence&
    EnumerationDomain () const;

    EnumerationDomain_sequence&
    EnumerationDomain ();

    void
    EnumerationDomain (const EnumerationDomain_sequence& s);

    // ForeignKey
    //
    typedef ::XMLSchema::ForeignKey ForeignKey_type;
    typedef ::xsd::cxx::tree::sequence< ForeignKey_type > ForeignKey_sequence;
    typedef ForeignKey_sequence::iterator ForeignKey_iterator;
    typedef ForeignKey_sequence::const_iterator ForeignKey_const_iterator;
    typedef ::xsd::cxx::tree::traits< ForeignKey_type, char > ForeignKey_traits;

    const ForeignKey_sequence&
    ForeignKey () const;

    ForeignKey_sequence&
    ForeignKey ();

    void
    ForeignKey (const ForeignKey_sequence& s);

    // ForeignKeyComponent
    //
    typedef ::XMLSchema::ForeignKeyComponent ForeignKeyComponent_type;
    typedef ::xsd::cxx::tree::sequence< ForeignKeyComponent_type > ForeignKeyComponent_sequence;
    typedef ForeignKeyComponent_sequence::iterator ForeignKeyComponent_iterator;
    typedef ForeignKeyComponent_sequence::const_iterator ForeignKeyComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< ForeignKeyComponent_type, char > ForeignKeyComponent_traits;

    const ForeignKeyComponent_sequence&
    ForeignKeyComponent () const;

    ForeignKeyComponent_sequence&
    ForeignKeyComponent ();

    void
    ForeignKeyComponent (const ForeignKeyComponent_sequence& s);

    // IdentifierComponent
    //
    typedef ::XMLSchema::IdentifierComponent IdentifierComponent_type;
    typedef ::xsd::cxx::tree::sequence< IdentifierComponent_type > IdentifierComponent_sequence;
    typedef IdentifierComponent_sequence::iterator IdentifierComponent_iterator;
    typedef IdentifierComponent_sequence::const_iterator IdentifierComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< IdentifierComponent_type, char > IdentifierComponent_traits;

    const IdentifierComponent_sequence&
    IdentifierComponent () const;

    IdentifierComponent_sequence&
    IdentifierComponent ();

    void
    IdentifierComponent (const IdentifierComponent_sequence& s);

    // Individual
    //
    typedef ::XMLSchema::Individual Individual_type;
    typedef ::xsd::cxx::tree::sequence< Individual_type > Individual_sequence;
    typedef Individual_sequence::iterator Individual_iterator;
    typedef Individual_sequence::const_iterator Individual_const_iterator;
    typedef ::xsd::cxx::tree::traits< Individual_type, char > Individual_traits;

    const Individual_sequence&
    Individual () const;

    Individual_sequence&
    Individual ();

    void
    Individual (const Individual_sequence& s);

    // InformationFlowDefinition
    //
    typedef ::XMLSchema::InformationFlowDefinition InformationFlowDefinition_type;
    typedef ::xsd::cxx::tree::sequence< InformationFlowDefinition_type > InformationFlowDefinition_sequence;
    typedef InformationFlowDefinition_sequence::iterator InformationFlowDefinition_iterator;
    typedef InformationFlowDefinition_sequence::const_iterator InformationFlowDefinition_const_iterator;
    typedef ::xsd::cxx::tree::traits< InformationFlowDefinition_type, char > InformationFlowDefinition_traits;

    const InformationFlowDefinition_sequence&
    InformationFlowDefinition () const;

    InformationFlowDefinition_sequence&
    InformationFlowDefinition ();

    void
    InformationFlowDefinition (const InformationFlowDefinition_sequence& s);

    // InstanceKey
    //
    typedef ::XMLSchema::InstanceKey InstanceKey_type;
    typedef ::xsd::cxx::tree::sequence< InstanceKey_type > InstanceKey_sequence;
    typedef InstanceKey_sequence::iterator InstanceKey_iterator;
    typedef InstanceKey_sequence::const_iterator InstanceKey_const_iterator;
    typedef ::xsd::cxx::tree::traits< InstanceKey_type, char > InstanceKey_traits;

    const InstanceKey_sequence&
    InstanceKey () const;

    InstanceKey_sequence&
    InstanceKey ();

    void
    InstanceKey (const InstanceKey_sequence& s);

    // InstanceValue
    //
    typedef ::XMLSchema::InstanceValue InstanceValue_type;
    typedef ::xsd::cxx::tree::sequence< InstanceValue_type > InstanceValue_sequence;
    typedef InstanceValue_sequence::iterator InstanceValue_iterator;
    typedef InstanceValue_sequence::const_iterator InstanceValue_const_iterator;
    typedef ::xsd::cxx::tree::traits< InstanceValue_type, char > InstanceValue_traits;

    const InstanceValue_sequence&
    InstanceValue () const;

    InstanceValue_sequence&
    InstanceValue ();

    void
    InstanceValue (const InstanceValue_sequence& s);

    // InstanceVariable
    //
    typedef ::XMLSchema::InstanceVariable InstanceVariable_type;
    typedef ::xsd::cxx::tree::sequence< InstanceVariable_type > InstanceVariable_sequence;
    typedef InstanceVariable_sequence::iterator InstanceVariable_iterator;
    typedef InstanceVariable_sequence::const_iterator InstanceVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< InstanceVariable_type, char > InstanceVariable_traits;

    const InstanceVariable_sequence&
    InstanceVariable () const;

    InstanceVariable_sequence&
    InstanceVariable ();

    void
    InstanceVariable (const InstanceVariable_sequence& s);

    // InstanceVariableMap
    //
    typedef ::XMLSchema::InstanceVariableMap InstanceVariableMap_type;
    typedef ::xsd::cxx::tree::sequence< InstanceVariableMap_type > InstanceVariableMap_sequence;
    typedef InstanceVariableMap_sequence::iterator InstanceVariableMap_iterator;
    typedef InstanceVariableMap_sequence::const_iterator InstanceVariableMap_const_iterator;
    typedef ::xsd::cxx::tree::traits< InstanceVariableMap_type, char > InstanceVariableMap_traits;

    const InstanceVariableMap_sequence&
    InstanceVariableMap () const;

    InstanceVariableMap_sequence&
    InstanceVariableMap ();

    void
    InstanceVariableMap (const InstanceVariableMap_sequence& s);

    // Key
    //
    typedef ::XMLSchema::Key Key_type;
    typedef ::xsd::cxx::tree::sequence< Key_type > Key_sequence;
    typedef Key_sequence::iterator Key_iterator;
    typedef Key_sequence::const_iterator Key_const_iterator;
    typedef ::xsd::cxx::tree::traits< Key_type, char > Key_traits;

    const Key_sequence&
    Key () const;

    Key_sequence&
    Key ();

    void
    Key (const Key_sequence& s);

    // KeyDefinition
    //
    typedef ::XMLSchema::KeyDefinition KeyDefinition_type;
    typedef ::xsd::cxx::tree::sequence< KeyDefinition_type > KeyDefinition_sequence;
    typedef KeyDefinition_sequence::iterator KeyDefinition_iterator;
    typedef KeyDefinition_sequence::const_iterator KeyDefinition_const_iterator;
    typedef ::xsd::cxx::tree::traits< KeyDefinition_type, char > KeyDefinition_traits;

    const KeyDefinition_sequence&
    KeyDefinition () const;

    KeyDefinition_sequence&
    KeyDefinition ();

    void
    KeyDefinition (const KeyDefinition_sequence& s);

    // KeyDefinitionMember
    //
    typedef ::XMLSchema::KeyDefinitionMember KeyDefinitionMember_type;
    typedef ::xsd::cxx::tree::sequence< KeyDefinitionMember_type > KeyDefinitionMember_sequence;
    typedef KeyDefinitionMember_sequence::iterator KeyDefinitionMember_iterator;
    typedef KeyDefinitionMember_sequence::const_iterator KeyDefinitionMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< KeyDefinitionMember_type, char > KeyDefinitionMember_traits;

    const KeyDefinitionMember_sequence&
    KeyDefinitionMember () const;

    KeyDefinitionMember_sequence&
    KeyDefinitionMember ();

    void
    KeyDefinitionMember (const KeyDefinitionMember_sequence& s);

    // KeyMember
    //
    typedef ::XMLSchema::KeyMember KeyMember_type;
    typedef ::xsd::cxx::tree::sequence< KeyMember_type > KeyMember_sequence;
    typedef KeyMember_sequence::iterator KeyMember_iterator;
    typedef KeyMember_sequence::const_iterator KeyMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< KeyMember_type, char > KeyMember_traits;

    const KeyMember_sequence&
    KeyMember () const;

    KeyMember_sequence&
    KeyMember ();

    void
    KeyMember (const KeyMember_sequence& s);

    // KeyValueDataStore
    //
    typedef ::XMLSchema::KeyValueDataStore KeyValueDataStore_type;
    typedef ::xsd::cxx::tree::sequence< KeyValueDataStore_type > KeyValueDataStore_sequence;
    typedef KeyValueDataStore_sequence::iterator KeyValueDataStore_iterator;
    typedef KeyValueDataStore_sequence::const_iterator KeyValueDataStore_const_iterator;
    typedef ::xsd::cxx::tree::traits< KeyValueDataStore_type, char > KeyValueDataStore_traits;

    const KeyValueDataStore_sequence&
    KeyValueDataStore () const;

    KeyValueDataStore_sequence&
    KeyValueDataStore ();

    void
    KeyValueDataStore (const KeyValueDataStore_sequence& s);

    // KeyValueStructure
    //
    typedef ::XMLSchema::KeyValueStructure KeyValueStructure_type;
    typedef ::xsd::cxx::tree::sequence< KeyValueStructure_type > KeyValueStructure_sequence;
    typedef KeyValueStructure_sequence::iterator KeyValueStructure_iterator;
    typedef KeyValueStructure_sequence::const_iterator KeyValueStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< KeyValueStructure_type, char > KeyValueStructure_traits;

    const KeyValueStructure_sequence&
    KeyValueStructure () const;

    KeyValueStructure_sequence&
    KeyValueStructure ();

    void
    KeyValueStructure (const KeyValueStructure_sequence& s);

    // Level
    //
    typedef ::XMLSchema::Level Level_type;
    typedef ::xsd::cxx::tree::sequence< Level_type > Level_sequence;
    typedef Level_sequence::iterator Level_iterator;
    typedef Level_sequence::const_iterator Level_const_iterator;
    typedef ::xsd::cxx::tree::traits< Level_type, char > Level_traits;

    const Level_sequence&
    Level () const;

    Level_sequence&
    Level ();

    void
    Level (const Level_sequence& s);

    // LevelStructure
    //
    typedef ::XMLSchema::LevelStructure LevelStructure_type;
    typedef ::xsd::cxx::tree::sequence< LevelStructure_type > LevelStructure_sequence;
    typedef LevelStructure_sequence::iterator LevelStructure_iterator;
    typedef LevelStructure_sequence::const_iterator LevelStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< LevelStructure_type, char > LevelStructure_traits;

    const LevelStructure_sequence&
    LevelStructure () const;

    LevelStructure_sequence&
    LevelStructure ();

    void
    LevelStructure (const LevelStructure_sequence& s);

    // LogicalRecord
    //
    typedef ::XMLSchema::LogicalRecord LogicalRecord_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecord_type > LogicalRecord_sequence;
    typedef LogicalRecord_sequence::iterator LogicalRecord_iterator;
    typedef LogicalRecord_sequence::const_iterator LogicalRecord_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecord_type, char > LogicalRecord_traits;

    const LogicalRecord_sequence&
    LogicalRecord () const;

    LogicalRecord_sequence&
    LogicalRecord ();

    void
    LogicalRecord (const LogicalRecord_sequence& s);

    // LogicalRecordPosition
    //
    typedef ::XMLSchema::LogicalRecordPosition LogicalRecordPosition_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecordPosition_type > LogicalRecordPosition_sequence;
    typedef LogicalRecordPosition_sequence::iterator LogicalRecordPosition_iterator;
    typedef LogicalRecordPosition_sequence::const_iterator LogicalRecordPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecordPosition_type, char > LogicalRecordPosition_traits;

    const LogicalRecordPosition_sequence&
    LogicalRecordPosition () const;

    LogicalRecordPosition_sequence&
    LogicalRecordPosition ();

    void
    LogicalRecordPosition (const LogicalRecordPosition_sequence& s);

    // LogicalRecordRelationStructure
    //
    typedef ::XMLSchema::LogicalRecordRelationStructure LogicalRecordRelationStructure_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecordRelationStructure_type > LogicalRecordRelationStructure_sequence;
    typedef LogicalRecordRelationStructure_sequence::iterator LogicalRecordRelationStructure_iterator;
    typedef LogicalRecordRelationStructure_sequence::const_iterator LogicalRecordRelationStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecordRelationStructure_type, char > LogicalRecordRelationStructure_traits;

    const LogicalRecordRelationStructure_sequence&
    LogicalRecordRelationStructure () const;

    LogicalRecordRelationStructure_sequence&
    LogicalRecordRelationStructure ();

    void
    LogicalRecordRelationStructure (const LogicalRecordRelationStructure_sequence& s);

    // LogicalRecordRelationship
    //
    typedef ::XMLSchema::LogicalRecordRelationship LogicalRecordRelationship_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecordRelationship_type > LogicalRecordRelationship_sequence;
    typedef LogicalRecordRelationship_sequence::iterator LogicalRecordRelationship_iterator;
    typedef LogicalRecordRelationship_sequence::const_iterator LogicalRecordRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecordRelationship_type, char > LogicalRecordRelationship_traits;

    const LogicalRecordRelationship_sequence&
    LogicalRecordRelationship () const;

    LogicalRecordRelationship_sequence&
    LogicalRecordRelationship ();

    void
    LogicalRecordRelationship (const LogicalRecordRelationship_sequence& s);

    // LongDataSet
    //
    typedef ::XMLSchema::LongDataSet LongDataSet_type;
    typedef ::xsd::cxx::tree::sequence< LongDataSet_type > LongDataSet_sequence;
    typedef LongDataSet_sequence::iterator LongDataSet_iterator;
    typedef LongDataSet_sequence::const_iterator LongDataSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< LongDataSet_type, char > LongDataSet_traits;

    const LongDataSet_sequence&
    LongDataSet () const;

    LongDataSet_sequence&
    LongDataSet ();

    void
    LongDataSet (const LongDataSet_sequence& s);

    // LongDataStructure
    //
    typedef ::XMLSchema::LongDataStructure LongDataStructure_type;
    typedef ::xsd::cxx::tree::sequence< LongDataStructure_type > LongDataStructure_sequence;
    typedef LongDataStructure_sequence::iterator LongDataStructure_iterator;
    typedef LongDataStructure_sequence::const_iterator LongDataStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< LongDataStructure_type, char > LongDataStructure_traits;

    const LongDataStructure_sequence&
    LongDataStructure () const;

    LongDataStructure_sequence&
    LongDataStructure ();

    void
    LongDataStructure (const LongDataStructure_sequence& s);

    // LongKey
    //
    typedef ::XMLSchema::LongKey LongKey_type;
    typedef ::xsd::cxx::tree::sequence< LongKey_type > LongKey_sequence;
    typedef LongKey_sequence::iterator LongKey_iterator;
    typedef LongKey_sequence::const_iterator LongKey_const_iterator;
    typedef ::xsd::cxx::tree::traits< LongKey_type, char > LongKey_traits;

    const LongKey_sequence&
    LongKey () const;

    LongKey_sequence&
    LongKey ();

    void
    LongKey (const LongKey_sequence& s);

    // LongMainKeyMember
    //
    typedef ::XMLSchema::LongMainKeyMember LongMainKeyMember_type;
    typedef ::xsd::cxx::tree::sequence< LongMainKeyMember_type > LongMainKeyMember_sequence;
    typedef LongMainKeyMember_sequence::iterator LongMainKeyMember_iterator;
    typedef LongMainKeyMember_sequence::const_iterator LongMainKeyMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< LongMainKeyMember_type, char > LongMainKeyMember_traits;

    const LongMainKeyMember_sequence&
    LongMainKeyMember () const;

    LongMainKeyMember_sequence&
    LongMainKeyMember ();

    void
    LongMainKeyMember (const LongMainKeyMember_sequence& s);

    // Machine
    //
    typedef ::XMLSchema::Machine Machine_type;
    typedef ::xsd::cxx::tree::sequence< Machine_type > Machine_sequence;
    typedef Machine_sequence::iterator Machine_iterator;
    typedef Machine_sequence::const_iterator Machine_const_iterator;
    typedef ::xsd::cxx::tree::traits< Machine_type, char > Machine_traits;

    const Machine_sequence&
    Machine () const;

    Machine_sequence&
    Machine ();

    void
    Machine (const Machine_sequence& s);

    // MainKeyMember
    //
    typedef ::XMLSchema::MainKeyMember MainKeyMember_type;
    typedef ::xsd::cxx::tree::sequence< MainKeyMember_type > MainKeyMember_sequence;
    typedef MainKeyMember_sequence::iterator MainKeyMember_iterator;
    typedef MainKeyMember_sequence::const_iterator MainKeyMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< MainKeyMember_type, char > MainKeyMember_traits;

    const MainKeyMember_sequence&
    MainKeyMember () const;

    MainKeyMember_sequence&
    MainKeyMember ();

    void
    MainKeyMember (const MainKeyMember_sequence& s);

    // MeasureComponent
    //
    typedef ::XMLSchema::MeasureComponent MeasureComponent_type;
    typedef ::xsd::cxx::tree::sequence< MeasureComponent_type > MeasureComponent_sequence;
    typedef MeasureComponent_sequence::iterator MeasureComponent_iterator;
    typedef MeasureComponent_sequence::const_iterator MeasureComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< MeasureComponent_type, char > MeasureComponent_traits;

    const MeasureComponent_sequence&
    MeasureComponent () const;

    MeasureComponent_sequence&
    MeasureComponent ();

    void
    MeasureComponent (const MeasureComponent_sequence& s);

    // NonDeterministicDeclarative
    //
    typedef ::XMLSchema::NonDeterministicDeclarative NonDeterministicDeclarative_type;
    typedef ::xsd::cxx::tree::sequence< NonDeterministicDeclarative_type > NonDeterministicDeclarative_sequence;
    typedef NonDeterministicDeclarative_sequence::iterator NonDeterministicDeclarative_iterator;
    typedef NonDeterministicDeclarative_sequence::const_iterator NonDeterministicDeclarative_const_iterator;
    typedef ::xsd::cxx::tree::traits< NonDeterministicDeclarative_type, char > NonDeterministicDeclarative_traits;

    const NonDeterministicDeclarative_sequence&
    NonDeterministicDeclarative () const;

    NonDeterministicDeclarative_sequence&
    NonDeterministicDeclarative ();

    void
    NonDeterministicDeclarative (const NonDeterministicDeclarative_sequence& s);

    // Notation
    //
    typedef ::XMLSchema::Notation Notation_type;
    typedef ::xsd::cxx::tree::sequence< Notation_type > Notation_sequence;
    typedef Notation_sequence::iterator Notation_iterator;
    typedef Notation_sequence::const_iterator Notation_const_iterator;
    typedef ::xsd::cxx::tree::traits< Notation_type, char > Notation_traits;

    const Notation_sequence&
    Notation () const;

    Notation_sequence&
    Notation ();

    void
    Notation (const Notation_sequence& s);

    // Organization
    //
    typedef ::XMLSchema::Organization Organization_type;
    typedef ::xsd::cxx::tree::sequence< Organization_type > Organization_sequence;
    typedef Organization_sequence::iterator Organization_iterator;
    typedef Organization_sequence::const_iterator Organization_const_iterator;
    typedef ::xsd::cxx::tree::traits< Organization_type, char > Organization_traits;

    const Organization_sequence&
    Organization () const;

    Organization_sequence&
    Organization ();

    void
    Organization (const Organization_sequence& s);

    // Parameter
    //
    typedef ::XMLSchema::Parameter Parameter_type;
    typedef ::xsd::cxx::tree::sequence< Parameter_type > Parameter_sequence;
    typedef Parameter_sequence::iterator Parameter_iterator;
    typedef Parameter_sequence::const_iterator Parameter_const_iterator;
    typedef ::xsd::cxx::tree::traits< Parameter_type, char > Parameter_traits;

    const Parameter_sequence&
    Parameter () const;

    Parameter_sequence&
    Parameter ();

    void
    Parameter (const Parameter_sequence& s);

    // PhysicalDataSet
    //
    typedef ::XMLSchema::PhysicalDataSet PhysicalDataSet_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalDataSet_type > PhysicalDataSet_sequence;
    typedef PhysicalDataSet_sequence::iterator PhysicalDataSet_iterator;
    typedef PhysicalDataSet_sequence::const_iterator PhysicalDataSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalDataSet_type, char > PhysicalDataSet_traits;

    const PhysicalDataSet_sequence&
    PhysicalDataSet () const;

    PhysicalDataSet_sequence&
    PhysicalDataSet ();

    void
    PhysicalDataSet (const PhysicalDataSet_sequence& s);

    // PhysicalDataSetStructure
    //
    typedef ::XMLSchema::PhysicalDataSetStructure PhysicalDataSetStructure_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalDataSetStructure_type > PhysicalDataSetStructure_sequence;
    typedef PhysicalDataSetStructure_sequence::iterator PhysicalDataSetStructure_iterator;
    typedef PhysicalDataSetStructure_sequence::const_iterator PhysicalDataSetStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalDataSetStructure_type, char > PhysicalDataSetStructure_traits;

    const PhysicalDataSetStructure_sequence&
    PhysicalDataSetStructure () const;

    PhysicalDataSetStructure_sequence&
    PhysicalDataSetStructure ();

    void
    PhysicalDataSetStructure (const PhysicalDataSetStructure_sequence& s);

    // PhysicalLayoutRelationStructure
    //
    typedef ::XMLSchema::PhysicalLayoutRelationStructure PhysicalLayoutRelationStructure_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalLayoutRelationStructure_type > PhysicalLayoutRelationStructure_sequence;
    typedef PhysicalLayoutRelationStructure_sequence::iterator PhysicalLayoutRelationStructure_iterator;
    typedef PhysicalLayoutRelationStructure_sequence::const_iterator PhysicalLayoutRelationStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalLayoutRelationStructure_type, char > PhysicalLayoutRelationStructure_traits;

    const PhysicalLayoutRelationStructure_sequence&
    PhysicalLayoutRelationStructure () const;

    PhysicalLayoutRelationStructure_sequence&
    PhysicalLayoutRelationStructure ();

    void
    PhysicalLayoutRelationStructure (const PhysicalLayoutRelationStructure_sequence& s);

    // PhysicalRecordSegment
    //
    typedef ::XMLSchema::PhysicalRecordSegment PhysicalRecordSegment_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalRecordSegment_type > PhysicalRecordSegment_sequence;
    typedef PhysicalRecordSegment_sequence::iterator PhysicalRecordSegment_iterator;
    typedef PhysicalRecordSegment_sequence::const_iterator PhysicalRecordSegment_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegment_type, char > PhysicalRecordSegment_traits;

    const PhysicalRecordSegment_sequence&
    PhysicalRecordSegment () const;

    PhysicalRecordSegment_sequence&
    PhysicalRecordSegment ();

    void
    PhysicalRecordSegment (const PhysicalRecordSegment_sequence& s);

    // PhysicalRecordSegmentPosition
    //
    typedef ::XMLSchema::PhysicalRecordSegmentPosition PhysicalRecordSegmentPosition_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalRecordSegmentPosition_type > PhysicalRecordSegmentPosition_sequence;
    typedef PhysicalRecordSegmentPosition_sequence::iterator PhysicalRecordSegmentPosition_iterator;
    typedef PhysicalRecordSegmentPosition_sequence::const_iterator PhysicalRecordSegmentPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegmentPosition_type, char > PhysicalRecordSegmentPosition_traits;

    const PhysicalRecordSegmentPosition_sequence&
    PhysicalRecordSegmentPosition () const;

    PhysicalRecordSegmentPosition_sequence&
    PhysicalRecordSegmentPosition ();

    void
    PhysicalRecordSegmentPosition (const PhysicalRecordSegmentPosition_sequence& s);

    // PhysicalRecordSegmentRelationship
    //
    typedef ::XMLSchema::PhysicalRecordSegmentRelationship PhysicalRecordSegmentRelationship_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalRecordSegmentRelationship_type > PhysicalRecordSegmentRelationship_sequence;
    typedef PhysicalRecordSegmentRelationship_sequence::iterator PhysicalRecordSegmentRelationship_iterator;
    typedef PhysicalRecordSegmentRelationship_sequence::const_iterator PhysicalRecordSegmentRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegmentRelationship_type, char > PhysicalRecordSegmentRelationship_traits;

    const PhysicalRecordSegmentRelationship_sequence&
    PhysicalRecordSegmentRelationship () const;

    PhysicalRecordSegmentRelationship_sequence&
    PhysicalRecordSegmentRelationship ();

    void
    PhysicalRecordSegmentRelationship (const PhysicalRecordSegmentRelationship_sequence& s);

    // PhysicalRecordSegmentStructure
    //
    typedef ::XMLSchema::PhysicalRecordSegmentStructure PhysicalRecordSegmentStructure_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalRecordSegmentStructure_type > PhysicalRecordSegmentStructure_sequence;
    typedef PhysicalRecordSegmentStructure_sequence::iterator PhysicalRecordSegmentStructure_iterator;
    typedef PhysicalRecordSegmentStructure_sequence::const_iterator PhysicalRecordSegmentStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegmentStructure_type, char > PhysicalRecordSegmentStructure_traits;

    const PhysicalRecordSegmentStructure_sequence&
    PhysicalRecordSegmentStructure () const;

    PhysicalRecordSegmentStructure_sequence&
    PhysicalRecordSegmentStructure ();

    void
    PhysicalRecordSegmentStructure (const PhysicalRecordSegmentStructure_sequence& s);

    // PhysicalSegmentLayout
    //
    typedef ::XMLSchema::PhysicalSegmentLayout PhysicalSegmentLayout_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalSegmentLayout_type > PhysicalSegmentLayout_sequence;
    typedef PhysicalSegmentLayout_sequence::iterator PhysicalSegmentLayout_iterator;
    typedef PhysicalSegmentLayout_sequence::const_iterator PhysicalSegmentLayout_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalSegmentLayout_type, char > PhysicalSegmentLayout_traits;

    const PhysicalSegmentLayout_sequence&
    PhysicalSegmentLayout () const;

    PhysicalSegmentLayout_sequence&
    PhysicalSegmentLayout ();

    void
    PhysicalSegmentLayout (const PhysicalSegmentLayout_sequence& s);

    // PhysicalSegmentLocation
    //
    typedef ::XMLSchema::PhysicalSegmentLocation PhysicalSegmentLocation_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalSegmentLocation_type > PhysicalSegmentLocation_sequence;
    typedef PhysicalSegmentLocation_sequence::iterator PhysicalSegmentLocation_iterator;
    typedef PhysicalSegmentLocation_sequence::const_iterator PhysicalSegmentLocation_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalSegmentLocation_type, char > PhysicalSegmentLocation_traits;

    const PhysicalSegmentLocation_sequence&
    PhysicalSegmentLocation () const;

    PhysicalSegmentLocation_sequence&
    PhysicalSegmentLocation ();

    void
    PhysicalSegmentLocation (const PhysicalSegmentLocation_sequence& s);

    // Population
    //
    typedef ::XMLSchema::Population Population_type;
    typedef ::xsd::cxx::tree::sequence< Population_type > Population_sequence;
    typedef Population_sequence::iterator Population_iterator;
    typedef Population_sequence::const_iterator Population_const_iterator;
    typedef ::xsd::cxx::tree::traits< Population_type, char > Population_traits;

    const Population_sequence&
    Population () const;

    Population_sequence&
    Population ();

    void
    Population (const Population_sequence& s);

    // PrimaryKey
    //
    typedef ::XMLSchema::PrimaryKey PrimaryKey_type;
    typedef ::xsd::cxx::tree::sequence< PrimaryKey_type > PrimaryKey_sequence;
    typedef PrimaryKey_sequence::iterator PrimaryKey_iterator;
    typedef PrimaryKey_sequence::const_iterator PrimaryKey_const_iterator;
    typedef ::xsd::cxx::tree::traits< PrimaryKey_type, char > PrimaryKey_traits;

    const PrimaryKey_sequence&
    PrimaryKey () const;

    PrimaryKey_sequence&
    PrimaryKey ();

    void
    PrimaryKey (const PrimaryKey_sequence& s);

    // PrimaryKeyComponent
    //
    typedef ::XMLSchema::PrimaryKeyComponent PrimaryKeyComponent_type;
    typedef ::xsd::cxx::tree::sequence< PrimaryKeyComponent_type > PrimaryKeyComponent_sequence;
    typedef PrimaryKeyComponent_sequence::iterator PrimaryKeyComponent_iterator;
    typedef PrimaryKeyComponent_sequence::const_iterator PrimaryKeyComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< PrimaryKeyComponent_type, char > PrimaryKeyComponent_traits;

    const PrimaryKeyComponent_sequence&
    PrimaryKeyComponent () const;

    PrimaryKeyComponent_sequence&
    PrimaryKeyComponent ();

    void
    PrimaryKeyComponent (const PrimaryKeyComponent_sequence& s);

    // ProcessingAgent
    //
    typedef ::XMLSchema::ProcessingAgent ProcessingAgent_type;
    typedef ::xsd::cxx::tree::sequence< ProcessingAgent_type > ProcessingAgent_sequence;
    typedef ProcessingAgent_sequence::iterator ProcessingAgent_iterator;
    typedef ProcessingAgent_sequence::const_iterator ProcessingAgent_const_iterator;
    typedef ::xsd::cxx::tree::traits< ProcessingAgent_type, char > ProcessingAgent_traits;

    const ProcessingAgent_sequence&
    ProcessingAgent () const;

    ProcessingAgent_sequence&
    ProcessingAgent ();

    void
    ProcessingAgent (const ProcessingAgent_sequence& s);

    // ProductionEnvironment
    //
    typedef ::XMLSchema::ProductionEnvironment ProductionEnvironment_type;
    typedef ::xsd::cxx::tree::sequence< ProductionEnvironment_type > ProductionEnvironment_sequence;
    typedef ProductionEnvironment_sequence::iterator ProductionEnvironment_iterator;
    typedef ProductionEnvironment_sequence::const_iterator ProductionEnvironment_const_iterator;
    typedef ::xsd::cxx::tree::traits< ProductionEnvironment_type, char > ProductionEnvironment_traits;

    const ProductionEnvironment_sequence&
    ProductionEnvironment () const;

    ProductionEnvironment_sequence&
    ProductionEnvironment ();

    void
    ProductionEnvironment (const ProductionEnvironment_sequence& s);

    // QualifiedMeasure
    //
    typedef ::XMLSchema::QualifiedMeasure QualifiedMeasure_type;
    typedef ::xsd::cxx::tree::sequence< QualifiedMeasure_type > QualifiedMeasure_sequence;
    typedef QualifiedMeasure_sequence::iterator QualifiedMeasure_iterator;
    typedef QualifiedMeasure_sequence::const_iterator QualifiedMeasure_const_iterator;
    typedef ::xsd::cxx::tree::traits< QualifiedMeasure_type, char > QualifiedMeasure_traits;

    const QualifiedMeasure_sequence&
    QualifiedMeasure () const;

    QualifiedMeasure_sequence&
    QualifiedMeasure ();

    void
    QualifiedMeasure (const QualifiedMeasure_sequence& s);

    // RecordRelation
    //
    typedef ::XMLSchema::RecordRelation RecordRelation_type;
    typedef ::xsd::cxx::tree::sequence< RecordRelation_type > RecordRelation_sequence;
    typedef RecordRelation_sequence::iterator RecordRelation_iterator;
    typedef RecordRelation_sequence::const_iterator RecordRelation_const_iterator;
    typedef ::xsd::cxx::tree::traits< RecordRelation_type, char > RecordRelation_traits;

    const RecordRelation_sequence&
    RecordRelation () const;

    RecordRelation_sequence&
    RecordRelation ();

    void
    RecordRelation (const RecordRelation_sequence& s);

    // ReferenceValue
    //
    typedef ::XMLSchema::ReferenceValue ReferenceValue_type;
    typedef ::xsd::cxx::tree::sequence< ReferenceValue_type > ReferenceValue_sequence;
    typedef ReferenceValue_sequence::iterator ReferenceValue_iterator;
    typedef ReferenceValue_sequence::const_iterator ReferenceValue_const_iterator;
    typedef ::xsd::cxx::tree::traits< ReferenceValue_type, char > ReferenceValue_traits;

    const ReferenceValue_sequence&
    ReferenceValue () const;

    ReferenceValue_sequence&
    ReferenceValue ();

    void
    ReferenceValue (const ReferenceValue_sequence& s);

    // ReferenceValueDomain
    //
    typedef ::XMLSchema::ReferenceValueDomain ReferenceValueDomain_type;
    typedef ::xsd::cxx::tree::sequence< ReferenceValueDomain_type > ReferenceValueDomain_sequence;
    typedef ReferenceValueDomain_sequence::iterator ReferenceValueDomain_iterator;
    typedef ReferenceValueDomain_sequence::const_iterator ReferenceValueDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< ReferenceValueDomain_type, char > ReferenceValueDomain_traits;

    const ReferenceValueDomain_sequence&
    ReferenceValueDomain () const;

    ReferenceValueDomain_sequence&
    ReferenceValueDomain ();

    void
    ReferenceValueDomain (const ReferenceValueDomain_sequence& s);

    // ReferenceVariable
    //
    typedef ::XMLSchema::ReferenceVariable ReferenceVariable_type;
    typedef ::xsd::cxx::tree::sequence< ReferenceVariable_type > ReferenceVariable_sequence;
    typedef ReferenceVariable_sequence::iterator ReferenceVariable_iterator;
    typedef ReferenceVariable_sequence::const_iterator ReferenceVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< ReferenceVariable_type, char > ReferenceVariable_traits;

    const ReferenceVariable_sequence&
    ReferenceVariable () const;

    ReferenceVariable_sequence&
    ReferenceVariable ();

    void
    ReferenceVariable (const ReferenceVariable_sequence& s);

    // RepresentedVariable
    //
    typedef ::XMLSchema::RepresentedVariable RepresentedVariable_type;
    typedef ::xsd::cxx::tree::sequence< RepresentedVariable_type > RepresentedVariable_sequence;
    typedef RepresentedVariable_sequence::iterator RepresentedVariable_iterator;
    typedef RepresentedVariable_sequence::const_iterator RepresentedVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< RepresentedVariable_type, char > RepresentedVariable_traits;

    const RepresentedVariable_sequence&
    RepresentedVariable () const;

    RepresentedVariable_sequence&
    RepresentedVariable ();

    void
    RepresentedVariable (const RepresentedVariable_sequence& s);

    // RevisableDatum
    //
    typedef ::XMLSchema::RevisableDatum RevisableDatum_type;
    typedef ::xsd::cxx::tree::sequence< RevisableDatum_type > RevisableDatum_sequence;
    typedef RevisableDatum_sequence::iterator RevisableDatum_iterator;
    typedef RevisableDatum_sequence::const_iterator RevisableDatum_const_iterator;
    typedef ::xsd::cxx::tree::traits< RevisableDatum_type, char > RevisableDatum_traits;

    const RevisableDatum_sequence&
    RevisableDatum () const;

    RevisableDatum_sequence&
    RevisableDatum ();

    void
    RevisableDatum (const RevisableDatum_sequence& s);

    // Revision
    //
    typedef ::XMLSchema::Revision Revision_type;
    typedef ::xsd::cxx::tree::sequence< Revision_type > Revision_sequence;
    typedef Revision_sequence::iterator Revision_iterator;
    typedef Revision_sequence::const_iterator Revision_const_iterator;
    typedef ::xsd::cxx::tree::traits< Revision_type, char > Revision_traits;

    const Revision_sequence&
    Revision () const;

    Revision_sequence&
    Revision ();

    void
    Revision (const Revision_sequence& s);

    // Rule
    //
    typedef ::XMLSchema::Rule Rule_type;
    typedef ::xsd::cxx::tree::sequence< Rule_type > Rule_sequence;
    typedef Rule_sequence::iterator Rule_iterator;
    typedef Rule_sequence::const_iterator Rule_const_iterator;
    typedef ::xsd::cxx::tree::traits< Rule_type, char > Rule_traits;

    const Rule_sequence&
    Rule () const;

    Rule_sequence&
    Rule ();

    void
    Rule (const Rule_sequence& s);

    // RuleBasedScheduling
    //
    typedef ::XMLSchema::RuleBasedScheduling RuleBasedScheduling_type;
    typedef ::xsd::cxx::tree::sequence< RuleBasedScheduling_type > RuleBasedScheduling_sequence;
    typedef RuleBasedScheduling_sequence::iterator RuleBasedScheduling_iterator;
    typedef RuleBasedScheduling_sequence::const_iterator RuleBasedScheduling_const_iterator;
    typedef ::xsd::cxx::tree::traits< RuleBasedScheduling_type, char > RuleBasedScheduling_traits;

    const RuleBasedScheduling_sequence&
    RuleBasedScheduling () const;

    RuleBasedScheduling_sequence&
    RuleBasedScheduling ();

    void
    RuleBasedScheduling (const RuleBasedScheduling_sequence& s);

    // RuleSet
    //
    typedef ::XMLSchema::RuleSet RuleSet_type;
    typedef ::xsd::cxx::tree::sequence< RuleSet_type > RuleSet_sequence;
    typedef RuleSet_sequence::iterator RuleSet_iterator;
    typedef RuleSet_sequence::const_iterator RuleSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< RuleSet_type, char > RuleSet_traits;

    const RuleSet_sequence&
    RuleSet () const;

    RuleSet_sequence&
    RuleSet ();

    void
    RuleSet (const RuleSet_sequence& s);

    // ScopedMeasure
    //
    typedef ::XMLSchema::ScopedMeasure ScopedMeasure_type;
    typedef ::xsd::cxx::tree::sequence< ScopedMeasure_type > ScopedMeasure_sequence;
    typedef ScopedMeasure_sequence::iterator ScopedMeasure_iterator;
    typedef ScopedMeasure_sequence::const_iterator ScopedMeasure_const_iterator;
    typedef ::xsd::cxx::tree::traits< ScopedMeasure_type, char > ScopedMeasure_traits;

    const ScopedMeasure_sequence&
    ScopedMeasure () const;

    ScopedMeasure_sequence&
    ScopedMeasure ();

    void
    ScopedMeasure (const ScopedMeasure_sequence& s);

    // SegmentByText
    //
    typedef ::XMLSchema::SegmentByText SegmentByText_type;
    typedef ::xsd::cxx::tree::sequence< SegmentByText_type > SegmentByText_sequence;
    typedef SegmentByText_sequence::iterator SegmentByText_iterator;
    typedef SegmentByText_sequence::const_iterator SegmentByText_const_iterator;
    typedef ::xsd::cxx::tree::traits< SegmentByText_type, char > SegmentByText_traits;

    const SegmentByText_sequence&
    SegmentByText () const;

    SegmentByText_sequence&
    SegmentByText ();

    void
    SegmentByText (const SegmentByText_sequence& s);

    // SentinelConceptualDomain
    //
    typedef ::XMLSchema::SentinelConceptualDomain SentinelConceptualDomain_type;
    typedef ::xsd::cxx::tree::sequence< SentinelConceptualDomain_type > SentinelConceptualDomain_sequence;
    typedef SentinelConceptualDomain_sequence::iterator SentinelConceptualDomain_iterator;
    typedef SentinelConceptualDomain_sequence::const_iterator SentinelConceptualDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< SentinelConceptualDomain_type, char > SentinelConceptualDomain_traits;

    const SentinelConceptualDomain_sequence&
    SentinelConceptualDomain () const;

    SentinelConceptualDomain_sequence&
    SentinelConceptualDomain ();

    void
    SentinelConceptualDomain (const SentinelConceptualDomain_sequence& s);

    // SentinelValueDomain
    //
    typedef ::XMLSchema::SentinelValueDomain SentinelValueDomain_type;
    typedef ::xsd::cxx::tree::sequence< SentinelValueDomain_type > SentinelValueDomain_sequence;
    typedef SentinelValueDomain_sequence::iterator SentinelValueDomain_iterator;
    typedef SentinelValueDomain_sequence::const_iterator SentinelValueDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< SentinelValueDomain_type, char > SentinelValueDomain_traits;

    const SentinelValueDomain_sequence&
    SentinelValueDomain () const;

    SentinelValueDomain_sequence&
    SentinelValueDomain ();

    void
    SentinelValueDomain (const SentinelValueDomain_sequence& s);

    // Sequence
    //
    typedef ::XMLSchema::Sequence Sequence_type;
    typedef ::xsd::cxx::tree::sequence< Sequence_type > Sequence_sequence;
    typedef Sequence_sequence::iterator Sequence_iterator;
    typedef Sequence_sequence::const_iterator Sequence_const_iterator;
    typedef ::xsd::cxx::tree::traits< Sequence_type, char > Sequence_traits;

    const Sequence_sequence&
    Sequence () const;

    Sequence_sequence&
    Sequence ();

    void
    Sequence (const Sequence_sequence& s);

    // SequencePosition
    //
    typedef ::XMLSchema::SequencePosition SequencePosition_type;
    typedef ::xsd::cxx::tree::sequence< SequencePosition_type > SequencePosition_sequence;
    typedef SequencePosition_sequence::iterator SequencePosition_iterator;
    typedef SequencePosition_sequence::const_iterator SequencePosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< SequencePosition_type, char > SequencePosition_traits;

    const SequencePosition_sequence&
    SequencePosition () const;

    SequencePosition_sequence&
    SequencePosition ();

    void
    SequencePosition (const SequencePosition_sequence& s);

    // Service
    //
    typedef ::XMLSchema::Service Service_type;
    typedef ::xsd::cxx::tree::sequence< Service_type > Service_sequence;
    typedef Service_sequence::iterator Service_iterator;
    typedef Service_sequence::const_iterator Service_const_iterator;
    typedef ::xsd::cxx::tree::traits< Service_type, char > Service_traits;

    const Service_sequence&
    Service () const;

    Service_sequence&
    Service ();

    void
    Service (const Service_sequence& s);

    // StatisticalClassification
    //
    typedef ::XMLSchema::StatisticalClassification StatisticalClassification_type;
    typedef ::xsd::cxx::tree::sequence< StatisticalClassification_type > StatisticalClassification_sequence;
    typedef StatisticalClassification_sequence::iterator StatisticalClassification_iterator;
    typedef StatisticalClassification_sequence::const_iterator StatisticalClassification_const_iterator;
    typedef ::xsd::cxx::tree::traits< StatisticalClassification_type, char > StatisticalClassification_traits;

    const StatisticalClassification_sequence&
    StatisticalClassification () const;

    StatisticalClassification_sequence&
    StatisticalClassification ();

    void
    StatisticalClassification (const StatisticalClassification_sequence& s);

    // StatisticalClassificationRelationship
    //
    typedef ::XMLSchema::StatisticalClassificationRelationship StatisticalClassificationRelationship_type;
    typedef ::xsd::cxx::tree::sequence< StatisticalClassificationRelationship_type > StatisticalClassificationRelationship_sequence;
    typedef StatisticalClassificationRelationship_sequence::iterator StatisticalClassificationRelationship_iterator;
    typedef StatisticalClassificationRelationship_sequence::const_iterator StatisticalClassificationRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< StatisticalClassificationRelationship_type, char > StatisticalClassificationRelationship_traits;

    const StatisticalClassificationRelationship_sequence&
    StatisticalClassificationRelationship () const;

    StatisticalClassificationRelationship_sequence&
    StatisticalClassificationRelationship ();

    void
    StatisticalClassificationRelationship (const StatisticalClassificationRelationship_sequence& s);

    // Step
    //
    typedef ::XMLSchema::Step Step_type;
    typedef ::xsd::cxx::tree::sequence< Step_type > Step_sequence;
    typedef Step_sequence::iterator Step_iterator;
    typedef Step_sequence::const_iterator Step_const_iterator;
    typedef ::xsd::cxx::tree::traits< Step_type, char > Step_traits;

    const Step_sequence&
    Step () const;

    Step_sequence&
    Step ();

    void
    Step (const Step_sequence& s);

    // SubstantiveConceptualDomain
    //
    typedef ::XMLSchema::SubstantiveConceptualDomain SubstantiveConceptualDomain_type;
    typedef ::xsd::cxx::tree::sequence< SubstantiveConceptualDomain_type > SubstantiveConceptualDomain_sequence;
    typedef SubstantiveConceptualDomain_sequence::iterator SubstantiveConceptualDomain_iterator;
    typedef SubstantiveConceptualDomain_sequence::const_iterator SubstantiveConceptualDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< SubstantiveConceptualDomain_type, char > SubstantiveConceptualDomain_traits;

    const SubstantiveConceptualDomain_sequence&
    SubstantiveConceptualDomain () const;

    SubstantiveConceptualDomain_sequence&
    SubstantiveConceptualDomain ();

    void
    SubstantiveConceptualDomain (const SubstantiveConceptualDomain_sequence& s);

    // SubstantiveValueDomain
    //
    typedef ::XMLSchema::SubstantiveValueDomain SubstantiveValueDomain_type;
    typedef ::xsd::cxx::tree::sequence< SubstantiveValueDomain_type > SubstantiveValueDomain_sequence;
    typedef SubstantiveValueDomain_sequence::iterator SubstantiveValueDomain_iterator;
    typedef SubstantiveValueDomain_sequence::const_iterator SubstantiveValueDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< SubstantiveValueDomain_type, char > SubstantiveValueDomain_traits;

    const SubstantiveValueDomain_sequence&
    SubstantiveValueDomain () const;

    SubstantiveValueDomain_sequence&
    SubstantiveValueDomain ();

    void
    SubstantiveValueDomain (const SubstantiveValueDomain_sequence& s);

    // SyntheticIdComponent
    //
    typedef ::XMLSchema::SyntheticIdComponent SyntheticIdComponent_type;
    typedef ::xsd::cxx::tree::sequence< SyntheticIdComponent_type > SyntheticIdComponent_sequence;
    typedef SyntheticIdComponent_sequence::iterator SyntheticIdComponent_iterator;
    typedef SyntheticIdComponent_sequence::const_iterator SyntheticIdComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< SyntheticIdComponent_type, char > SyntheticIdComponent_traits;

    const SyntheticIdComponent_sequence&
    SyntheticIdComponent () const;

    SyntheticIdComponent_sequence&
    SyntheticIdComponent ();

    void
    SyntheticIdComponent (const SyntheticIdComponent_sequence& s);

    // TemporalConstraints
    //
    typedef ::XMLSchema::TemporalConstraints TemporalConstraints_type;
    typedef ::xsd::cxx::tree::sequence< TemporalConstraints_type > TemporalConstraints_sequence;
    typedef TemporalConstraints_sequence::iterator TemporalConstraints_iterator;
    typedef TemporalConstraints_sequence::const_iterator TemporalConstraints_const_iterator;
    typedef ::xsd::cxx::tree::traits< TemporalConstraints_type, char > TemporalConstraints_traits;

    const TemporalConstraints_sequence&
    TemporalConstraints () const;

    TemporalConstraints_sequence&
    TemporalConstraints ();

    void
    TemporalConstraints (const TemporalConstraints_sequence& s);

    // TemporalControlConstruct
    //
    typedef ::XMLSchema::TemporalControlConstruct TemporalControlConstruct_type;
    typedef ::xsd::cxx::tree::sequence< TemporalControlConstruct_type > TemporalControlConstruct_sequence;
    typedef TemporalControlConstruct_sequence::iterator TemporalControlConstruct_iterator;
    typedef TemporalControlConstruct_sequence::const_iterator TemporalControlConstruct_const_iterator;
    typedef ::xsd::cxx::tree::traits< TemporalControlConstruct_type, char > TemporalControlConstruct_traits;

    const TemporalControlConstruct_sequence&
    TemporalControlConstruct () const;

    TemporalControlConstruct_sequence&
    TemporalControlConstruct ();

    void
    TemporalControlConstruct (const TemporalControlConstruct_sequence& s);

    // Unit
    //
    typedef ::XMLSchema::Unit Unit_type;
    typedef ::xsd::cxx::tree::sequence< Unit_type > Unit_sequence;
    typedef Unit_sequence::iterator Unit_iterator;
    typedef Unit_sequence::const_iterator Unit_const_iterator;
    typedef ::xsd::cxx::tree::traits< Unit_type, char > Unit_traits;

    const Unit_sequence&
    Unit () const;

    Unit_sequence&
    Unit ();

    void
    Unit (const Unit_sequence& s);

    // UnitSegmentLayout
    //
    typedef ::XMLSchema::UnitSegmentLayout UnitSegmentLayout_type;
    typedef ::xsd::cxx::tree::sequence< UnitSegmentLayout_type > UnitSegmentLayout_sequence;
    typedef UnitSegmentLayout_sequence::iterator UnitSegmentLayout_iterator;
    typedef UnitSegmentLayout_sequence::const_iterator UnitSegmentLayout_const_iterator;
    typedef ::xsd::cxx::tree::traits< UnitSegmentLayout_type, char > UnitSegmentLayout_traits;

    const UnitSegmentLayout_sequence&
    UnitSegmentLayout () const;

    UnitSegmentLayout_sequence&
    UnitSegmentLayout ();

    void
    UnitSegmentLayout (const UnitSegmentLayout_sequence& s);

    // UnitType
    //
    typedef ::XMLSchema::UnitType UnitType_type;
    typedef ::xsd::cxx::tree::sequence< UnitType_type > UnitType_sequence;
    typedef UnitType_sequence::iterator UnitType_iterator;
    typedef UnitType_sequence::const_iterator UnitType_const_iterator;
    typedef ::xsd::cxx::tree::traits< UnitType_type, char > UnitType_traits;

    const UnitType_sequence&
    UnitType () const;

    UnitType_sequence&
    UnitType ();

    void
    UnitType (const UnitType_sequence& s);

    // Universe
    //
    typedef ::XMLSchema::Universe Universe_type;
    typedef ::xsd::cxx::tree::sequence< Universe_type > Universe_sequence;
    typedef Universe_sequence::iterator Universe_iterator;
    typedef Universe_sequence::const_iterator Universe_const_iterator;
    typedef ::xsd::cxx::tree::traits< Universe_type, char > Universe_traits;

    const Universe_sequence&
    Universe () const;

    Universe_sequence&
    Universe ();

    void
    Universe (const Universe_sequence& s);

    // ValueAndConceptDescription
    //
    typedef ::XMLSchema::ValueAndConceptDescription ValueAndConceptDescription_type;
    typedef ::xsd::cxx::tree::sequence< ValueAndConceptDescription_type > ValueAndConceptDescription_sequence;
    typedef ValueAndConceptDescription_sequence::iterator ValueAndConceptDescription_iterator;
    typedef ValueAndConceptDescription_sequence::const_iterator ValueAndConceptDescription_const_iterator;
    typedef ::xsd::cxx::tree::traits< ValueAndConceptDescription_type, char > ValueAndConceptDescription_traits;

    const ValueAndConceptDescription_sequence&
    ValueAndConceptDescription () const;

    ValueAndConceptDescription_sequence&
    ValueAndConceptDescription ();

    void
    ValueAndConceptDescription (const ValueAndConceptDescription_sequence& s);

    // ValueDomain
    //
    typedef ::XMLSchema::ValueDomain ValueDomain_type;
    typedef ::xsd::cxx::tree::sequence< ValueDomain_type > ValueDomain_sequence;
    typedef ValueDomain_sequence::iterator ValueDomain_iterator;
    typedef ValueDomain_sequence::const_iterator ValueDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< ValueDomain_type, char > ValueDomain_traits;

    const ValueDomain_sequence&
    ValueDomain () const;

    ValueDomain_sequence&
    ValueDomain ();

    void
    ValueDomain (const ValueDomain_sequence& s);

    // ValueMapping
    //
    typedef ::XMLSchema::ValueMapping ValueMapping_type;
    typedef ::xsd::cxx::tree::sequence< ValueMapping_type > ValueMapping_sequence;
    typedef ValueMapping_sequence::iterator ValueMapping_iterator;
    typedef ValueMapping_sequence::const_iterator ValueMapping_const_iterator;
    typedef ::xsd::cxx::tree::traits< ValueMapping_type, char > ValueMapping_traits;

    const ValueMapping_sequence&
    ValueMapping () const;

    ValueMapping_sequence&
    ValueMapping ();

    void
    ValueMapping (const ValueMapping_sequence& s);

    // ValueMappingPosition
    //
    typedef ::XMLSchema::ValueMappingPosition ValueMappingPosition_type;
    typedef ::xsd::cxx::tree::sequence< ValueMappingPosition_type > ValueMappingPosition_sequence;
    typedef ValueMappingPosition_sequence::iterator ValueMappingPosition_iterator;
    typedef ValueMappingPosition_sequence::const_iterator ValueMappingPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< ValueMappingPosition_type, char > ValueMappingPosition_traits;

    const ValueMappingPosition_sequence&
    ValueMappingPosition () const;

    ValueMappingPosition_sequence&
    ValueMappingPosition ();

    void
    ValueMappingPosition (const ValueMappingPosition_sequence& s);

    // ValueMappingRelationship
    //
    typedef ::XMLSchema::ValueMappingRelationship ValueMappingRelationship_type;
    typedef ::xsd::cxx::tree::sequence< ValueMappingRelationship_type > ValueMappingRelationship_sequence;
    typedef ValueMappingRelationship_sequence::iterator ValueMappingRelationship_iterator;
    typedef ValueMappingRelationship_sequence::const_iterator ValueMappingRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< ValueMappingRelationship_type, char > ValueMappingRelationship_traits;

    const ValueMappingRelationship_sequence&
    ValueMappingRelationship () const;

    ValueMappingRelationship_sequence&
    ValueMappingRelationship ();

    void
    ValueMappingRelationship (const ValueMappingRelationship_sequence& s);

    // VariableCollection
    //
    typedef ::XMLSchema::VariableCollection VariableCollection_type;
    typedef ::xsd::cxx::tree::sequence< VariableCollection_type > VariableCollection_sequence;
    typedef VariableCollection_sequence::iterator VariableCollection_iterator;
    typedef VariableCollection_sequence::const_iterator VariableCollection_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableCollection_type, char > VariableCollection_traits;

    const VariableCollection_sequence&
    VariableCollection () const;

    VariableCollection_sequence&
    VariableCollection ();

    void
    VariableCollection (const VariableCollection_sequence& s);

    // VariableDescriptorComponent
    //
    typedef ::XMLSchema::VariableDescriptorComponent VariableDescriptorComponent_type;
    typedef ::xsd::cxx::tree::sequence< VariableDescriptorComponent_type > VariableDescriptorComponent_sequence;
    typedef VariableDescriptorComponent_sequence::iterator VariableDescriptorComponent_iterator;
    typedef VariableDescriptorComponent_sequence::const_iterator VariableDescriptorComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableDescriptorComponent_type, char > VariableDescriptorComponent_traits;

    const VariableDescriptorComponent_sequence&
    VariableDescriptorComponent () const;

    VariableDescriptorComponent_sequence&
    VariableDescriptorComponent ();

    void
    VariableDescriptorComponent (const VariableDescriptorComponent_sequence& s);

    // VariablePosition
    //
    typedef ::XMLSchema::VariablePosition VariablePosition_type;
    typedef ::xsd::cxx::tree::sequence< VariablePosition_type > VariablePosition_sequence;
    typedef VariablePosition_sequence::iterator VariablePosition_iterator;
    typedef VariablePosition_sequence::const_iterator VariablePosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariablePosition_type, char > VariablePosition_traits;

    const VariablePosition_sequence&
    VariablePosition () const;

    VariablePosition_sequence&
    VariablePosition ();

    void
    VariablePosition (const VariablePosition_sequence& s);

    // VariableRelationship
    //
    typedef ::XMLSchema::VariableRelationship VariableRelationship_type;
    typedef ::xsd::cxx::tree::sequence< VariableRelationship_type > VariableRelationship_sequence;
    typedef VariableRelationship_sequence::iterator VariableRelationship_iterator;
    typedef VariableRelationship_sequence::const_iterator VariableRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableRelationship_type, char > VariableRelationship_traits;

    const VariableRelationship_sequence&
    VariableRelationship () const;

    VariableRelationship_sequence&
    VariableRelationship ();

    void
    VariableRelationship (const VariableRelationship_sequence& s);

    // VariableStructure
    //
    typedef ::XMLSchema::VariableStructure VariableStructure_type;
    typedef ::xsd::cxx::tree::sequence< VariableStructure_type > VariableStructure_sequence;
    typedef VariableStructure_sequence::iterator VariableStructure_iterator;
    typedef VariableStructure_sequence::const_iterator VariableStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableStructure_type, char > VariableStructure_traits;

    const VariableStructure_sequence&
    VariableStructure () const;

    VariableStructure_sequence&
    VariableStructure ();

    void
    VariableStructure (const VariableStructure_sequence& s);

    // VariableValueComponent
    //
    typedef ::XMLSchema::VariableValueComponent VariableValueComponent_type;
    typedef ::xsd::cxx::tree::sequence< VariableValueComponent_type > VariableValueComponent_sequence;
    typedef VariableValueComponent_sequence::iterator VariableValueComponent_iterator;
    typedef VariableValueComponent_sequence::const_iterator VariableValueComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableValueComponent_type, char > VariableValueComponent_traits;

    const VariableValueComponent_sequence&
    VariableValueComponent () const;

    VariableValueComponent_sequence&
    VariableValueComponent ();

    void
    VariableValueComponent (const VariableValueComponent_sequence& s);

    // WideDataSet
    //
    typedef ::XMLSchema::WideDataSet WideDataSet_type;
    typedef ::xsd::cxx::tree::sequence< WideDataSet_type > WideDataSet_sequence;
    typedef WideDataSet_sequence::iterator WideDataSet_iterator;
    typedef WideDataSet_sequence::const_iterator WideDataSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< WideDataSet_type, char > WideDataSet_traits;

    const WideDataSet_sequence&
    WideDataSet () const;

    WideDataSet_sequence&
    WideDataSet ();

    void
    WideDataSet (const WideDataSet_sequence& s);

    // WideDataStructure
    //
    typedef ::XMLSchema::WideDataStructure WideDataStructure_type;
    typedef ::xsd::cxx::tree::sequence< WideDataStructure_type > WideDataStructure_sequence;
    typedef WideDataStructure_sequence::iterator WideDataStructure_iterator;
    typedef WideDataStructure_sequence::const_iterator WideDataStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< WideDataStructure_type, char > WideDataStructure_traits;

    const WideDataStructure_sequence&
    WideDataStructure () const;

    WideDataStructure_sequence&
    WideDataStructure ();

    void
    WideDataStructure (const WideDataStructure_sequence& s);

    // WideKey
    //
    typedef ::XMLSchema::WideKey WideKey_type;
    typedef ::xsd::cxx::tree::sequence< WideKey_type > WideKey_sequence;
    typedef WideKey_sequence::iterator WideKey_iterator;
    typedef WideKey_sequence::const_iterator WideKey_const_iterator;
    typedef ::xsd::cxx::tree::traits< WideKey_type, char > WideKey_traits;

    const WideKey_sequence&
    WideKey () const;

    WideKey_sequence&
    WideKey ();

    void
    WideKey (const WideKey_sequence& s);

    // WideKeyMember
    //
    typedef ::XMLSchema::WideKeyMember WideKeyMember_type;
    typedef ::xsd::cxx::tree::sequence< WideKeyMember_type > WideKeyMember_sequence;
    typedef WideKeyMember_sequence::iterator WideKeyMember_iterator;
    typedef WideKeyMember_sequence::const_iterator WideKeyMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< WideKeyMember_type, char > WideKeyMember_traits;

    const WideKeyMember_sequence&
    WideKeyMember () const;

    WideKeyMember_sequence&
    WideKeyMember ();

    void
    WideKeyMember (const WideKeyMember_sequence& s);

    // Wrapper
    //
    typedef ::XMLSchema::Wrapper Wrapper_type;
    typedef ::xsd::cxx::tree::sequence< Wrapper_type > Wrapper_sequence;
    typedef Wrapper_sequence::iterator Wrapper_iterator;
    typedef Wrapper_sequence::const_iterator Wrapper_const_iterator;
    typedef ::xsd::cxx::tree::traits< Wrapper_type, char > Wrapper_traits;

    const Wrapper_sequence&
    Wrapper () const;

    Wrapper_sequence&
    Wrapper ();

    void
    Wrapper (const Wrapper_sequence& s);

    // Constructors.
    //
    DDICDIModels ();

    DDICDIModels (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    DDICDIModels (const DDICDIModels& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual DDICDIModels*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DDICDIModels&
    operator= (const DDICDIModels& x);

    virtual 
    ~DDICDIModels ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Activity_sequence Activity_;
    Agent_sequence Agent_;
    AgentListing_sequence AgentListing_;
    AgentPosition_sequence AgentPosition_;
    AgentRelationship_sequence AgentRelationship_;
    AgentStructure_sequence AgentStructure_;
    AllenIntervalAlgebra_sequence AllenIntervalAlgebra_;
    AttributeComponent_sequence AttributeComponent_;
    AuthorizationSource_sequence AuthorizationSource_;
    Category_sequence Category_;
    CategoryPosition_sequence CategoryPosition_;
    CategoryRelationStructure_sequence CategoryRelationStructure_;
    CategoryRelationship_sequence CategoryRelationship_;
    CategorySet_sequence CategorySet_;
    CategoryStatistic_sequence CategoryStatistic_;
    ClassificationFamily_sequence ClassificationFamily_;
    ClassificationIndex_sequence ClassificationIndex_;
    ClassificationIndexEntry_sequence ClassificationIndexEntry_;
    ClassificationIndexEntryPosition_sequence ClassificationIndexEntryPosition_;
    ClassificationItem_sequence ClassificationItem_;
    ClassificationItemPosition_sequence ClassificationItemPosition_;
    ClassificationItemRelationship_sequence ClassificationItemRelationship_;
    ClassificationItemStructure_sequence ClassificationItemStructure_;
    ClassificationPosition_sequence ClassificationPosition_;
    ClassificationSeries_sequence ClassificationSeries_;
    ClassificationSeriesStructure_sequence ClassificationSeriesStructure_;
    Code_sequence Code_;
    CodeList_sequence CodeList_;
    CodeListStructure_sequence CodeListStructure_;
    CodePosition_sequence CodePosition_;
    CodeRelationship_sequence CodeRelationship_;
    ComponentPosition_sequence ComponentPosition_;
    Concept_sequence Concept_;
    ConceptMap_sequence ConceptMap_;
    ConceptRelationship_sequence ConceptRelationship_;
    ConceptStructure_sequence ConceptStructure_;
    ConceptSystem_sequence ConceptSystem_;
    ConceptSystemCorrespondence_sequence ConceptSystemCorrespondence_;
    ConceptualDomain_sequence ConceptualDomain_;
    ConceptualValue_sequence ConceptualValue_;
    ConceptualVariable_sequence ConceptualVariable_;
    ConditionalControlLogic_sequence ConditionalControlLogic_;
    ContextualComponent_sequence ContextualComponent_;
    ControlLogic_sequence ControlLogic_;
    CorrespondenceTable_sequence CorrespondenceTable_;
    Curator_sequence Curator_;
    DataPoint_sequence DataPoint_;
    DataPointPosition_sequence DataPointPosition_;
    DataPointRelationship_sequence DataPointRelationship_;
    DataSet_sequence DataSet_;
    DataStore_sequence DataStore_;
    DataStructure_sequence DataStructure_;
    DataStructureComponent_sequence DataStructureComponent_;
    Datum_sequence Datum_;
    Descriptor_sequence Descriptor_;
    DescriptorValueDomain_sequence DescriptorValueDomain_;
    DescriptorVariable_sequence DescriptorVariable_;
    DeterministicImperative_sequence DeterministicImperative_;
    DimensionComponent_sequence DimensionComponent_;
    DimensionGroup_sequence DimensionGroup_;
    DimensionalDataSet_sequence DimensionalDataSet_;
    DimensionalDataStructure_sequence DimensionalDataStructure_;
    DimensionalKey_sequence DimensionalKey_;
    DimensionalKeyDefinition_sequence DimensionalKeyDefinition_;
    DimensionalKeyDefinitionMember_sequence DimensionalKeyDefinitionMember_;
    DimensionalKeyMember_sequence DimensionalKeyMember_;
    EnumerationDomain_sequence EnumerationDomain_;
    ForeignKey_sequence ForeignKey_;
    ForeignKeyComponent_sequence ForeignKeyComponent_;
    IdentifierComponent_sequence IdentifierComponent_;
    Individual_sequence Individual_;
    InformationFlowDefinition_sequence InformationFlowDefinition_;
    InstanceKey_sequence InstanceKey_;
    InstanceValue_sequence InstanceValue_;
    InstanceVariable_sequence InstanceVariable_;
    InstanceVariableMap_sequence InstanceVariableMap_;
    Key_sequence Key_;
    KeyDefinition_sequence KeyDefinition_;
    KeyDefinitionMember_sequence KeyDefinitionMember_;
    KeyMember_sequence KeyMember_;
    KeyValueDataStore_sequence KeyValueDataStore_;
    KeyValueStructure_sequence KeyValueStructure_;
    Level_sequence Level_;
    LevelStructure_sequence LevelStructure_;
    LogicalRecord_sequence LogicalRecord_;
    LogicalRecordPosition_sequence LogicalRecordPosition_;
    LogicalRecordRelationStructure_sequence LogicalRecordRelationStructure_;
    LogicalRecordRelationship_sequence LogicalRecordRelationship_;
    LongDataSet_sequence LongDataSet_;
    LongDataStructure_sequence LongDataStructure_;
    LongKey_sequence LongKey_;
    LongMainKeyMember_sequence LongMainKeyMember_;
    Machine_sequence Machine_;
    MainKeyMember_sequence MainKeyMember_;
    MeasureComponent_sequence MeasureComponent_;
    NonDeterministicDeclarative_sequence NonDeterministicDeclarative_;
    Notation_sequence Notation_;
    Organization_sequence Organization_;
    Parameter_sequence Parameter_;
    PhysicalDataSet_sequence PhysicalDataSet_;
    PhysicalDataSetStructure_sequence PhysicalDataSetStructure_;
    PhysicalLayoutRelationStructure_sequence PhysicalLayoutRelationStructure_;
    PhysicalRecordSegment_sequence PhysicalRecordSegment_;
    PhysicalRecordSegmentPosition_sequence PhysicalRecordSegmentPosition_;
    PhysicalRecordSegmentRelationship_sequence PhysicalRecordSegmentRelationship_;
    PhysicalRecordSegmentStructure_sequence PhysicalRecordSegmentStructure_;
    PhysicalSegmentLayout_sequence PhysicalSegmentLayout_;
    PhysicalSegmentLocation_sequence PhysicalSegmentLocation_;
    Population_sequence Population_;
    PrimaryKey_sequence PrimaryKey_;
    PrimaryKeyComponent_sequence PrimaryKeyComponent_;
    ProcessingAgent_sequence ProcessingAgent_;
    ProductionEnvironment_sequence ProductionEnvironment_;
    QualifiedMeasure_sequence QualifiedMeasure_;
    RecordRelation_sequence RecordRelation_;
    ReferenceValue_sequence ReferenceValue_;
    ReferenceValueDomain_sequence ReferenceValueDomain_;
    ReferenceVariable_sequence ReferenceVariable_;
    RepresentedVariable_sequence RepresentedVariable_;
    RevisableDatum_sequence RevisableDatum_;
    Revision_sequence Revision_;
    Rule_sequence Rule_;
    RuleBasedScheduling_sequence RuleBasedScheduling_;
    RuleSet_sequence RuleSet_;
    ScopedMeasure_sequence ScopedMeasure_;
    SegmentByText_sequence SegmentByText_;
    SentinelConceptualDomain_sequence SentinelConceptualDomain_;
    SentinelValueDomain_sequence SentinelValueDomain_;
    Sequence_sequence Sequence_;
    SequencePosition_sequence SequencePosition_;
    Service_sequence Service_;
    StatisticalClassification_sequence StatisticalClassification_;
    StatisticalClassificationRelationship_sequence StatisticalClassificationRelationship_;
    Step_sequence Step_;
    SubstantiveConceptualDomain_sequence SubstantiveConceptualDomain_;
    SubstantiveValueDomain_sequence SubstantiveValueDomain_;
    SyntheticIdComponent_sequence SyntheticIdComponent_;
    TemporalConstraints_sequence TemporalConstraints_;
    TemporalControlConstruct_sequence TemporalControlConstruct_;
    Unit_sequence Unit_;
    UnitSegmentLayout_sequence UnitSegmentLayout_;
    UnitType_sequence UnitType_;
    Universe_sequence Universe_;
    ValueAndConceptDescription_sequence ValueAndConceptDescription_;
    ValueDomain_sequence ValueDomain_;
    ValueMapping_sequence ValueMapping_;
    ValueMappingPosition_sequence ValueMappingPosition_;
    ValueMappingRelationship_sequence ValueMappingRelationship_;
    VariableCollection_sequence VariableCollection_;
    VariableDescriptorComponent_sequence VariableDescriptorComponent_;
    VariablePosition_sequence VariablePosition_;
    VariableRelationship_sequence VariableRelationship_;
    VariableStructure_sequence VariableStructure_;
    VariableValueComponent_sequence VariableValueComponent_;
    WideDataSet_sequence WideDataSet_;
    WideDataStructure_sequence WideDataStructure_;
    WideKey_sequence WideKey_;
    WideKeyMember_sequence WideKeyMember_;
    Wrapper_sequence Wrapper_;
  };

  class Wrapper: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // supportingInformation
    //
    typedef ::XMLSchema::Reference supportingInformation_type;
    typedef ::xsd::cxx::tree::sequence< supportingInformation_type > supportingInformation_sequence;
    typedef supportingInformation_sequence::iterator supportingInformation_iterator;
    typedef supportingInformation_sequence::const_iterator supportingInformation_const_iterator;
    typedef ::xsd::cxx::tree::traits< supportingInformation_type, char > supportingInformation_traits;

    const supportingInformation_sequence&
    supportingInformation () const;

    supportingInformation_sequence&
    supportingInformation ();

    void
    supportingInformation (const supportingInformation_sequence& s);

    // Activity
    //
    typedef ::XMLSchema::Activity Activity_type;
    typedef ::xsd::cxx::tree::sequence< Activity_type > Activity_sequence;
    typedef Activity_sequence::iterator Activity_iterator;
    typedef Activity_sequence::const_iterator Activity_const_iterator;
    typedef ::xsd::cxx::tree::traits< Activity_type, char > Activity_traits;

    const Activity_sequence&
    Activity () const;

    Activity_sequence&
    Activity ();

    void
    Activity (const Activity_sequence& s);

    // Agent
    //
    typedef ::XMLSchema::Agent Agent_type;
    typedef ::xsd::cxx::tree::sequence< Agent_type > Agent_sequence;
    typedef Agent_sequence::iterator Agent_iterator;
    typedef Agent_sequence::const_iterator Agent_const_iterator;
    typedef ::xsd::cxx::tree::traits< Agent_type, char > Agent_traits;

    const Agent_sequence&
    Agent () const;

    Agent_sequence&
    Agent ();

    void
    Agent (const Agent_sequence& s);

    // AgentListing
    //
    typedef ::XMLSchema::AgentListing AgentListing_type;
    typedef ::xsd::cxx::tree::sequence< AgentListing_type > AgentListing_sequence;
    typedef AgentListing_sequence::iterator AgentListing_iterator;
    typedef AgentListing_sequence::const_iterator AgentListing_const_iterator;
    typedef ::xsd::cxx::tree::traits< AgentListing_type, char > AgentListing_traits;

    const AgentListing_sequence&
    AgentListing () const;

    AgentListing_sequence&
    AgentListing ();

    void
    AgentListing (const AgentListing_sequence& s);

    // AgentPosition
    //
    typedef ::XMLSchema::AgentPosition AgentPosition_type;
    typedef ::xsd::cxx::tree::sequence< AgentPosition_type > AgentPosition_sequence;
    typedef AgentPosition_sequence::iterator AgentPosition_iterator;
    typedef AgentPosition_sequence::const_iterator AgentPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< AgentPosition_type, char > AgentPosition_traits;

    const AgentPosition_sequence&
    AgentPosition () const;

    AgentPosition_sequence&
    AgentPosition ();

    void
    AgentPosition (const AgentPosition_sequence& s);

    // AgentRelationship
    //
    typedef ::XMLSchema::AgentRelationship AgentRelationship_type;
    typedef ::xsd::cxx::tree::sequence< AgentRelationship_type > AgentRelationship_sequence;
    typedef AgentRelationship_sequence::iterator AgentRelationship_iterator;
    typedef AgentRelationship_sequence::const_iterator AgentRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< AgentRelationship_type, char > AgentRelationship_traits;

    const AgentRelationship_sequence&
    AgentRelationship () const;

    AgentRelationship_sequence&
    AgentRelationship ();

    void
    AgentRelationship (const AgentRelationship_sequence& s);

    // AgentStructure
    //
    typedef ::XMLSchema::AgentStructure AgentStructure_type;
    typedef ::xsd::cxx::tree::sequence< AgentStructure_type > AgentStructure_sequence;
    typedef AgentStructure_sequence::iterator AgentStructure_iterator;
    typedef AgentStructure_sequence::const_iterator AgentStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< AgentStructure_type, char > AgentStructure_traits;

    const AgentStructure_sequence&
    AgentStructure () const;

    AgentStructure_sequence&
    AgentStructure ();

    void
    AgentStructure (const AgentStructure_sequence& s);

    // AllenIntervalAlgebra
    //
    typedef ::XMLSchema::AllenIntervalAlgebra AllenIntervalAlgebra_type;
    typedef ::xsd::cxx::tree::sequence< AllenIntervalAlgebra_type > AllenIntervalAlgebra_sequence;
    typedef AllenIntervalAlgebra_sequence::iterator AllenIntervalAlgebra_iterator;
    typedef AllenIntervalAlgebra_sequence::const_iterator AllenIntervalAlgebra_const_iterator;
    typedef ::xsd::cxx::tree::traits< AllenIntervalAlgebra_type, char > AllenIntervalAlgebra_traits;

    const AllenIntervalAlgebra_sequence&
    AllenIntervalAlgebra () const;

    AllenIntervalAlgebra_sequence&
    AllenIntervalAlgebra ();

    void
    AllenIntervalAlgebra (const AllenIntervalAlgebra_sequence& s);

    // AttributeComponent
    //
    typedef ::XMLSchema::AttributeComponent AttributeComponent_type;
    typedef ::xsd::cxx::tree::sequence< AttributeComponent_type > AttributeComponent_sequence;
    typedef AttributeComponent_sequence::iterator AttributeComponent_iterator;
    typedef AttributeComponent_sequence::const_iterator AttributeComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< AttributeComponent_type, char > AttributeComponent_traits;

    const AttributeComponent_sequence&
    AttributeComponent () const;

    AttributeComponent_sequence&
    AttributeComponent ();

    void
    AttributeComponent (const AttributeComponent_sequence& s);

    // AuthorizationSource
    //
    typedef ::XMLSchema::AuthorizationSource AuthorizationSource_type;
    typedef ::xsd::cxx::tree::sequence< AuthorizationSource_type > AuthorizationSource_sequence;
    typedef AuthorizationSource_sequence::iterator AuthorizationSource_iterator;
    typedef AuthorizationSource_sequence::const_iterator AuthorizationSource_const_iterator;
    typedef ::xsd::cxx::tree::traits< AuthorizationSource_type, char > AuthorizationSource_traits;

    const AuthorizationSource_sequence&
    AuthorizationSource () const;

    AuthorizationSource_sequence&
    AuthorizationSource ();

    void
    AuthorizationSource (const AuthorizationSource_sequence& s);

    // Category
    //
    typedef ::XMLSchema::Category Category_type;
    typedef ::xsd::cxx::tree::sequence< Category_type > Category_sequence;
    typedef Category_sequence::iterator Category_iterator;
    typedef Category_sequence::const_iterator Category_const_iterator;
    typedef ::xsd::cxx::tree::traits< Category_type, char > Category_traits;

    const Category_sequence&
    Category () const;

    Category_sequence&
    Category ();

    void
    Category (const Category_sequence& s);

    // CategoryPosition
    //
    typedef ::XMLSchema::CategoryPosition CategoryPosition_type;
    typedef ::xsd::cxx::tree::sequence< CategoryPosition_type > CategoryPosition_sequence;
    typedef CategoryPosition_sequence::iterator CategoryPosition_iterator;
    typedef CategoryPosition_sequence::const_iterator CategoryPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategoryPosition_type, char > CategoryPosition_traits;

    const CategoryPosition_sequence&
    CategoryPosition () const;

    CategoryPosition_sequence&
    CategoryPosition ();

    void
    CategoryPosition (const CategoryPosition_sequence& s);

    // CategoryRelationStructure
    //
    typedef ::XMLSchema::CategoryRelationStructure CategoryRelationStructure_type;
    typedef ::xsd::cxx::tree::sequence< CategoryRelationStructure_type > CategoryRelationStructure_sequence;
    typedef CategoryRelationStructure_sequence::iterator CategoryRelationStructure_iterator;
    typedef CategoryRelationStructure_sequence::const_iterator CategoryRelationStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategoryRelationStructure_type, char > CategoryRelationStructure_traits;

    const CategoryRelationStructure_sequence&
    CategoryRelationStructure () const;

    CategoryRelationStructure_sequence&
    CategoryRelationStructure ();

    void
    CategoryRelationStructure (const CategoryRelationStructure_sequence& s);

    // CategoryRelationship
    //
    typedef ::XMLSchema::CategoryRelationship CategoryRelationship_type;
    typedef ::xsd::cxx::tree::sequence< CategoryRelationship_type > CategoryRelationship_sequence;
    typedef CategoryRelationship_sequence::iterator CategoryRelationship_iterator;
    typedef CategoryRelationship_sequence::const_iterator CategoryRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategoryRelationship_type, char > CategoryRelationship_traits;

    const CategoryRelationship_sequence&
    CategoryRelationship () const;

    CategoryRelationship_sequence&
    CategoryRelationship ();

    void
    CategoryRelationship (const CategoryRelationship_sequence& s);

    // CategorySet
    //
    typedef ::XMLSchema::CategorySet CategorySet_type;
    typedef ::xsd::cxx::tree::sequence< CategorySet_type > CategorySet_sequence;
    typedef CategorySet_sequence::iterator CategorySet_iterator;
    typedef CategorySet_sequence::const_iterator CategorySet_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategorySet_type, char > CategorySet_traits;

    const CategorySet_sequence&
    CategorySet () const;

    CategorySet_sequence&
    CategorySet ();

    void
    CategorySet (const CategorySet_sequence& s);

    // CategoryStatistic
    //
    typedef ::XMLSchema::CategoryStatistic CategoryStatistic_type;
    typedef ::xsd::cxx::tree::sequence< CategoryStatistic_type > CategoryStatistic_sequence;
    typedef CategoryStatistic_sequence::iterator CategoryStatistic_iterator;
    typedef CategoryStatistic_sequence::const_iterator CategoryStatistic_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategoryStatistic_type, char > CategoryStatistic_traits;

    const CategoryStatistic_sequence&
    CategoryStatistic () const;

    CategoryStatistic_sequence&
    CategoryStatistic ();

    void
    CategoryStatistic (const CategoryStatistic_sequence& s);

    // ClassificationFamily
    //
    typedef ::XMLSchema::ClassificationFamily ClassificationFamily_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationFamily_type > ClassificationFamily_sequence;
    typedef ClassificationFamily_sequence::iterator ClassificationFamily_iterator;
    typedef ClassificationFamily_sequence::const_iterator ClassificationFamily_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationFamily_type, char > ClassificationFamily_traits;

    const ClassificationFamily_sequence&
    ClassificationFamily () const;

    ClassificationFamily_sequence&
    ClassificationFamily ();

    void
    ClassificationFamily (const ClassificationFamily_sequence& s);

    // ClassificationIndex
    //
    typedef ::XMLSchema::ClassificationIndex ClassificationIndex_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationIndex_type > ClassificationIndex_sequence;
    typedef ClassificationIndex_sequence::iterator ClassificationIndex_iterator;
    typedef ClassificationIndex_sequence::const_iterator ClassificationIndex_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationIndex_type, char > ClassificationIndex_traits;

    const ClassificationIndex_sequence&
    ClassificationIndex () const;

    ClassificationIndex_sequence&
    ClassificationIndex ();

    void
    ClassificationIndex (const ClassificationIndex_sequence& s);

    // ClassificationIndexEntry
    //
    typedef ::XMLSchema::ClassificationIndexEntry ClassificationIndexEntry_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationIndexEntry_type > ClassificationIndexEntry_sequence;
    typedef ClassificationIndexEntry_sequence::iterator ClassificationIndexEntry_iterator;
    typedef ClassificationIndexEntry_sequence::const_iterator ClassificationIndexEntry_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationIndexEntry_type, char > ClassificationIndexEntry_traits;

    const ClassificationIndexEntry_sequence&
    ClassificationIndexEntry () const;

    ClassificationIndexEntry_sequence&
    ClassificationIndexEntry ();

    void
    ClassificationIndexEntry (const ClassificationIndexEntry_sequence& s);

    // ClassificationIndexEntryPosition
    //
    typedef ::XMLSchema::ClassificationIndexEntryPosition ClassificationIndexEntryPosition_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationIndexEntryPosition_type > ClassificationIndexEntryPosition_sequence;
    typedef ClassificationIndexEntryPosition_sequence::iterator ClassificationIndexEntryPosition_iterator;
    typedef ClassificationIndexEntryPosition_sequence::const_iterator ClassificationIndexEntryPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationIndexEntryPosition_type, char > ClassificationIndexEntryPosition_traits;

    const ClassificationIndexEntryPosition_sequence&
    ClassificationIndexEntryPosition () const;

    ClassificationIndexEntryPosition_sequence&
    ClassificationIndexEntryPosition ();

    void
    ClassificationIndexEntryPosition (const ClassificationIndexEntryPosition_sequence& s);

    // ClassificationItem
    //
    typedef ::XMLSchema::ClassificationItem ClassificationItem_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationItem_type > ClassificationItem_sequence;
    typedef ClassificationItem_sequence::iterator ClassificationItem_iterator;
    typedef ClassificationItem_sequence::const_iterator ClassificationItem_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationItem_type, char > ClassificationItem_traits;

    const ClassificationItem_sequence&
    ClassificationItem () const;

    ClassificationItem_sequence&
    ClassificationItem ();

    void
    ClassificationItem (const ClassificationItem_sequence& s);

    // ClassificationItemPosition
    //
    typedef ::XMLSchema::ClassificationItemPosition ClassificationItemPosition_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationItemPosition_type > ClassificationItemPosition_sequence;
    typedef ClassificationItemPosition_sequence::iterator ClassificationItemPosition_iterator;
    typedef ClassificationItemPosition_sequence::const_iterator ClassificationItemPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationItemPosition_type, char > ClassificationItemPosition_traits;

    const ClassificationItemPosition_sequence&
    ClassificationItemPosition () const;

    ClassificationItemPosition_sequence&
    ClassificationItemPosition ();

    void
    ClassificationItemPosition (const ClassificationItemPosition_sequence& s);

    // ClassificationItemRelationship
    //
    typedef ::XMLSchema::ClassificationItemRelationship ClassificationItemRelationship_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationItemRelationship_type > ClassificationItemRelationship_sequence;
    typedef ClassificationItemRelationship_sequence::iterator ClassificationItemRelationship_iterator;
    typedef ClassificationItemRelationship_sequence::const_iterator ClassificationItemRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationItemRelationship_type, char > ClassificationItemRelationship_traits;

    const ClassificationItemRelationship_sequence&
    ClassificationItemRelationship () const;

    ClassificationItemRelationship_sequence&
    ClassificationItemRelationship ();

    void
    ClassificationItemRelationship (const ClassificationItemRelationship_sequence& s);

    // ClassificationItemStructure
    //
    typedef ::XMLSchema::ClassificationItemStructure ClassificationItemStructure_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationItemStructure_type > ClassificationItemStructure_sequence;
    typedef ClassificationItemStructure_sequence::iterator ClassificationItemStructure_iterator;
    typedef ClassificationItemStructure_sequence::const_iterator ClassificationItemStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationItemStructure_type, char > ClassificationItemStructure_traits;

    const ClassificationItemStructure_sequence&
    ClassificationItemStructure () const;

    ClassificationItemStructure_sequence&
    ClassificationItemStructure ();

    void
    ClassificationItemStructure (const ClassificationItemStructure_sequence& s);

    // ClassificationPosition
    //
    typedef ::XMLSchema::ClassificationPosition ClassificationPosition_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationPosition_type > ClassificationPosition_sequence;
    typedef ClassificationPosition_sequence::iterator ClassificationPosition_iterator;
    typedef ClassificationPosition_sequence::const_iterator ClassificationPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationPosition_type, char > ClassificationPosition_traits;

    const ClassificationPosition_sequence&
    ClassificationPosition () const;

    ClassificationPosition_sequence&
    ClassificationPosition ();

    void
    ClassificationPosition (const ClassificationPosition_sequence& s);

    // ClassificationSeries
    //
    typedef ::XMLSchema::ClassificationSeries ClassificationSeries_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationSeries_type > ClassificationSeries_sequence;
    typedef ClassificationSeries_sequence::iterator ClassificationSeries_iterator;
    typedef ClassificationSeries_sequence::const_iterator ClassificationSeries_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationSeries_type, char > ClassificationSeries_traits;

    const ClassificationSeries_sequence&
    ClassificationSeries () const;

    ClassificationSeries_sequence&
    ClassificationSeries ();

    void
    ClassificationSeries (const ClassificationSeries_sequence& s);

    // ClassificationSeriesStructure
    //
    typedef ::XMLSchema::ClassificationSeriesStructure ClassificationSeriesStructure_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationSeriesStructure_type > ClassificationSeriesStructure_sequence;
    typedef ClassificationSeriesStructure_sequence::iterator ClassificationSeriesStructure_iterator;
    typedef ClassificationSeriesStructure_sequence::const_iterator ClassificationSeriesStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationSeriesStructure_type, char > ClassificationSeriesStructure_traits;

    const ClassificationSeriesStructure_sequence&
    ClassificationSeriesStructure () const;

    ClassificationSeriesStructure_sequence&
    ClassificationSeriesStructure ();

    void
    ClassificationSeriesStructure (const ClassificationSeriesStructure_sequence& s);

    // Code
    //
    typedef ::XMLSchema::Code Code_type;
    typedef ::xsd::cxx::tree::sequence< Code_type > Code_sequence;
    typedef Code_sequence::iterator Code_iterator;
    typedef Code_sequence::const_iterator Code_const_iterator;
    typedef ::xsd::cxx::tree::traits< Code_type, char > Code_traits;

    const Code_sequence&
    Code () const;

    Code_sequence&
    Code ();

    void
    Code (const Code_sequence& s);

    // CodeList
    //
    typedef ::XMLSchema::CodeList CodeList_type;
    typedef ::xsd::cxx::tree::sequence< CodeList_type > CodeList_sequence;
    typedef CodeList_sequence::iterator CodeList_iterator;
    typedef CodeList_sequence::const_iterator CodeList_const_iterator;
    typedef ::xsd::cxx::tree::traits< CodeList_type, char > CodeList_traits;

    const CodeList_sequence&
    CodeList () const;

    CodeList_sequence&
    CodeList ();

    void
    CodeList (const CodeList_sequence& s);

    // CodeListStructure
    //
    typedef ::XMLSchema::CodeListStructure CodeListStructure_type;
    typedef ::xsd::cxx::tree::sequence< CodeListStructure_type > CodeListStructure_sequence;
    typedef CodeListStructure_sequence::iterator CodeListStructure_iterator;
    typedef CodeListStructure_sequence::const_iterator CodeListStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< CodeListStructure_type, char > CodeListStructure_traits;

    const CodeListStructure_sequence&
    CodeListStructure () const;

    CodeListStructure_sequence&
    CodeListStructure ();

    void
    CodeListStructure (const CodeListStructure_sequence& s);

    // CodePosition
    //
    typedef ::XMLSchema::CodePosition CodePosition_type;
    typedef ::xsd::cxx::tree::sequence< CodePosition_type > CodePosition_sequence;
    typedef CodePosition_sequence::iterator CodePosition_iterator;
    typedef CodePosition_sequence::const_iterator CodePosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< CodePosition_type, char > CodePosition_traits;

    const CodePosition_sequence&
    CodePosition () const;

    CodePosition_sequence&
    CodePosition ();

    void
    CodePosition (const CodePosition_sequence& s);

    // CodeRelationship
    //
    typedef ::XMLSchema::CodeRelationship CodeRelationship_type;
    typedef ::xsd::cxx::tree::sequence< CodeRelationship_type > CodeRelationship_sequence;
    typedef CodeRelationship_sequence::iterator CodeRelationship_iterator;
    typedef CodeRelationship_sequence::const_iterator CodeRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< CodeRelationship_type, char > CodeRelationship_traits;

    const CodeRelationship_sequence&
    CodeRelationship () const;

    CodeRelationship_sequence&
    CodeRelationship ();

    void
    CodeRelationship (const CodeRelationship_sequence& s);

    // ComponentPosition
    //
    typedef ::XMLSchema::ComponentPosition ComponentPosition_type;
    typedef ::xsd::cxx::tree::sequence< ComponentPosition_type > ComponentPosition_sequence;
    typedef ComponentPosition_sequence::iterator ComponentPosition_iterator;
    typedef ComponentPosition_sequence::const_iterator ComponentPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< ComponentPosition_type, char > ComponentPosition_traits;

    const ComponentPosition_sequence&
    ComponentPosition () const;

    ComponentPosition_sequence&
    ComponentPosition ();

    void
    ComponentPosition (const ComponentPosition_sequence& s);

    // Concept
    //
    typedef ::XMLSchema::Concept Concept_type;
    typedef ::xsd::cxx::tree::sequence< Concept_type > Concept_sequence;
    typedef Concept_sequence::iterator Concept_iterator;
    typedef Concept_sequence::const_iterator Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< Concept_type, char > Concept_traits;

    const Concept_sequence&
    Concept () const;

    Concept_sequence&
    Concept ();

    void
    Concept (const Concept_sequence& s);

    // ConceptMap
    //
    typedef ::XMLSchema::ConceptMap ConceptMap_type;
    typedef ::xsd::cxx::tree::sequence< ConceptMap_type > ConceptMap_sequence;
    typedef ConceptMap_sequence::iterator ConceptMap_iterator;
    typedef ConceptMap_sequence::const_iterator ConceptMap_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptMap_type, char > ConceptMap_traits;

    const ConceptMap_sequence&
    ConceptMap () const;

    ConceptMap_sequence&
    ConceptMap ();

    void
    ConceptMap (const ConceptMap_sequence& s);

    // ConceptRelationship
    //
    typedef ::XMLSchema::ConceptRelationship ConceptRelationship_type;
    typedef ::xsd::cxx::tree::sequence< ConceptRelationship_type > ConceptRelationship_sequence;
    typedef ConceptRelationship_sequence::iterator ConceptRelationship_iterator;
    typedef ConceptRelationship_sequence::const_iterator ConceptRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptRelationship_type, char > ConceptRelationship_traits;

    const ConceptRelationship_sequence&
    ConceptRelationship () const;

    ConceptRelationship_sequence&
    ConceptRelationship ();

    void
    ConceptRelationship (const ConceptRelationship_sequence& s);

    // ConceptStructure
    //
    typedef ::XMLSchema::ConceptStructure ConceptStructure_type;
    typedef ::xsd::cxx::tree::sequence< ConceptStructure_type > ConceptStructure_sequence;
    typedef ConceptStructure_sequence::iterator ConceptStructure_iterator;
    typedef ConceptStructure_sequence::const_iterator ConceptStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptStructure_type, char > ConceptStructure_traits;

    const ConceptStructure_sequence&
    ConceptStructure () const;

    ConceptStructure_sequence&
    ConceptStructure ();

    void
    ConceptStructure (const ConceptStructure_sequence& s);

    // ConceptSystem
    //
    typedef ::XMLSchema::ConceptSystem ConceptSystem_type;
    typedef ::xsd::cxx::tree::sequence< ConceptSystem_type > ConceptSystem_sequence;
    typedef ConceptSystem_sequence::iterator ConceptSystem_iterator;
    typedef ConceptSystem_sequence::const_iterator ConceptSystem_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptSystem_type, char > ConceptSystem_traits;

    const ConceptSystem_sequence&
    ConceptSystem () const;

    ConceptSystem_sequence&
    ConceptSystem ();

    void
    ConceptSystem (const ConceptSystem_sequence& s);

    // ConceptSystemCorrespondence
    //
    typedef ::XMLSchema::ConceptSystemCorrespondence ConceptSystemCorrespondence_type;
    typedef ::xsd::cxx::tree::sequence< ConceptSystemCorrespondence_type > ConceptSystemCorrespondence_sequence;
    typedef ConceptSystemCorrespondence_sequence::iterator ConceptSystemCorrespondence_iterator;
    typedef ConceptSystemCorrespondence_sequence::const_iterator ConceptSystemCorrespondence_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptSystemCorrespondence_type, char > ConceptSystemCorrespondence_traits;

    const ConceptSystemCorrespondence_sequence&
    ConceptSystemCorrespondence () const;

    ConceptSystemCorrespondence_sequence&
    ConceptSystemCorrespondence ();

    void
    ConceptSystemCorrespondence (const ConceptSystemCorrespondence_sequence& s);

    // ConceptualDomain
    //
    typedef ::XMLSchema::ConceptualDomain ConceptualDomain_type;
    typedef ::xsd::cxx::tree::sequence< ConceptualDomain_type > ConceptualDomain_sequence;
    typedef ConceptualDomain_sequence::iterator ConceptualDomain_iterator;
    typedef ConceptualDomain_sequence::const_iterator ConceptualDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptualDomain_type, char > ConceptualDomain_traits;

    const ConceptualDomain_sequence&
    ConceptualDomain () const;

    ConceptualDomain_sequence&
    ConceptualDomain ();

    void
    ConceptualDomain (const ConceptualDomain_sequence& s);

    // ConceptualValue
    //
    typedef ::XMLSchema::ConceptualValue ConceptualValue_type;
    typedef ::xsd::cxx::tree::sequence< ConceptualValue_type > ConceptualValue_sequence;
    typedef ConceptualValue_sequence::iterator ConceptualValue_iterator;
    typedef ConceptualValue_sequence::const_iterator ConceptualValue_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptualValue_type, char > ConceptualValue_traits;

    const ConceptualValue_sequence&
    ConceptualValue () const;

    ConceptualValue_sequence&
    ConceptualValue ();

    void
    ConceptualValue (const ConceptualValue_sequence& s);

    // ConceptualVariable
    //
    typedef ::XMLSchema::ConceptualVariable ConceptualVariable_type;
    typedef ::xsd::cxx::tree::sequence< ConceptualVariable_type > ConceptualVariable_sequence;
    typedef ConceptualVariable_sequence::iterator ConceptualVariable_iterator;
    typedef ConceptualVariable_sequence::const_iterator ConceptualVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptualVariable_type, char > ConceptualVariable_traits;

    const ConceptualVariable_sequence&
    ConceptualVariable () const;

    ConceptualVariable_sequence&
    ConceptualVariable ();

    void
    ConceptualVariable (const ConceptualVariable_sequence& s);

    // ConditionalControlLogic
    //
    typedef ::XMLSchema::ConditionalControlLogic ConditionalControlLogic_type;
    typedef ::xsd::cxx::tree::sequence< ConditionalControlLogic_type > ConditionalControlLogic_sequence;
    typedef ConditionalControlLogic_sequence::iterator ConditionalControlLogic_iterator;
    typedef ConditionalControlLogic_sequence::const_iterator ConditionalControlLogic_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConditionalControlLogic_type, char > ConditionalControlLogic_traits;

    const ConditionalControlLogic_sequence&
    ConditionalControlLogic () const;

    ConditionalControlLogic_sequence&
    ConditionalControlLogic ();

    void
    ConditionalControlLogic (const ConditionalControlLogic_sequence& s);

    // ContextualComponent
    //
    typedef ::XMLSchema::ContextualComponent ContextualComponent_type;
    typedef ::xsd::cxx::tree::sequence< ContextualComponent_type > ContextualComponent_sequence;
    typedef ContextualComponent_sequence::iterator ContextualComponent_iterator;
    typedef ContextualComponent_sequence::const_iterator ContextualComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< ContextualComponent_type, char > ContextualComponent_traits;

    const ContextualComponent_sequence&
    ContextualComponent () const;

    ContextualComponent_sequence&
    ContextualComponent ();

    void
    ContextualComponent (const ContextualComponent_sequence& s);

    // ControlLogic
    //
    typedef ::XMLSchema::ControlLogic ControlLogic_type;
    typedef ::xsd::cxx::tree::sequence< ControlLogic_type > ControlLogic_sequence;
    typedef ControlLogic_sequence::iterator ControlLogic_iterator;
    typedef ControlLogic_sequence::const_iterator ControlLogic_const_iterator;
    typedef ::xsd::cxx::tree::traits< ControlLogic_type, char > ControlLogic_traits;

    const ControlLogic_sequence&
    ControlLogic () const;

    ControlLogic_sequence&
    ControlLogic ();

    void
    ControlLogic (const ControlLogic_sequence& s);

    // CorrespondenceTable
    //
    typedef ::XMLSchema::CorrespondenceTable CorrespondenceTable_type;
    typedef ::xsd::cxx::tree::sequence< CorrespondenceTable_type > CorrespondenceTable_sequence;
    typedef CorrespondenceTable_sequence::iterator CorrespondenceTable_iterator;
    typedef CorrespondenceTable_sequence::const_iterator CorrespondenceTable_const_iterator;
    typedef ::xsd::cxx::tree::traits< CorrespondenceTable_type, char > CorrespondenceTable_traits;

    const CorrespondenceTable_sequence&
    CorrespondenceTable () const;

    CorrespondenceTable_sequence&
    CorrespondenceTable ();

    void
    CorrespondenceTable (const CorrespondenceTable_sequence& s);

    // Curator
    //
    typedef ::XMLSchema::Curator Curator_type;
    typedef ::xsd::cxx::tree::sequence< Curator_type > Curator_sequence;
    typedef Curator_sequence::iterator Curator_iterator;
    typedef Curator_sequence::const_iterator Curator_const_iterator;
    typedef ::xsd::cxx::tree::traits< Curator_type, char > Curator_traits;

    const Curator_sequence&
    Curator () const;

    Curator_sequence&
    Curator ();

    void
    Curator (const Curator_sequence& s);

    // DataPoint
    //
    typedef ::XMLSchema::DataPoint DataPoint_type;
    typedef ::xsd::cxx::tree::sequence< DataPoint_type > DataPoint_sequence;
    typedef DataPoint_sequence::iterator DataPoint_iterator;
    typedef DataPoint_sequence::const_iterator DataPoint_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataPoint_type, char > DataPoint_traits;

    const DataPoint_sequence&
    DataPoint () const;

    DataPoint_sequence&
    DataPoint ();

    void
    DataPoint (const DataPoint_sequence& s);

    // DataPointPosition
    //
    typedef ::XMLSchema::DataPointPosition DataPointPosition_type;
    typedef ::xsd::cxx::tree::sequence< DataPointPosition_type > DataPointPosition_sequence;
    typedef DataPointPosition_sequence::iterator DataPointPosition_iterator;
    typedef DataPointPosition_sequence::const_iterator DataPointPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataPointPosition_type, char > DataPointPosition_traits;

    const DataPointPosition_sequence&
    DataPointPosition () const;

    DataPointPosition_sequence&
    DataPointPosition ();

    void
    DataPointPosition (const DataPointPosition_sequence& s);

    // DataPointRelationship
    //
    typedef ::XMLSchema::DataPointRelationship DataPointRelationship_type;
    typedef ::xsd::cxx::tree::sequence< DataPointRelationship_type > DataPointRelationship_sequence;
    typedef DataPointRelationship_sequence::iterator DataPointRelationship_iterator;
    typedef DataPointRelationship_sequence::const_iterator DataPointRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataPointRelationship_type, char > DataPointRelationship_traits;

    const DataPointRelationship_sequence&
    DataPointRelationship () const;

    DataPointRelationship_sequence&
    DataPointRelationship ();

    void
    DataPointRelationship (const DataPointRelationship_sequence& s);

    // DataSet
    //
    typedef ::XMLSchema::DataSet DataSet_type;
    typedef ::xsd::cxx::tree::sequence< DataSet_type > DataSet_sequence;
    typedef DataSet_sequence::iterator DataSet_iterator;
    typedef DataSet_sequence::const_iterator DataSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataSet_type, char > DataSet_traits;

    const DataSet_sequence&
    DataSet () const;

    DataSet_sequence&
    DataSet ();

    void
    DataSet (const DataSet_sequence& s);

    // DataStore
    //
    typedef ::XMLSchema::DataStore DataStore_type;
    typedef ::xsd::cxx::tree::sequence< DataStore_type > DataStore_sequence;
    typedef DataStore_sequence::iterator DataStore_iterator;
    typedef DataStore_sequence::const_iterator DataStore_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataStore_type, char > DataStore_traits;

    const DataStore_sequence&
    DataStore () const;

    DataStore_sequence&
    DataStore ();

    void
    DataStore (const DataStore_sequence& s);

    // DataStructure
    //
    typedef ::XMLSchema::DataStructure DataStructure_type;
    typedef ::xsd::cxx::tree::sequence< DataStructure_type > DataStructure_sequence;
    typedef DataStructure_sequence::iterator DataStructure_iterator;
    typedef DataStructure_sequence::const_iterator DataStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataStructure_type, char > DataStructure_traits;

    const DataStructure_sequence&
    DataStructure () const;

    DataStructure_sequence&
    DataStructure ();

    void
    DataStructure (const DataStructure_sequence& s);

    // DataStructureComponent
    //
    typedef ::XMLSchema::DataStructureComponent DataStructureComponent_type;
    typedef ::xsd::cxx::tree::sequence< DataStructureComponent_type > DataStructureComponent_sequence;
    typedef DataStructureComponent_sequence::iterator DataStructureComponent_iterator;
    typedef DataStructureComponent_sequence::const_iterator DataStructureComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataStructureComponent_type, char > DataStructureComponent_traits;

    const DataStructureComponent_sequence&
    DataStructureComponent () const;

    DataStructureComponent_sequence&
    DataStructureComponent ();

    void
    DataStructureComponent (const DataStructureComponent_sequence& s);

    // Datum
    //
    typedef ::XMLSchema::Datum Datum_type;
    typedef ::xsd::cxx::tree::sequence< Datum_type > Datum_sequence;
    typedef Datum_sequence::iterator Datum_iterator;
    typedef Datum_sequence::const_iterator Datum_const_iterator;
    typedef ::xsd::cxx::tree::traits< Datum_type, char > Datum_traits;

    const Datum_sequence&
    Datum () const;

    Datum_sequence&
    Datum ();

    void
    Datum (const Datum_sequence& s);

    // Descriptor
    //
    typedef ::XMLSchema::Descriptor Descriptor_type;
    typedef ::xsd::cxx::tree::sequence< Descriptor_type > Descriptor_sequence;
    typedef Descriptor_sequence::iterator Descriptor_iterator;
    typedef Descriptor_sequence::const_iterator Descriptor_const_iterator;
    typedef ::xsd::cxx::tree::traits< Descriptor_type, char > Descriptor_traits;

    const Descriptor_sequence&
    Descriptor () const;

    Descriptor_sequence&
    Descriptor ();

    void
    Descriptor (const Descriptor_sequence& s);

    // DescriptorValueDomain
    //
    typedef ::XMLSchema::DescriptorValueDomain DescriptorValueDomain_type;
    typedef ::xsd::cxx::tree::sequence< DescriptorValueDomain_type > DescriptorValueDomain_sequence;
    typedef DescriptorValueDomain_sequence::iterator DescriptorValueDomain_iterator;
    typedef DescriptorValueDomain_sequence::const_iterator DescriptorValueDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< DescriptorValueDomain_type, char > DescriptorValueDomain_traits;

    const DescriptorValueDomain_sequence&
    DescriptorValueDomain () const;

    DescriptorValueDomain_sequence&
    DescriptorValueDomain ();

    void
    DescriptorValueDomain (const DescriptorValueDomain_sequence& s);

    // DescriptorVariable
    //
    typedef ::XMLSchema::DescriptorVariable DescriptorVariable_type;
    typedef ::xsd::cxx::tree::sequence< DescriptorVariable_type > DescriptorVariable_sequence;
    typedef DescriptorVariable_sequence::iterator DescriptorVariable_iterator;
    typedef DescriptorVariable_sequence::const_iterator DescriptorVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< DescriptorVariable_type, char > DescriptorVariable_traits;

    const DescriptorVariable_sequence&
    DescriptorVariable () const;

    DescriptorVariable_sequence&
    DescriptorVariable ();

    void
    DescriptorVariable (const DescriptorVariable_sequence& s);

    // DeterministicImperative
    //
    typedef ::XMLSchema::DeterministicImperative DeterministicImperative_type;
    typedef ::xsd::cxx::tree::sequence< DeterministicImperative_type > DeterministicImperative_sequence;
    typedef DeterministicImperative_sequence::iterator DeterministicImperative_iterator;
    typedef DeterministicImperative_sequence::const_iterator DeterministicImperative_const_iterator;
    typedef ::xsd::cxx::tree::traits< DeterministicImperative_type, char > DeterministicImperative_traits;

    const DeterministicImperative_sequence&
    DeterministicImperative () const;

    DeterministicImperative_sequence&
    DeterministicImperative ();

    void
    DeterministicImperative (const DeterministicImperative_sequence& s);

    // DimensionComponent
    //
    typedef ::XMLSchema::DimensionComponent DimensionComponent_type;
    typedef ::xsd::cxx::tree::sequence< DimensionComponent_type > DimensionComponent_sequence;
    typedef DimensionComponent_sequence::iterator DimensionComponent_iterator;
    typedef DimensionComponent_sequence::const_iterator DimensionComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionComponent_type, char > DimensionComponent_traits;

    const DimensionComponent_sequence&
    DimensionComponent () const;

    DimensionComponent_sequence&
    DimensionComponent ();

    void
    DimensionComponent (const DimensionComponent_sequence& s);

    // DimensionGroup
    //
    typedef ::XMLSchema::DimensionGroup DimensionGroup_type;
    typedef ::xsd::cxx::tree::sequence< DimensionGroup_type > DimensionGroup_sequence;
    typedef DimensionGroup_sequence::iterator DimensionGroup_iterator;
    typedef DimensionGroup_sequence::const_iterator DimensionGroup_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionGroup_type, char > DimensionGroup_traits;

    const DimensionGroup_sequence&
    DimensionGroup () const;

    DimensionGroup_sequence&
    DimensionGroup ();

    void
    DimensionGroup (const DimensionGroup_sequence& s);

    // DimensionalDataSet
    //
    typedef ::XMLSchema::DimensionalDataSet DimensionalDataSet_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalDataSet_type > DimensionalDataSet_sequence;
    typedef DimensionalDataSet_sequence::iterator DimensionalDataSet_iterator;
    typedef DimensionalDataSet_sequence::const_iterator DimensionalDataSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalDataSet_type, char > DimensionalDataSet_traits;

    const DimensionalDataSet_sequence&
    DimensionalDataSet () const;

    DimensionalDataSet_sequence&
    DimensionalDataSet ();

    void
    DimensionalDataSet (const DimensionalDataSet_sequence& s);

    // DimensionalDataStructure
    //
    typedef ::XMLSchema::DimensionalDataStructure DimensionalDataStructure_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalDataStructure_type > DimensionalDataStructure_sequence;
    typedef DimensionalDataStructure_sequence::iterator DimensionalDataStructure_iterator;
    typedef DimensionalDataStructure_sequence::const_iterator DimensionalDataStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalDataStructure_type, char > DimensionalDataStructure_traits;

    const DimensionalDataStructure_sequence&
    DimensionalDataStructure () const;

    DimensionalDataStructure_sequence&
    DimensionalDataStructure ();

    void
    DimensionalDataStructure (const DimensionalDataStructure_sequence& s);

    // DimensionalKey
    //
    typedef ::XMLSchema::DimensionalKey DimensionalKey_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalKey_type > DimensionalKey_sequence;
    typedef DimensionalKey_sequence::iterator DimensionalKey_iterator;
    typedef DimensionalKey_sequence::const_iterator DimensionalKey_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalKey_type, char > DimensionalKey_traits;

    const DimensionalKey_sequence&
    DimensionalKey () const;

    DimensionalKey_sequence&
    DimensionalKey ();

    void
    DimensionalKey (const DimensionalKey_sequence& s);

    // DimensionalKeyDefinition
    //
    typedef ::XMLSchema::DimensionalKeyDefinition DimensionalKeyDefinition_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalKeyDefinition_type > DimensionalKeyDefinition_sequence;
    typedef DimensionalKeyDefinition_sequence::iterator DimensionalKeyDefinition_iterator;
    typedef DimensionalKeyDefinition_sequence::const_iterator DimensionalKeyDefinition_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalKeyDefinition_type, char > DimensionalKeyDefinition_traits;

    const DimensionalKeyDefinition_sequence&
    DimensionalKeyDefinition () const;

    DimensionalKeyDefinition_sequence&
    DimensionalKeyDefinition ();

    void
    DimensionalKeyDefinition (const DimensionalKeyDefinition_sequence& s);

    // DimensionalKeyDefinitionMember
    //
    typedef ::XMLSchema::DimensionalKeyDefinitionMember DimensionalKeyDefinitionMember_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalKeyDefinitionMember_type > DimensionalKeyDefinitionMember_sequence;
    typedef DimensionalKeyDefinitionMember_sequence::iterator DimensionalKeyDefinitionMember_iterator;
    typedef DimensionalKeyDefinitionMember_sequence::const_iterator DimensionalKeyDefinitionMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalKeyDefinitionMember_type, char > DimensionalKeyDefinitionMember_traits;

    const DimensionalKeyDefinitionMember_sequence&
    DimensionalKeyDefinitionMember () const;

    DimensionalKeyDefinitionMember_sequence&
    DimensionalKeyDefinitionMember ();

    void
    DimensionalKeyDefinitionMember (const DimensionalKeyDefinitionMember_sequence& s);

    // DimensionalKeyMember
    //
    typedef ::XMLSchema::DimensionalKeyMember DimensionalKeyMember_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalKeyMember_type > DimensionalKeyMember_sequence;
    typedef DimensionalKeyMember_sequence::iterator DimensionalKeyMember_iterator;
    typedef DimensionalKeyMember_sequence::const_iterator DimensionalKeyMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalKeyMember_type, char > DimensionalKeyMember_traits;

    const DimensionalKeyMember_sequence&
    DimensionalKeyMember () const;

    DimensionalKeyMember_sequence&
    DimensionalKeyMember ();

    void
    DimensionalKeyMember (const DimensionalKeyMember_sequence& s);

    // EnumerationDomain
    //
    typedef ::XMLSchema::EnumerationDomain EnumerationDomain_type;
    typedef ::xsd::cxx::tree::sequence< EnumerationDomain_type > EnumerationDomain_sequence;
    typedef EnumerationDomain_sequence::iterator EnumerationDomain_iterator;
    typedef EnumerationDomain_sequence::const_iterator EnumerationDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< EnumerationDomain_type, char > EnumerationDomain_traits;

    const EnumerationDomain_sequence&
    EnumerationDomain () const;

    EnumerationDomain_sequence&
    EnumerationDomain ();

    void
    EnumerationDomain (const EnumerationDomain_sequence& s);

    // ForeignKey
    //
    typedef ::XMLSchema::ForeignKey ForeignKey_type;
    typedef ::xsd::cxx::tree::sequence< ForeignKey_type > ForeignKey_sequence;
    typedef ForeignKey_sequence::iterator ForeignKey_iterator;
    typedef ForeignKey_sequence::const_iterator ForeignKey_const_iterator;
    typedef ::xsd::cxx::tree::traits< ForeignKey_type, char > ForeignKey_traits;

    const ForeignKey_sequence&
    ForeignKey () const;

    ForeignKey_sequence&
    ForeignKey ();

    void
    ForeignKey (const ForeignKey_sequence& s);

    // ForeignKeyComponent
    //
    typedef ::XMLSchema::ForeignKeyComponent ForeignKeyComponent_type;
    typedef ::xsd::cxx::tree::sequence< ForeignKeyComponent_type > ForeignKeyComponent_sequence;
    typedef ForeignKeyComponent_sequence::iterator ForeignKeyComponent_iterator;
    typedef ForeignKeyComponent_sequence::const_iterator ForeignKeyComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< ForeignKeyComponent_type, char > ForeignKeyComponent_traits;

    const ForeignKeyComponent_sequence&
    ForeignKeyComponent () const;

    ForeignKeyComponent_sequence&
    ForeignKeyComponent ();

    void
    ForeignKeyComponent (const ForeignKeyComponent_sequence& s);

    // IdentifierComponent
    //
    typedef ::XMLSchema::IdentifierComponent IdentifierComponent_type;
    typedef ::xsd::cxx::tree::sequence< IdentifierComponent_type > IdentifierComponent_sequence;
    typedef IdentifierComponent_sequence::iterator IdentifierComponent_iterator;
    typedef IdentifierComponent_sequence::const_iterator IdentifierComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< IdentifierComponent_type, char > IdentifierComponent_traits;

    const IdentifierComponent_sequence&
    IdentifierComponent () const;

    IdentifierComponent_sequence&
    IdentifierComponent ();

    void
    IdentifierComponent (const IdentifierComponent_sequence& s);

    // Individual
    //
    typedef ::XMLSchema::Individual Individual_type;
    typedef ::xsd::cxx::tree::sequence< Individual_type > Individual_sequence;
    typedef Individual_sequence::iterator Individual_iterator;
    typedef Individual_sequence::const_iterator Individual_const_iterator;
    typedef ::xsd::cxx::tree::traits< Individual_type, char > Individual_traits;

    const Individual_sequence&
    Individual () const;

    Individual_sequence&
    Individual ();

    void
    Individual (const Individual_sequence& s);

    // InformationFlowDefinition
    //
    typedef ::XMLSchema::InformationFlowDefinition InformationFlowDefinition_type;
    typedef ::xsd::cxx::tree::sequence< InformationFlowDefinition_type > InformationFlowDefinition_sequence;
    typedef InformationFlowDefinition_sequence::iterator InformationFlowDefinition_iterator;
    typedef InformationFlowDefinition_sequence::const_iterator InformationFlowDefinition_const_iterator;
    typedef ::xsd::cxx::tree::traits< InformationFlowDefinition_type, char > InformationFlowDefinition_traits;

    const InformationFlowDefinition_sequence&
    InformationFlowDefinition () const;

    InformationFlowDefinition_sequence&
    InformationFlowDefinition ();

    void
    InformationFlowDefinition (const InformationFlowDefinition_sequence& s);

    // InstanceKey
    //
    typedef ::XMLSchema::InstanceKey InstanceKey_type;
    typedef ::xsd::cxx::tree::sequence< InstanceKey_type > InstanceKey_sequence;
    typedef InstanceKey_sequence::iterator InstanceKey_iterator;
    typedef InstanceKey_sequence::const_iterator InstanceKey_const_iterator;
    typedef ::xsd::cxx::tree::traits< InstanceKey_type, char > InstanceKey_traits;

    const InstanceKey_sequence&
    InstanceKey () const;

    InstanceKey_sequence&
    InstanceKey ();

    void
    InstanceKey (const InstanceKey_sequence& s);

    // InstanceValue
    //
    typedef ::XMLSchema::InstanceValue InstanceValue_type;
    typedef ::xsd::cxx::tree::sequence< InstanceValue_type > InstanceValue_sequence;
    typedef InstanceValue_sequence::iterator InstanceValue_iterator;
    typedef InstanceValue_sequence::const_iterator InstanceValue_const_iterator;
    typedef ::xsd::cxx::tree::traits< InstanceValue_type, char > InstanceValue_traits;

    const InstanceValue_sequence&
    InstanceValue () const;

    InstanceValue_sequence&
    InstanceValue ();

    void
    InstanceValue (const InstanceValue_sequence& s);

    // InstanceVariable
    //
    typedef ::XMLSchema::InstanceVariable InstanceVariable_type;
    typedef ::xsd::cxx::tree::sequence< InstanceVariable_type > InstanceVariable_sequence;
    typedef InstanceVariable_sequence::iterator InstanceVariable_iterator;
    typedef InstanceVariable_sequence::const_iterator InstanceVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< InstanceVariable_type, char > InstanceVariable_traits;

    const InstanceVariable_sequence&
    InstanceVariable () const;

    InstanceVariable_sequence&
    InstanceVariable ();

    void
    InstanceVariable (const InstanceVariable_sequence& s);

    // InstanceVariableMap
    //
    typedef ::XMLSchema::InstanceVariableMap InstanceVariableMap_type;
    typedef ::xsd::cxx::tree::sequence< InstanceVariableMap_type > InstanceVariableMap_sequence;
    typedef InstanceVariableMap_sequence::iterator InstanceVariableMap_iterator;
    typedef InstanceVariableMap_sequence::const_iterator InstanceVariableMap_const_iterator;
    typedef ::xsd::cxx::tree::traits< InstanceVariableMap_type, char > InstanceVariableMap_traits;

    const InstanceVariableMap_sequence&
    InstanceVariableMap () const;

    InstanceVariableMap_sequence&
    InstanceVariableMap ();

    void
    InstanceVariableMap (const InstanceVariableMap_sequence& s);

    // Key
    //
    typedef ::XMLSchema::Key Key_type;
    typedef ::xsd::cxx::tree::sequence< Key_type > Key_sequence;
    typedef Key_sequence::iterator Key_iterator;
    typedef Key_sequence::const_iterator Key_const_iterator;
    typedef ::xsd::cxx::tree::traits< Key_type, char > Key_traits;

    const Key_sequence&
    Key () const;

    Key_sequence&
    Key ();

    void
    Key (const Key_sequence& s);

    // KeyDefinition
    //
    typedef ::XMLSchema::KeyDefinition KeyDefinition_type;
    typedef ::xsd::cxx::tree::sequence< KeyDefinition_type > KeyDefinition_sequence;
    typedef KeyDefinition_sequence::iterator KeyDefinition_iterator;
    typedef KeyDefinition_sequence::const_iterator KeyDefinition_const_iterator;
    typedef ::xsd::cxx::tree::traits< KeyDefinition_type, char > KeyDefinition_traits;

    const KeyDefinition_sequence&
    KeyDefinition () const;

    KeyDefinition_sequence&
    KeyDefinition ();

    void
    KeyDefinition (const KeyDefinition_sequence& s);

    // KeyDefinitionMember
    //
    typedef ::XMLSchema::KeyDefinitionMember KeyDefinitionMember_type;
    typedef ::xsd::cxx::tree::sequence< KeyDefinitionMember_type > KeyDefinitionMember_sequence;
    typedef KeyDefinitionMember_sequence::iterator KeyDefinitionMember_iterator;
    typedef KeyDefinitionMember_sequence::const_iterator KeyDefinitionMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< KeyDefinitionMember_type, char > KeyDefinitionMember_traits;

    const KeyDefinitionMember_sequence&
    KeyDefinitionMember () const;

    KeyDefinitionMember_sequence&
    KeyDefinitionMember ();

    void
    KeyDefinitionMember (const KeyDefinitionMember_sequence& s);

    // KeyMember
    //
    typedef ::XMLSchema::KeyMember KeyMember_type;
    typedef ::xsd::cxx::tree::sequence< KeyMember_type > KeyMember_sequence;
    typedef KeyMember_sequence::iterator KeyMember_iterator;
    typedef KeyMember_sequence::const_iterator KeyMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< KeyMember_type, char > KeyMember_traits;

    const KeyMember_sequence&
    KeyMember () const;

    KeyMember_sequence&
    KeyMember ();

    void
    KeyMember (const KeyMember_sequence& s);

    // KeyValueDataStore
    //
    typedef ::XMLSchema::KeyValueDataStore KeyValueDataStore_type;
    typedef ::xsd::cxx::tree::sequence< KeyValueDataStore_type > KeyValueDataStore_sequence;
    typedef KeyValueDataStore_sequence::iterator KeyValueDataStore_iterator;
    typedef KeyValueDataStore_sequence::const_iterator KeyValueDataStore_const_iterator;
    typedef ::xsd::cxx::tree::traits< KeyValueDataStore_type, char > KeyValueDataStore_traits;

    const KeyValueDataStore_sequence&
    KeyValueDataStore () const;

    KeyValueDataStore_sequence&
    KeyValueDataStore ();

    void
    KeyValueDataStore (const KeyValueDataStore_sequence& s);

    // KeyValueStructure
    //
    typedef ::XMLSchema::KeyValueStructure KeyValueStructure_type;
    typedef ::xsd::cxx::tree::sequence< KeyValueStructure_type > KeyValueStructure_sequence;
    typedef KeyValueStructure_sequence::iterator KeyValueStructure_iterator;
    typedef KeyValueStructure_sequence::const_iterator KeyValueStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< KeyValueStructure_type, char > KeyValueStructure_traits;

    const KeyValueStructure_sequence&
    KeyValueStructure () const;

    KeyValueStructure_sequence&
    KeyValueStructure ();

    void
    KeyValueStructure (const KeyValueStructure_sequence& s);

    // Level
    //
    typedef ::XMLSchema::Level Level_type;
    typedef ::xsd::cxx::tree::sequence< Level_type > Level_sequence;
    typedef Level_sequence::iterator Level_iterator;
    typedef Level_sequence::const_iterator Level_const_iterator;
    typedef ::xsd::cxx::tree::traits< Level_type, char > Level_traits;

    const Level_sequence&
    Level () const;

    Level_sequence&
    Level ();

    void
    Level (const Level_sequence& s);

    // LevelStructure
    //
    typedef ::XMLSchema::LevelStructure LevelStructure_type;
    typedef ::xsd::cxx::tree::sequence< LevelStructure_type > LevelStructure_sequence;
    typedef LevelStructure_sequence::iterator LevelStructure_iterator;
    typedef LevelStructure_sequence::const_iterator LevelStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< LevelStructure_type, char > LevelStructure_traits;

    const LevelStructure_sequence&
    LevelStructure () const;

    LevelStructure_sequence&
    LevelStructure ();

    void
    LevelStructure (const LevelStructure_sequence& s);

    // LogicalRecord
    //
    typedef ::XMLSchema::LogicalRecord LogicalRecord_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecord_type > LogicalRecord_sequence;
    typedef LogicalRecord_sequence::iterator LogicalRecord_iterator;
    typedef LogicalRecord_sequence::const_iterator LogicalRecord_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecord_type, char > LogicalRecord_traits;

    const LogicalRecord_sequence&
    LogicalRecord () const;

    LogicalRecord_sequence&
    LogicalRecord ();

    void
    LogicalRecord (const LogicalRecord_sequence& s);

    // LogicalRecordPosition
    //
    typedef ::XMLSchema::LogicalRecordPosition LogicalRecordPosition_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecordPosition_type > LogicalRecordPosition_sequence;
    typedef LogicalRecordPosition_sequence::iterator LogicalRecordPosition_iterator;
    typedef LogicalRecordPosition_sequence::const_iterator LogicalRecordPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecordPosition_type, char > LogicalRecordPosition_traits;

    const LogicalRecordPosition_sequence&
    LogicalRecordPosition () const;

    LogicalRecordPosition_sequence&
    LogicalRecordPosition ();

    void
    LogicalRecordPosition (const LogicalRecordPosition_sequence& s);

    // LogicalRecordRelationStructure
    //
    typedef ::XMLSchema::LogicalRecordRelationStructure LogicalRecordRelationStructure_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecordRelationStructure_type > LogicalRecordRelationStructure_sequence;
    typedef LogicalRecordRelationStructure_sequence::iterator LogicalRecordRelationStructure_iterator;
    typedef LogicalRecordRelationStructure_sequence::const_iterator LogicalRecordRelationStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecordRelationStructure_type, char > LogicalRecordRelationStructure_traits;

    const LogicalRecordRelationStructure_sequence&
    LogicalRecordRelationStructure () const;

    LogicalRecordRelationStructure_sequence&
    LogicalRecordRelationStructure ();

    void
    LogicalRecordRelationStructure (const LogicalRecordRelationStructure_sequence& s);

    // LogicalRecordRelationship
    //
    typedef ::XMLSchema::LogicalRecordRelationship LogicalRecordRelationship_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecordRelationship_type > LogicalRecordRelationship_sequence;
    typedef LogicalRecordRelationship_sequence::iterator LogicalRecordRelationship_iterator;
    typedef LogicalRecordRelationship_sequence::const_iterator LogicalRecordRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecordRelationship_type, char > LogicalRecordRelationship_traits;

    const LogicalRecordRelationship_sequence&
    LogicalRecordRelationship () const;

    LogicalRecordRelationship_sequence&
    LogicalRecordRelationship ();

    void
    LogicalRecordRelationship (const LogicalRecordRelationship_sequence& s);

    // LongDataSet
    //
    typedef ::XMLSchema::LongDataSet LongDataSet_type;
    typedef ::xsd::cxx::tree::sequence< LongDataSet_type > LongDataSet_sequence;
    typedef LongDataSet_sequence::iterator LongDataSet_iterator;
    typedef LongDataSet_sequence::const_iterator LongDataSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< LongDataSet_type, char > LongDataSet_traits;

    const LongDataSet_sequence&
    LongDataSet () const;

    LongDataSet_sequence&
    LongDataSet ();

    void
    LongDataSet (const LongDataSet_sequence& s);

    // LongDataStructure
    //
    typedef ::XMLSchema::LongDataStructure LongDataStructure_type;
    typedef ::xsd::cxx::tree::sequence< LongDataStructure_type > LongDataStructure_sequence;
    typedef LongDataStructure_sequence::iterator LongDataStructure_iterator;
    typedef LongDataStructure_sequence::const_iterator LongDataStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< LongDataStructure_type, char > LongDataStructure_traits;

    const LongDataStructure_sequence&
    LongDataStructure () const;

    LongDataStructure_sequence&
    LongDataStructure ();

    void
    LongDataStructure (const LongDataStructure_sequence& s);

    // LongKey
    //
    typedef ::XMLSchema::LongKey LongKey_type;
    typedef ::xsd::cxx::tree::sequence< LongKey_type > LongKey_sequence;
    typedef LongKey_sequence::iterator LongKey_iterator;
    typedef LongKey_sequence::const_iterator LongKey_const_iterator;
    typedef ::xsd::cxx::tree::traits< LongKey_type, char > LongKey_traits;

    const LongKey_sequence&
    LongKey () const;

    LongKey_sequence&
    LongKey ();

    void
    LongKey (const LongKey_sequence& s);

    // LongMainKeyMember
    //
    typedef ::XMLSchema::LongMainKeyMember LongMainKeyMember_type;
    typedef ::xsd::cxx::tree::sequence< LongMainKeyMember_type > LongMainKeyMember_sequence;
    typedef LongMainKeyMember_sequence::iterator LongMainKeyMember_iterator;
    typedef LongMainKeyMember_sequence::const_iterator LongMainKeyMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< LongMainKeyMember_type, char > LongMainKeyMember_traits;

    const LongMainKeyMember_sequence&
    LongMainKeyMember () const;

    LongMainKeyMember_sequence&
    LongMainKeyMember ();

    void
    LongMainKeyMember (const LongMainKeyMember_sequence& s);

    // Machine
    //
    typedef ::XMLSchema::Machine Machine_type;
    typedef ::xsd::cxx::tree::sequence< Machine_type > Machine_sequence;
    typedef Machine_sequence::iterator Machine_iterator;
    typedef Machine_sequence::const_iterator Machine_const_iterator;
    typedef ::xsd::cxx::tree::traits< Machine_type, char > Machine_traits;

    const Machine_sequence&
    Machine () const;

    Machine_sequence&
    Machine ();

    void
    Machine (const Machine_sequence& s);

    // MainKeyMember
    //
    typedef ::XMLSchema::MainKeyMember MainKeyMember_type;
    typedef ::xsd::cxx::tree::sequence< MainKeyMember_type > MainKeyMember_sequence;
    typedef MainKeyMember_sequence::iterator MainKeyMember_iterator;
    typedef MainKeyMember_sequence::const_iterator MainKeyMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< MainKeyMember_type, char > MainKeyMember_traits;

    const MainKeyMember_sequence&
    MainKeyMember () const;

    MainKeyMember_sequence&
    MainKeyMember ();

    void
    MainKeyMember (const MainKeyMember_sequence& s);

    // MeasureComponent
    //
    typedef ::XMLSchema::MeasureComponent MeasureComponent_type;
    typedef ::xsd::cxx::tree::sequence< MeasureComponent_type > MeasureComponent_sequence;
    typedef MeasureComponent_sequence::iterator MeasureComponent_iterator;
    typedef MeasureComponent_sequence::const_iterator MeasureComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< MeasureComponent_type, char > MeasureComponent_traits;

    const MeasureComponent_sequence&
    MeasureComponent () const;

    MeasureComponent_sequence&
    MeasureComponent ();

    void
    MeasureComponent (const MeasureComponent_sequence& s);

    // NonDeterministicDeclarative
    //
    typedef ::XMLSchema::NonDeterministicDeclarative NonDeterministicDeclarative_type;
    typedef ::xsd::cxx::tree::sequence< NonDeterministicDeclarative_type > NonDeterministicDeclarative_sequence;
    typedef NonDeterministicDeclarative_sequence::iterator NonDeterministicDeclarative_iterator;
    typedef NonDeterministicDeclarative_sequence::const_iterator NonDeterministicDeclarative_const_iterator;
    typedef ::xsd::cxx::tree::traits< NonDeterministicDeclarative_type, char > NonDeterministicDeclarative_traits;

    const NonDeterministicDeclarative_sequence&
    NonDeterministicDeclarative () const;

    NonDeterministicDeclarative_sequence&
    NonDeterministicDeclarative ();

    void
    NonDeterministicDeclarative (const NonDeterministicDeclarative_sequence& s);

    // Notation
    //
    typedef ::XMLSchema::Notation Notation_type;
    typedef ::xsd::cxx::tree::sequence< Notation_type > Notation_sequence;
    typedef Notation_sequence::iterator Notation_iterator;
    typedef Notation_sequence::const_iterator Notation_const_iterator;
    typedef ::xsd::cxx::tree::traits< Notation_type, char > Notation_traits;

    const Notation_sequence&
    Notation () const;

    Notation_sequence&
    Notation ();

    void
    Notation (const Notation_sequence& s);

    // Organization
    //
    typedef ::XMLSchema::Organization Organization_type;
    typedef ::xsd::cxx::tree::sequence< Organization_type > Organization_sequence;
    typedef Organization_sequence::iterator Organization_iterator;
    typedef Organization_sequence::const_iterator Organization_const_iterator;
    typedef ::xsd::cxx::tree::traits< Organization_type, char > Organization_traits;

    const Organization_sequence&
    Organization () const;

    Organization_sequence&
    Organization ();

    void
    Organization (const Organization_sequence& s);

    // Parameter
    //
    typedef ::XMLSchema::Parameter Parameter_type;
    typedef ::xsd::cxx::tree::sequence< Parameter_type > Parameter_sequence;
    typedef Parameter_sequence::iterator Parameter_iterator;
    typedef Parameter_sequence::const_iterator Parameter_const_iterator;
    typedef ::xsd::cxx::tree::traits< Parameter_type, char > Parameter_traits;

    const Parameter_sequence&
    Parameter () const;

    Parameter_sequence&
    Parameter ();

    void
    Parameter (const Parameter_sequence& s);

    // PhysicalDataSet
    //
    typedef ::XMLSchema::PhysicalDataSet PhysicalDataSet_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalDataSet_type > PhysicalDataSet_sequence;
    typedef PhysicalDataSet_sequence::iterator PhysicalDataSet_iterator;
    typedef PhysicalDataSet_sequence::const_iterator PhysicalDataSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalDataSet_type, char > PhysicalDataSet_traits;

    const PhysicalDataSet_sequence&
    PhysicalDataSet () const;

    PhysicalDataSet_sequence&
    PhysicalDataSet ();

    void
    PhysicalDataSet (const PhysicalDataSet_sequence& s);

    // PhysicalDataSetStructure
    //
    typedef ::XMLSchema::PhysicalDataSetStructure PhysicalDataSetStructure_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalDataSetStructure_type > PhysicalDataSetStructure_sequence;
    typedef PhysicalDataSetStructure_sequence::iterator PhysicalDataSetStructure_iterator;
    typedef PhysicalDataSetStructure_sequence::const_iterator PhysicalDataSetStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalDataSetStructure_type, char > PhysicalDataSetStructure_traits;

    const PhysicalDataSetStructure_sequence&
    PhysicalDataSetStructure () const;

    PhysicalDataSetStructure_sequence&
    PhysicalDataSetStructure ();

    void
    PhysicalDataSetStructure (const PhysicalDataSetStructure_sequence& s);

    // PhysicalLayoutRelationStructure
    //
    typedef ::XMLSchema::PhysicalLayoutRelationStructure PhysicalLayoutRelationStructure_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalLayoutRelationStructure_type > PhysicalLayoutRelationStructure_sequence;
    typedef PhysicalLayoutRelationStructure_sequence::iterator PhysicalLayoutRelationStructure_iterator;
    typedef PhysicalLayoutRelationStructure_sequence::const_iterator PhysicalLayoutRelationStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalLayoutRelationStructure_type, char > PhysicalLayoutRelationStructure_traits;

    const PhysicalLayoutRelationStructure_sequence&
    PhysicalLayoutRelationStructure () const;

    PhysicalLayoutRelationStructure_sequence&
    PhysicalLayoutRelationStructure ();

    void
    PhysicalLayoutRelationStructure (const PhysicalLayoutRelationStructure_sequence& s);

    // PhysicalRecordSegment
    //
    typedef ::XMLSchema::PhysicalRecordSegment PhysicalRecordSegment_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalRecordSegment_type > PhysicalRecordSegment_sequence;
    typedef PhysicalRecordSegment_sequence::iterator PhysicalRecordSegment_iterator;
    typedef PhysicalRecordSegment_sequence::const_iterator PhysicalRecordSegment_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegment_type, char > PhysicalRecordSegment_traits;

    const PhysicalRecordSegment_sequence&
    PhysicalRecordSegment () const;

    PhysicalRecordSegment_sequence&
    PhysicalRecordSegment ();

    void
    PhysicalRecordSegment (const PhysicalRecordSegment_sequence& s);

    // PhysicalRecordSegmentPosition
    //
    typedef ::XMLSchema::PhysicalRecordSegmentPosition PhysicalRecordSegmentPosition_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalRecordSegmentPosition_type > PhysicalRecordSegmentPosition_sequence;
    typedef PhysicalRecordSegmentPosition_sequence::iterator PhysicalRecordSegmentPosition_iterator;
    typedef PhysicalRecordSegmentPosition_sequence::const_iterator PhysicalRecordSegmentPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegmentPosition_type, char > PhysicalRecordSegmentPosition_traits;

    const PhysicalRecordSegmentPosition_sequence&
    PhysicalRecordSegmentPosition () const;

    PhysicalRecordSegmentPosition_sequence&
    PhysicalRecordSegmentPosition ();

    void
    PhysicalRecordSegmentPosition (const PhysicalRecordSegmentPosition_sequence& s);

    // PhysicalRecordSegmentRelationship
    //
    typedef ::XMLSchema::PhysicalRecordSegmentRelationship PhysicalRecordSegmentRelationship_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalRecordSegmentRelationship_type > PhysicalRecordSegmentRelationship_sequence;
    typedef PhysicalRecordSegmentRelationship_sequence::iterator PhysicalRecordSegmentRelationship_iterator;
    typedef PhysicalRecordSegmentRelationship_sequence::const_iterator PhysicalRecordSegmentRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegmentRelationship_type, char > PhysicalRecordSegmentRelationship_traits;

    const PhysicalRecordSegmentRelationship_sequence&
    PhysicalRecordSegmentRelationship () const;

    PhysicalRecordSegmentRelationship_sequence&
    PhysicalRecordSegmentRelationship ();

    void
    PhysicalRecordSegmentRelationship (const PhysicalRecordSegmentRelationship_sequence& s);

    // PhysicalRecordSegmentStructure
    //
    typedef ::XMLSchema::PhysicalRecordSegmentStructure PhysicalRecordSegmentStructure_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalRecordSegmentStructure_type > PhysicalRecordSegmentStructure_sequence;
    typedef PhysicalRecordSegmentStructure_sequence::iterator PhysicalRecordSegmentStructure_iterator;
    typedef PhysicalRecordSegmentStructure_sequence::const_iterator PhysicalRecordSegmentStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegmentStructure_type, char > PhysicalRecordSegmentStructure_traits;

    const PhysicalRecordSegmentStructure_sequence&
    PhysicalRecordSegmentStructure () const;

    PhysicalRecordSegmentStructure_sequence&
    PhysicalRecordSegmentStructure ();

    void
    PhysicalRecordSegmentStructure (const PhysicalRecordSegmentStructure_sequence& s);

    // PhysicalSegmentLayout
    //
    typedef ::XMLSchema::PhysicalSegmentLayout PhysicalSegmentLayout_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalSegmentLayout_type > PhysicalSegmentLayout_sequence;
    typedef PhysicalSegmentLayout_sequence::iterator PhysicalSegmentLayout_iterator;
    typedef PhysicalSegmentLayout_sequence::const_iterator PhysicalSegmentLayout_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalSegmentLayout_type, char > PhysicalSegmentLayout_traits;

    const PhysicalSegmentLayout_sequence&
    PhysicalSegmentLayout () const;

    PhysicalSegmentLayout_sequence&
    PhysicalSegmentLayout ();

    void
    PhysicalSegmentLayout (const PhysicalSegmentLayout_sequence& s);

    // PhysicalSegmentLocation
    //
    typedef ::XMLSchema::PhysicalSegmentLocation PhysicalSegmentLocation_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalSegmentLocation_type > PhysicalSegmentLocation_sequence;
    typedef PhysicalSegmentLocation_sequence::iterator PhysicalSegmentLocation_iterator;
    typedef PhysicalSegmentLocation_sequence::const_iterator PhysicalSegmentLocation_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalSegmentLocation_type, char > PhysicalSegmentLocation_traits;

    const PhysicalSegmentLocation_sequence&
    PhysicalSegmentLocation () const;

    PhysicalSegmentLocation_sequence&
    PhysicalSegmentLocation ();

    void
    PhysicalSegmentLocation (const PhysicalSegmentLocation_sequence& s);

    // Population
    //
    typedef ::XMLSchema::Population Population_type;
    typedef ::xsd::cxx::tree::sequence< Population_type > Population_sequence;
    typedef Population_sequence::iterator Population_iterator;
    typedef Population_sequence::const_iterator Population_const_iterator;
    typedef ::xsd::cxx::tree::traits< Population_type, char > Population_traits;

    const Population_sequence&
    Population () const;

    Population_sequence&
    Population ();

    void
    Population (const Population_sequence& s);

    // PrimaryKey
    //
    typedef ::XMLSchema::PrimaryKey PrimaryKey_type;
    typedef ::xsd::cxx::tree::sequence< PrimaryKey_type > PrimaryKey_sequence;
    typedef PrimaryKey_sequence::iterator PrimaryKey_iterator;
    typedef PrimaryKey_sequence::const_iterator PrimaryKey_const_iterator;
    typedef ::xsd::cxx::tree::traits< PrimaryKey_type, char > PrimaryKey_traits;

    const PrimaryKey_sequence&
    PrimaryKey () const;

    PrimaryKey_sequence&
    PrimaryKey ();

    void
    PrimaryKey (const PrimaryKey_sequence& s);

    // PrimaryKeyComponent
    //
    typedef ::XMLSchema::PrimaryKeyComponent PrimaryKeyComponent_type;
    typedef ::xsd::cxx::tree::sequence< PrimaryKeyComponent_type > PrimaryKeyComponent_sequence;
    typedef PrimaryKeyComponent_sequence::iterator PrimaryKeyComponent_iterator;
    typedef PrimaryKeyComponent_sequence::const_iterator PrimaryKeyComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< PrimaryKeyComponent_type, char > PrimaryKeyComponent_traits;

    const PrimaryKeyComponent_sequence&
    PrimaryKeyComponent () const;

    PrimaryKeyComponent_sequence&
    PrimaryKeyComponent ();

    void
    PrimaryKeyComponent (const PrimaryKeyComponent_sequence& s);

    // ProcessingAgent
    //
    typedef ::XMLSchema::ProcessingAgent ProcessingAgent_type;
    typedef ::xsd::cxx::tree::sequence< ProcessingAgent_type > ProcessingAgent_sequence;
    typedef ProcessingAgent_sequence::iterator ProcessingAgent_iterator;
    typedef ProcessingAgent_sequence::const_iterator ProcessingAgent_const_iterator;
    typedef ::xsd::cxx::tree::traits< ProcessingAgent_type, char > ProcessingAgent_traits;

    const ProcessingAgent_sequence&
    ProcessingAgent () const;

    ProcessingAgent_sequence&
    ProcessingAgent ();

    void
    ProcessingAgent (const ProcessingAgent_sequence& s);

    // ProductionEnvironment
    //
    typedef ::XMLSchema::ProductionEnvironment ProductionEnvironment_type;
    typedef ::xsd::cxx::tree::sequence< ProductionEnvironment_type > ProductionEnvironment_sequence;
    typedef ProductionEnvironment_sequence::iterator ProductionEnvironment_iterator;
    typedef ProductionEnvironment_sequence::const_iterator ProductionEnvironment_const_iterator;
    typedef ::xsd::cxx::tree::traits< ProductionEnvironment_type, char > ProductionEnvironment_traits;

    const ProductionEnvironment_sequence&
    ProductionEnvironment () const;

    ProductionEnvironment_sequence&
    ProductionEnvironment ();

    void
    ProductionEnvironment (const ProductionEnvironment_sequence& s);

    // QualifiedMeasure
    //
    typedef ::XMLSchema::QualifiedMeasure QualifiedMeasure_type;
    typedef ::xsd::cxx::tree::sequence< QualifiedMeasure_type > QualifiedMeasure_sequence;
    typedef QualifiedMeasure_sequence::iterator QualifiedMeasure_iterator;
    typedef QualifiedMeasure_sequence::const_iterator QualifiedMeasure_const_iterator;
    typedef ::xsd::cxx::tree::traits< QualifiedMeasure_type, char > QualifiedMeasure_traits;

    const QualifiedMeasure_sequence&
    QualifiedMeasure () const;

    QualifiedMeasure_sequence&
    QualifiedMeasure ();

    void
    QualifiedMeasure (const QualifiedMeasure_sequence& s);

    // RecordRelation
    //
    typedef ::XMLSchema::RecordRelation RecordRelation_type;
    typedef ::xsd::cxx::tree::sequence< RecordRelation_type > RecordRelation_sequence;
    typedef RecordRelation_sequence::iterator RecordRelation_iterator;
    typedef RecordRelation_sequence::const_iterator RecordRelation_const_iterator;
    typedef ::xsd::cxx::tree::traits< RecordRelation_type, char > RecordRelation_traits;

    const RecordRelation_sequence&
    RecordRelation () const;

    RecordRelation_sequence&
    RecordRelation ();

    void
    RecordRelation (const RecordRelation_sequence& s);

    // ReferenceValue
    //
    typedef ::XMLSchema::ReferenceValue ReferenceValue_type;
    typedef ::xsd::cxx::tree::sequence< ReferenceValue_type > ReferenceValue_sequence;
    typedef ReferenceValue_sequence::iterator ReferenceValue_iterator;
    typedef ReferenceValue_sequence::const_iterator ReferenceValue_const_iterator;
    typedef ::xsd::cxx::tree::traits< ReferenceValue_type, char > ReferenceValue_traits;

    const ReferenceValue_sequence&
    ReferenceValue () const;

    ReferenceValue_sequence&
    ReferenceValue ();

    void
    ReferenceValue (const ReferenceValue_sequence& s);

    // ReferenceValueDomain
    //
    typedef ::XMLSchema::ReferenceValueDomain ReferenceValueDomain_type;
    typedef ::xsd::cxx::tree::sequence< ReferenceValueDomain_type > ReferenceValueDomain_sequence;
    typedef ReferenceValueDomain_sequence::iterator ReferenceValueDomain_iterator;
    typedef ReferenceValueDomain_sequence::const_iterator ReferenceValueDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< ReferenceValueDomain_type, char > ReferenceValueDomain_traits;

    const ReferenceValueDomain_sequence&
    ReferenceValueDomain () const;

    ReferenceValueDomain_sequence&
    ReferenceValueDomain ();

    void
    ReferenceValueDomain (const ReferenceValueDomain_sequence& s);

    // ReferenceVariable
    //
    typedef ::XMLSchema::ReferenceVariable ReferenceVariable_type;
    typedef ::xsd::cxx::tree::sequence< ReferenceVariable_type > ReferenceVariable_sequence;
    typedef ReferenceVariable_sequence::iterator ReferenceVariable_iterator;
    typedef ReferenceVariable_sequence::const_iterator ReferenceVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< ReferenceVariable_type, char > ReferenceVariable_traits;

    const ReferenceVariable_sequence&
    ReferenceVariable () const;

    ReferenceVariable_sequence&
    ReferenceVariable ();

    void
    ReferenceVariable (const ReferenceVariable_sequence& s);

    // RepresentedVariable
    //
    typedef ::XMLSchema::RepresentedVariable RepresentedVariable_type;
    typedef ::xsd::cxx::tree::sequence< RepresentedVariable_type > RepresentedVariable_sequence;
    typedef RepresentedVariable_sequence::iterator RepresentedVariable_iterator;
    typedef RepresentedVariable_sequence::const_iterator RepresentedVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< RepresentedVariable_type, char > RepresentedVariable_traits;

    const RepresentedVariable_sequence&
    RepresentedVariable () const;

    RepresentedVariable_sequence&
    RepresentedVariable ();

    void
    RepresentedVariable (const RepresentedVariable_sequence& s);

    // RevisableDatum
    //
    typedef ::XMLSchema::RevisableDatum RevisableDatum_type;
    typedef ::xsd::cxx::tree::sequence< RevisableDatum_type > RevisableDatum_sequence;
    typedef RevisableDatum_sequence::iterator RevisableDatum_iterator;
    typedef RevisableDatum_sequence::const_iterator RevisableDatum_const_iterator;
    typedef ::xsd::cxx::tree::traits< RevisableDatum_type, char > RevisableDatum_traits;

    const RevisableDatum_sequence&
    RevisableDatum () const;

    RevisableDatum_sequence&
    RevisableDatum ();

    void
    RevisableDatum (const RevisableDatum_sequence& s);

    // Revision
    //
    typedef ::XMLSchema::Revision Revision_type;
    typedef ::xsd::cxx::tree::sequence< Revision_type > Revision_sequence;
    typedef Revision_sequence::iterator Revision_iterator;
    typedef Revision_sequence::const_iterator Revision_const_iterator;
    typedef ::xsd::cxx::tree::traits< Revision_type, char > Revision_traits;

    const Revision_sequence&
    Revision () const;

    Revision_sequence&
    Revision ();

    void
    Revision (const Revision_sequence& s);

    // Rule
    //
    typedef ::XMLSchema::Rule Rule_type;
    typedef ::xsd::cxx::tree::sequence< Rule_type > Rule_sequence;
    typedef Rule_sequence::iterator Rule_iterator;
    typedef Rule_sequence::const_iterator Rule_const_iterator;
    typedef ::xsd::cxx::tree::traits< Rule_type, char > Rule_traits;

    const Rule_sequence&
    Rule () const;

    Rule_sequence&
    Rule ();

    void
    Rule (const Rule_sequence& s);

    // RuleBasedScheduling
    //
    typedef ::XMLSchema::RuleBasedScheduling RuleBasedScheduling_type;
    typedef ::xsd::cxx::tree::sequence< RuleBasedScheduling_type > RuleBasedScheduling_sequence;
    typedef RuleBasedScheduling_sequence::iterator RuleBasedScheduling_iterator;
    typedef RuleBasedScheduling_sequence::const_iterator RuleBasedScheduling_const_iterator;
    typedef ::xsd::cxx::tree::traits< RuleBasedScheduling_type, char > RuleBasedScheduling_traits;

    const RuleBasedScheduling_sequence&
    RuleBasedScheduling () const;

    RuleBasedScheduling_sequence&
    RuleBasedScheduling ();

    void
    RuleBasedScheduling (const RuleBasedScheduling_sequence& s);

    // RuleSet
    //
    typedef ::XMLSchema::RuleSet RuleSet_type;
    typedef ::xsd::cxx::tree::sequence< RuleSet_type > RuleSet_sequence;
    typedef RuleSet_sequence::iterator RuleSet_iterator;
    typedef RuleSet_sequence::const_iterator RuleSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< RuleSet_type, char > RuleSet_traits;

    const RuleSet_sequence&
    RuleSet () const;

    RuleSet_sequence&
    RuleSet ();

    void
    RuleSet (const RuleSet_sequence& s);

    // ScopedMeasure
    //
    typedef ::XMLSchema::ScopedMeasure ScopedMeasure_type;
    typedef ::xsd::cxx::tree::sequence< ScopedMeasure_type > ScopedMeasure_sequence;
    typedef ScopedMeasure_sequence::iterator ScopedMeasure_iterator;
    typedef ScopedMeasure_sequence::const_iterator ScopedMeasure_const_iterator;
    typedef ::xsd::cxx::tree::traits< ScopedMeasure_type, char > ScopedMeasure_traits;

    const ScopedMeasure_sequence&
    ScopedMeasure () const;

    ScopedMeasure_sequence&
    ScopedMeasure ();

    void
    ScopedMeasure (const ScopedMeasure_sequence& s);

    // SegmentByText
    //
    typedef ::XMLSchema::SegmentByText SegmentByText_type;
    typedef ::xsd::cxx::tree::sequence< SegmentByText_type > SegmentByText_sequence;
    typedef SegmentByText_sequence::iterator SegmentByText_iterator;
    typedef SegmentByText_sequence::const_iterator SegmentByText_const_iterator;
    typedef ::xsd::cxx::tree::traits< SegmentByText_type, char > SegmentByText_traits;

    const SegmentByText_sequence&
    SegmentByText () const;

    SegmentByText_sequence&
    SegmentByText ();

    void
    SegmentByText (const SegmentByText_sequence& s);

    // SentinelConceptualDomain
    //
    typedef ::XMLSchema::SentinelConceptualDomain SentinelConceptualDomain_type;
    typedef ::xsd::cxx::tree::sequence< SentinelConceptualDomain_type > SentinelConceptualDomain_sequence;
    typedef SentinelConceptualDomain_sequence::iterator SentinelConceptualDomain_iterator;
    typedef SentinelConceptualDomain_sequence::const_iterator SentinelConceptualDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< SentinelConceptualDomain_type, char > SentinelConceptualDomain_traits;

    const SentinelConceptualDomain_sequence&
    SentinelConceptualDomain () const;

    SentinelConceptualDomain_sequence&
    SentinelConceptualDomain ();

    void
    SentinelConceptualDomain (const SentinelConceptualDomain_sequence& s);

    // SentinelValueDomain
    //
    typedef ::XMLSchema::SentinelValueDomain SentinelValueDomain_type;
    typedef ::xsd::cxx::tree::sequence< SentinelValueDomain_type > SentinelValueDomain_sequence;
    typedef SentinelValueDomain_sequence::iterator SentinelValueDomain_iterator;
    typedef SentinelValueDomain_sequence::const_iterator SentinelValueDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< SentinelValueDomain_type, char > SentinelValueDomain_traits;

    const SentinelValueDomain_sequence&
    SentinelValueDomain () const;

    SentinelValueDomain_sequence&
    SentinelValueDomain ();

    void
    SentinelValueDomain (const SentinelValueDomain_sequence& s);

    // Sequence
    //
    typedef ::XMLSchema::Sequence Sequence_type;
    typedef ::xsd::cxx::tree::sequence< Sequence_type > Sequence_sequence;
    typedef Sequence_sequence::iterator Sequence_iterator;
    typedef Sequence_sequence::const_iterator Sequence_const_iterator;
    typedef ::xsd::cxx::tree::traits< Sequence_type, char > Sequence_traits;

    const Sequence_sequence&
    Sequence () const;

    Sequence_sequence&
    Sequence ();

    void
    Sequence (const Sequence_sequence& s);

    // SequencePosition
    //
    typedef ::XMLSchema::SequencePosition SequencePosition_type;
    typedef ::xsd::cxx::tree::sequence< SequencePosition_type > SequencePosition_sequence;
    typedef SequencePosition_sequence::iterator SequencePosition_iterator;
    typedef SequencePosition_sequence::const_iterator SequencePosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< SequencePosition_type, char > SequencePosition_traits;

    const SequencePosition_sequence&
    SequencePosition () const;

    SequencePosition_sequence&
    SequencePosition ();

    void
    SequencePosition (const SequencePosition_sequence& s);

    // Service
    //
    typedef ::XMLSchema::Service Service_type;
    typedef ::xsd::cxx::tree::sequence< Service_type > Service_sequence;
    typedef Service_sequence::iterator Service_iterator;
    typedef Service_sequence::const_iterator Service_const_iterator;
    typedef ::xsd::cxx::tree::traits< Service_type, char > Service_traits;

    const Service_sequence&
    Service () const;

    Service_sequence&
    Service ();

    void
    Service (const Service_sequence& s);

    // StatisticalClassification
    //
    typedef ::XMLSchema::StatisticalClassification StatisticalClassification_type;
    typedef ::xsd::cxx::tree::sequence< StatisticalClassification_type > StatisticalClassification_sequence;
    typedef StatisticalClassification_sequence::iterator StatisticalClassification_iterator;
    typedef StatisticalClassification_sequence::const_iterator StatisticalClassification_const_iterator;
    typedef ::xsd::cxx::tree::traits< StatisticalClassification_type, char > StatisticalClassification_traits;

    const StatisticalClassification_sequence&
    StatisticalClassification () const;

    StatisticalClassification_sequence&
    StatisticalClassification ();

    void
    StatisticalClassification (const StatisticalClassification_sequence& s);

    // StatisticalClassificationRelationship
    //
    typedef ::XMLSchema::StatisticalClassificationRelationship StatisticalClassificationRelationship_type;
    typedef ::xsd::cxx::tree::sequence< StatisticalClassificationRelationship_type > StatisticalClassificationRelationship_sequence;
    typedef StatisticalClassificationRelationship_sequence::iterator StatisticalClassificationRelationship_iterator;
    typedef StatisticalClassificationRelationship_sequence::const_iterator StatisticalClassificationRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< StatisticalClassificationRelationship_type, char > StatisticalClassificationRelationship_traits;

    const StatisticalClassificationRelationship_sequence&
    StatisticalClassificationRelationship () const;

    StatisticalClassificationRelationship_sequence&
    StatisticalClassificationRelationship ();

    void
    StatisticalClassificationRelationship (const StatisticalClassificationRelationship_sequence& s);

    // Step
    //
    typedef ::XMLSchema::Step Step_type;
    typedef ::xsd::cxx::tree::sequence< Step_type > Step_sequence;
    typedef Step_sequence::iterator Step_iterator;
    typedef Step_sequence::const_iterator Step_const_iterator;
    typedef ::xsd::cxx::tree::traits< Step_type, char > Step_traits;

    const Step_sequence&
    Step () const;

    Step_sequence&
    Step ();

    void
    Step (const Step_sequence& s);

    // SubstantiveConceptualDomain
    //
    typedef ::XMLSchema::SubstantiveConceptualDomain SubstantiveConceptualDomain_type;
    typedef ::xsd::cxx::tree::sequence< SubstantiveConceptualDomain_type > SubstantiveConceptualDomain_sequence;
    typedef SubstantiveConceptualDomain_sequence::iterator SubstantiveConceptualDomain_iterator;
    typedef SubstantiveConceptualDomain_sequence::const_iterator SubstantiveConceptualDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< SubstantiveConceptualDomain_type, char > SubstantiveConceptualDomain_traits;

    const SubstantiveConceptualDomain_sequence&
    SubstantiveConceptualDomain () const;

    SubstantiveConceptualDomain_sequence&
    SubstantiveConceptualDomain ();

    void
    SubstantiveConceptualDomain (const SubstantiveConceptualDomain_sequence& s);

    // SubstantiveValueDomain
    //
    typedef ::XMLSchema::SubstantiveValueDomain SubstantiveValueDomain_type;
    typedef ::xsd::cxx::tree::sequence< SubstantiveValueDomain_type > SubstantiveValueDomain_sequence;
    typedef SubstantiveValueDomain_sequence::iterator SubstantiveValueDomain_iterator;
    typedef SubstantiveValueDomain_sequence::const_iterator SubstantiveValueDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< SubstantiveValueDomain_type, char > SubstantiveValueDomain_traits;

    const SubstantiveValueDomain_sequence&
    SubstantiveValueDomain () const;

    SubstantiveValueDomain_sequence&
    SubstantiveValueDomain ();

    void
    SubstantiveValueDomain (const SubstantiveValueDomain_sequence& s);

    // SyntheticIdComponent
    //
    typedef ::XMLSchema::SyntheticIdComponent SyntheticIdComponent_type;
    typedef ::xsd::cxx::tree::sequence< SyntheticIdComponent_type > SyntheticIdComponent_sequence;
    typedef SyntheticIdComponent_sequence::iterator SyntheticIdComponent_iterator;
    typedef SyntheticIdComponent_sequence::const_iterator SyntheticIdComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< SyntheticIdComponent_type, char > SyntheticIdComponent_traits;

    const SyntheticIdComponent_sequence&
    SyntheticIdComponent () const;

    SyntheticIdComponent_sequence&
    SyntheticIdComponent ();

    void
    SyntheticIdComponent (const SyntheticIdComponent_sequence& s);

    // TemporalConstraints
    //
    typedef ::XMLSchema::TemporalConstraints TemporalConstraints_type;
    typedef ::xsd::cxx::tree::sequence< TemporalConstraints_type > TemporalConstraints_sequence;
    typedef TemporalConstraints_sequence::iterator TemporalConstraints_iterator;
    typedef TemporalConstraints_sequence::const_iterator TemporalConstraints_const_iterator;
    typedef ::xsd::cxx::tree::traits< TemporalConstraints_type, char > TemporalConstraints_traits;

    const TemporalConstraints_sequence&
    TemporalConstraints () const;

    TemporalConstraints_sequence&
    TemporalConstraints ();

    void
    TemporalConstraints (const TemporalConstraints_sequence& s);

    // TemporalControlConstruct
    //
    typedef ::XMLSchema::TemporalControlConstruct TemporalControlConstruct_type;
    typedef ::xsd::cxx::tree::sequence< TemporalControlConstruct_type > TemporalControlConstruct_sequence;
    typedef TemporalControlConstruct_sequence::iterator TemporalControlConstruct_iterator;
    typedef TemporalControlConstruct_sequence::const_iterator TemporalControlConstruct_const_iterator;
    typedef ::xsd::cxx::tree::traits< TemporalControlConstruct_type, char > TemporalControlConstruct_traits;

    const TemporalControlConstruct_sequence&
    TemporalControlConstruct () const;

    TemporalControlConstruct_sequence&
    TemporalControlConstruct ();

    void
    TemporalControlConstruct (const TemporalControlConstruct_sequence& s);

    // Unit
    //
    typedef ::XMLSchema::Unit Unit_type;
    typedef ::xsd::cxx::tree::sequence< Unit_type > Unit_sequence;
    typedef Unit_sequence::iterator Unit_iterator;
    typedef Unit_sequence::const_iterator Unit_const_iterator;
    typedef ::xsd::cxx::tree::traits< Unit_type, char > Unit_traits;

    const Unit_sequence&
    Unit () const;

    Unit_sequence&
    Unit ();

    void
    Unit (const Unit_sequence& s);

    // UnitSegmentLayout
    //
    typedef ::XMLSchema::UnitSegmentLayout UnitSegmentLayout_type;
    typedef ::xsd::cxx::tree::sequence< UnitSegmentLayout_type > UnitSegmentLayout_sequence;
    typedef UnitSegmentLayout_sequence::iterator UnitSegmentLayout_iterator;
    typedef UnitSegmentLayout_sequence::const_iterator UnitSegmentLayout_const_iterator;
    typedef ::xsd::cxx::tree::traits< UnitSegmentLayout_type, char > UnitSegmentLayout_traits;

    const UnitSegmentLayout_sequence&
    UnitSegmentLayout () const;

    UnitSegmentLayout_sequence&
    UnitSegmentLayout ();

    void
    UnitSegmentLayout (const UnitSegmentLayout_sequence& s);

    // UnitType
    //
    typedef ::XMLSchema::UnitType UnitType_type;
    typedef ::xsd::cxx::tree::sequence< UnitType_type > UnitType_sequence;
    typedef UnitType_sequence::iterator UnitType_iterator;
    typedef UnitType_sequence::const_iterator UnitType_const_iterator;
    typedef ::xsd::cxx::tree::traits< UnitType_type, char > UnitType_traits;

    const UnitType_sequence&
    UnitType () const;

    UnitType_sequence&
    UnitType ();

    void
    UnitType (const UnitType_sequence& s);

    // Universe
    //
    typedef ::XMLSchema::Universe Universe_type;
    typedef ::xsd::cxx::tree::sequence< Universe_type > Universe_sequence;
    typedef Universe_sequence::iterator Universe_iterator;
    typedef Universe_sequence::const_iterator Universe_const_iterator;
    typedef ::xsd::cxx::tree::traits< Universe_type, char > Universe_traits;

    const Universe_sequence&
    Universe () const;

    Universe_sequence&
    Universe ();

    void
    Universe (const Universe_sequence& s);

    // ValueAndConceptDescription
    //
    typedef ::XMLSchema::ValueAndConceptDescription ValueAndConceptDescription_type;
    typedef ::xsd::cxx::tree::sequence< ValueAndConceptDescription_type > ValueAndConceptDescription_sequence;
    typedef ValueAndConceptDescription_sequence::iterator ValueAndConceptDescription_iterator;
    typedef ValueAndConceptDescription_sequence::const_iterator ValueAndConceptDescription_const_iterator;
    typedef ::xsd::cxx::tree::traits< ValueAndConceptDescription_type, char > ValueAndConceptDescription_traits;

    const ValueAndConceptDescription_sequence&
    ValueAndConceptDescription () const;

    ValueAndConceptDescription_sequence&
    ValueAndConceptDescription ();

    void
    ValueAndConceptDescription (const ValueAndConceptDescription_sequence& s);

    // ValueDomain
    //
    typedef ::XMLSchema::ValueDomain ValueDomain_type;
    typedef ::xsd::cxx::tree::sequence< ValueDomain_type > ValueDomain_sequence;
    typedef ValueDomain_sequence::iterator ValueDomain_iterator;
    typedef ValueDomain_sequence::const_iterator ValueDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< ValueDomain_type, char > ValueDomain_traits;

    const ValueDomain_sequence&
    ValueDomain () const;

    ValueDomain_sequence&
    ValueDomain ();

    void
    ValueDomain (const ValueDomain_sequence& s);

    // ValueMapping
    //
    typedef ::XMLSchema::ValueMapping ValueMapping_type;
    typedef ::xsd::cxx::tree::sequence< ValueMapping_type > ValueMapping_sequence;
    typedef ValueMapping_sequence::iterator ValueMapping_iterator;
    typedef ValueMapping_sequence::const_iterator ValueMapping_const_iterator;
    typedef ::xsd::cxx::tree::traits< ValueMapping_type, char > ValueMapping_traits;

    const ValueMapping_sequence&
    ValueMapping () const;

    ValueMapping_sequence&
    ValueMapping ();

    void
    ValueMapping (const ValueMapping_sequence& s);

    // ValueMappingPosition
    //
    typedef ::XMLSchema::ValueMappingPosition ValueMappingPosition_type;
    typedef ::xsd::cxx::tree::sequence< ValueMappingPosition_type > ValueMappingPosition_sequence;
    typedef ValueMappingPosition_sequence::iterator ValueMappingPosition_iterator;
    typedef ValueMappingPosition_sequence::const_iterator ValueMappingPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< ValueMappingPosition_type, char > ValueMappingPosition_traits;

    const ValueMappingPosition_sequence&
    ValueMappingPosition () const;

    ValueMappingPosition_sequence&
    ValueMappingPosition ();

    void
    ValueMappingPosition (const ValueMappingPosition_sequence& s);

    // ValueMappingRelationship
    //
    typedef ::XMLSchema::ValueMappingRelationship ValueMappingRelationship_type;
    typedef ::xsd::cxx::tree::sequence< ValueMappingRelationship_type > ValueMappingRelationship_sequence;
    typedef ValueMappingRelationship_sequence::iterator ValueMappingRelationship_iterator;
    typedef ValueMappingRelationship_sequence::const_iterator ValueMappingRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< ValueMappingRelationship_type, char > ValueMappingRelationship_traits;

    const ValueMappingRelationship_sequence&
    ValueMappingRelationship () const;

    ValueMappingRelationship_sequence&
    ValueMappingRelationship ();

    void
    ValueMappingRelationship (const ValueMappingRelationship_sequence& s);

    // VariableCollection
    //
    typedef ::XMLSchema::VariableCollection VariableCollection_type;
    typedef ::xsd::cxx::tree::sequence< VariableCollection_type > VariableCollection_sequence;
    typedef VariableCollection_sequence::iterator VariableCollection_iterator;
    typedef VariableCollection_sequence::const_iterator VariableCollection_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableCollection_type, char > VariableCollection_traits;

    const VariableCollection_sequence&
    VariableCollection () const;

    VariableCollection_sequence&
    VariableCollection ();

    void
    VariableCollection (const VariableCollection_sequence& s);

    // VariableDescriptorComponent
    //
    typedef ::XMLSchema::VariableDescriptorComponent VariableDescriptorComponent_type;
    typedef ::xsd::cxx::tree::sequence< VariableDescriptorComponent_type > VariableDescriptorComponent_sequence;
    typedef VariableDescriptorComponent_sequence::iterator VariableDescriptorComponent_iterator;
    typedef VariableDescriptorComponent_sequence::const_iterator VariableDescriptorComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableDescriptorComponent_type, char > VariableDescriptorComponent_traits;

    const VariableDescriptorComponent_sequence&
    VariableDescriptorComponent () const;

    VariableDescriptorComponent_sequence&
    VariableDescriptorComponent ();

    void
    VariableDescriptorComponent (const VariableDescriptorComponent_sequence& s);

    // VariablePosition
    //
    typedef ::XMLSchema::VariablePosition VariablePosition_type;
    typedef ::xsd::cxx::tree::sequence< VariablePosition_type > VariablePosition_sequence;
    typedef VariablePosition_sequence::iterator VariablePosition_iterator;
    typedef VariablePosition_sequence::const_iterator VariablePosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariablePosition_type, char > VariablePosition_traits;

    const VariablePosition_sequence&
    VariablePosition () const;

    VariablePosition_sequence&
    VariablePosition ();

    void
    VariablePosition (const VariablePosition_sequence& s);

    // VariableRelationship
    //
    typedef ::XMLSchema::VariableRelationship VariableRelationship_type;
    typedef ::xsd::cxx::tree::sequence< VariableRelationship_type > VariableRelationship_sequence;
    typedef VariableRelationship_sequence::iterator VariableRelationship_iterator;
    typedef VariableRelationship_sequence::const_iterator VariableRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableRelationship_type, char > VariableRelationship_traits;

    const VariableRelationship_sequence&
    VariableRelationship () const;

    VariableRelationship_sequence&
    VariableRelationship ();

    void
    VariableRelationship (const VariableRelationship_sequence& s);

    // VariableStructure
    //
    typedef ::XMLSchema::VariableStructure VariableStructure_type;
    typedef ::xsd::cxx::tree::sequence< VariableStructure_type > VariableStructure_sequence;
    typedef VariableStructure_sequence::iterator VariableStructure_iterator;
    typedef VariableStructure_sequence::const_iterator VariableStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableStructure_type, char > VariableStructure_traits;

    const VariableStructure_sequence&
    VariableStructure () const;

    VariableStructure_sequence&
    VariableStructure ();

    void
    VariableStructure (const VariableStructure_sequence& s);

    // VariableValueComponent
    //
    typedef ::XMLSchema::VariableValueComponent VariableValueComponent_type;
    typedef ::xsd::cxx::tree::sequence< VariableValueComponent_type > VariableValueComponent_sequence;
    typedef VariableValueComponent_sequence::iterator VariableValueComponent_iterator;
    typedef VariableValueComponent_sequence::const_iterator VariableValueComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableValueComponent_type, char > VariableValueComponent_traits;

    const VariableValueComponent_sequence&
    VariableValueComponent () const;

    VariableValueComponent_sequence&
    VariableValueComponent ();

    void
    VariableValueComponent (const VariableValueComponent_sequence& s);

    // WideDataSet
    //
    typedef ::XMLSchema::WideDataSet WideDataSet_type;
    typedef ::xsd::cxx::tree::sequence< WideDataSet_type > WideDataSet_sequence;
    typedef WideDataSet_sequence::iterator WideDataSet_iterator;
    typedef WideDataSet_sequence::const_iterator WideDataSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< WideDataSet_type, char > WideDataSet_traits;

    const WideDataSet_sequence&
    WideDataSet () const;

    WideDataSet_sequence&
    WideDataSet ();

    void
    WideDataSet (const WideDataSet_sequence& s);

    // WideDataStructure
    //
    typedef ::XMLSchema::WideDataStructure WideDataStructure_type;
    typedef ::xsd::cxx::tree::sequence< WideDataStructure_type > WideDataStructure_sequence;
    typedef WideDataStructure_sequence::iterator WideDataStructure_iterator;
    typedef WideDataStructure_sequence::const_iterator WideDataStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< WideDataStructure_type, char > WideDataStructure_traits;

    const WideDataStructure_sequence&
    WideDataStructure () const;

    WideDataStructure_sequence&
    WideDataStructure ();

    void
    WideDataStructure (const WideDataStructure_sequence& s);

    // WideKey
    //
    typedef ::XMLSchema::WideKey WideKey_type;
    typedef ::xsd::cxx::tree::sequence< WideKey_type > WideKey_sequence;
    typedef WideKey_sequence::iterator WideKey_iterator;
    typedef WideKey_sequence::const_iterator WideKey_const_iterator;
    typedef ::xsd::cxx::tree::traits< WideKey_type, char > WideKey_traits;

    const WideKey_sequence&
    WideKey () const;

    WideKey_sequence&
    WideKey ();

    void
    WideKey (const WideKey_sequence& s);

    // WideKeyMember
    //
    typedef ::XMLSchema::WideKeyMember WideKeyMember_type;
    typedef ::xsd::cxx::tree::sequence< WideKeyMember_type > WideKeyMember_sequence;
    typedef WideKeyMember_sequence::iterator WideKeyMember_iterator;
    typedef WideKeyMember_sequence::const_iterator WideKeyMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< WideKeyMember_type, char > WideKeyMember_traits;

    const WideKeyMember_sequence&
    WideKeyMember () const;

    WideKeyMember_sequence&
    WideKeyMember ();

    void
    WideKeyMember (const WideKeyMember_sequence& s);

    // Constructors.
    //
    Wrapper ();

    Wrapper (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Wrapper (const Wrapper& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual Wrapper*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Wrapper&
    operator= (const Wrapper& x);

    virtual 
    ~Wrapper ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    supportingInformation_sequence supportingInformation_;
    Activity_sequence Activity_;
    Agent_sequence Agent_;
    AgentListing_sequence AgentListing_;
    AgentPosition_sequence AgentPosition_;
    AgentRelationship_sequence AgentRelationship_;
    AgentStructure_sequence AgentStructure_;
    AllenIntervalAlgebra_sequence AllenIntervalAlgebra_;
    AttributeComponent_sequence AttributeComponent_;
    AuthorizationSource_sequence AuthorizationSource_;
    Category_sequence Category_;
    CategoryPosition_sequence CategoryPosition_;
    CategoryRelationStructure_sequence CategoryRelationStructure_;
    CategoryRelationship_sequence CategoryRelationship_;
    CategorySet_sequence CategorySet_;
    CategoryStatistic_sequence CategoryStatistic_;
    ClassificationFamily_sequence ClassificationFamily_;
    ClassificationIndex_sequence ClassificationIndex_;
    ClassificationIndexEntry_sequence ClassificationIndexEntry_;
    ClassificationIndexEntryPosition_sequence ClassificationIndexEntryPosition_;
    ClassificationItem_sequence ClassificationItem_;
    ClassificationItemPosition_sequence ClassificationItemPosition_;
    ClassificationItemRelationship_sequence ClassificationItemRelationship_;
    ClassificationItemStructure_sequence ClassificationItemStructure_;
    ClassificationPosition_sequence ClassificationPosition_;
    ClassificationSeries_sequence ClassificationSeries_;
    ClassificationSeriesStructure_sequence ClassificationSeriesStructure_;
    Code_sequence Code_;
    CodeList_sequence CodeList_;
    CodeListStructure_sequence CodeListStructure_;
    CodePosition_sequence CodePosition_;
    CodeRelationship_sequence CodeRelationship_;
    ComponentPosition_sequence ComponentPosition_;
    Concept_sequence Concept_;
    ConceptMap_sequence ConceptMap_;
    ConceptRelationship_sequence ConceptRelationship_;
    ConceptStructure_sequence ConceptStructure_;
    ConceptSystem_sequence ConceptSystem_;
    ConceptSystemCorrespondence_sequence ConceptSystemCorrespondence_;
    ConceptualDomain_sequence ConceptualDomain_;
    ConceptualValue_sequence ConceptualValue_;
    ConceptualVariable_sequence ConceptualVariable_;
    ConditionalControlLogic_sequence ConditionalControlLogic_;
    ContextualComponent_sequence ContextualComponent_;
    ControlLogic_sequence ControlLogic_;
    CorrespondenceTable_sequence CorrespondenceTable_;
    Curator_sequence Curator_;
    DataPoint_sequence DataPoint_;
    DataPointPosition_sequence DataPointPosition_;
    DataPointRelationship_sequence DataPointRelationship_;
    DataSet_sequence DataSet_;
    DataStore_sequence DataStore_;
    DataStructure_sequence DataStructure_;
    DataStructureComponent_sequence DataStructureComponent_;
    Datum_sequence Datum_;
    Descriptor_sequence Descriptor_;
    DescriptorValueDomain_sequence DescriptorValueDomain_;
    DescriptorVariable_sequence DescriptorVariable_;
    DeterministicImperative_sequence DeterministicImperative_;
    DimensionComponent_sequence DimensionComponent_;
    DimensionGroup_sequence DimensionGroup_;
    DimensionalDataSet_sequence DimensionalDataSet_;
    DimensionalDataStructure_sequence DimensionalDataStructure_;
    DimensionalKey_sequence DimensionalKey_;
    DimensionalKeyDefinition_sequence DimensionalKeyDefinition_;
    DimensionalKeyDefinitionMember_sequence DimensionalKeyDefinitionMember_;
    DimensionalKeyMember_sequence DimensionalKeyMember_;
    EnumerationDomain_sequence EnumerationDomain_;
    ForeignKey_sequence ForeignKey_;
    ForeignKeyComponent_sequence ForeignKeyComponent_;
    IdentifierComponent_sequence IdentifierComponent_;
    Individual_sequence Individual_;
    InformationFlowDefinition_sequence InformationFlowDefinition_;
    InstanceKey_sequence InstanceKey_;
    InstanceValue_sequence InstanceValue_;
    InstanceVariable_sequence InstanceVariable_;
    InstanceVariableMap_sequence InstanceVariableMap_;
    Key_sequence Key_;
    KeyDefinition_sequence KeyDefinition_;
    KeyDefinitionMember_sequence KeyDefinitionMember_;
    KeyMember_sequence KeyMember_;
    KeyValueDataStore_sequence KeyValueDataStore_;
    KeyValueStructure_sequence KeyValueStructure_;
    Level_sequence Level_;
    LevelStructure_sequence LevelStructure_;
    LogicalRecord_sequence LogicalRecord_;
    LogicalRecordPosition_sequence LogicalRecordPosition_;
    LogicalRecordRelationStructure_sequence LogicalRecordRelationStructure_;
    LogicalRecordRelationship_sequence LogicalRecordRelationship_;
    LongDataSet_sequence LongDataSet_;
    LongDataStructure_sequence LongDataStructure_;
    LongKey_sequence LongKey_;
    LongMainKeyMember_sequence LongMainKeyMember_;
    Machine_sequence Machine_;
    MainKeyMember_sequence MainKeyMember_;
    MeasureComponent_sequence MeasureComponent_;
    NonDeterministicDeclarative_sequence NonDeterministicDeclarative_;
    Notation_sequence Notation_;
    Organization_sequence Organization_;
    Parameter_sequence Parameter_;
    PhysicalDataSet_sequence PhysicalDataSet_;
    PhysicalDataSetStructure_sequence PhysicalDataSetStructure_;
    PhysicalLayoutRelationStructure_sequence PhysicalLayoutRelationStructure_;
    PhysicalRecordSegment_sequence PhysicalRecordSegment_;
    PhysicalRecordSegmentPosition_sequence PhysicalRecordSegmentPosition_;
    PhysicalRecordSegmentRelationship_sequence PhysicalRecordSegmentRelationship_;
    PhysicalRecordSegmentStructure_sequence PhysicalRecordSegmentStructure_;
    PhysicalSegmentLayout_sequence PhysicalSegmentLayout_;
    PhysicalSegmentLocation_sequence PhysicalSegmentLocation_;
    Population_sequence Population_;
    PrimaryKey_sequence PrimaryKey_;
    PrimaryKeyComponent_sequence PrimaryKeyComponent_;
    ProcessingAgent_sequence ProcessingAgent_;
    ProductionEnvironment_sequence ProductionEnvironment_;
    QualifiedMeasure_sequence QualifiedMeasure_;
    RecordRelation_sequence RecordRelation_;
    ReferenceValue_sequence ReferenceValue_;
    ReferenceValueDomain_sequence ReferenceValueDomain_;
    ReferenceVariable_sequence ReferenceVariable_;
    RepresentedVariable_sequence RepresentedVariable_;
    RevisableDatum_sequence RevisableDatum_;
    Revision_sequence Revision_;
    Rule_sequence Rule_;
    RuleBasedScheduling_sequence RuleBasedScheduling_;
    RuleSet_sequence RuleSet_;
    ScopedMeasure_sequence ScopedMeasure_;
    SegmentByText_sequence SegmentByText_;
    SentinelConceptualDomain_sequence SentinelConceptualDomain_;
    SentinelValueDomain_sequence SentinelValueDomain_;
    Sequence_sequence Sequence_;
    SequencePosition_sequence SequencePosition_;
    Service_sequence Service_;
    StatisticalClassification_sequence StatisticalClassification_;
    StatisticalClassificationRelationship_sequence StatisticalClassificationRelationship_;
    Step_sequence Step_;
    SubstantiveConceptualDomain_sequence SubstantiveConceptualDomain_;
    SubstantiveValueDomain_sequence SubstantiveValueDomain_;
    SyntheticIdComponent_sequence SyntheticIdComponent_;
    TemporalConstraints_sequence TemporalConstraints_;
    TemporalControlConstruct_sequence TemporalControlConstruct_;
    Unit_sequence Unit_;
    UnitSegmentLayout_sequence UnitSegmentLayout_;
    UnitType_sequence UnitType_;
    Universe_sequence Universe_;
    ValueAndConceptDescription_sequence ValueAndConceptDescription_;
    ValueDomain_sequence ValueDomain_;
    ValueMapping_sequence ValueMapping_;
    ValueMappingPosition_sequence ValueMappingPosition_;
    ValueMappingRelationship_sequence ValueMappingRelationship_;
    VariableCollection_sequence VariableCollection_;
    VariableDescriptorComponent_sequence VariableDescriptorComponent_;
    VariablePosition_sequence VariablePosition_;
    VariableRelationship_sequence VariableRelationship_;
    VariableStructure_sequence VariableStructure_;
    VariableValueComponent_sequence VariableValueComponent_;
    WideDataSet_sequence WideDataSet_;
    WideDataStructure_sequence WideDataStructure_;
    WideKey_sequence WideKey_;
    WideKeyMember_sequence WideKeyMember_;
  };

  class Activity: public ::xml_schema::type
  {
    public:
    // definition
    //
    typedef ::XMLSchema::InternationalString definition_type;
    typedef ::xsd::cxx::tree::optional< definition_type > definition_optional;
    typedef ::xsd::cxx::tree::traits< definition_type, char > definition_traits;

    const definition_optional&
    definition () const;

    definition_optional&
    definition ();

    void
    definition (const definition_type& x);

    void
    definition (const definition_optional& x);

    void
    definition (::std::unique_ptr< definition_type > p);

    // description
    //
    typedef ::xml_schema::string description_type;
    typedef ::xsd::cxx::tree::optional< description_type > description_optional;
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    const description_optional&
    description () const;

    description_optional&
    description ();

    void
    description (const description_type& x);

    void
    description (const description_optional& x);

    void
    description (::std::unique_ptr< description_type > p);

    // displayLabel
    //
    typedef ::XMLSchema::LabelForDisplay displayLabel_type;
    typedef ::xsd::cxx::tree::sequence< displayLabel_type > displayLabel_sequence;
    typedef displayLabel_sequence::iterator displayLabel_iterator;
    typedef displayLabel_sequence::const_iterator displayLabel_const_iterator;
    typedef ::xsd::cxx::tree::traits< displayLabel_type, char > displayLabel_traits;

    const displayLabel_sequence&
    displayLabel () const;

    displayLabel_sequence&
    displayLabel ();

    void
    displayLabel (const displayLabel_sequence& s);

    // entityProduced
    //
    typedef ::XMLSchema::entityProduced entityProduced_type;
    typedef ::xsd::cxx::tree::sequence< entityProduced_type > entityProduced_sequence;
    typedef entityProduced_sequence::iterator entityProduced_iterator;
    typedef entityProduced_sequence::const_iterator entityProduced_const_iterator;
    typedef ::xsd::cxx::tree::traits< entityProduced_type, char > entityProduced_traits;

    const entityProduced_sequence&
    entityProduced () const;

    entityProduced_sequence&
    entityProduced ();

    void
    entityProduced (const entityProduced_sequence& s);

    // entityUsed
    //
    typedef ::XMLSchema::entityUsed entityUsed_type;
    typedef ::xsd::cxx::tree::sequence< entityUsed_type > entityUsed_sequence;
    typedef entityUsed_sequence::iterator entityUsed_iterator;
    typedef entityUsed_sequence::const_iterator entityUsed_const_iterator;
    typedef ::xsd::cxx::tree::traits< entityUsed_type, char > entityUsed_traits;

    const entityUsed_sequence&
    entityUsed () const;

    entityUsed_sequence&
    entityUsed ();

    void
    entityUsed (const entityUsed_sequence& s);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // standardModelMapping
    //
    typedef ::XMLSchema::standardModelMapping standardModelMapping_type;
    typedef ::xsd::cxx::tree::sequence< standardModelMapping_type > standardModelMapping_sequence;
    typedef standardModelMapping_sequence::iterator standardModelMapping_iterator;
    typedef standardModelMapping_sequence::const_iterator standardModelMapping_const_iterator;
    typedef ::xsd::cxx::tree::traits< standardModelMapping_type, char > standardModelMapping_traits;

    const standardModelMapping_sequence&
    standardModelMapping () const;

    standardModelMapping_sequence&
    standardModelMapping ();

    void
    standardModelMapping (const standardModelMapping_sequence& s);

    // Activity_hasInternal_ControlLogic
    //
    typedef ::XMLSchema::Activity_hasInternal_ControlLogic Activity_hasInternal_ControlLogic_type;
    typedef ::xsd::cxx::tree::sequence< Activity_hasInternal_ControlLogic_type > Activity_hasInternal_ControlLogic_sequence;
    typedef Activity_hasInternal_ControlLogic_sequence::iterator Activity_hasInternal_ControlLogic_iterator;
    typedef Activity_hasInternal_ControlLogic_sequence::const_iterator Activity_hasInternal_ControlLogic_const_iterator;
    typedef ::xsd::cxx::tree::traits< Activity_hasInternal_ControlLogic_type, char > Activity_hasInternal_ControlLogic_traits;

    const Activity_hasInternal_ControlLogic_sequence&
    Activity_hasInternal_ControlLogic () const;

    Activity_hasInternal_ControlLogic_sequence&
    Activity_hasInternal_ControlLogic ();

    void
    Activity_hasInternal_ControlLogic (const Activity_hasInternal_ControlLogic_sequence& s);

    // Activity_hasSubActivity_Activity
    //
    typedef ::XMLSchema::Activity_hasSubActivity_Activity Activity_hasSubActivity_Activity_type;
    typedef ::xsd::cxx::tree::sequence< Activity_hasSubActivity_Activity_type > Activity_hasSubActivity_Activity_sequence;
    typedef Activity_hasSubActivity_Activity_sequence::iterator Activity_hasSubActivity_Activity_iterator;
    typedef Activity_hasSubActivity_Activity_sequence::const_iterator Activity_hasSubActivity_Activity_const_iterator;
    typedef ::xsd::cxx::tree::traits< Activity_hasSubActivity_Activity_type, char > Activity_hasSubActivity_Activity_traits;

    const Activity_hasSubActivity_Activity_sequence&
    Activity_hasSubActivity_Activity () const;

    Activity_hasSubActivity_Activity_sequence&
    Activity_hasSubActivity_Activity ();

    void
    Activity_hasSubActivity_Activity (const Activity_hasSubActivity_Activity_sequence& s);

    // Activity_has_Step
    //
    typedef ::XMLSchema::Activity_has_Step Activity_has_Step_type;
    typedef ::xsd::cxx::tree::sequence< Activity_has_Step_type > Activity_has_Step_sequence;
    typedef Activity_has_Step_sequence::iterator Activity_has_Step_iterator;
    typedef Activity_has_Step_sequence::const_iterator Activity_has_Step_const_iterator;
    typedef ::xsd::cxx::tree::traits< Activity_has_Step_type, char > Activity_has_Step_traits;

    const Activity_has_Step_sequence&
    Activity_has_Step () const;

    Activity_has_Step_sequence&
    Activity_has_Step ();

    void
    Activity_has_Step (const Activity_has_Step_sequence& s);

    // Constructors.
    //
    Activity ();

    Activity (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Activity (const Activity& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual Activity*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Activity&
    operator= (const Activity& x);

    virtual 
    ~Activity ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    definition_optional definition_;
    description_optional description_;
    displayLabel_sequence displayLabel_;
    entityProduced_sequence entityProduced_;
    entityUsed_sequence entityUsed_;
    identifier_optional identifier_;
    name_sequence name_;
    standardModelMapping_sequence standardModelMapping_;
    Activity_hasInternal_ControlLogic_sequence Activity_hasInternal_ControlLogic_;
    Activity_hasSubActivity_Activity_sequence Activity_hasSubActivity_Activity_;
    Activity_has_Step_sequence Activity_has_Step_;
  };

  class Agent: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // image
    //
    typedef ::XMLSchema::PrivateImage image_type;
    typedef ::xsd::cxx::tree::sequence< image_type > image_sequence;
    typedef image_sequence::iterator image_iterator;
    typedef image_sequence::const_iterator image_const_iterator;
    typedef ::xsd::cxx::tree::traits< image_type, char > image_traits;

    const image_sequence&
    image () const;

    image_sequence&
    image ();

    void
    image (const image_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // Constructors.
    //
    Agent ();

    Agent (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Agent (const Agent& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Agent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Agent&
    operator= (const Agent& x);

    virtual 
    ~Agent ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    identifier_optional identifier_;
    image_sequence image_;
    purpose_optional purpose_;
  };

  class AgentListing: public ::xml_schema::type
  {
    public:
    // allowsDuplicates
    //
    typedef ::xml_schema::boolean allowsDuplicates_type;
    typedef ::xsd::cxx::tree::traits< allowsDuplicates_type, char > allowsDuplicates_traits;

    const allowsDuplicates_type&
    allowsDuplicates () const;

    allowsDuplicates_type&
    allowsDuplicates ();

    void
    allowsDuplicates (const allowsDuplicates_type& x);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // AgentListing_isDefinedBy_Concept
    //
    typedef ::XMLSchema::AgentListing_isDefinedBy_Concept AgentListing_isDefinedBy_Concept_type;
    typedef ::xsd::cxx::tree::sequence< AgentListing_isDefinedBy_Concept_type > AgentListing_isDefinedBy_Concept_sequence;
    typedef AgentListing_isDefinedBy_Concept_sequence::iterator AgentListing_isDefinedBy_Concept_iterator;
    typedef AgentListing_isDefinedBy_Concept_sequence::const_iterator AgentListing_isDefinedBy_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< AgentListing_isDefinedBy_Concept_type, char > AgentListing_isDefinedBy_Concept_traits;

    const AgentListing_isDefinedBy_Concept_sequence&
    AgentListing_isDefinedBy_Concept () const;

    AgentListing_isDefinedBy_Concept_sequence&
    AgentListing_isDefinedBy_Concept ();

    void
    AgentListing_isDefinedBy_Concept (const AgentListing_isDefinedBy_Concept_sequence& s);

    // AgentListing_isMaintainedBy_Agent
    //
    typedef ::XMLSchema::AgentListing_isMaintainedBy_Agent AgentListing_isMaintainedBy_Agent_type;
    typedef ::xsd::cxx::tree::optional< AgentListing_isMaintainedBy_Agent_type > AgentListing_isMaintainedBy_Agent_optional;
    typedef ::xsd::cxx::tree::traits< AgentListing_isMaintainedBy_Agent_type, char > AgentListing_isMaintainedBy_Agent_traits;

    const AgentListing_isMaintainedBy_Agent_optional&
    AgentListing_isMaintainedBy_Agent () const;

    AgentListing_isMaintainedBy_Agent_optional&
    AgentListing_isMaintainedBy_Agent ();

    void
    AgentListing_isMaintainedBy_Agent (const AgentListing_isMaintainedBy_Agent_type& x);

    void
    AgentListing_isMaintainedBy_Agent (const AgentListing_isMaintainedBy_Agent_optional& x);

    void
    AgentListing_isMaintainedBy_Agent (::std::unique_ptr< AgentListing_isMaintainedBy_Agent_type > p);

    // AgentListing_has_AgentPosition
    //
    typedef ::XMLSchema::AgentListing_has_AgentPosition AgentListing_has_AgentPosition_type;
    typedef ::xsd::cxx::tree::sequence< AgentListing_has_AgentPosition_type > AgentListing_has_AgentPosition_sequence;
    typedef AgentListing_has_AgentPosition_sequence::iterator AgentListing_has_AgentPosition_iterator;
    typedef AgentListing_has_AgentPosition_sequence::const_iterator AgentListing_has_AgentPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< AgentListing_has_AgentPosition_type, char > AgentListing_has_AgentPosition_traits;

    const AgentListing_has_AgentPosition_sequence&
    AgentListing_has_AgentPosition () const;

    AgentListing_has_AgentPosition_sequence&
    AgentListing_has_AgentPosition ();

    void
    AgentListing_has_AgentPosition (const AgentListing_has_AgentPosition_sequence& s);

    // AgentListing_has_Agent
    //
    typedef ::XMLSchema::AgentListing_has_Agent AgentListing_has_Agent_type;
    typedef ::xsd::cxx::tree::sequence< AgentListing_has_Agent_type > AgentListing_has_Agent_sequence;
    typedef AgentListing_has_Agent_sequence::iterator AgentListing_has_Agent_iterator;
    typedef AgentListing_has_Agent_sequence::const_iterator AgentListing_has_Agent_const_iterator;
    typedef ::xsd::cxx::tree::traits< AgentListing_has_Agent_type, char > AgentListing_has_Agent_traits;

    const AgentListing_has_Agent_sequence&
    AgentListing_has_Agent () const;

    AgentListing_has_Agent_sequence&
    AgentListing_has_Agent ();

    void
    AgentListing_has_Agent (const AgentListing_has_Agent_sequence& s);

    // Constructors.
    //
    AgentListing (const allowsDuplicates_type&);

    AgentListing (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    AgentListing (const AgentListing& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual AgentListing*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AgentListing&
    operator= (const AgentListing& x);

    virtual 
    ~AgentListing ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< allowsDuplicates_type > allowsDuplicates_;
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    AgentListing_isDefinedBy_Concept_sequence AgentListing_isDefinedBy_Concept_;
    AgentListing_isMaintainedBy_Agent_optional AgentListing_isMaintainedBy_Agent_;
    AgentListing_has_AgentPosition_sequence AgentListing_has_AgentPosition_;
    AgentListing_has_Agent_sequence AgentListing_has_Agent_;
  };

  class AgentPosition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // value
    //
    typedef ::xml_schema::integer value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    // AgentPosition_indexes_Agent
    //
    typedef ::XMLSchema::AgentPosition_indexes_Agent AgentPosition_indexes_Agent_type;
    typedef ::xsd::cxx::tree::optional< AgentPosition_indexes_Agent_type > AgentPosition_indexes_Agent_optional;
    typedef ::xsd::cxx::tree::traits< AgentPosition_indexes_Agent_type, char > AgentPosition_indexes_Agent_traits;

    const AgentPosition_indexes_Agent_optional&
    AgentPosition_indexes_Agent () const;

    AgentPosition_indexes_Agent_optional&
    AgentPosition_indexes_Agent ();

    void
    AgentPosition_indexes_Agent (const AgentPosition_indexes_Agent_type& x);

    void
    AgentPosition_indexes_Agent (const AgentPosition_indexes_Agent_optional& x);

    void
    AgentPosition_indexes_Agent (::std::unique_ptr< AgentPosition_indexes_Agent_type > p);

    // Constructors.
    //
    AgentPosition (const value_type&);

    AgentPosition (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    AgentPosition (const AgentPosition& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual AgentPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AgentPosition&
    operator= (const AgentPosition& x);

    virtual 
    ~AgentPosition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< value_type > value_;
    AgentPosition_indexes_Agent_optional AgentPosition_indexes_Agent_;
  };

  class AgentRelationship: public ::xml_schema::type
  {
    public:
    // effectiveDates
    //
    typedef ::XMLSchema::DateRange effectiveDates_type;
    typedef ::xsd::cxx::tree::optional< effectiveDates_type > effectiveDates_optional;
    typedef ::xsd::cxx::tree::traits< effectiveDates_type, char > effectiveDates_traits;

    const effectiveDates_optional&
    effectiveDates () const;

    effectiveDates_optional&
    effectiveDates ();

    void
    effectiveDates (const effectiveDates_type& x);

    void
    effectiveDates (const effectiveDates_optional& x);

    void
    effectiveDates (::std::unique_ptr< effectiveDates_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // AgentRelationship_hasSource_Agent
    //
    typedef ::XMLSchema::AgentRelationship_hasSource_Agent AgentRelationship_hasSource_Agent_type;
    typedef ::xsd::cxx::tree::traits< AgentRelationship_hasSource_Agent_type, char > AgentRelationship_hasSource_Agent_traits;

    const AgentRelationship_hasSource_Agent_type&
    AgentRelationship_hasSource_Agent () const;

    AgentRelationship_hasSource_Agent_type&
    AgentRelationship_hasSource_Agent ();

    void
    AgentRelationship_hasSource_Agent (const AgentRelationship_hasSource_Agent_type& x);

    void
    AgentRelationship_hasSource_Agent (::std::unique_ptr< AgentRelationship_hasSource_Agent_type > p);

    // AgentRelationship_hasTarget_Agent
    //
    typedef ::XMLSchema::AgentRelationship_hasTarget_Agent AgentRelationship_hasTarget_Agent_type;
    typedef ::xsd::cxx::tree::traits< AgentRelationship_hasTarget_Agent_type, char > AgentRelationship_hasTarget_Agent_traits;

    const AgentRelationship_hasTarget_Agent_type&
    AgentRelationship_hasTarget_Agent () const;

    AgentRelationship_hasTarget_Agent_type&
    AgentRelationship_hasTarget_Agent ();

    void
    AgentRelationship_hasTarget_Agent (const AgentRelationship_hasTarget_Agent_type& x);

    void
    AgentRelationship_hasTarget_Agent (::std::unique_ptr< AgentRelationship_hasTarget_Agent_type > p);

    // Constructors.
    //
    AgentRelationship (const AgentRelationship_hasSource_Agent_type&,
                       const AgentRelationship_hasTarget_Agent_type&);

    AgentRelationship (::std::unique_ptr< AgentRelationship_hasSource_Agent_type >,
                       ::std::unique_ptr< AgentRelationship_hasTarget_Agent_type >);

    AgentRelationship (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    AgentRelationship (const AgentRelationship& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual AgentRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AgentRelationship&
    operator= (const AgentRelationship& x);

    virtual 
    ~AgentRelationship ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    effectiveDates_optional effectiveDates_;
    identifier_optional identifier_;
    semantics_optional semantics_;
    ::xsd::cxx::tree::one< AgentRelationship_hasSource_Agent_type > AgentRelationship_hasSource_Agent_;
    ::xsd::cxx::tree::one< AgentRelationship_hasTarget_Agent_type > AgentRelationship_hasTarget_Agent_;
  };

  class AgentStructure: public ::xml_schema::type
  {
    public:
    // effectiveDates
    //
    typedef ::XMLSchema::DateRange effectiveDates_type;
    typedef ::xsd::cxx::tree::optional< effectiveDates_type > effectiveDates_optional;
    typedef ::xsd::cxx::tree::traits< effectiveDates_type, char > effectiveDates_traits;

    const effectiveDates_optional&
    effectiveDates () const;

    effectiveDates_optional&
    effectiveDates ();

    void
    effectiveDates (const effectiveDates_type& x);

    void
    effectiveDates (const effectiveDates_optional& x);

    void
    effectiveDates (::std::unique_ptr< effectiveDates_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // privacy
    //
    typedef ::XMLSchema::ControlledVocabularyEntry privacy_type;
    typedef ::xsd::cxx::tree::optional< privacy_type > privacy_optional;
    typedef ::xsd::cxx::tree::traits< privacy_type, char > privacy_traits;

    const privacy_optional&
    privacy () const;

    privacy_optional&
    privacy ();

    void
    privacy (const privacy_type& x);

    void
    privacy (const privacy_optional& x);

    void
    privacy (::std::unique_ptr< privacy_type > p);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // specification
    //
    typedef ::XMLSchema::StructureSpecification specification_type;
    typedef ::xsd::cxx::tree::optional< specification_type > specification_optional;
    typedef ::xsd::cxx::tree::traits< specification_type, char > specification_traits;

    const specification_optional&
    specification () const;

    specification_optional&
    specification ();

    void
    specification (const specification_type& x);

    void
    specification (const specification_optional& x);

    void
    specification (::std::unique_ptr< specification_type > p);

    // topology
    //
    typedef ::XMLSchema::ControlledVocabularyEntry topology_type;
    typedef ::xsd::cxx::tree::optional< topology_type > topology_optional;
    typedef ::xsd::cxx::tree::traits< topology_type, char > topology_traits;

    const topology_optional&
    topology () const;

    topology_optional&
    topology ();

    void
    topology (const topology_type& x);

    void
    topology (const topology_optional& x);

    void
    topology (::std::unique_ptr< topology_type > p);

    // totality
    //
    typedef ::XMLSchema::StructureExtent totality_type;
    typedef ::xsd::cxx::tree::optional< totality_type > totality_optional;
    typedef ::xsd::cxx::tree::traits< totality_type, char > totality_traits;

    const totality_optional&
    totality () const;

    totality_optional&
    totality ();

    void
    totality (const totality_type& x);

    void
    totality (const totality_optional& x);

    void
    totality (::std::unique_ptr< totality_type > p);

    // AgentStructure_structures_AgentListing
    //
    typedef ::XMLSchema::AgentStructure_structures_AgentListing AgentStructure_structures_AgentListing_type;
    typedef ::xsd::cxx::tree::optional< AgentStructure_structures_AgentListing_type > AgentStructure_structures_AgentListing_optional;
    typedef ::xsd::cxx::tree::traits< AgentStructure_structures_AgentListing_type, char > AgentStructure_structures_AgentListing_traits;

    const AgentStructure_structures_AgentListing_optional&
    AgentStructure_structures_AgentListing () const;

    AgentStructure_structures_AgentListing_optional&
    AgentStructure_structures_AgentListing ();

    void
    AgentStructure_structures_AgentListing (const AgentStructure_structures_AgentListing_type& x);

    void
    AgentStructure_structures_AgentListing (const AgentStructure_structures_AgentListing_optional& x);

    void
    AgentStructure_structures_AgentListing (::std::unique_ptr< AgentStructure_structures_AgentListing_type > p);

    // AgentStructure_has_AgentRelationship
    //
    typedef ::XMLSchema::AgentStructure_has_AgentRelationship AgentStructure_has_AgentRelationship_type;
    typedef ::xsd::cxx::tree::sequence< AgentStructure_has_AgentRelationship_type > AgentStructure_has_AgentRelationship_sequence;
    typedef AgentStructure_has_AgentRelationship_sequence::iterator AgentStructure_has_AgentRelationship_iterator;
    typedef AgentStructure_has_AgentRelationship_sequence::const_iterator AgentStructure_has_AgentRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< AgentStructure_has_AgentRelationship_type, char > AgentStructure_has_AgentRelationship_traits;

    const AgentStructure_has_AgentRelationship_sequence&
    AgentStructure_has_AgentRelationship () const;

    AgentStructure_has_AgentRelationship_sequence&
    AgentStructure_has_AgentRelationship ();

    void
    AgentStructure_has_AgentRelationship (const AgentStructure_has_AgentRelationship_sequence& s);

    // Constructors.
    //
    AgentStructure ();

    AgentStructure (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    AgentStructure (const AgentStructure& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual AgentStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AgentStructure&
    operator= (const AgentStructure& x);

    virtual 
    ~AgentStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    effectiveDates_optional effectiveDates_;
    identifier_optional identifier_;
    name_sequence name_;
    privacy_optional privacy_;
    purpose_optional purpose_;
    semantics_optional semantics_;
    specification_optional specification_;
    topology_optional topology_;
    totality_optional totality_;
    AgentStructure_structures_AgentListing_optional AgentStructure_structures_AgentListing_;
    AgentStructure_has_AgentRelationship_sequence AgentStructure_has_AgentRelationship_;
  };

  class ControlLogic: public ::xml_schema::type
  {
    public:
    // description
    //
    typedef ::xml_schema::string description_type;
    typedef ::xsd::cxx::tree::optional< description_type > description_optional;
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    const description_optional&
    description () const;

    description_optional&
    description ();

    void
    description (const description_type& x);

    void
    description (const description_optional& x);

    void
    description (::std::unique_ptr< description_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // workflow
    //
    typedef ::XMLSchema::ControlledVocabularyEntry workflow_type;
    typedef ::xsd::cxx::tree::optional< workflow_type > workflow_optional;
    typedef ::xsd::cxx::tree::traits< workflow_type, char > workflow_traits;

    const workflow_optional&
    workflow () const;

    workflow_optional&
    workflow ();

    void
    workflow (const workflow_type& x);

    void
    workflow (const workflow_optional& x);

    void
    workflow (::std::unique_ptr< workflow_type > p);

    // ControlLogic_informs_ProcessingAgent
    //
    typedef ::XMLSchema::ControlLogic_informs_ProcessingAgent ControlLogic_informs_ProcessingAgent_type;
    typedef ::xsd::cxx::tree::sequence< ControlLogic_informs_ProcessingAgent_type > ControlLogic_informs_ProcessingAgent_sequence;
    typedef ControlLogic_informs_ProcessingAgent_sequence::iterator ControlLogic_informs_ProcessingAgent_iterator;
    typedef ControlLogic_informs_ProcessingAgent_sequence::const_iterator ControlLogic_informs_ProcessingAgent_const_iterator;
    typedef ::xsd::cxx::tree::traits< ControlLogic_informs_ProcessingAgent_type, char > ControlLogic_informs_ProcessingAgent_traits;

    const ControlLogic_informs_ProcessingAgent_sequence&
    ControlLogic_informs_ProcessingAgent () const;

    ControlLogic_informs_ProcessingAgent_sequence&
    ControlLogic_informs_ProcessingAgent ();

    void
    ControlLogic_informs_ProcessingAgent (const ControlLogic_informs_ProcessingAgent_sequence& s);

    // ControlLogic_invokes_Activity
    //
    typedef ::XMLSchema::ControlLogic_invokes_Activity ControlLogic_invokes_Activity_type;
    typedef ::xsd::cxx::tree::sequence< ControlLogic_invokes_Activity_type > ControlLogic_invokes_Activity_sequence;
    typedef ControlLogic_invokes_Activity_sequence::iterator ControlLogic_invokes_Activity_iterator;
    typedef ControlLogic_invokes_Activity_sequence::const_iterator ControlLogic_invokes_Activity_const_iterator;
    typedef ::xsd::cxx::tree::traits< ControlLogic_invokes_Activity_type, char > ControlLogic_invokes_Activity_traits;

    const ControlLogic_invokes_Activity_sequence&
    ControlLogic_invokes_Activity () const;

    ControlLogic_invokes_Activity_sequence&
    ControlLogic_invokes_Activity ();

    void
    ControlLogic_invokes_Activity (const ControlLogic_invokes_Activity_sequence& s);

    // ControlLogic_hasSubControlLogic_ControlLogic
    //
    typedef ::XMLSchema::ControlLogic_hasSubControlLogic_ControlLogic ControlLogic_hasSubControlLogic_ControlLogic_type;
    typedef ::xsd::cxx::tree::sequence< ControlLogic_hasSubControlLogic_ControlLogic_type > ControlLogic_hasSubControlLogic_ControlLogic_sequence;
    typedef ControlLogic_hasSubControlLogic_ControlLogic_sequence::iterator ControlLogic_hasSubControlLogic_ControlLogic_iterator;
    typedef ControlLogic_hasSubControlLogic_ControlLogic_sequence::const_iterator ControlLogic_hasSubControlLogic_ControlLogic_const_iterator;
    typedef ::xsd::cxx::tree::traits< ControlLogic_hasSubControlLogic_ControlLogic_type, char > ControlLogic_hasSubControlLogic_ControlLogic_traits;

    const ControlLogic_hasSubControlLogic_ControlLogic_sequence&
    ControlLogic_hasSubControlLogic_ControlLogic () const;

    ControlLogic_hasSubControlLogic_ControlLogic_sequence&
    ControlLogic_hasSubControlLogic_ControlLogic ();

    void
    ControlLogic_hasSubControlLogic_ControlLogic (const ControlLogic_hasSubControlLogic_ControlLogic_sequence& s);

    // ControlLogic_has_InformationFlowDefinition
    //
    typedef ::XMLSchema::ControlLogic_has_InformationFlowDefinition ControlLogic_has_InformationFlowDefinition_type;
    typedef ::xsd::cxx::tree::sequence< ControlLogic_has_InformationFlowDefinition_type > ControlLogic_has_InformationFlowDefinition_sequence;
    typedef ControlLogic_has_InformationFlowDefinition_sequence::iterator ControlLogic_has_InformationFlowDefinition_iterator;
    typedef ControlLogic_has_InformationFlowDefinition_sequence::const_iterator ControlLogic_has_InformationFlowDefinition_const_iterator;
    typedef ::xsd::cxx::tree::traits< ControlLogic_has_InformationFlowDefinition_type, char > ControlLogic_has_InformationFlowDefinition_traits;

    const ControlLogic_has_InformationFlowDefinition_sequence&
    ControlLogic_has_InformationFlowDefinition () const;

    ControlLogic_has_InformationFlowDefinition_sequence&
    ControlLogic_has_InformationFlowDefinition ();

    void
    ControlLogic_has_InformationFlowDefinition (const ControlLogic_has_InformationFlowDefinition_sequence& s);

    // Constructors.
    //
    ControlLogic ();

    ControlLogic (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    ControlLogic (const ControlLogic& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual ControlLogic*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ControlLogic&
    operator= (const ControlLogic& x);

    virtual 
    ~ControlLogic ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    description_optional description_;
    identifier_optional identifier_;
    workflow_optional workflow_;
    ControlLogic_informs_ProcessingAgent_sequence ControlLogic_informs_ProcessingAgent_;
    ControlLogic_invokes_Activity_sequence ControlLogic_invokes_Activity_;
    ControlLogic_hasSubControlLogic_ControlLogic_sequence ControlLogic_hasSubControlLogic_ControlLogic_;
    ControlLogic_has_InformationFlowDefinition_sequence ControlLogic_has_InformationFlowDefinition_;
  };

  class NonDeterministicDeclarative: public ::XMLSchema::ControlLogic
  {
    public:
    // Constructors.
    //
    NonDeterministicDeclarative ();

    NonDeterministicDeclarative (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    NonDeterministicDeclarative (const NonDeterministicDeclarative& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual NonDeterministicDeclarative*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    NonDeterministicDeclarative&
    operator= (const NonDeterministicDeclarative&) = default;
#endif

    virtual 
    ~NonDeterministicDeclarative ();
  };

  class TemporalConstraints: public ::XMLSchema::NonDeterministicDeclarative
  {
    public:
    // Constructors.
    //
    TemporalConstraints ();

    TemporalConstraints (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    TemporalConstraints (const TemporalConstraints& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual TemporalConstraints*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    TemporalConstraints&
    operator= (const TemporalConstraints&) = default;
#endif

    virtual 
    ~TemporalConstraints ();
  };

  class AllenIntervalAlgebra: public ::XMLSchema::TemporalConstraints
  {
    public:
    // temporalIntervalRelation
    //
    typedef ::XMLSchema::TemporalRelation temporalIntervalRelation_type;
    typedef ::xsd::cxx::tree::traits< temporalIntervalRelation_type, char > temporalIntervalRelation_traits;

    const temporalIntervalRelation_type&
    temporalIntervalRelation () const;

    temporalIntervalRelation_type&
    temporalIntervalRelation ();

    void
    temporalIntervalRelation (const temporalIntervalRelation_type& x);

    void
    temporalIntervalRelation (::std::unique_ptr< temporalIntervalRelation_type > p);

    // Constructors.
    //
    AllenIntervalAlgebra (const temporalIntervalRelation_type&);

    AllenIntervalAlgebra (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    AllenIntervalAlgebra (const AllenIntervalAlgebra& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual AllenIntervalAlgebra*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AllenIntervalAlgebra&
    operator= (const AllenIntervalAlgebra& x);

    virtual 
    ~AllenIntervalAlgebra ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< temporalIntervalRelation_type > temporalIntervalRelation_;
  };

  class DataStructureComponent: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // semantic
    //
    typedef ::XMLSchema::PairedControlledVocabularyEntry semantic_type;
    typedef ::xsd::cxx::tree::sequence< semantic_type > semantic_sequence;
    typedef semantic_sequence::iterator semantic_iterator;
    typedef semantic_sequence::const_iterator semantic_const_iterator;
    typedef ::xsd::cxx::tree::traits< semantic_type, char > semantic_traits;

    const semantic_sequence&
    semantic () const;

    semantic_sequence&
    semantic ();

    void
    semantic (const semantic_sequence& s);

    // specialization
    //
    typedef ::XMLSchema::SpecializationRole specialization_type;
    typedef ::xsd::cxx::tree::optional< specialization_type > specialization_optional;
    typedef ::xsd::cxx::tree::traits< specialization_type, char > specialization_traits;

    const specialization_optional&
    specialization () const;

    specialization_optional&
    specialization ();

    void
    specialization (const specialization_type& x);

    void
    specialization (const specialization_optional& x);

    void
    specialization (::std::unique_ptr< specialization_type > p);

    // DataStructureComponent_isDefinedBy_RepresentedVariable
    //
    typedef ::XMLSchema::DataStructureComponent_isDefinedBy_RepresentedVariable DataStructureComponent_isDefinedBy_RepresentedVariable_type;
    typedef ::xsd::cxx::tree::optional< DataStructureComponent_isDefinedBy_RepresentedVariable_type > DataStructureComponent_isDefinedBy_RepresentedVariable_optional;
    typedef ::xsd::cxx::tree::traits< DataStructureComponent_isDefinedBy_RepresentedVariable_type, char > DataStructureComponent_isDefinedBy_RepresentedVariable_traits;

    const DataStructureComponent_isDefinedBy_RepresentedVariable_optional&
    DataStructureComponent_isDefinedBy_RepresentedVariable () const;

    DataStructureComponent_isDefinedBy_RepresentedVariable_optional&
    DataStructureComponent_isDefinedBy_RepresentedVariable ();

    void
    DataStructureComponent_isDefinedBy_RepresentedVariable (const DataStructureComponent_isDefinedBy_RepresentedVariable_type& x);

    void
    DataStructureComponent_isDefinedBy_RepresentedVariable (const DataStructureComponent_isDefinedBy_RepresentedVariable_optional& x);

    void
    DataStructureComponent_isDefinedBy_RepresentedVariable (::std::unique_ptr< DataStructureComponent_isDefinedBy_RepresentedVariable_type > p);

    // Constructors.
    //
    DataStructureComponent ();

    DataStructureComponent (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    DataStructureComponent (const DataStructureComponent& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual DataStructureComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DataStructureComponent&
    operator= (const DataStructureComponent& x);

    virtual 
    ~DataStructureComponent ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    semantic_sequence semantic_;
    specialization_optional specialization_;
    DataStructureComponent_isDefinedBy_RepresentedVariable_optional DataStructureComponent_isDefinedBy_RepresentedVariable_;
  };

  class AttributeComponent: public ::XMLSchema::DataStructureComponent
  {
    public:
    // AttributeComponent_qualifies_DataStructureComponent
    //
    typedef ::XMLSchema::AttributeComponent_qualifies_DataStructureComponent AttributeComponent_qualifies_DataStructureComponent_type;
    typedef ::xsd::cxx::tree::sequence< AttributeComponent_qualifies_DataStructureComponent_type > AttributeComponent_qualifies_DataStructureComponent_sequence;
    typedef AttributeComponent_qualifies_DataStructureComponent_sequence::iterator AttributeComponent_qualifies_DataStructureComponent_iterator;
    typedef AttributeComponent_qualifies_DataStructureComponent_sequence::const_iterator AttributeComponent_qualifies_DataStructureComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< AttributeComponent_qualifies_DataStructureComponent_type, char > AttributeComponent_qualifies_DataStructureComponent_traits;

    const AttributeComponent_qualifies_DataStructureComponent_sequence&
    AttributeComponent_qualifies_DataStructureComponent () const;

    AttributeComponent_qualifies_DataStructureComponent_sequence&
    AttributeComponent_qualifies_DataStructureComponent ();

    void
    AttributeComponent_qualifies_DataStructureComponent (const AttributeComponent_qualifies_DataStructureComponent_sequence& s);

    // Constructors.
    //
    AttributeComponent ();

    AttributeComponent (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    AttributeComponent (const AttributeComponent& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual AttributeComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AttributeComponent&
    operator= (const AttributeComponent& x);

    virtual 
    ~AttributeComponent ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    AttributeComponent_qualifies_DataStructureComponent_sequence AttributeComponent_qualifies_DataStructureComponent_;
  };

  class AuthorizationSource: public ::xml_schema::type
  {
    public:
    // authorizationDate
    //
    typedef ::XMLSchema::CombinedDate authorizationDate_type;
    typedef ::xsd::cxx::tree::optional< authorizationDate_type > authorizationDate_optional;
    typedef ::xsd::cxx::tree::traits< authorizationDate_type, char > authorizationDate_traits;

    const authorizationDate_optional&
    authorizationDate () const;

    authorizationDate_optional&
    authorizationDate ();

    void
    authorizationDate (const authorizationDate_type& x);

    void
    authorizationDate (const authorizationDate_optional& x);

    void
    authorizationDate (::std::unique_ptr< authorizationDate_type > p);

    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // legalMandate
    //
    typedef ::XMLSchema::InternationalString legalMandate_type;
    typedef ::xsd::cxx::tree::optional< legalMandate_type > legalMandate_optional;
    typedef ::xsd::cxx::tree::traits< legalMandate_type, char > legalMandate_traits;

    const legalMandate_optional&
    legalMandate () const;

    legalMandate_optional&
    legalMandate ();

    void
    legalMandate (const legalMandate_type& x);

    void
    legalMandate (const legalMandate_optional& x);

    void
    legalMandate (::std::unique_ptr< legalMandate_type > p);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // statementOfAuthorization
    //
    typedef ::XMLSchema::InternationalString statementOfAuthorization_type;
    typedef ::xsd::cxx::tree::optional< statementOfAuthorization_type > statementOfAuthorization_optional;
    typedef ::xsd::cxx::tree::traits< statementOfAuthorization_type, char > statementOfAuthorization_traits;

    const statementOfAuthorization_optional&
    statementOfAuthorization () const;

    statementOfAuthorization_optional&
    statementOfAuthorization ();

    void
    statementOfAuthorization (const statementOfAuthorization_type& x);

    void
    statementOfAuthorization (const statementOfAuthorization_optional& x);

    void
    statementOfAuthorization (::std::unique_ptr< statementOfAuthorization_type > p);

    // AuthorizationSource_has_Agent
    //
    typedef ::XMLSchema::AuthorizationSource_has_Agent AuthorizationSource_has_Agent_type;
    typedef ::xsd::cxx::tree::sequence< AuthorizationSource_has_Agent_type > AuthorizationSource_has_Agent_sequence;
    typedef AuthorizationSource_has_Agent_sequence::iterator AuthorizationSource_has_Agent_iterator;
    typedef AuthorizationSource_has_Agent_sequence::const_iterator AuthorizationSource_has_Agent_const_iterator;
    typedef ::xsd::cxx::tree::traits< AuthorizationSource_has_Agent_type, char > AuthorizationSource_has_Agent_traits;

    const AuthorizationSource_has_Agent_sequence&
    AuthorizationSource_has_Agent () const;

    AuthorizationSource_has_Agent_sequence&
    AuthorizationSource_has_Agent ();

    void
    AuthorizationSource_has_Agent (const AuthorizationSource_has_Agent_sequence& s);

    // Constructors.
    //
    AuthorizationSource ();

    AuthorizationSource (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    AuthorizationSource (const AuthorizationSource& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual AuthorizationSource*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AuthorizationSource&
    operator= (const AuthorizationSource& x);

    virtual 
    ~AuthorizationSource ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    authorizationDate_optional authorizationDate_;
    catalogDetails_optional catalogDetails_;
    identifier_optional identifier_;
    legalMandate_optional legalMandate_;
    purpose_optional purpose_;
    statementOfAuthorization_optional statementOfAuthorization_;
    AuthorizationSource_has_Agent_sequence AuthorizationSource_has_Agent_;
  };

  class Concept: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // definition
    //
    typedef ::XMLSchema::InternationalString definition_type;
    typedef ::xsd::cxx::tree::optional< definition_type > definition_optional;
    typedef ::xsd::cxx::tree::traits< definition_type, char > definition_traits;

    const definition_optional&
    definition () const;

    definition_optional&
    definition ();

    void
    definition (const definition_type& x);

    void
    definition (const definition_optional& x);

    void
    definition (::std::unique_ptr< definition_type > p);

    // displayLabel
    //
    typedef ::XMLSchema::LabelForDisplay displayLabel_type;
    typedef ::xsd::cxx::tree::sequence< displayLabel_type > displayLabel_sequence;
    typedef displayLabel_sequence::iterator displayLabel_iterator;
    typedef displayLabel_sequence::const_iterator displayLabel_const_iterator;
    typedef ::xsd::cxx::tree::traits< displayLabel_type, char > displayLabel_traits;

    const displayLabel_sequence&
    displayLabel () const;

    displayLabel_sequence&
    displayLabel ();

    void
    displayLabel (const displayLabel_sequence& s);

    // externalDefinition
    //
    typedef ::XMLSchema::externalDefinition externalDefinition_type;
    typedef ::xsd::cxx::tree::optional< externalDefinition_type > externalDefinition_optional;
    typedef ::xsd::cxx::tree::traits< externalDefinition_type, char > externalDefinition_traits;

    const externalDefinition_optional&
    externalDefinition () const;

    externalDefinition_optional&
    externalDefinition ();

    void
    externalDefinition (const externalDefinition_type& x);

    void
    externalDefinition (const externalDefinition_optional& x);

    void
    externalDefinition (::std::unique_ptr< externalDefinition_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // Concept_uses_Concept
    //
    typedef ::XMLSchema::Concept_uses_Concept Concept_uses_Concept_type;
    typedef ::xsd::cxx::tree::sequence< Concept_uses_Concept_type > Concept_uses_Concept_sequence;
    typedef Concept_uses_Concept_sequence::iterator Concept_uses_Concept_iterator;
    typedef Concept_uses_Concept_sequence::const_iterator Concept_uses_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< Concept_uses_Concept_type, char > Concept_uses_Concept_traits;

    const Concept_uses_Concept_sequence&
    Concept_uses_Concept () const;

    Concept_uses_Concept_sequence&
    Concept_uses_Concept ();

    void
    Concept_uses_Concept (const Concept_uses_Concept_sequence& s);

    // Constructors.
    //
    Concept ();

    Concept (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Concept (const Concept& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Concept&
    operator= (const Concept& x);

    virtual 
    ~Concept ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    definition_optional definition_;
    displayLabel_sequence displayLabel_;
    externalDefinition_optional externalDefinition_;
    identifier_optional identifier_;
    name_sequence name_;
    Concept_uses_Concept_sequence Concept_uses_Concept_;
  };

  class Category: public ::XMLSchema::Concept
  {
    public:
    // descriptiveText
    //
    typedef ::XMLSchema::InternationalString descriptiveText_type;
    typedef ::xsd::cxx::tree::optional< descriptiveText_type > descriptiveText_optional;
    typedef ::xsd::cxx::tree::traits< descriptiveText_type, char > descriptiveText_traits;

    const descriptiveText_optional&
    descriptiveText () const;

    descriptiveText_optional&
    descriptiveText ();

    void
    descriptiveText (const descriptiveText_type& x);

    void
    descriptiveText (const descriptiveText_optional& x);

    void
    descriptiveText (::std::unique_ptr< descriptiveText_type > p);

    // Constructors.
    //
    Category ();

    Category (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Category (const Category& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual Category*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Category&
    operator= (const Category& x);

    virtual 
    ~Category ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    descriptiveText_optional descriptiveText_;
  };

  class CategoryPosition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // value
    //
    typedef ::xml_schema::integer value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    // CategoryPosition_indexes_Category
    //
    typedef ::XMLSchema::CategoryPosition_indexes_Category CategoryPosition_indexes_Category_type;
    typedef ::xsd::cxx::tree::traits< CategoryPosition_indexes_Category_type, char > CategoryPosition_indexes_Category_traits;

    const CategoryPosition_indexes_Category_type&
    CategoryPosition_indexes_Category () const;

    CategoryPosition_indexes_Category_type&
    CategoryPosition_indexes_Category ();

    void
    CategoryPosition_indexes_Category (const CategoryPosition_indexes_Category_type& x);

    void
    CategoryPosition_indexes_Category (::std::unique_ptr< CategoryPosition_indexes_Category_type > p);

    // Constructors.
    //
    CategoryPosition (const value_type&,
                      const CategoryPosition_indexes_Category_type&);

    CategoryPosition (const value_type&,
                      ::std::unique_ptr< CategoryPosition_indexes_Category_type >);

    CategoryPosition (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    CategoryPosition (const CategoryPosition& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual CategoryPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CategoryPosition&
    operator= (const CategoryPosition& x);

    virtual 
    ~CategoryPosition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< value_type > value_;
    ::xsd::cxx::tree::one< CategoryPosition_indexes_Category_type > CategoryPosition_indexes_Category_;
  };

  class CategoryRelationStructure: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // specification
    //
    typedef ::XMLSchema::StructureSpecification specification_type;
    typedef ::xsd::cxx::tree::optional< specification_type > specification_optional;
    typedef ::xsd::cxx::tree::traits< specification_type, char > specification_traits;

    const specification_optional&
    specification () const;

    specification_optional&
    specification ();

    void
    specification (const specification_type& x);

    void
    specification (const specification_optional& x);

    void
    specification (::std::unique_ptr< specification_type > p);

    // topology
    //
    typedef ::XMLSchema::ControlledVocabularyEntry topology_type;
    typedef ::xsd::cxx::tree::optional< topology_type > topology_optional;
    typedef ::xsd::cxx::tree::traits< topology_type, char > topology_traits;

    const topology_optional&
    topology () const;

    topology_optional&
    topology ();

    void
    topology (const topology_type& x);

    void
    topology (const topology_optional& x);

    void
    topology (::std::unique_ptr< topology_type > p);

    // totality
    //
    typedef ::XMLSchema::StructureExtent totality_type;
    typedef ::xsd::cxx::tree::optional< totality_type > totality_optional;
    typedef ::xsd::cxx::tree::traits< totality_type, char > totality_traits;

    const totality_optional&
    totality () const;

    totality_optional&
    totality ();

    void
    totality (const totality_type& x);

    void
    totality (const totality_optional& x);

    void
    totality (::std::unique_ptr< totality_type > p);

    // CategoryRelationStructure_structures_CategorySet
    //
    typedef ::XMLSchema::CategoryRelationStructure_structures_CategorySet CategoryRelationStructure_structures_CategorySet_type;
    typedef ::xsd::cxx::tree::optional< CategoryRelationStructure_structures_CategorySet_type > CategoryRelationStructure_structures_CategorySet_optional;
    typedef ::xsd::cxx::tree::traits< CategoryRelationStructure_structures_CategorySet_type, char > CategoryRelationStructure_structures_CategorySet_traits;

    const CategoryRelationStructure_structures_CategorySet_optional&
    CategoryRelationStructure_structures_CategorySet () const;

    CategoryRelationStructure_structures_CategorySet_optional&
    CategoryRelationStructure_structures_CategorySet ();

    void
    CategoryRelationStructure_structures_CategorySet (const CategoryRelationStructure_structures_CategorySet_type& x);

    void
    CategoryRelationStructure_structures_CategorySet (const CategoryRelationStructure_structures_CategorySet_optional& x);

    void
    CategoryRelationStructure_structures_CategorySet (::std::unique_ptr< CategoryRelationStructure_structures_CategorySet_type > p);

    // CategoryRelationStructure_has_CategoryRelationship
    //
    typedef ::XMLSchema::CategoryRelationStructure_has_CategoryRelationship CategoryRelationStructure_has_CategoryRelationship_type;
    typedef ::xsd::cxx::tree::sequence< CategoryRelationStructure_has_CategoryRelationship_type > CategoryRelationStructure_has_CategoryRelationship_sequence;
    typedef CategoryRelationStructure_has_CategoryRelationship_sequence::iterator CategoryRelationStructure_has_CategoryRelationship_iterator;
    typedef CategoryRelationStructure_has_CategoryRelationship_sequence::const_iterator CategoryRelationStructure_has_CategoryRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategoryRelationStructure_has_CategoryRelationship_type, char > CategoryRelationStructure_has_CategoryRelationship_traits;

    const CategoryRelationStructure_has_CategoryRelationship_sequence&
    CategoryRelationStructure_has_CategoryRelationship () const;

    CategoryRelationStructure_has_CategoryRelationship_sequence&
    CategoryRelationStructure_has_CategoryRelationship ();

    void
    CategoryRelationStructure_has_CategoryRelationship (const CategoryRelationStructure_has_CategoryRelationship_sequence& s);

    // Constructors.
    //
    CategoryRelationStructure ();

    CategoryRelationStructure (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    CategoryRelationStructure (const CategoryRelationStructure& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual CategoryRelationStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CategoryRelationStructure&
    operator= (const CategoryRelationStructure& x);

    virtual 
    ~CategoryRelationStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    semantics_optional semantics_;
    specification_optional specification_;
    topology_optional topology_;
    totality_optional totality_;
    CategoryRelationStructure_structures_CategorySet_optional CategoryRelationStructure_structures_CategorySet_;
    CategoryRelationStructure_has_CategoryRelationship_sequence CategoryRelationStructure_has_CategoryRelationship_;
  };

  class CategoryRelationship: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // CategoryRelationship_hasSource_Category
    //
    typedef ::XMLSchema::CategoryRelationship_hasSource_Category CategoryRelationship_hasSource_Category_type;
    typedef ::xsd::cxx::tree::sequence< CategoryRelationship_hasSource_Category_type > CategoryRelationship_hasSource_Category_sequence;
    typedef CategoryRelationship_hasSource_Category_sequence::iterator CategoryRelationship_hasSource_Category_iterator;
    typedef CategoryRelationship_hasSource_Category_sequence::const_iterator CategoryRelationship_hasSource_Category_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategoryRelationship_hasSource_Category_type, char > CategoryRelationship_hasSource_Category_traits;

    const CategoryRelationship_hasSource_Category_sequence&
    CategoryRelationship_hasSource_Category () const;

    CategoryRelationship_hasSource_Category_sequence&
    CategoryRelationship_hasSource_Category ();

    void
    CategoryRelationship_hasSource_Category (const CategoryRelationship_hasSource_Category_sequence& s);

    // CategoryRelationship_hasTarget_Category
    //
    typedef ::XMLSchema::CategoryRelationship_hasTarget_Category CategoryRelationship_hasTarget_Category_type;
    typedef ::xsd::cxx::tree::sequence< CategoryRelationship_hasTarget_Category_type > CategoryRelationship_hasTarget_Category_sequence;
    typedef CategoryRelationship_hasTarget_Category_sequence::iterator CategoryRelationship_hasTarget_Category_iterator;
    typedef CategoryRelationship_hasTarget_Category_sequence::const_iterator CategoryRelationship_hasTarget_Category_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategoryRelationship_hasTarget_Category_type, char > CategoryRelationship_hasTarget_Category_traits;

    const CategoryRelationship_hasTarget_Category_sequence&
    CategoryRelationship_hasTarget_Category () const;

    CategoryRelationship_hasTarget_Category_sequence&
    CategoryRelationship_hasTarget_Category ();

    void
    CategoryRelationship_hasTarget_Category (const CategoryRelationship_hasTarget_Category_sequence& s);

    // Constructors.
    //
    CategoryRelationship ();

    CategoryRelationship (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    CategoryRelationship (const CategoryRelationship& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual CategoryRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CategoryRelationship&
    operator= (const CategoryRelationship& x);

    virtual 
    ~CategoryRelationship ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    semantics_optional semantics_;
    CategoryRelationship_hasSource_Category_sequence CategoryRelationship_hasSource_Category_;
    CategoryRelationship_hasTarget_Category_sequence CategoryRelationship_hasTarget_Category_;
  };

  class ConceptSystem: public ::xml_schema::type
  {
    public:
    // allowsDuplicates
    //
    typedef ::xml_schema::boolean allowsDuplicates_type;
    typedef ::xsd::cxx::tree::traits< allowsDuplicates_type, char > allowsDuplicates_traits;

    const allowsDuplicates_type&
    allowsDuplicates () const;

    allowsDuplicates_type&
    allowsDuplicates ();

    void
    allowsDuplicates (const allowsDuplicates_type& x);

    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // externalDefinition
    //
    typedef ::XMLSchema::externalDefinition externalDefinition_type;
    typedef ::xsd::cxx::tree::optional< externalDefinition_type > externalDefinition_optional;
    typedef ::xsd::cxx::tree::traits< externalDefinition_type, char > externalDefinition_traits;

    const externalDefinition_optional&
    externalDefinition () const;

    externalDefinition_optional&
    externalDefinition ();

    void
    externalDefinition (const externalDefinition_type& x);

    void
    externalDefinition (const externalDefinition_optional& x);

    void
    externalDefinition (::std::unique_ptr< externalDefinition_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // ConceptSystem_isDefinedBy_Concept
    //
    typedef ::XMLSchema::ConceptSystem_isDefinedBy_Concept ConceptSystem_isDefinedBy_Concept_type;
    typedef ::xsd::cxx::tree::sequence< ConceptSystem_isDefinedBy_Concept_type > ConceptSystem_isDefinedBy_Concept_sequence;
    typedef ConceptSystem_isDefinedBy_Concept_sequence::iterator ConceptSystem_isDefinedBy_Concept_iterator;
    typedef ConceptSystem_isDefinedBy_Concept_sequence::const_iterator ConceptSystem_isDefinedBy_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptSystem_isDefinedBy_Concept_type, char > ConceptSystem_isDefinedBy_Concept_traits;

    const ConceptSystem_isDefinedBy_Concept_sequence&
    ConceptSystem_isDefinedBy_Concept () const;

    ConceptSystem_isDefinedBy_Concept_sequence&
    ConceptSystem_isDefinedBy_Concept ();

    void
    ConceptSystem_isDefinedBy_Concept (const ConceptSystem_isDefinedBy_Concept_sequence& s);

    // ConceptSystem_has_Concept
    //
    typedef ::XMLSchema::ConceptSystem_has_Concept ConceptSystem_has_Concept_type;
    typedef ::xsd::cxx::tree::sequence< ConceptSystem_has_Concept_type > ConceptSystem_has_Concept_sequence;
    typedef ConceptSystem_has_Concept_sequence::iterator ConceptSystem_has_Concept_iterator;
    typedef ConceptSystem_has_Concept_sequence::const_iterator ConceptSystem_has_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptSystem_has_Concept_type, char > ConceptSystem_has_Concept_traits;

    const ConceptSystem_has_Concept_sequence&
    ConceptSystem_has_Concept () const;

    ConceptSystem_has_Concept_sequence&
    ConceptSystem_has_Concept ();

    void
    ConceptSystem_has_Concept (const ConceptSystem_has_Concept_sequence& s);

    // Constructors.
    //
    ConceptSystem (const allowsDuplicates_type&);

    ConceptSystem (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    ConceptSystem (const ConceptSystem& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual ConceptSystem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConceptSystem&
    operator= (const ConceptSystem& x);

    virtual 
    ~ConceptSystem ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< allowsDuplicates_type > allowsDuplicates_;
    catalogDetails_optional catalogDetails_;
    externalDefinition_optional externalDefinition_;
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    ConceptSystem_isDefinedBy_Concept_sequence ConceptSystem_isDefinedBy_Concept_;
    ConceptSystem_has_Concept_sequence ConceptSystem_has_Concept_;
  };

  class CategorySet: public ::XMLSchema::ConceptSystem
  {
    public:
    // CategorySet_has_Category
    //
    typedef ::XMLSchema::CategorySet_has_Category CategorySet_has_Category_type;
    typedef ::xsd::cxx::tree::sequence< CategorySet_has_Category_type > CategorySet_has_Category_sequence;
    typedef CategorySet_has_Category_sequence::iterator CategorySet_has_Category_iterator;
    typedef CategorySet_has_Category_sequence::const_iterator CategorySet_has_Category_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategorySet_has_Category_type, char > CategorySet_has_Category_traits;

    const CategorySet_has_Category_sequence&
    CategorySet_has_Category () const;

    CategorySet_has_Category_sequence&
    CategorySet_has_Category ();

    void
    CategorySet_has_Category (const CategorySet_has_Category_sequence& s);

    // CategorySet_has_CategoryPosition
    //
    typedef ::XMLSchema::CategorySet_has_CategoryPosition CategorySet_has_CategoryPosition_type;
    typedef ::xsd::cxx::tree::sequence< CategorySet_has_CategoryPosition_type > CategorySet_has_CategoryPosition_sequence;
    typedef CategorySet_has_CategoryPosition_sequence::iterator CategorySet_has_CategoryPosition_iterator;
    typedef CategorySet_has_CategoryPosition_sequence::const_iterator CategorySet_has_CategoryPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategorySet_has_CategoryPosition_type, char > CategorySet_has_CategoryPosition_traits;

    const CategorySet_has_CategoryPosition_sequence&
    CategorySet_has_CategoryPosition () const;

    CategorySet_has_CategoryPosition_sequence&
    CategorySet_has_CategoryPosition ();

    void
    CategorySet_has_CategoryPosition (const CategorySet_has_CategoryPosition_sequence& s);

    // Constructors.
    //
    CategorySet (const allowsDuplicates_type&);

    CategorySet (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    CategorySet (const CategorySet& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual CategorySet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CategorySet&
    operator= (const CategorySet& x);

    virtual 
    ~CategorySet ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    CategorySet_has_Category_sequence CategorySet_has_Category_;
    CategorySet_has_CategoryPosition_sequence CategorySet_has_CategoryPosition_;
  };

  class CategoryStatistic: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // statistic
    //
    typedef ::XMLSchema::Statistic statistic_type;
    typedef ::xsd::cxx::tree::sequence< statistic_type > statistic_sequence;
    typedef statistic_sequence::iterator statistic_iterator;
    typedef statistic_sequence::const_iterator statistic_const_iterator;
    typedef ::xsd::cxx::tree::traits< statistic_type, char > statistic_traits;

    const statistic_sequence&
    statistic () const;

    statistic_sequence&
    statistic ();

    void
    statistic (const statistic_sequence& s);

    // typeOfCategoryStatistic
    //
    typedef ::XMLSchema::ControlledVocabularyEntry typeOfCategoryStatistic_type;
    typedef ::xsd::cxx::tree::optional< typeOfCategoryStatistic_type > typeOfCategoryStatistic_optional;
    typedef ::xsd::cxx::tree::traits< typeOfCategoryStatistic_type, char > typeOfCategoryStatistic_traits;

    const typeOfCategoryStatistic_optional&
    typeOfCategoryStatistic () const;

    typeOfCategoryStatistic_optional&
    typeOfCategoryStatistic ();

    void
    typeOfCategoryStatistic (const typeOfCategoryStatistic_type& x);

    void
    typeOfCategoryStatistic (const typeOfCategoryStatistic_optional& x);

    void
    typeOfCategoryStatistic (::std::unique_ptr< typeOfCategoryStatistic_type > p);

    // CategoryStatistic_appliesTo_InstanceVariable
    //
    typedef ::XMLSchema::CategoryStatistic_appliesTo_InstanceVariable CategoryStatistic_appliesTo_InstanceVariable_type;
    typedef ::xsd::cxx::tree::sequence< CategoryStatistic_appliesTo_InstanceVariable_type > CategoryStatistic_appliesTo_InstanceVariable_sequence;
    typedef CategoryStatistic_appliesTo_InstanceVariable_sequence::iterator CategoryStatistic_appliesTo_InstanceVariable_iterator;
    typedef CategoryStatistic_appliesTo_InstanceVariable_sequence::const_iterator CategoryStatistic_appliesTo_InstanceVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< CategoryStatistic_appliesTo_InstanceVariable_type, char > CategoryStatistic_appliesTo_InstanceVariable_traits;

    const CategoryStatistic_appliesTo_InstanceVariable_sequence&
    CategoryStatistic_appliesTo_InstanceVariable () const;

    CategoryStatistic_appliesTo_InstanceVariable_sequence&
    CategoryStatistic_appliesTo_InstanceVariable ();

    void
    CategoryStatistic_appliesTo_InstanceVariable (const CategoryStatistic_appliesTo_InstanceVariable_sequence& s);

    // CategoryStatistic_for_Category
    //
    typedef ::XMLSchema::CategoryStatistic_for_Category CategoryStatistic_for_Category_type;
    typedef ::xsd::cxx::tree::optional< CategoryStatistic_for_Category_type > CategoryStatistic_for_Category_optional;
    typedef ::xsd::cxx::tree::traits< CategoryStatistic_for_Category_type, char > CategoryStatistic_for_Category_traits;

    const CategoryStatistic_for_Category_optional&
    CategoryStatistic_for_Category () const;

    CategoryStatistic_for_Category_optional&
    CategoryStatistic_for_Category ();

    void
    CategoryStatistic_for_Category (const CategoryStatistic_for_Category_type& x);

    void
    CategoryStatistic_for_Category (const CategoryStatistic_for_Category_optional& x);

    void
    CategoryStatistic_for_Category (::std::unique_ptr< CategoryStatistic_for_Category_type > p);

    // Constructors.
    //
    CategoryStatistic ();

    CategoryStatistic (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    CategoryStatistic (const CategoryStatistic& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual CategoryStatistic*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CategoryStatistic&
    operator= (const CategoryStatistic& x);

    virtual 
    ~CategoryStatistic ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    statistic_sequence statistic_;
    typeOfCategoryStatistic_optional typeOfCategoryStatistic_;
    CategoryStatistic_appliesTo_InstanceVariable_sequence CategoryStatistic_appliesTo_InstanceVariable_;
    CategoryStatistic_for_Category_optional CategoryStatistic_for_Category_;
  };

  class ClassificationFamily: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // ClassificationFamily_uses_ClassificationIndex
    //
    typedef ::XMLSchema::ClassificationFamily_uses_ClassificationIndex ClassificationFamily_uses_ClassificationIndex_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationFamily_uses_ClassificationIndex_type > ClassificationFamily_uses_ClassificationIndex_sequence;
    typedef ClassificationFamily_uses_ClassificationIndex_sequence::iterator ClassificationFamily_uses_ClassificationIndex_iterator;
    typedef ClassificationFamily_uses_ClassificationIndex_sequence::const_iterator ClassificationFamily_uses_ClassificationIndex_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationFamily_uses_ClassificationIndex_type, char > ClassificationFamily_uses_ClassificationIndex_traits;

    const ClassificationFamily_uses_ClassificationIndex_sequence&
    ClassificationFamily_uses_ClassificationIndex () const;

    ClassificationFamily_uses_ClassificationIndex_sequence&
    ClassificationFamily_uses_ClassificationIndex ();

    void
    ClassificationFamily_uses_ClassificationIndex (const ClassificationFamily_uses_ClassificationIndex_sequence& s);

    // ClassificationFamily_isDefinedBy_Concept
    //
    typedef ::XMLSchema::ClassificationFamily_isDefinedBy_Concept ClassificationFamily_isDefinedBy_Concept_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationFamily_isDefinedBy_Concept_type > ClassificationFamily_isDefinedBy_Concept_sequence;
    typedef ClassificationFamily_isDefinedBy_Concept_sequence::iterator ClassificationFamily_isDefinedBy_Concept_iterator;
    typedef ClassificationFamily_isDefinedBy_Concept_sequence::const_iterator ClassificationFamily_isDefinedBy_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationFamily_isDefinedBy_Concept_type, char > ClassificationFamily_isDefinedBy_Concept_traits;

    const ClassificationFamily_isDefinedBy_Concept_sequence&
    ClassificationFamily_isDefinedBy_Concept () const;

    ClassificationFamily_isDefinedBy_Concept_sequence&
    ClassificationFamily_isDefinedBy_Concept ();

    void
    ClassificationFamily_isDefinedBy_Concept (const ClassificationFamily_isDefinedBy_Concept_sequence& s);

    // ClassificationFamily_groups_ClassificationSeries
    //
    typedef ::XMLSchema::ClassificationFamily_groups_ClassificationSeries ClassificationFamily_groups_ClassificationSeries_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationFamily_groups_ClassificationSeries_type > ClassificationFamily_groups_ClassificationSeries_sequence;
    typedef ClassificationFamily_groups_ClassificationSeries_sequence::iterator ClassificationFamily_groups_ClassificationSeries_iterator;
    typedef ClassificationFamily_groups_ClassificationSeries_sequence::const_iterator ClassificationFamily_groups_ClassificationSeries_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationFamily_groups_ClassificationSeries_type, char > ClassificationFamily_groups_ClassificationSeries_traits;

    const ClassificationFamily_groups_ClassificationSeries_sequence&
    ClassificationFamily_groups_ClassificationSeries () const;

    ClassificationFamily_groups_ClassificationSeries_sequence&
    ClassificationFamily_groups_ClassificationSeries ();

    void
    ClassificationFamily_groups_ClassificationSeries (const ClassificationFamily_groups_ClassificationSeries_sequence& s);

    // Constructors.
    //
    ClassificationFamily ();

    ClassificationFamily (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    ClassificationFamily (const ClassificationFamily& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual ClassificationFamily*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ClassificationFamily&
    operator= (const ClassificationFamily& x);

    virtual 
    ~ClassificationFamily ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    ClassificationFamily_uses_ClassificationIndex_sequence ClassificationFamily_uses_ClassificationIndex_;
    ClassificationFamily_isDefinedBy_Concept_sequence ClassificationFamily_isDefinedBy_Concept_;
    ClassificationFamily_groups_ClassificationSeries_sequence ClassificationFamily_groups_ClassificationSeries_;
  };

  class ClassificationIndex: public ::xml_schema::type
  {
    public:
    // allowsDuplicates
    //
    typedef ::xml_schema::boolean allowsDuplicates_type;
    typedef ::xsd::cxx::tree::traits< allowsDuplicates_type, char > allowsDuplicates_traits;

    const allowsDuplicates_type&
    allowsDuplicates () const;

    allowsDuplicates_type&
    allowsDuplicates ();

    void
    allowsDuplicates (const allowsDuplicates_type& x);

    // availableLanguage
    //
    typedef ::xml_schema::language availableLanguage_type;
    typedef ::xsd::cxx::tree::sequence< availableLanguage_type > availableLanguage_sequence;
    typedef availableLanguage_sequence::iterator availableLanguage_iterator;
    typedef availableLanguage_sequence::const_iterator availableLanguage_const_iterator;
    typedef ::xsd::cxx::tree::traits< availableLanguage_type, char > availableLanguage_traits;

    const availableLanguage_sequence&
    availableLanguage () const;

    availableLanguage_sequence&
    availableLanguage ();

    void
    availableLanguage (const availableLanguage_sequence& s);

    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // codingInstruction
    //
    typedef ::XMLSchema::CommandCode codingInstruction_type;
    typedef ::xsd::cxx::tree::sequence< codingInstruction_type > codingInstruction_sequence;
    typedef codingInstruction_sequence::iterator codingInstruction_iterator;
    typedef codingInstruction_sequence::const_iterator codingInstruction_const_iterator;
    typedef ::xsd::cxx::tree::traits< codingInstruction_type, char > codingInstruction_traits;

    const codingInstruction_sequence&
    codingInstruction () const;

    codingInstruction_sequence&
    codingInstruction ();

    void
    codingInstruction (const codingInstruction_sequence& s);

    // corrections
    //
    typedef ::XMLSchema::InternationalString corrections_type;
    typedef ::xsd::cxx::tree::sequence< corrections_type > corrections_sequence;
    typedef corrections_sequence::iterator corrections_iterator;
    typedef corrections_sequence::const_iterator corrections_const_iterator;
    typedef ::xsd::cxx::tree::traits< corrections_type, char > corrections_traits;

    const corrections_sequence&
    corrections () const;

    corrections_sequence&
    corrections ();

    void
    corrections (const corrections_sequence& s);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // releaseDate
    //
    typedef ::XMLSchema::CombinedDate releaseDate_type;
    typedef ::xsd::cxx::tree::optional< releaseDate_type > releaseDate_optional;
    typedef ::xsd::cxx::tree::traits< releaseDate_type, char > releaseDate_traits;

    const releaseDate_optional&
    releaseDate () const;

    releaseDate_optional&
    releaseDate ();

    void
    releaseDate (const releaseDate_type& x);

    void
    releaseDate (const releaseDate_optional& x);

    void
    releaseDate (::std::unique_ptr< releaseDate_type > p);

    // ClassificationIndex_isMaintainedBy_Agent
    //
    typedef ::XMLSchema::ClassificationIndex_isMaintainedBy_Agent ClassificationIndex_isMaintainedBy_Agent_type;
    typedef ::xsd::cxx::tree::optional< ClassificationIndex_isMaintainedBy_Agent_type > ClassificationIndex_isMaintainedBy_Agent_optional;
    typedef ::xsd::cxx::tree::traits< ClassificationIndex_isMaintainedBy_Agent_type, char > ClassificationIndex_isMaintainedBy_Agent_traits;

    const ClassificationIndex_isMaintainedBy_Agent_optional&
    ClassificationIndex_isMaintainedBy_Agent () const;

    ClassificationIndex_isMaintainedBy_Agent_optional&
    ClassificationIndex_isMaintainedBy_Agent ();

    void
    ClassificationIndex_isMaintainedBy_Agent (const ClassificationIndex_isMaintainedBy_Agent_type& x);

    void
    ClassificationIndex_isMaintainedBy_Agent (const ClassificationIndex_isMaintainedBy_Agent_optional& x);

    void
    ClassificationIndex_isMaintainedBy_Agent (::std::unique_ptr< ClassificationIndex_isMaintainedBy_Agent_type > p);

    // ClassificationIndex_hasContact_Agent
    //
    typedef ::XMLSchema::ClassificationIndex_hasContact_Agent ClassificationIndex_hasContact_Agent_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationIndex_hasContact_Agent_type > ClassificationIndex_hasContact_Agent_sequence;
    typedef ClassificationIndex_hasContact_Agent_sequence::iterator ClassificationIndex_hasContact_Agent_iterator;
    typedef ClassificationIndex_hasContact_Agent_sequence::const_iterator ClassificationIndex_hasContact_Agent_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationIndex_hasContact_Agent_type, char > ClassificationIndex_hasContact_Agent_traits;

    const ClassificationIndex_hasContact_Agent_sequence&
    ClassificationIndex_hasContact_Agent () const;

    ClassificationIndex_hasContact_Agent_sequence&
    ClassificationIndex_hasContact_Agent ();

    void
    ClassificationIndex_hasContact_Agent (const ClassificationIndex_hasContact_Agent_sequence& s);

    // ClassificationIndex_isDefinedBy_Concept
    //
    typedef ::XMLSchema::ClassificationIndex_isDefinedBy_Concept ClassificationIndex_isDefinedBy_Concept_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationIndex_isDefinedBy_Concept_type > ClassificationIndex_isDefinedBy_Concept_sequence;
    typedef ClassificationIndex_isDefinedBy_Concept_sequence::iterator ClassificationIndex_isDefinedBy_Concept_iterator;
    typedef ClassificationIndex_isDefinedBy_Concept_sequence::const_iterator ClassificationIndex_isDefinedBy_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationIndex_isDefinedBy_Concept_type, char > ClassificationIndex_isDefinedBy_Concept_traits;

    const ClassificationIndex_isDefinedBy_Concept_sequence&
    ClassificationIndex_isDefinedBy_Concept () const;

    ClassificationIndex_isDefinedBy_Concept_sequence&
    ClassificationIndex_isDefinedBy_Concept ();

    void
    ClassificationIndex_isDefinedBy_Concept (const ClassificationIndex_isDefinedBy_Concept_sequence& s);

    // ClassificationIndex_has_ClassificationIndexEntryPosition
    //
    typedef ::XMLSchema::ClassificationIndex_has_ClassificationIndexEntryPosition ClassificationIndex_has_ClassificationIndexEntryPosition_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationIndex_has_ClassificationIndexEntryPosition_type > ClassificationIndex_has_ClassificationIndexEntryPosition_sequence;
    typedef ClassificationIndex_has_ClassificationIndexEntryPosition_sequence::iterator ClassificationIndex_has_ClassificationIndexEntryPosition_iterator;
    typedef ClassificationIndex_has_ClassificationIndexEntryPosition_sequence::const_iterator ClassificationIndex_has_ClassificationIndexEntryPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationIndex_has_ClassificationIndexEntryPosition_type, char > ClassificationIndex_has_ClassificationIndexEntryPosition_traits;

    const ClassificationIndex_has_ClassificationIndexEntryPosition_sequence&
    ClassificationIndex_has_ClassificationIndexEntryPosition () const;

    ClassificationIndex_has_ClassificationIndexEntryPosition_sequence&
    ClassificationIndex_has_ClassificationIndexEntryPosition ();

    void
    ClassificationIndex_has_ClassificationIndexEntryPosition (const ClassificationIndex_has_ClassificationIndexEntryPosition_sequence& s);

    // ClassificationIndex_has_ClassificationIndexEntry
    //
    typedef ::XMLSchema::ClassificationIndex_has_ClassificationIndexEntry ClassificationIndex_has_ClassificationIndexEntry_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationIndex_has_ClassificationIndexEntry_type > ClassificationIndex_has_ClassificationIndexEntry_sequence;
    typedef ClassificationIndex_has_ClassificationIndexEntry_sequence::iterator ClassificationIndex_has_ClassificationIndexEntry_iterator;
    typedef ClassificationIndex_has_ClassificationIndexEntry_sequence::const_iterator ClassificationIndex_has_ClassificationIndexEntry_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationIndex_has_ClassificationIndexEntry_type, char > ClassificationIndex_has_ClassificationIndexEntry_traits;

    const ClassificationIndex_has_ClassificationIndexEntry_sequence&
    ClassificationIndex_has_ClassificationIndexEntry () const;

    ClassificationIndex_has_ClassificationIndexEntry_sequence&
    ClassificationIndex_has_ClassificationIndexEntry ();

    void
    ClassificationIndex_has_ClassificationIndexEntry (const ClassificationIndex_has_ClassificationIndexEntry_sequence& s);

    // Constructors.
    //
    ClassificationIndex (const allowsDuplicates_type&);

    ClassificationIndex (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ClassificationIndex (const ClassificationIndex& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual ClassificationIndex*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ClassificationIndex&
    operator= (const ClassificationIndex& x);

    virtual 
    ~ClassificationIndex ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< allowsDuplicates_type > allowsDuplicates_;
    availableLanguage_sequence availableLanguage_;
    catalogDetails_optional catalogDetails_;
    codingInstruction_sequence codingInstruction_;
    corrections_sequence corrections_;
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    releaseDate_optional releaseDate_;
    ClassificationIndex_isMaintainedBy_Agent_optional ClassificationIndex_isMaintainedBy_Agent_;
    ClassificationIndex_hasContact_Agent_sequence ClassificationIndex_hasContact_Agent_;
    ClassificationIndex_isDefinedBy_Concept_sequence ClassificationIndex_isDefinedBy_Concept_;
    ClassificationIndex_has_ClassificationIndexEntryPosition_sequence ClassificationIndex_has_ClassificationIndexEntryPosition_;
    ClassificationIndex_has_ClassificationIndexEntry_sequence ClassificationIndex_has_ClassificationIndexEntry_;
  };

  class ClassificationIndexEntry: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // codingInstruction
    //
    typedef ::XMLSchema::CommandCode codingInstruction_type;
    typedef ::xsd::cxx::tree::optional< codingInstruction_type > codingInstruction_optional;
    typedef ::xsd::cxx::tree::traits< codingInstruction_type, char > codingInstruction_traits;

    const codingInstruction_optional&
    codingInstruction () const;

    codingInstruction_optional&
    codingInstruction ();

    void
    codingInstruction (const codingInstruction_type& x);

    void
    codingInstruction (const codingInstruction_optional& x);

    void
    codingInstruction (::std::unique_ptr< codingInstruction_type > p);

    // entry
    //
    typedef ::XMLSchema::InternationalString entry_type;
    typedef ::xsd::cxx::tree::optional< entry_type > entry_optional;
    typedef ::xsd::cxx::tree::traits< entry_type, char > entry_traits;

    const entry_optional&
    entry () const;

    entry_optional&
    entry ();

    void
    entry (const entry_type& x);

    void
    entry (const entry_optional& x);

    void
    entry (::std::unique_ptr< entry_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // validDates
    //
    typedef ::XMLSchema::DateRange validDates_type;
    typedef ::xsd::cxx::tree::optional< validDates_type > validDates_optional;
    typedef ::xsd::cxx::tree::traits< validDates_type, char > validDates_traits;

    const validDates_optional&
    validDates () const;

    validDates_optional&
    validDates ();

    void
    validDates (const validDates_type& x);

    void
    validDates (const validDates_optional& x);

    void
    validDates (::std::unique_ptr< validDates_type > p);

    // Constructors.
    //
    ClassificationIndexEntry ();

    ClassificationIndexEntry (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ClassificationIndexEntry (const ClassificationIndexEntry& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual ClassificationIndexEntry*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ClassificationIndexEntry&
    operator= (const ClassificationIndexEntry& x);

    virtual 
    ~ClassificationIndexEntry ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    codingInstruction_optional codingInstruction_;
    entry_optional entry_;
    identifier_optional identifier_;
    validDates_optional validDates_;
  };

  class ClassificationIndexEntryPosition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // value
    //
    typedef ::xml_schema::integer value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    // ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry
    //
    typedef ::XMLSchema::ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type;
    typedef ::xsd::cxx::tree::traits< ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type, char > ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_traits;

    const ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type&
    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry () const;

    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type&
    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry ();

    void
    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry (const ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type& x);

    void
    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry (::std::unique_ptr< ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type > p);

    // Constructors.
    //
    ClassificationIndexEntryPosition (const value_type&,
                                      const ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type&);

    ClassificationIndexEntryPosition (const value_type&,
                                      ::std::unique_ptr< ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type >);

    ClassificationIndexEntryPosition (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ClassificationIndexEntryPosition (const ClassificationIndexEntryPosition& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual ClassificationIndexEntryPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ClassificationIndexEntryPosition&
    operator= (const ClassificationIndexEntryPosition& x);

    virtual 
    ~ClassificationIndexEntryPosition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< value_type > value_;
    ::xsd::cxx::tree::one< ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_type > ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_;
  };

  class ClassificationItem: public ::xml_schema::type
  {
    public:
    // changeFromPreviousVersion
    //
    typedef ::XMLSchema::InternationalString changeFromPreviousVersion_type;
    typedef ::xsd::cxx::tree::optional< changeFromPreviousVersion_type > changeFromPreviousVersion_optional;
    typedef ::xsd::cxx::tree::traits< changeFromPreviousVersion_type, char > changeFromPreviousVersion_traits;

    const changeFromPreviousVersion_optional&
    changeFromPreviousVersion () const;

    changeFromPreviousVersion_optional&
    changeFromPreviousVersion ();

    void
    changeFromPreviousVersion (const changeFromPreviousVersion_type& x);

    void
    changeFromPreviousVersion (const changeFromPreviousVersion_optional& x);

    void
    changeFromPreviousVersion (::std::unique_ptr< changeFromPreviousVersion_type > p);

    // changeLog
    //
    typedef ::XMLSchema::InternationalString changeLog_type;
    typedef ::xsd::cxx::tree::optional< changeLog_type > changeLog_optional;
    typedef ::xsd::cxx::tree::traits< changeLog_type, char > changeLog_traits;

    const changeLog_optional&
    changeLog () const;

    changeLog_optional&
    changeLog ();

    void
    changeLog (const changeLog_type& x);

    void
    changeLog (const changeLog_optional& x);

    void
    changeLog (::std::unique_ptr< changeLog_type > p);

    // explanatoryNotes
    //
    typedef ::XMLSchema::InternationalString explanatoryNotes_type;
    typedef ::xsd::cxx::tree::sequence< explanatoryNotes_type > explanatoryNotes_sequence;
    typedef explanatoryNotes_sequence::iterator explanatoryNotes_iterator;
    typedef explanatoryNotes_sequence::const_iterator explanatoryNotes_const_iterator;
    typedef ::xsd::cxx::tree::traits< explanatoryNotes_type, char > explanatoryNotes_traits;

    const explanatoryNotes_sequence&
    explanatoryNotes () const;

    explanatoryNotes_sequence&
    explanatoryNotes ();

    void
    explanatoryNotes (const explanatoryNotes_sequence& s);

    // futureNotes
    //
    typedef ::XMLSchema::InternationalString futureNotes_type;
    typedef ::xsd::cxx::tree::sequence< futureNotes_type > futureNotes_sequence;
    typedef futureNotes_sequence::iterator futureNotes_iterator;
    typedef futureNotes_sequence::const_iterator futureNotes_const_iterator;
    typedef ::xsd::cxx::tree::traits< futureNotes_type, char > futureNotes_traits;

    const futureNotes_sequence&
    futureNotes () const;

    futureNotes_sequence&
    futureNotes ();

    void
    futureNotes (const futureNotes_sequence& s);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // isGenerated
    //
    typedef ::xml_schema::boolean isGenerated_type;
    typedef ::xsd::cxx::tree::optional< isGenerated_type > isGenerated_optional;
    typedef ::xsd::cxx::tree::traits< isGenerated_type, char > isGenerated_traits;

    const isGenerated_optional&
    isGenerated () const;

    isGenerated_optional&
    isGenerated ();

    void
    isGenerated (const isGenerated_type& x);

    void
    isGenerated (const isGenerated_optional& x);

    // isValid
    //
    typedef ::xml_schema::boolean isValid_type;
    typedef ::xsd::cxx::tree::optional< isValid_type > isValid_optional;
    typedef ::xsd::cxx::tree::traits< isValid_type, char > isValid_traits;

    const isValid_optional&
    isValid () const;

    isValid_optional&
    isValid ();

    void
    isValid (const isValid_type& x);

    void
    isValid (const isValid_optional& x);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // validDates
    //
    typedef ::XMLSchema::DateRange validDates_type;
    typedef ::xsd::cxx::tree::optional< validDates_type > validDates_optional;
    typedef ::xsd::cxx::tree::traits< validDates_type, char > validDates_traits;

    const validDates_optional&
    validDates () const;

    validDates_optional&
    validDates ();

    void
    validDates (const validDates_type& x);

    void
    validDates (const validDates_optional& x);

    void
    validDates (::std::unique_ptr< validDates_type > p);

    // ClassificationItem_excludes_ClassificationItem
    //
    typedef ::XMLSchema::ClassificationItem_excludes_ClassificationItem ClassificationItem_excludes_ClassificationItem_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationItem_excludes_ClassificationItem_type > ClassificationItem_excludes_ClassificationItem_sequence;
    typedef ClassificationItem_excludes_ClassificationItem_sequence::iterator ClassificationItem_excludes_ClassificationItem_iterator;
    typedef ClassificationItem_excludes_ClassificationItem_sequence::const_iterator ClassificationItem_excludes_ClassificationItem_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationItem_excludes_ClassificationItem_type, char > ClassificationItem_excludes_ClassificationItem_traits;

    const ClassificationItem_excludes_ClassificationItem_sequence&
    ClassificationItem_excludes_ClassificationItem () const;

    ClassificationItem_excludes_ClassificationItem_sequence&
    ClassificationItem_excludes_ClassificationItem ();

    void
    ClassificationItem_excludes_ClassificationItem (const ClassificationItem_excludes_ClassificationItem_sequence& s);

    // ClassificationItem_denotes_Category
    //
    typedef ::XMLSchema::ClassificationItem_denotes_Category ClassificationItem_denotes_Category_type;
    typedef ::xsd::cxx::tree::traits< ClassificationItem_denotes_Category_type, char > ClassificationItem_denotes_Category_traits;

    const ClassificationItem_denotes_Category_type&
    ClassificationItem_denotes_Category () const;

    ClassificationItem_denotes_Category_type&
    ClassificationItem_denotes_Category ();

    void
    ClassificationItem_denotes_Category (const ClassificationItem_denotes_Category_type& x);

    void
    ClassificationItem_denotes_Category (::std::unique_ptr< ClassificationItem_denotes_Category_type > p);

    // ClassificationItem_uses_Notation
    //
    typedef ::XMLSchema::ClassificationItem_uses_Notation ClassificationItem_uses_Notation_type;
    typedef ::xsd::cxx::tree::traits< ClassificationItem_uses_Notation_type, char > ClassificationItem_uses_Notation_traits;

    const ClassificationItem_uses_Notation_type&
    ClassificationItem_uses_Notation () const;

    ClassificationItem_uses_Notation_type&
    ClassificationItem_uses_Notation ();

    void
    ClassificationItem_uses_Notation (const ClassificationItem_uses_Notation_type& x);

    void
    ClassificationItem_uses_Notation (::std::unique_ptr< ClassificationItem_uses_Notation_type > p);

    // ClassificationItem_hasRulingBy_AuthorizationSource
    //
    typedef ::XMLSchema::ClassificationItem_hasRulingBy_AuthorizationSource ClassificationItem_hasRulingBy_AuthorizationSource_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationItem_hasRulingBy_AuthorizationSource_type > ClassificationItem_hasRulingBy_AuthorizationSource_sequence;
    typedef ClassificationItem_hasRulingBy_AuthorizationSource_sequence::iterator ClassificationItem_hasRulingBy_AuthorizationSource_iterator;
    typedef ClassificationItem_hasRulingBy_AuthorizationSource_sequence::const_iterator ClassificationItem_hasRulingBy_AuthorizationSource_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationItem_hasRulingBy_AuthorizationSource_type, char > ClassificationItem_hasRulingBy_AuthorizationSource_traits;

    const ClassificationItem_hasRulingBy_AuthorizationSource_sequence&
    ClassificationItem_hasRulingBy_AuthorizationSource () const;

    ClassificationItem_hasRulingBy_AuthorizationSource_sequence&
    ClassificationItem_hasRulingBy_AuthorizationSource ();

    void
    ClassificationItem_hasRulingBy_AuthorizationSource (const ClassificationItem_hasRulingBy_AuthorizationSource_sequence& s);

    // Constructors.
    //
    ClassificationItem (const ClassificationItem_denotes_Category_type&,
                        const ClassificationItem_uses_Notation_type&);

    ClassificationItem (::std::unique_ptr< ClassificationItem_denotes_Category_type >,
                        ::std::unique_ptr< ClassificationItem_uses_Notation_type >);

    ClassificationItem (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    ClassificationItem (const ClassificationItem& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual ClassificationItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ClassificationItem&
    operator= (const ClassificationItem& x);

    virtual 
    ~ClassificationItem ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    changeFromPreviousVersion_optional changeFromPreviousVersion_;
    changeLog_optional changeLog_;
    explanatoryNotes_sequence explanatoryNotes_;
    futureNotes_sequence futureNotes_;
    identifier_optional identifier_;
    isGenerated_optional isGenerated_;
    isValid_optional isValid_;
    name_sequence name_;
    validDates_optional validDates_;
    ClassificationItem_excludes_ClassificationItem_sequence ClassificationItem_excludes_ClassificationItem_;
    ::xsd::cxx::tree::one< ClassificationItem_denotes_Category_type > ClassificationItem_denotes_Category_;
    ::xsd::cxx::tree::one< ClassificationItem_uses_Notation_type > ClassificationItem_uses_Notation_;
    ClassificationItem_hasRulingBy_AuthorizationSource_sequence ClassificationItem_hasRulingBy_AuthorizationSource_;
  };

  class ClassificationItemPosition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // value
    //
    typedef ::xml_schema::integer value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    // ClassificationItemPosition_indexes_ClassificationItem
    //
    typedef ::XMLSchema::ClassificationItemPosition_indexes_ClassificationItem ClassificationItemPosition_indexes_ClassificationItem_type;
    typedef ::xsd::cxx::tree::optional< ClassificationItemPosition_indexes_ClassificationItem_type > ClassificationItemPosition_indexes_ClassificationItem_optional;
    typedef ::xsd::cxx::tree::traits< ClassificationItemPosition_indexes_ClassificationItem_type, char > ClassificationItemPosition_indexes_ClassificationItem_traits;

    const ClassificationItemPosition_indexes_ClassificationItem_optional&
    ClassificationItemPosition_indexes_ClassificationItem () const;

    ClassificationItemPosition_indexes_ClassificationItem_optional&
    ClassificationItemPosition_indexes_ClassificationItem ();

    void
    ClassificationItemPosition_indexes_ClassificationItem (const ClassificationItemPosition_indexes_ClassificationItem_type& x);

    void
    ClassificationItemPosition_indexes_ClassificationItem (const ClassificationItemPosition_indexes_ClassificationItem_optional& x);

    void
    ClassificationItemPosition_indexes_ClassificationItem (::std::unique_ptr< ClassificationItemPosition_indexes_ClassificationItem_type > p);

    // Constructors.
    //
    ClassificationItemPosition (const value_type&);

    ClassificationItemPosition (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    ClassificationItemPosition (const ClassificationItemPosition& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual ClassificationItemPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ClassificationItemPosition&
    operator= (const ClassificationItemPosition& x);

    virtual 
    ~ClassificationItemPosition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< value_type > value_;
    ClassificationItemPosition_indexes_ClassificationItem_optional ClassificationItemPosition_indexes_ClassificationItem_;
  };

  class ClassificationItemRelationship: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // ClassificationItemRelationship_hasSource_ClassificationItem
    //
    typedef ::XMLSchema::ClassificationItemRelationship_hasSource_ClassificationItem ClassificationItemRelationship_hasSource_ClassificationItem_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationItemRelationship_hasSource_ClassificationItem_type > ClassificationItemRelationship_hasSource_ClassificationItem_sequence;
    typedef ClassificationItemRelationship_hasSource_ClassificationItem_sequence::iterator ClassificationItemRelationship_hasSource_ClassificationItem_iterator;
    typedef ClassificationItemRelationship_hasSource_ClassificationItem_sequence::const_iterator ClassificationItemRelationship_hasSource_ClassificationItem_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationItemRelationship_hasSource_ClassificationItem_type, char > ClassificationItemRelationship_hasSource_ClassificationItem_traits;

    const ClassificationItemRelationship_hasSource_ClassificationItem_sequence&
    ClassificationItemRelationship_hasSource_ClassificationItem () const;

    ClassificationItemRelationship_hasSource_ClassificationItem_sequence&
    ClassificationItemRelationship_hasSource_ClassificationItem ();

    void
    ClassificationItemRelationship_hasSource_ClassificationItem (const ClassificationItemRelationship_hasSource_ClassificationItem_sequence& s);

    // ClassificationItemRelationship_hasTarget_ClassificationItem
    //
    typedef ::XMLSchema::ClassificationItemRelationship_hasTarget_ClassificationItem ClassificationItemRelationship_hasTarget_ClassificationItem_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationItemRelationship_hasTarget_ClassificationItem_type > ClassificationItemRelationship_hasTarget_ClassificationItem_sequence;
    typedef ClassificationItemRelationship_hasTarget_ClassificationItem_sequence::iterator ClassificationItemRelationship_hasTarget_ClassificationItem_iterator;
    typedef ClassificationItemRelationship_hasTarget_ClassificationItem_sequence::const_iterator ClassificationItemRelationship_hasTarget_ClassificationItem_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationItemRelationship_hasTarget_ClassificationItem_type, char > ClassificationItemRelationship_hasTarget_ClassificationItem_traits;

    const ClassificationItemRelationship_hasTarget_ClassificationItem_sequence&
    ClassificationItemRelationship_hasTarget_ClassificationItem () const;

    ClassificationItemRelationship_hasTarget_ClassificationItem_sequence&
    ClassificationItemRelationship_hasTarget_ClassificationItem ();

    void
    ClassificationItemRelationship_hasTarget_ClassificationItem (const ClassificationItemRelationship_hasTarget_ClassificationItem_sequence& s);

    // Constructors.
    //
    ClassificationItemRelationship ();

    ClassificationItemRelationship (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ClassificationItemRelationship (const ClassificationItemRelationship& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual ClassificationItemRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ClassificationItemRelationship&
    operator= (const ClassificationItemRelationship& x);

    virtual 
    ~ClassificationItemRelationship ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    semantics_optional semantics_;
    ClassificationItemRelationship_hasSource_ClassificationItem_sequence ClassificationItemRelationship_hasSource_ClassificationItem_;
    ClassificationItemRelationship_hasTarget_ClassificationItem_sequence ClassificationItemRelationship_hasTarget_ClassificationItem_;
  };

  class ClassificationItemStructure: public ::xml_schema::type
  {
    public:
    // displayLabel
    //
    typedef ::XMLSchema::LabelForDisplay displayLabel_type;
    typedef ::xsd::cxx::tree::sequence< displayLabel_type > displayLabel_sequence;
    typedef displayLabel_sequence::iterator displayLabel_iterator;
    typedef displayLabel_sequence::const_iterator displayLabel_const_iterator;
    typedef ::xsd::cxx::tree::traits< displayLabel_type, char > displayLabel_traits;

    const displayLabel_sequence&
    displayLabel () const;

    displayLabel_sequence&
    displayLabel ();

    void
    displayLabel (const displayLabel_sequence& s);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // specification
    //
    typedef ::XMLSchema::StructureSpecification specification_type;
    typedef ::xsd::cxx::tree::optional< specification_type > specification_optional;
    typedef ::xsd::cxx::tree::traits< specification_type, char > specification_traits;

    const specification_optional&
    specification () const;

    specification_optional&
    specification ();

    void
    specification (const specification_type& x);

    void
    specification (const specification_optional& x);

    void
    specification (::std::unique_ptr< specification_type > p);

    // topology
    //
    typedef ::XMLSchema::ControlledVocabularyEntry topology_type;
    typedef ::xsd::cxx::tree::optional< topology_type > topology_optional;
    typedef ::xsd::cxx::tree::traits< topology_type, char > topology_traits;

    const topology_optional&
    topology () const;

    topology_optional&
    topology ();

    void
    topology (const topology_type& x);

    void
    topology (const topology_optional& x);

    void
    topology (::std::unique_ptr< topology_type > p);

    // totality
    //
    typedef ::XMLSchema::StructureExtent totality_type;
    typedef ::xsd::cxx::tree::optional< totality_type > totality_optional;
    typedef ::xsd::cxx::tree::traits< totality_type, char > totality_traits;

    const totality_optional&
    totality () const;

    totality_optional&
    totality ();

    void
    totality (const totality_type& x);

    void
    totality (const totality_optional& x);

    void
    totality (::std::unique_ptr< totality_type > p);

    // ClassificationItemStructure_structures_StatisticalClassification
    //
    typedef ::XMLSchema::ClassificationItemStructure_structures_StatisticalClassification ClassificationItemStructure_structures_StatisticalClassification_type;
    typedef ::xsd::cxx::tree::optional< ClassificationItemStructure_structures_StatisticalClassification_type > ClassificationItemStructure_structures_StatisticalClassification_optional;
    typedef ::xsd::cxx::tree::traits< ClassificationItemStructure_structures_StatisticalClassification_type, char > ClassificationItemStructure_structures_StatisticalClassification_traits;

    const ClassificationItemStructure_structures_StatisticalClassification_optional&
    ClassificationItemStructure_structures_StatisticalClassification () const;

    ClassificationItemStructure_structures_StatisticalClassification_optional&
    ClassificationItemStructure_structures_StatisticalClassification ();

    void
    ClassificationItemStructure_structures_StatisticalClassification (const ClassificationItemStructure_structures_StatisticalClassification_type& x);

    void
    ClassificationItemStructure_structures_StatisticalClassification (const ClassificationItemStructure_structures_StatisticalClassification_optional& x);

    void
    ClassificationItemStructure_structures_StatisticalClassification (::std::unique_ptr< ClassificationItemStructure_structures_StatisticalClassification_type > p);

    // ClassificationItemStructure_has_ClassificationItemRelationship
    //
    typedef ::XMLSchema::ClassificationItemStructure_has_ClassificationItemRelationship ClassificationItemStructure_has_ClassificationItemRelationship_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationItemStructure_has_ClassificationItemRelationship_type > ClassificationItemStructure_has_ClassificationItemRelationship_sequence;
    typedef ClassificationItemStructure_has_ClassificationItemRelationship_sequence::iterator ClassificationItemStructure_has_ClassificationItemRelationship_iterator;
    typedef ClassificationItemStructure_has_ClassificationItemRelationship_sequence::const_iterator ClassificationItemStructure_has_ClassificationItemRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationItemStructure_has_ClassificationItemRelationship_type, char > ClassificationItemStructure_has_ClassificationItemRelationship_traits;

    const ClassificationItemStructure_has_ClassificationItemRelationship_sequence&
    ClassificationItemStructure_has_ClassificationItemRelationship () const;

    ClassificationItemStructure_has_ClassificationItemRelationship_sequence&
    ClassificationItemStructure_has_ClassificationItemRelationship ();

    void
    ClassificationItemStructure_has_ClassificationItemRelationship (const ClassificationItemStructure_has_ClassificationItemRelationship_sequence& s);

    // Constructors.
    //
    ClassificationItemStructure ();

    ClassificationItemStructure (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ClassificationItemStructure (const ClassificationItemStructure& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual ClassificationItemStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ClassificationItemStructure&
    operator= (const ClassificationItemStructure& x);

    virtual 
    ~ClassificationItemStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    displayLabel_sequence displayLabel_;
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    semantics_optional semantics_;
    specification_optional specification_;
    topology_optional topology_;
    totality_optional totality_;
    ClassificationItemStructure_structures_StatisticalClassification_optional ClassificationItemStructure_structures_StatisticalClassification_;
    ClassificationItemStructure_has_ClassificationItemRelationship_sequence ClassificationItemStructure_has_ClassificationItemRelationship_;
  };

  class ClassificationPosition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // value
    //
    typedef ::xml_schema::integer value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    // ClassificationPosition_indexes_StatisticalClassification
    //
    typedef ::XMLSchema::ClassificationPosition_indexes_StatisticalClassification ClassificationPosition_indexes_StatisticalClassification_type;
    typedef ::xsd::cxx::tree::optional< ClassificationPosition_indexes_StatisticalClassification_type > ClassificationPosition_indexes_StatisticalClassification_optional;
    typedef ::xsd::cxx::tree::traits< ClassificationPosition_indexes_StatisticalClassification_type, char > ClassificationPosition_indexes_StatisticalClassification_traits;

    const ClassificationPosition_indexes_StatisticalClassification_optional&
    ClassificationPosition_indexes_StatisticalClassification () const;

    ClassificationPosition_indexes_StatisticalClassification_optional&
    ClassificationPosition_indexes_StatisticalClassification ();

    void
    ClassificationPosition_indexes_StatisticalClassification (const ClassificationPosition_indexes_StatisticalClassification_type& x);

    void
    ClassificationPosition_indexes_StatisticalClassification (const ClassificationPosition_indexes_StatisticalClassification_optional& x);

    void
    ClassificationPosition_indexes_StatisticalClassification (::std::unique_ptr< ClassificationPosition_indexes_StatisticalClassification_type > p);

    // Constructors.
    //
    ClassificationPosition (const value_type&);

    ClassificationPosition (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    ClassificationPosition (const ClassificationPosition& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual ClassificationPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ClassificationPosition&
    operator= (const ClassificationPosition& x);

    virtual 
    ~ClassificationPosition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< value_type > value_;
    ClassificationPosition_indexes_StatisticalClassification_optional ClassificationPosition_indexes_StatisticalClassification_;
  };

  class ClassificationSeries: public ::xml_schema::type
  {
    public:
    // allowsDuplicates
    //
    typedef ::xml_schema::boolean allowsDuplicates_type;
    typedef ::xsd::cxx::tree::traits< allowsDuplicates_type, char > allowsDuplicates_traits;

    const allowsDuplicates_type&
    allowsDuplicates () const;

    allowsDuplicates_type&
    allowsDuplicates ();

    void
    allowsDuplicates (const allowsDuplicates_type& x);

    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // context
    //
    typedef ::XMLSchema::ControlledVocabularyEntry context_type;
    typedef ::xsd::cxx::tree::optional< context_type > context_optional;
    typedef ::xsd::cxx::tree::traits< context_type, char > context_traits;

    const context_optional&
    context () const;

    context_optional&
    context ();

    void
    context (const context_type& x);

    void
    context (const context_optional& x);

    void
    context (::std::unique_ptr< context_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // keyword
    //
    typedef ::XMLSchema::ControlledVocabularyEntry keyword_type;
    typedef ::xsd::cxx::tree::sequence< keyword_type > keyword_sequence;
    typedef keyword_sequence::iterator keyword_iterator;
    typedef keyword_sequence::const_iterator keyword_const_iterator;
    typedef ::xsd::cxx::tree::traits< keyword_type, char > keyword_traits;

    const keyword_sequence&
    keyword () const;

    keyword_sequence&
    keyword ();

    void
    keyword (const keyword_sequence& s);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // objectsOrUnitsClassified
    //
    typedef ::XMLSchema::ControlledVocabularyEntry objectsOrUnitsClassified_type;
    typedef ::xsd::cxx::tree::optional< objectsOrUnitsClassified_type > objectsOrUnitsClassified_optional;
    typedef ::xsd::cxx::tree::traits< objectsOrUnitsClassified_type, char > objectsOrUnitsClassified_traits;

    const objectsOrUnitsClassified_optional&
    objectsOrUnitsClassified () const;

    objectsOrUnitsClassified_optional&
    objectsOrUnitsClassified ();

    void
    objectsOrUnitsClassified (const objectsOrUnitsClassified_type& x);

    void
    objectsOrUnitsClassified (const objectsOrUnitsClassified_optional& x);

    void
    objectsOrUnitsClassified (::std::unique_ptr< objectsOrUnitsClassified_type > p);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // subject
    //
    typedef ::XMLSchema::ControlledVocabularyEntry subject_type;
    typedef ::xsd::cxx::tree::sequence< subject_type > subject_sequence;
    typedef subject_sequence::iterator subject_iterator;
    typedef subject_sequence::const_iterator subject_const_iterator;
    typedef ::xsd::cxx::tree::traits< subject_type, char > subject_traits;

    const subject_sequence&
    subject () const;

    subject_sequence&
    subject ();

    void
    subject (const subject_sequence& s);

    // ClassificationSeries_isOwnedBy_Agent
    //
    typedef ::XMLSchema::ClassificationSeries_isOwnedBy_Agent ClassificationSeries_isOwnedBy_Agent_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationSeries_isOwnedBy_Agent_type > ClassificationSeries_isOwnedBy_Agent_sequence;
    typedef ClassificationSeries_isOwnedBy_Agent_sequence::iterator ClassificationSeries_isOwnedBy_Agent_iterator;
    typedef ClassificationSeries_isOwnedBy_Agent_sequence::const_iterator ClassificationSeries_isOwnedBy_Agent_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationSeries_isOwnedBy_Agent_type, char > ClassificationSeries_isOwnedBy_Agent_traits;

    const ClassificationSeries_isOwnedBy_Agent_sequence&
    ClassificationSeries_isOwnedBy_Agent () const;

    ClassificationSeries_isOwnedBy_Agent_sequence&
    ClassificationSeries_isOwnedBy_Agent ();

    void
    ClassificationSeries_isOwnedBy_Agent (const ClassificationSeries_isOwnedBy_Agent_sequence& s);

    // ClassificationSeries_isDefinedBy_Concept
    //
    typedef ::XMLSchema::ClassificationSeries_isDefinedBy_Concept ClassificationSeries_isDefinedBy_Concept_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationSeries_isDefinedBy_Concept_type > ClassificationSeries_isDefinedBy_Concept_sequence;
    typedef ClassificationSeries_isDefinedBy_Concept_sequence::iterator ClassificationSeries_isDefinedBy_Concept_iterator;
    typedef ClassificationSeries_isDefinedBy_Concept_sequence::const_iterator ClassificationSeries_isDefinedBy_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationSeries_isDefinedBy_Concept_type, char > ClassificationSeries_isDefinedBy_Concept_traits;

    const ClassificationSeries_isDefinedBy_Concept_sequence&
    ClassificationSeries_isDefinedBy_Concept () const;

    ClassificationSeries_isDefinedBy_Concept_sequence&
    ClassificationSeries_isDefinedBy_Concept ();

    void
    ClassificationSeries_isDefinedBy_Concept (const ClassificationSeries_isDefinedBy_Concept_sequence& s);

    // ClassificationSeries_has_StatisticalClassification
    //
    typedef ::XMLSchema::ClassificationSeries_has_StatisticalClassification ClassificationSeries_has_StatisticalClassification_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationSeries_has_StatisticalClassification_type > ClassificationSeries_has_StatisticalClassification_sequence;
    typedef ClassificationSeries_has_StatisticalClassification_sequence::iterator ClassificationSeries_has_StatisticalClassification_iterator;
    typedef ClassificationSeries_has_StatisticalClassification_sequence::const_iterator ClassificationSeries_has_StatisticalClassification_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationSeries_has_StatisticalClassification_type, char > ClassificationSeries_has_StatisticalClassification_traits;

    const ClassificationSeries_has_StatisticalClassification_sequence&
    ClassificationSeries_has_StatisticalClassification () const;

    ClassificationSeries_has_StatisticalClassification_sequence&
    ClassificationSeries_has_StatisticalClassification ();

    void
    ClassificationSeries_has_StatisticalClassification (const ClassificationSeries_has_StatisticalClassification_sequence& s);

    // ClassificationSeries_has_ClassificationPosition
    //
    typedef ::XMLSchema::ClassificationSeries_has_ClassificationPosition ClassificationSeries_has_ClassificationPosition_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationSeries_has_ClassificationPosition_type > ClassificationSeries_has_ClassificationPosition_sequence;
    typedef ClassificationSeries_has_ClassificationPosition_sequence::iterator ClassificationSeries_has_ClassificationPosition_iterator;
    typedef ClassificationSeries_has_ClassificationPosition_sequence::const_iterator ClassificationSeries_has_ClassificationPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationSeries_has_ClassificationPosition_type, char > ClassificationSeries_has_ClassificationPosition_traits;

    const ClassificationSeries_has_ClassificationPosition_sequence&
    ClassificationSeries_has_ClassificationPosition () const;

    ClassificationSeries_has_ClassificationPosition_sequence&
    ClassificationSeries_has_ClassificationPosition ();

    void
    ClassificationSeries_has_ClassificationPosition (const ClassificationSeries_has_ClassificationPosition_sequence& s);

    // Constructors.
    //
    ClassificationSeries (const allowsDuplicates_type&);

    ClassificationSeries (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    ClassificationSeries (const ClassificationSeries& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual ClassificationSeries*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ClassificationSeries&
    operator= (const ClassificationSeries& x);

    virtual 
    ~ClassificationSeries ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< allowsDuplicates_type > allowsDuplicates_;
    catalogDetails_optional catalogDetails_;
    context_optional context_;
    identifier_optional identifier_;
    keyword_sequence keyword_;
    name_sequence name_;
    objectsOrUnitsClassified_optional objectsOrUnitsClassified_;
    purpose_optional purpose_;
    subject_sequence subject_;
    ClassificationSeries_isOwnedBy_Agent_sequence ClassificationSeries_isOwnedBy_Agent_;
    ClassificationSeries_isDefinedBy_Concept_sequence ClassificationSeries_isDefinedBy_Concept_;
    ClassificationSeries_has_StatisticalClassification_sequence ClassificationSeries_has_StatisticalClassification_;
    ClassificationSeries_has_ClassificationPosition_sequence ClassificationSeries_has_ClassificationPosition_;
  };

  class ClassificationSeriesStructure: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // specification
    //
    typedef ::XMLSchema::StructureSpecification specification_type;
    typedef ::xsd::cxx::tree::optional< specification_type > specification_optional;
    typedef ::xsd::cxx::tree::traits< specification_type, char > specification_traits;

    const specification_optional&
    specification () const;

    specification_optional&
    specification ();

    void
    specification (const specification_type& x);

    void
    specification (const specification_optional& x);

    void
    specification (::std::unique_ptr< specification_type > p);

    // topology
    //
    typedef ::XMLSchema::ControlledVocabularyEntry topology_type;
    typedef ::xsd::cxx::tree::optional< topology_type > topology_optional;
    typedef ::xsd::cxx::tree::traits< topology_type, char > topology_traits;

    const topology_optional&
    topology () const;

    topology_optional&
    topology ();

    void
    topology (const topology_type& x);

    void
    topology (const topology_optional& x);

    void
    topology (::std::unique_ptr< topology_type > p);

    // totality
    //
    typedef ::XMLSchema::StructureExtent totality_type;
    typedef ::xsd::cxx::tree::optional< totality_type > totality_optional;
    typedef ::xsd::cxx::tree::traits< totality_type, char > totality_traits;

    const totality_optional&
    totality () const;

    totality_optional&
    totality ();

    void
    totality (const totality_type& x);

    void
    totality (const totality_optional& x);

    void
    totality (::std::unique_ptr< totality_type > p);

    // ClassificationSeriesStructure_structures_ClassificationSeries
    //
    typedef ::XMLSchema::ClassificationSeriesStructure_structures_ClassificationSeries ClassificationSeriesStructure_structures_ClassificationSeries_type;
    typedef ::xsd::cxx::tree::optional< ClassificationSeriesStructure_structures_ClassificationSeries_type > ClassificationSeriesStructure_structures_ClassificationSeries_optional;
    typedef ::xsd::cxx::tree::traits< ClassificationSeriesStructure_structures_ClassificationSeries_type, char > ClassificationSeriesStructure_structures_ClassificationSeries_traits;

    const ClassificationSeriesStructure_structures_ClassificationSeries_optional&
    ClassificationSeriesStructure_structures_ClassificationSeries () const;

    ClassificationSeriesStructure_structures_ClassificationSeries_optional&
    ClassificationSeriesStructure_structures_ClassificationSeries ();

    void
    ClassificationSeriesStructure_structures_ClassificationSeries (const ClassificationSeriesStructure_structures_ClassificationSeries_type& x);

    void
    ClassificationSeriesStructure_structures_ClassificationSeries (const ClassificationSeriesStructure_structures_ClassificationSeries_optional& x);

    void
    ClassificationSeriesStructure_structures_ClassificationSeries (::std::unique_ptr< ClassificationSeriesStructure_structures_ClassificationSeries_type > p);

    // ClassificationSeriesStructure_has_StatisticalClassificationRelationship
    //
    typedef ::XMLSchema::ClassificationSeriesStructure_has_StatisticalClassificationRelationship ClassificationSeriesStructure_has_StatisticalClassificationRelationship_type;
    typedef ::xsd::cxx::tree::sequence< ClassificationSeriesStructure_has_StatisticalClassificationRelationship_type > ClassificationSeriesStructure_has_StatisticalClassificationRelationship_sequence;
    typedef ClassificationSeriesStructure_has_StatisticalClassificationRelationship_sequence::iterator ClassificationSeriesStructure_has_StatisticalClassificationRelationship_iterator;
    typedef ClassificationSeriesStructure_has_StatisticalClassificationRelationship_sequence::const_iterator ClassificationSeriesStructure_has_StatisticalClassificationRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< ClassificationSeriesStructure_has_StatisticalClassificationRelationship_type, char > ClassificationSeriesStructure_has_StatisticalClassificationRelationship_traits;

    const ClassificationSeriesStructure_has_StatisticalClassificationRelationship_sequence&
    ClassificationSeriesStructure_has_StatisticalClassificationRelationship () const;

    ClassificationSeriesStructure_has_StatisticalClassificationRelationship_sequence&
    ClassificationSeriesStructure_has_StatisticalClassificationRelationship ();

    void
    ClassificationSeriesStructure_has_StatisticalClassificationRelationship (const ClassificationSeriesStructure_has_StatisticalClassificationRelationship_sequence& s);

    // Constructors.
    //
    ClassificationSeriesStructure ();

    ClassificationSeriesStructure (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    ClassificationSeriesStructure (const ClassificationSeriesStructure& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual ClassificationSeriesStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ClassificationSeriesStructure&
    operator= (const ClassificationSeriesStructure& x);

    virtual 
    ~ClassificationSeriesStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    semantics_optional semantics_;
    specification_optional specification_;
    topology_optional topology_;
    totality_optional totality_;
    ClassificationSeriesStructure_structures_ClassificationSeries_optional ClassificationSeriesStructure_structures_ClassificationSeries_;
    ClassificationSeriesStructure_has_StatisticalClassificationRelationship_sequence ClassificationSeriesStructure_has_StatisticalClassificationRelationship_;
  };

  class Code: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // Code_denotes_Category
    //
    typedef ::XMLSchema::Code_denotes_Category Code_denotes_Category_type;
    typedef ::xsd::cxx::tree::traits< Code_denotes_Category_type, char > Code_denotes_Category_traits;

    const Code_denotes_Category_type&
    Code_denotes_Category () const;

    Code_denotes_Category_type&
    Code_denotes_Category ();

    void
    Code_denotes_Category (const Code_denotes_Category_type& x);

    void
    Code_denotes_Category (::std::unique_ptr< Code_denotes_Category_type > p);

    // Code_uses_Notation
    //
    typedef ::XMLSchema::Code_uses_Notation Code_uses_Notation_type;
    typedef ::xsd::cxx::tree::traits< Code_uses_Notation_type, char > Code_uses_Notation_traits;

    const Code_uses_Notation_type&
    Code_uses_Notation () const;

    Code_uses_Notation_type&
    Code_uses_Notation ();

    void
    Code_uses_Notation (const Code_uses_Notation_type& x);

    void
    Code_uses_Notation (::std::unique_ptr< Code_uses_Notation_type > p);

    // Constructors.
    //
    Code (const Code_denotes_Category_type&,
          const Code_uses_Notation_type&);

    Code (::std::unique_ptr< Code_denotes_Category_type >,
          ::std::unique_ptr< Code_uses_Notation_type >);

    Code (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    Code (const Code& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual Code*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Code&
    operator= (const Code& x);

    virtual 
    ~Code ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< Code_denotes_Category_type > Code_denotes_Category_;
    ::xsd::cxx::tree::one< Code_uses_Notation_type > Code_uses_Notation_;
  };

  class EnumerationDomain: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // EnumerationDomain_uses_LevelStructure
    //
    typedef ::XMLSchema::EnumerationDomain_uses_LevelStructure EnumerationDomain_uses_LevelStructure_type;
    typedef ::xsd::cxx::tree::optional< EnumerationDomain_uses_LevelStructure_type > EnumerationDomain_uses_LevelStructure_optional;
    typedef ::xsd::cxx::tree::traits< EnumerationDomain_uses_LevelStructure_type, char > EnumerationDomain_uses_LevelStructure_traits;

    const EnumerationDomain_uses_LevelStructure_optional&
    EnumerationDomain_uses_LevelStructure () const;

    EnumerationDomain_uses_LevelStructure_optional&
    EnumerationDomain_uses_LevelStructure ();

    void
    EnumerationDomain_uses_LevelStructure (const EnumerationDomain_uses_LevelStructure_type& x);

    void
    EnumerationDomain_uses_LevelStructure (const EnumerationDomain_uses_LevelStructure_optional& x);

    void
    EnumerationDomain_uses_LevelStructure (::std::unique_ptr< EnumerationDomain_uses_LevelStructure_type > p);

    // EnumerationDomain_references_CategorySet
    //
    typedef ::XMLSchema::EnumerationDomain_references_CategorySet EnumerationDomain_references_CategorySet_type;
    typedef ::xsd::cxx::tree::optional< EnumerationDomain_references_CategorySet_type > EnumerationDomain_references_CategorySet_optional;
    typedef ::xsd::cxx::tree::traits< EnumerationDomain_references_CategorySet_type, char > EnumerationDomain_references_CategorySet_traits;

    const EnumerationDomain_references_CategorySet_optional&
    EnumerationDomain_references_CategorySet () const;

    EnumerationDomain_references_CategorySet_optional&
    EnumerationDomain_references_CategorySet ();

    void
    EnumerationDomain_references_CategorySet (const EnumerationDomain_references_CategorySet_type& x);

    void
    EnumerationDomain_references_CategorySet (const EnumerationDomain_references_CategorySet_optional& x);

    void
    EnumerationDomain_references_CategorySet (::std::unique_ptr< EnumerationDomain_references_CategorySet_type > p);

    // EnumerationDomain_isDefinedBy_Concept
    //
    typedef ::XMLSchema::EnumerationDomain_isDefinedBy_Concept EnumerationDomain_isDefinedBy_Concept_type;
    typedef ::xsd::cxx::tree::sequence< EnumerationDomain_isDefinedBy_Concept_type > EnumerationDomain_isDefinedBy_Concept_sequence;
    typedef EnumerationDomain_isDefinedBy_Concept_sequence::iterator EnumerationDomain_isDefinedBy_Concept_iterator;
    typedef EnumerationDomain_isDefinedBy_Concept_sequence::const_iterator EnumerationDomain_isDefinedBy_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< EnumerationDomain_isDefinedBy_Concept_type, char > EnumerationDomain_isDefinedBy_Concept_traits;

    const EnumerationDomain_isDefinedBy_Concept_sequence&
    EnumerationDomain_isDefinedBy_Concept () const;

    EnumerationDomain_isDefinedBy_Concept_sequence&
    EnumerationDomain_isDefinedBy_Concept ();

    void
    EnumerationDomain_isDefinedBy_Concept (const EnumerationDomain_isDefinedBy_Concept_sequence& s);

    // Constructors.
    //
    EnumerationDomain ();

    EnumerationDomain (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    EnumerationDomain (const EnumerationDomain& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual EnumerationDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EnumerationDomain&
    operator= (const EnumerationDomain& x);

    virtual 
    ~EnumerationDomain ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    EnumerationDomain_uses_LevelStructure_optional EnumerationDomain_uses_LevelStructure_;
    EnumerationDomain_references_CategorySet_optional EnumerationDomain_references_CategorySet_;
    EnumerationDomain_isDefinedBy_Concept_sequence EnumerationDomain_isDefinedBy_Concept_;
  };

  class CodeList: public ::XMLSchema::EnumerationDomain
  {
    public:
    // allowsDuplicates
    //
    typedef ::xml_schema::boolean allowsDuplicates_type;
    typedef ::xsd::cxx::tree::traits< allowsDuplicates_type, char > allowsDuplicates_traits;

    const allowsDuplicates_type&
    allowsDuplicates () const;

    allowsDuplicates_type&
    allowsDuplicates ();

    void
    allowsDuplicates (const allowsDuplicates_type& x);

    // CodeList_has_CodePosition
    //
    typedef ::XMLSchema::CodeList_has_CodePosition CodeList_has_CodePosition_type;
    typedef ::xsd::cxx::tree::sequence< CodeList_has_CodePosition_type > CodeList_has_CodePosition_sequence;
    typedef CodeList_has_CodePosition_sequence::iterator CodeList_has_CodePosition_iterator;
    typedef CodeList_has_CodePosition_sequence::const_iterator CodeList_has_CodePosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< CodeList_has_CodePosition_type, char > CodeList_has_CodePosition_traits;

    const CodeList_has_CodePosition_sequence&
    CodeList_has_CodePosition () const;

    CodeList_has_CodePosition_sequence&
    CodeList_has_CodePosition ();

    void
    CodeList_has_CodePosition (const CodeList_has_CodePosition_sequence& s);

    // CodeList_has_Code
    //
    typedef ::XMLSchema::CodeList_has_Code CodeList_has_Code_type;
    typedef ::xsd::cxx::tree::sequence< CodeList_has_Code_type > CodeList_has_Code_sequence;
    typedef CodeList_has_Code_sequence::iterator CodeList_has_Code_iterator;
    typedef CodeList_has_Code_sequence::const_iterator CodeList_has_Code_const_iterator;
    typedef ::xsd::cxx::tree::traits< CodeList_has_Code_type, char > CodeList_has_Code_traits;

    const CodeList_has_Code_sequence&
    CodeList_has_Code () const;

    CodeList_has_Code_sequence&
    CodeList_has_Code ();

    void
    CodeList_has_Code (const CodeList_has_Code_sequence& s);

    // Constructors.
    //
    CodeList (const allowsDuplicates_type&);

    CodeList (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    CodeList (const CodeList& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual CodeList*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CodeList&
    operator= (const CodeList& x);

    virtual 
    ~CodeList ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< allowsDuplicates_type > allowsDuplicates_;
    CodeList_has_CodePosition_sequence CodeList_has_CodePosition_;
    CodeList_has_Code_sequence CodeList_has_Code_;
  };

  class CodeListStructure: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // specification
    //
    typedef ::XMLSchema::StructureSpecification specification_type;
    typedef ::xsd::cxx::tree::optional< specification_type > specification_optional;
    typedef ::xsd::cxx::tree::traits< specification_type, char > specification_traits;

    const specification_optional&
    specification () const;

    specification_optional&
    specification ();

    void
    specification (const specification_type& x);

    void
    specification (const specification_optional& x);

    void
    specification (::std::unique_ptr< specification_type > p);

    // topology
    //
    typedef ::XMLSchema::ControlledVocabularyEntry topology_type;
    typedef ::xsd::cxx::tree::traits< topology_type, char > topology_traits;

    const topology_type&
    topology () const;

    topology_type&
    topology ();

    void
    topology (const topology_type& x);

    void
    topology (::std::unique_ptr< topology_type > p);

    // totality
    //
    typedef ::XMLSchema::StructureExtent totality_type;
    typedef ::xsd::cxx::tree::optional< totality_type > totality_optional;
    typedef ::xsd::cxx::tree::traits< totality_type, char > totality_traits;

    const totality_optional&
    totality () const;

    totality_optional&
    totality ();

    void
    totality (const totality_type& x);

    void
    totality (const totality_optional& x);

    void
    totality (::std::unique_ptr< totality_type > p);

    // CodeListStructure_structures_CodeList
    //
    typedef ::XMLSchema::CodeListStructure_structures_CodeList CodeListStructure_structures_CodeList_type;
    typedef ::xsd::cxx::tree::optional< CodeListStructure_structures_CodeList_type > CodeListStructure_structures_CodeList_optional;
    typedef ::xsd::cxx::tree::traits< CodeListStructure_structures_CodeList_type, char > CodeListStructure_structures_CodeList_traits;

    const CodeListStructure_structures_CodeList_optional&
    CodeListStructure_structures_CodeList () const;

    CodeListStructure_structures_CodeList_optional&
    CodeListStructure_structures_CodeList ();

    void
    CodeListStructure_structures_CodeList (const CodeListStructure_structures_CodeList_type& x);

    void
    CodeListStructure_structures_CodeList (const CodeListStructure_structures_CodeList_optional& x);

    void
    CodeListStructure_structures_CodeList (::std::unique_ptr< CodeListStructure_structures_CodeList_type > p);

    // CodeListStructure_has_CodeRelationship
    //
    typedef ::XMLSchema::CodeListStructure_has_CodeRelationship CodeListStructure_has_CodeRelationship_type;
    typedef ::xsd::cxx::tree::sequence< CodeListStructure_has_CodeRelationship_type > CodeListStructure_has_CodeRelationship_sequence;
    typedef CodeListStructure_has_CodeRelationship_sequence::iterator CodeListStructure_has_CodeRelationship_iterator;
    typedef CodeListStructure_has_CodeRelationship_sequence::const_iterator CodeListStructure_has_CodeRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< CodeListStructure_has_CodeRelationship_type, char > CodeListStructure_has_CodeRelationship_traits;

    const CodeListStructure_has_CodeRelationship_sequence&
    CodeListStructure_has_CodeRelationship () const;

    CodeListStructure_has_CodeRelationship_sequence&
    CodeListStructure_has_CodeRelationship ();

    void
    CodeListStructure_has_CodeRelationship (const CodeListStructure_has_CodeRelationship_sequence& s);

    // Constructors.
    //
    CodeListStructure (const topology_type&);

    CodeListStructure (::std::unique_ptr< topology_type >);

    CodeListStructure (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    CodeListStructure (const CodeListStructure& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual CodeListStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CodeListStructure&
    operator= (const CodeListStructure& x);

    virtual 
    ~CodeListStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    semantics_optional semantics_;
    specification_optional specification_;
    ::xsd::cxx::tree::one< topology_type > topology_;
    totality_optional totality_;
    CodeListStructure_structures_CodeList_optional CodeListStructure_structures_CodeList_;
    CodeListStructure_has_CodeRelationship_sequence CodeListStructure_has_CodeRelationship_;
  };

  class CodePosition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // value
    //
    typedef ::xml_schema::integer value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    // CodePosition_indexes_Code
    //
    typedef ::XMLSchema::CodePosition_indexes_Code CodePosition_indexes_Code_type;
    typedef ::xsd::cxx::tree::optional< CodePosition_indexes_Code_type > CodePosition_indexes_Code_optional;
    typedef ::xsd::cxx::tree::traits< CodePosition_indexes_Code_type, char > CodePosition_indexes_Code_traits;

    const CodePosition_indexes_Code_optional&
    CodePosition_indexes_Code () const;

    CodePosition_indexes_Code_optional&
    CodePosition_indexes_Code ();

    void
    CodePosition_indexes_Code (const CodePosition_indexes_Code_type& x);

    void
    CodePosition_indexes_Code (const CodePosition_indexes_Code_optional& x);

    void
    CodePosition_indexes_Code (::std::unique_ptr< CodePosition_indexes_Code_type > p);

    // Constructors.
    //
    CodePosition (const value_type&);

    CodePosition (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    CodePosition (const CodePosition& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual CodePosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CodePosition&
    operator= (const CodePosition& x);

    virtual 
    ~CodePosition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< value_type > value_;
    CodePosition_indexes_Code_optional CodePosition_indexes_Code_;
  };

  class CodeRelationship: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // CodeRelationship_hasTarget_Code
    //
    typedef ::XMLSchema::CodeRelationship_hasTarget_Code CodeRelationship_hasTarget_Code_type;
    typedef ::xsd::cxx::tree::sequence< CodeRelationship_hasTarget_Code_type > CodeRelationship_hasTarget_Code_sequence;
    typedef CodeRelationship_hasTarget_Code_sequence::iterator CodeRelationship_hasTarget_Code_iterator;
    typedef CodeRelationship_hasTarget_Code_sequence::const_iterator CodeRelationship_hasTarget_Code_const_iterator;
    typedef ::xsd::cxx::tree::traits< CodeRelationship_hasTarget_Code_type, char > CodeRelationship_hasTarget_Code_traits;

    const CodeRelationship_hasTarget_Code_sequence&
    CodeRelationship_hasTarget_Code () const;

    CodeRelationship_hasTarget_Code_sequence&
    CodeRelationship_hasTarget_Code ();

    void
    CodeRelationship_hasTarget_Code (const CodeRelationship_hasTarget_Code_sequence& s);

    // CodeRelationship_hasSource_Code
    //
    typedef ::XMLSchema::CodeRelationship_hasSource_Code CodeRelationship_hasSource_Code_type;
    typedef ::xsd::cxx::tree::sequence< CodeRelationship_hasSource_Code_type > CodeRelationship_hasSource_Code_sequence;
    typedef CodeRelationship_hasSource_Code_sequence::iterator CodeRelationship_hasSource_Code_iterator;
    typedef CodeRelationship_hasSource_Code_sequence::const_iterator CodeRelationship_hasSource_Code_const_iterator;
    typedef ::xsd::cxx::tree::traits< CodeRelationship_hasSource_Code_type, char > CodeRelationship_hasSource_Code_traits;

    const CodeRelationship_hasSource_Code_sequence&
    CodeRelationship_hasSource_Code () const;

    CodeRelationship_hasSource_Code_sequence&
    CodeRelationship_hasSource_Code ();

    void
    CodeRelationship_hasSource_Code (const CodeRelationship_hasSource_Code_sequence& s);

    // Constructors.
    //
    CodeRelationship ();

    CodeRelationship (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    CodeRelationship (const CodeRelationship& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual CodeRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CodeRelationship&
    operator= (const CodeRelationship& x);

    virtual 
    ~CodeRelationship ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    semantics_optional semantics_;
    CodeRelationship_hasTarget_Code_sequence CodeRelationship_hasTarget_Code_;
    CodeRelationship_hasSource_Code_sequence CodeRelationship_hasSource_Code_;
  };

  class ComponentPosition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // value
    //
    typedef ::xml_schema::integer value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    // ComponentPosition_indexes_DataStructureComponent
    //
    typedef ::XMLSchema::ComponentPosition_indexes_DataStructureComponent ComponentPosition_indexes_DataStructureComponent_type;
    typedef ::xsd::cxx::tree::optional< ComponentPosition_indexes_DataStructureComponent_type > ComponentPosition_indexes_DataStructureComponent_optional;
    typedef ::xsd::cxx::tree::traits< ComponentPosition_indexes_DataStructureComponent_type, char > ComponentPosition_indexes_DataStructureComponent_traits;

    const ComponentPosition_indexes_DataStructureComponent_optional&
    ComponentPosition_indexes_DataStructureComponent () const;

    ComponentPosition_indexes_DataStructureComponent_optional&
    ComponentPosition_indexes_DataStructureComponent ();

    void
    ComponentPosition_indexes_DataStructureComponent (const ComponentPosition_indexes_DataStructureComponent_type& x);

    void
    ComponentPosition_indexes_DataStructureComponent (const ComponentPosition_indexes_DataStructureComponent_optional& x);

    void
    ComponentPosition_indexes_DataStructureComponent (::std::unique_ptr< ComponentPosition_indexes_DataStructureComponent_type > p);

    // Constructors.
    //
    ComponentPosition (const value_type&);

    ComponentPosition (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    ComponentPosition (const ComponentPosition& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual ComponentPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ComponentPosition&
    operator= (const ComponentPosition& x);

    virtual 
    ~ComponentPosition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< value_type > value_;
    ComponentPosition_indexes_DataStructureComponent_optional ComponentPosition_indexes_DataStructureComponent_;
  };

  class ConceptMap: public ::xml_schema::type
  {
    public:
    // correspondence
    //
    typedef ::XMLSchema::CorrespondenceDefinition correspondence_type;
    typedef ::xsd::cxx::tree::optional< correspondence_type > correspondence_optional;
    typedef ::xsd::cxx::tree::traits< correspondence_type, char > correspondence_traits;

    const correspondence_optional&
    correspondence () const;

    correspondence_optional&
    correspondence ();

    void
    correspondence (const correspondence_type& x);

    void
    correspondence (const correspondence_optional& x);

    void
    correspondence (::std::unique_ptr< correspondence_type > p);

    // displayLabel
    //
    typedef ::XMLSchema::LabelForDisplay displayLabel_type;
    typedef ::xsd::cxx::tree::optional< displayLabel_type > displayLabel_optional;
    typedef ::xsd::cxx::tree::traits< displayLabel_type, char > displayLabel_traits;

    const displayLabel_optional&
    displayLabel () const;

    displayLabel_optional&
    displayLabel ();

    void
    displayLabel (const displayLabel_type& x);

    void
    displayLabel (const displayLabel_optional& x);

    void
    displayLabel (::std::unique_ptr< displayLabel_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // usage
    //
    typedef ::XMLSchema::InternationalString usage_type;
    typedef ::xsd::cxx::tree::optional< usage_type > usage_optional;
    typedef ::xsd::cxx::tree::traits< usage_type, char > usage_traits;

    const usage_optional&
    usage () const;

    usage_optional&
    usage ();

    void
    usage (const usage_type& x);

    void
    usage (const usage_optional& x);

    void
    usage (::std::unique_ptr< usage_type > p);

    // validDates
    //
    typedef ::XMLSchema::DateRange validDates_type;
    typedef ::xsd::cxx::tree::optional< validDates_type > validDates_optional;
    typedef ::xsd::cxx::tree::traits< validDates_type, char > validDates_traits;

    const validDates_optional&
    validDates () const;

    validDates_optional&
    validDates ();

    void
    validDates (const validDates_type& x);

    void
    validDates (const validDates_optional& x);

    void
    validDates (::std::unique_ptr< validDates_type > p);

    // ConceptMap_hasSource_Concept
    //
    typedef ::XMLSchema::ConceptMap_hasSource_Concept ConceptMap_hasSource_Concept_type;
    typedef ::xsd::cxx::tree::sequence< ConceptMap_hasSource_Concept_type > ConceptMap_hasSource_Concept_sequence;
    typedef ConceptMap_hasSource_Concept_sequence::iterator ConceptMap_hasSource_Concept_iterator;
    typedef ConceptMap_hasSource_Concept_sequence::const_iterator ConceptMap_hasSource_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptMap_hasSource_Concept_type, char > ConceptMap_hasSource_Concept_traits;

    const ConceptMap_hasSource_Concept_sequence&
    ConceptMap_hasSource_Concept () const;

    ConceptMap_hasSource_Concept_sequence&
    ConceptMap_hasSource_Concept ();

    void
    ConceptMap_hasSource_Concept (const ConceptMap_hasSource_Concept_sequence& s);

    // ConceptMap_hasTarget_Concept
    //
    typedef ::XMLSchema::ConceptMap_hasTarget_Concept ConceptMap_hasTarget_Concept_type;
    typedef ::xsd::cxx::tree::sequence< ConceptMap_hasTarget_Concept_type > ConceptMap_hasTarget_Concept_sequence;
    typedef ConceptMap_hasTarget_Concept_sequence::iterator ConceptMap_hasTarget_Concept_iterator;
    typedef ConceptMap_hasTarget_Concept_sequence::const_iterator ConceptMap_hasTarget_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptMap_hasTarget_Concept_type, char > ConceptMap_hasTarget_Concept_traits;

    const ConceptMap_hasTarget_Concept_sequence&
    ConceptMap_hasTarget_Concept () const;

    ConceptMap_hasTarget_Concept_sequence&
    ConceptMap_hasTarget_Concept ();

    void
    ConceptMap_hasTarget_Concept (const ConceptMap_hasTarget_Concept_sequence& s);

    // Constructors.
    //
    ConceptMap ();

    ConceptMap (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    ConceptMap (const ConceptMap& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual ConceptMap*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConceptMap&
    operator= (const ConceptMap& x);

    virtual 
    ~ConceptMap ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    correspondence_optional correspondence_;
    displayLabel_optional displayLabel_;
    identifier_optional identifier_;
    usage_optional usage_;
    validDates_optional validDates_;
    ConceptMap_hasSource_Concept_sequence ConceptMap_hasSource_Concept_;
    ConceptMap_hasTarget_Concept_sequence ConceptMap_hasTarget_Concept_;
  };

  class ConceptRelationship: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // ConceptRelationship_hasSource_Concept
    //
    typedef ::XMLSchema::ConceptRelationship_hasSource_Concept ConceptRelationship_hasSource_Concept_type;
    typedef ::xsd::cxx::tree::traits< ConceptRelationship_hasSource_Concept_type, char > ConceptRelationship_hasSource_Concept_traits;

    const ConceptRelationship_hasSource_Concept_type&
    ConceptRelationship_hasSource_Concept () const;

    ConceptRelationship_hasSource_Concept_type&
    ConceptRelationship_hasSource_Concept ();

    void
    ConceptRelationship_hasSource_Concept (const ConceptRelationship_hasSource_Concept_type& x);

    void
    ConceptRelationship_hasSource_Concept (::std::unique_ptr< ConceptRelationship_hasSource_Concept_type > p);

    // ConceptRelationship_hasTarget_Concept
    //
    typedef ::XMLSchema::ConceptRelationship_hasTarget_Concept ConceptRelationship_hasTarget_Concept_type;
    typedef ::xsd::cxx::tree::traits< ConceptRelationship_hasTarget_Concept_type, char > ConceptRelationship_hasTarget_Concept_traits;

    const ConceptRelationship_hasTarget_Concept_type&
    ConceptRelationship_hasTarget_Concept () const;

    ConceptRelationship_hasTarget_Concept_type&
    ConceptRelationship_hasTarget_Concept ();

    void
    ConceptRelationship_hasTarget_Concept (const ConceptRelationship_hasTarget_Concept_type& x);

    void
    ConceptRelationship_hasTarget_Concept (::std::unique_ptr< ConceptRelationship_hasTarget_Concept_type > p);

    // Constructors.
    //
    ConceptRelationship (const ConceptRelationship_hasSource_Concept_type&,
                         const ConceptRelationship_hasTarget_Concept_type&);

    ConceptRelationship (::std::unique_ptr< ConceptRelationship_hasSource_Concept_type >,
                         ::std::unique_ptr< ConceptRelationship_hasTarget_Concept_type >);

    ConceptRelationship (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ConceptRelationship (const ConceptRelationship& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual ConceptRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConceptRelationship&
    operator= (const ConceptRelationship& x);

    virtual 
    ~ConceptRelationship ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    semantics_optional semantics_;
    ::xsd::cxx::tree::one< ConceptRelationship_hasSource_Concept_type > ConceptRelationship_hasSource_Concept_;
    ::xsd::cxx::tree::one< ConceptRelationship_hasTarget_Concept_type > ConceptRelationship_hasTarget_Concept_;
  };

  class ConceptStructure: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // specification
    //
    typedef ::XMLSchema::StructureSpecification specification_type;
    typedef ::xsd::cxx::tree::optional< specification_type > specification_optional;
    typedef ::xsd::cxx::tree::traits< specification_type, char > specification_traits;

    const specification_optional&
    specification () const;

    specification_optional&
    specification ();

    void
    specification (const specification_type& x);

    void
    specification (const specification_optional& x);

    void
    specification (::std::unique_ptr< specification_type > p);

    // topology
    //
    typedef ::XMLSchema::ControlledVocabularyEntry topology_type;
    typedef ::xsd::cxx::tree::optional< topology_type > topology_optional;
    typedef ::xsd::cxx::tree::traits< topology_type, char > topology_traits;

    const topology_optional&
    topology () const;

    topology_optional&
    topology ();

    void
    topology (const topology_type& x);

    void
    topology (const topology_optional& x);

    void
    topology (::std::unique_ptr< topology_type > p);

    // totality
    //
    typedef ::XMLSchema::StructureExtent totality_type;
    typedef ::xsd::cxx::tree::optional< totality_type > totality_optional;
    typedef ::xsd::cxx::tree::traits< totality_type, char > totality_traits;

    const totality_optional&
    totality () const;

    totality_optional&
    totality ();

    void
    totality (const totality_type& x);

    void
    totality (const totality_optional& x);

    void
    totality (::std::unique_ptr< totality_type > p);

    // ConceptStructure_structures_ConceptSystem
    //
    typedef ::XMLSchema::ConceptStructure_structures_ConceptSystem ConceptStructure_structures_ConceptSystem_type;
    typedef ::xsd::cxx::tree::optional< ConceptStructure_structures_ConceptSystem_type > ConceptStructure_structures_ConceptSystem_optional;
    typedef ::xsd::cxx::tree::traits< ConceptStructure_structures_ConceptSystem_type, char > ConceptStructure_structures_ConceptSystem_traits;

    const ConceptStructure_structures_ConceptSystem_optional&
    ConceptStructure_structures_ConceptSystem () const;

    ConceptStructure_structures_ConceptSystem_optional&
    ConceptStructure_structures_ConceptSystem ();

    void
    ConceptStructure_structures_ConceptSystem (const ConceptStructure_structures_ConceptSystem_type& x);

    void
    ConceptStructure_structures_ConceptSystem (const ConceptStructure_structures_ConceptSystem_optional& x);

    void
    ConceptStructure_structures_ConceptSystem (::std::unique_ptr< ConceptStructure_structures_ConceptSystem_type > p);

    // ConceptStructure_has_ConceptRelationship
    //
    typedef ::XMLSchema::ConceptStructure_has_ConceptRelationship ConceptStructure_has_ConceptRelationship_type;
    typedef ::xsd::cxx::tree::sequence< ConceptStructure_has_ConceptRelationship_type > ConceptStructure_has_ConceptRelationship_sequence;
    typedef ConceptStructure_has_ConceptRelationship_sequence::iterator ConceptStructure_has_ConceptRelationship_iterator;
    typedef ConceptStructure_has_ConceptRelationship_sequence::const_iterator ConceptStructure_has_ConceptRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptStructure_has_ConceptRelationship_type, char > ConceptStructure_has_ConceptRelationship_traits;

    const ConceptStructure_has_ConceptRelationship_sequence&
    ConceptStructure_has_ConceptRelationship () const;

    ConceptStructure_has_ConceptRelationship_sequence&
    ConceptStructure_has_ConceptRelationship ();

    void
    ConceptStructure_has_ConceptRelationship (const ConceptStructure_has_ConceptRelationship_sequence& s);

    // Constructors.
    //
    ConceptStructure ();

    ConceptStructure (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    ConceptStructure (const ConceptStructure& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual ConceptStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConceptStructure&
    operator= (const ConceptStructure& x);

    virtual 
    ~ConceptStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    semantics_optional semantics_;
    specification_optional specification_;
    topology_optional topology_;
    totality_optional totality_;
    ConceptStructure_structures_ConceptSystem_optional ConceptStructure_structures_ConceptSystem_;
    ConceptStructure_has_ConceptRelationship_sequence ConceptStructure_has_ConceptRelationship_;
  };

  class ConceptSystemCorrespondence: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // displayLabel
    //
    typedef ::XMLSchema::LabelForDisplay displayLabel_type;
    typedef ::xsd::cxx::tree::sequence< displayLabel_type > displayLabel_sequence;
    typedef displayLabel_sequence::iterator displayLabel_iterator;
    typedef displayLabel_sequence::const_iterator displayLabel_const_iterator;
    typedef ::xsd::cxx::tree::traits< displayLabel_type, char > displayLabel_traits;

    const displayLabel_sequence&
    displayLabel () const;

    displayLabel_sequence&
    displayLabel ();

    void
    displayLabel (const displayLabel_sequence& s);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // usage
    //
    typedef ::XMLSchema::InternationalString usage_type;
    typedef ::xsd::cxx::tree::optional< usage_type > usage_optional;
    typedef ::xsd::cxx::tree::traits< usage_type, char > usage_traits;

    const usage_optional&
    usage () const;

    usage_optional&
    usage ();

    void
    usage (const usage_type& x);

    void
    usage (const usage_optional& x);

    void
    usage (::std::unique_ptr< usage_type > p);

    // ConceptSystemCorrespondence_maps_ConceptSystem
    //
    typedef ::XMLSchema::ConceptSystemCorrespondence_maps_ConceptSystem ConceptSystemCorrespondence_maps_ConceptSystem_type;
    typedef ::xsd::cxx::tree::sequence< ConceptSystemCorrespondence_maps_ConceptSystem_type > ConceptSystemCorrespondence_maps_ConceptSystem_sequence;
    typedef ConceptSystemCorrespondence_maps_ConceptSystem_sequence::iterator ConceptSystemCorrespondence_maps_ConceptSystem_iterator;
    typedef ConceptSystemCorrespondence_maps_ConceptSystem_sequence::const_iterator ConceptSystemCorrespondence_maps_ConceptSystem_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptSystemCorrespondence_maps_ConceptSystem_type, char > ConceptSystemCorrespondence_maps_ConceptSystem_traits;

    const ConceptSystemCorrespondence_maps_ConceptSystem_sequence&
    ConceptSystemCorrespondence_maps_ConceptSystem () const;

    ConceptSystemCorrespondence_maps_ConceptSystem_sequence&
    ConceptSystemCorrespondence_maps_ConceptSystem ();

    void
    ConceptSystemCorrespondence_maps_ConceptSystem (const ConceptSystemCorrespondence_maps_ConceptSystem_sequence& s);

    // ConceptSystemCorrespondence_has_ConceptMap
    //
    typedef ::XMLSchema::ConceptSystemCorrespondence_has_ConceptMap ConceptSystemCorrespondence_has_ConceptMap_type;
    typedef ::xsd::cxx::tree::sequence< ConceptSystemCorrespondence_has_ConceptMap_type > ConceptSystemCorrespondence_has_ConceptMap_sequence;
    typedef ConceptSystemCorrespondence_has_ConceptMap_sequence::iterator ConceptSystemCorrespondence_has_ConceptMap_iterator;
    typedef ConceptSystemCorrespondence_has_ConceptMap_sequence::const_iterator ConceptSystemCorrespondence_has_ConceptMap_const_iterator;
    typedef ::xsd::cxx::tree::traits< ConceptSystemCorrespondence_has_ConceptMap_type, char > ConceptSystemCorrespondence_has_ConceptMap_traits;

    const ConceptSystemCorrespondence_has_ConceptMap_sequence&
    ConceptSystemCorrespondence_has_ConceptMap () const;

    ConceptSystemCorrespondence_has_ConceptMap_sequence&
    ConceptSystemCorrespondence_has_ConceptMap ();

    void
    ConceptSystemCorrespondence_has_ConceptMap (const ConceptSystemCorrespondence_has_ConceptMap_sequence& s);

    // Constructors.
    //
    ConceptSystemCorrespondence ();

    ConceptSystemCorrespondence (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    ConceptSystemCorrespondence (const ConceptSystemCorrespondence& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual ConceptSystemCorrespondence*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConceptSystemCorrespondence&
    operator= (const ConceptSystemCorrespondence& x);

    virtual 
    ~ConceptSystemCorrespondence ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    displayLabel_sequence displayLabel_;
    identifier_optional identifier_;
    purpose_optional purpose_;
    usage_optional usage_;
    ConceptSystemCorrespondence_maps_ConceptSystem_sequence ConceptSystemCorrespondence_maps_ConceptSystem_;
    ConceptSystemCorrespondence_has_ConceptMap_sequence ConceptSystemCorrespondence_has_ConceptMap_;
  };

  class ConceptualDomain: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // displayLabel
    //
    typedef ::XMLSchema::LabelForDisplay displayLabel_type;
    typedef ::xsd::cxx::tree::sequence< displayLabel_type > displayLabel_sequence;
    typedef displayLabel_sequence::iterator displayLabel_iterator;
    typedef displayLabel_sequence::const_iterator displayLabel_const_iterator;
    typedef ::xsd::cxx::tree::traits< displayLabel_type, char > displayLabel_traits;

    const displayLabel_sequence&
    displayLabel () const;

    displayLabel_sequence&
    displayLabel ();

    void
    displayLabel (const displayLabel_sequence& s);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // ConceptualDomain_isDescribedBy_ValueAndConceptDescription
    //
    typedef ::XMLSchema::ConceptualDomain_isDescribedBy_ValueAndConceptDescription ConceptualDomain_isDescribedBy_ValueAndConceptDescription_type;
    typedef ::xsd::cxx::tree::optional< ConceptualDomain_isDescribedBy_ValueAndConceptDescription_type > ConceptualDomain_isDescribedBy_ValueAndConceptDescription_optional;
    typedef ::xsd::cxx::tree::traits< ConceptualDomain_isDescribedBy_ValueAndConceptDescription_type, char > ConceptualDomain_isDescribedBy_ValueAndConceptDescription_traits;

    const ConceptualDomain_isDescribedBy_ValueAndConceptDescription_optional&
    ConceptualDomain_isDescribedBy_ValueAndConceptDescription () const;

    ConceptualDomain_isDescribedBy_ValueAndConceptDescription_optional&
    ConceptualDomain_isDescribedBy_ValueAndConceptDescription ();

    void
    ConceptualDomain_isDescribedBy_ValueAndConceptDescription (const ConceptualDomain_isDescribedBy_ValueAndConceptDescription_type& x);

    void
    ConceptualDomain_isDescribedBy_ValueAndConceptDescription (const ConceptualDomain_isDescribedBy_ValueAndConceptDescription_optional& x);

    void
    ConceptualDomain_isDescribedBy_ValueAndConceptDescription (::std::unique_ptr< ConceptualDomain_isDescribedBy_ValueAndConceptDescription_type > p);

    // ConceptualDomain_takesConceptsFrom_ConceptSystem
    //
    typedef ::XMLSchema::ConceptualDomain_takesConceptsFrom_ConceptSystem ConceptualDomain_takesConceptsFrom_ConceptSystem_type;
    typedef ::xsd::cxx::tree::optional< ConceptualDomain_takesConceptsFrom_ConceptSystem_type > ConceptualDomain_takesConceptsFrom_ConceptSystem_optional;
    typedef ::xsd::cxx::tree::traits< ConceptualDomain_takesConceptsFrom_ConceptSystem_type, char > ConceptualDomain_takesConceptsFrom_ConceptSystem_traits;

    const ConceptualDomain_takesConceptsFrom_ConceptSystem_optional&
    ConceptualDomain_takesConceptsFrom_ConceptSystem () const;

    ConceptualDomain_takesConceptsFrom_ConceptSystem_optional&
    ConceptualDomain_takesConceptsFrom_ConceptSystem ();

    void
    ConceptualDomain_takesConceptsFrom_ConceptSystem (const ConceptualDomain_takesConceptsFrom_ConceptSystem_type& x);

    void
    ConceptualDomain_takesConceptsFrom_ConceptSystem (const ConceptualDomain_takesConceptsFrom_ConceptSystem_optional& x);

    void
    ConceptualDomain_takesConceptsFrom_ConceptSystem (::std::unique_ptr< ConceptualDomain_takesConceptsFrom_ConceptSystem_type > p);

    // Constructors.
    //
    ConceptualDomain ();

    ConceptualDomain (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    ConceptualDomain (const ConceptualDomain& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual ConceptualDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConceptualDomain&
    operator= (const ConceptualDomain& x);

    virtual 
    ~ConceptualDomain ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    displayLabel_sequence displayLabel_;
    identifier_optional identifier_;
    ConceptualDomain_isDescribedBy_ValueAndConceptDescription_optional ConceptualDomain_isDescribedBy_ValueAndConceptDescription_;
    ConceptualDomain_takesConceptsFrom_ConceptSystem_optional ConceptualDomain_takesConceptsFrom_ConceptSystem_;
  };

  class ConceptualValue: public ::XMLSchema::Concept
  {
    public:
    // ConceptualValue_hasConceptFrom_ConceptualDomain
    //
    typedef ::XMLSchema::ConceptualValue_hasConceptFrom_ConceptualDomain ConceptualValue_hasConceptFrom_ConceptualDomain_type;
    typedef ::xsd::cxx::tree::traits< ConceptualValue_hasConceptFrom_ConceptualDomain_type, char > ConceptualValue_hasConceptFrom_ConceptualDomain_traits;

    const ConceptualValue_hasConceptFrom_ConceptualDomain_type&
    ConceptualValue_hasConceptFrom_ConceptualDomain () const;

    ConceptualValue_hasConceptFrom_ConceptualDomain_type&
    ConceptualValue_hasConceptFrom_ConceptualDomain ();

    void
    ConceptualValue_hasConceptFrom_ConceptualDomain (const ConceptualValue_hasConceptFrom_ConceptualDomain_type& x);

    void
    ConceptualValue_hasConceptFrom_ConceptualDomain (::std::unique_ptr< ConceptualValue_hasConceptFrom_ConceptualDomain_type > p);

    // Constructors.
    //
    ConceptualValue (const ConceptualValue_hasConceptFrom_ConceptualDomain_type&);

    ConceptualValue (::std::unique_ptr< ConceptualValue_hasConceptFrom_ConceptualDomain_type >);

    ConceptualValue (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    ConceptualValue (const ConceptualValue& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual ConceptualValue*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConceptualValue&
    operator= (const ConceptualValue& x);

    virtual 
    ~ConceptualValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ConceptualValue_hasConceptFrom_ConceptualDomain_type > ConceptualValue_hasConceptFrom_ConceptualDomain_;
  };

  class ConceptualVariable: public ::XMLSchema::Concept
  {
    public:
    // descriptiveText
    //
    typedef ::XMLSchema::InternationalString descriptiveText_type;
    typedef ::xsd::cxx::tree::optional< descriptiveText_type > descriptiveText_optional;
    typedef ::xsd::cxx::tree::traits< descriptiveText_type, char > descriptiveText_traits;

    const descriptiveText_optional&
    descriptiveText () const;

    descriptiveText_optional&
    descriptiveText ();

    void
    descriptiveText (const descriptiveText_type& x);

    void
    descriptiveText (const descriptiveText_optional& x);

    void
    descriptiveText (::std::unique_ptr< descriptiveText_type > p);

    // unitOfMeasureKind
    //
    typedef ::XMLSchema::ControlledVocabularyEntry unitOfMeasureKind_type;
    typedef ::xsd::cxx::tree::optional< unitOfMeasureKind_type > unitOfMeasureKind_optional;
    typedef ::xsd::cxx::tree::traits< unitOfMeasureKind_type, char > unitOfMeasureKind_traits;

    const unitOfMeasureKind_optional&
    unitOfMeasureKind () const;

    unitOfMeasureKind_optional&
    unitOfMeasureKind ();

    void
    unitOfMeasureKind (const unitOfMeasureKind_type& x);

    void
    unitOfMeasureKind (const unitOfMeasureKind_optional& x);

    void
    unitOfMeasureKind (::std::unique_ptr< unitOfMeasureKind_type > p);

    // ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain
    //
    typedef ::XMLSchema::ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_type;
    typedef ::xsd::cxx::tree::optional< ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_type > ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_optional;
    typedef ::xsd::cxx::tree::traits< ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_type, char > ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_traits;

    const ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_optional&
    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain () const;

    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_optional&
    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain ();

    void
    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain (const ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_type& x);

    void
    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain (const ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_optional& x);

    void
    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain (::std::unique_ptr< ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_type > p);

    // ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain
    //
    typedef ::XMLSchema::ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_type;
    typedef ::xsd::cxx::tree::optional< ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_type > ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_optional;
    typedef ::xsd::cxx::tree::traits< ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_type, char > ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_traits;

    const ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_optional&
    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain () const;

    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_optional&
    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain ();

    void
    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain (const ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_type& x);

    void
    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain (const ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_optional& x);

    void
    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain (::std::unique_ptr< ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_type > p);

    // ConceptualVariable_measures_UnitType
    //
    typedef ::XMLSchema::ConceptualVariable_measures_UnitType ConceptualVariable_measures_UnitType_type;
    typedef ::xsd::cxx::tree::optional< ConceptualVariable_measures_UnitType_type > ConceptualVariable_measures_UnitType_optional;
    typedef ::xsd::cxx::tree::traits< ConceptualVariable_measures_UnitType_type, char > ConceptualVariable_measures_UnitType_traits;

    const ConceptualVariable_measures_UnitType_optional&
    ConceptualVariable_measures_UnitType () const;

    ConceptualVariable_measures_UnitType_optional&
    ConceptualVariable_measures_UnitType ();

    void
    ConceptualVariable_measures_UnitType (const ConceptualVariable_measures_UnitType_type& x);

    void
    ConceptualVariable_measures_UnitType (const ConceptualVariable_measures_UnitType_optional& x);

    void
    ConceptualVariable_measures_UnitType (::std::unique_ptr< ConceptualVariable_measures_UnitType_type > p);

    // Constructors.
    //
    ConceptualVariable ();

    ConceptualVariable (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    ConceptualVariable (const ConceptualVariable& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual ConceptualVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConceptualVariable&
    operator= (const ConceptualVariable& x);

    virtual 
    ~ConceptualVariable ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    descriptiveText_optional descriptiveText_;
    unitOfMeasureKind_optional unitOfMeasureKind_;
    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_optional ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_;
    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_optional ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_;
    ConceptualVariable_measures_UnitType_optional ConceptualVariable_measures_UnitType_;
  };

  class DeterministicImperative: public ::XMLSchema::ControlLogic
  {
    public:
    // Constructors.
    //
    DeterministicImperative ();

    DeterministicImperative (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    DeterministicImperative (const DeterministicImperative& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual DeterministicImperative*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DeterministicImperative&
    operator= (const DeterministicImperative&) = default;
#endif

    virtual 
    ~DeterministicImperative ();
  };

  class ConditionalControlLogic: public ::XMLSchema::DeterministicImperative
  {
    public:
    // condition
    //
    typedef ::XMLSchema::CommandCode condition_type;
    typedef ::xsd::cxx::tree::traits< condition_type, char > condition_traits;

    const condition_type&
    condition () const;

    condition_type&
    condition ();

    void
    condition (const condition_type& x);

    void
    condition (::std::unique_ptr< condition_type > p);

    // construct
    //
    typedef ::XMLSchema::ControlConstruct construct_type;
    typedef ::xsd::cxx::tree::traits< construct_type, char > construct_traits;

    const construct_type&
    construct () const;

    construct_type&
    construct ();

    void
    construct (const construct_type& x);

    void
    construct (::std::unique_ptr< construct_type > p);

    // Constructors.
    //
    ConditionalControlLogic (const condition_type&,
                             const construct_type&);

    ConditionalControlLogic (::std::unique_ptr< condition_type >,
                             const construct_type&);

    ConditionalControlLogic (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ConditionalControlLogic (const ConditionalControlLogic& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual ConditionalControlLogic*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ConditionalControlLogic&
    operator= (const ConditionalControlLogic& x);

    virtual 
    ~ConditionalControlLogic ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< condition_type > condition_;
    ::xsd::cxx::tree::one< construct_type > construct_;
  };

  class ContextualComponent: public ::XMLSchema::DataStructureComponent
  {
    public:
    // Constructors.
    //
    ContextualComponent ();

    ContextualComponent (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ContextualComponent (const ContextualComponent& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual ContextualComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ContextualComponent&
    operator= (const ContextualComponent&) = default;
#endif

    virtual 
    ~ContextualComponent ();
  };

  class CorrespondenceTable: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // effectiveDates
    //
    typedef ::XMLSchema::DateRange effectiveDates_type;
    typedef ::xsd::cxx::tree::optional< effectiveDates_type > effectiveDates_optional;
    typedef ::xsd::cxx::tree::traits< effectiveDates_type, char > effectiveDates_traits;

    const effectiveDates_optional&
    effectiveDates () const;

    effectiveDates_optional&
    effectiveDates ();

    void
    effectiveDates (const effectiveDates_type& x);

    void
    effectiveDates (const effectiveDates_optional& x);

    void
    effectiveDates (::std::unique_ptr< effectiveDates_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // CorrespondenceTable_hasSource_Level
    //
    typedef ::XMLSchema::CorrespondenceTable_hasSource_Level CorrespondenceTable_hasSource_Level_type;
    typedef ::xsd::cxx::tree::optional< CorrespondenceTable_hasSource_Level_type > CorrespondenceTable_hasSource_Level_optional;
    typedef ::xsd::cxx::tree::traits< CorrespondenceTable_hasSource_Level_type, char > CorrespondenceTable_hasSource_Level_traits;

    const CorrespondenceTable_hasSource_Level_optional&
    CorrespondenceTable_hasSource_Level () const;

    CorrespondenceTable_hasSource_Level_optional&
    CorrespondenceTable_hasSource_Level ();

    void
    CorrespondenceTable_hasSource_Level (const CorrespondenceTable_hasSource_Level_type& x);

    void
    CorrespondenceTable_hasSource_Level (const CorrespondenceTable_hasSource_Level_optional& x);

    void
    CorrespondenceTable_hasSource_Level (::std::unique_ptr< CorrespondenceTable_hasSource_Level_type > p);

    // CorrespondenceTable_hasTarget_Level
    //
    typedef ::XMLSchema::CorrespondenceTable_hasTarget_Level CorrespondenceTable_hasTarget_Level_type;
    typedef ::xsd::cxx::tree::optional< CorrespondenceTable_hasTarget_Level_type > CorrespondenceTable_hasTarget_Level_optional;
    typedef ::xsd::cxx::tree::traits< CorrespondenceTable_hasTarget_Level_type, char > CorrespondenceTable_hasTarget_Level_traits;

    const CorrespondenceTable_hasTarget_Level_optional&
    CorrespondenceTable_hasTarget_Level () const;

    CorrespondenceTable_hasTarget_Level_optional&
    CorrespondenceTable_hasTarget_Level ();

    void
    CorrespondenceTable_hasTarget_Level (const CorrespondenceTable_hasTarget_Level_type& x);

    void
    CorrespondenceTable_hasTarget_Level (const CorrespondenceTable_hasTarget_Level_optional& x);

    void
    CorrespondenceTable_hasTarget_Level (::std::unique_ptr< CorrespondenceTable_hasTarget_Level_type > p);

    // CorrespondenceTable_isOwnedBy_Agent
    //
    typedef ::XMLSchema::CorrespondenceTable_isOwnedBy_Agent CorrespondenceTable_isOwnedBy_Agent_type;
    typedef ::xsd::cxx::tree::sequence< CorrespondenceTable_isOwnedBy_Agent_type > CorrespondenceTable_isOwnedBy_Agent_sequence;
    typedef CorrespondenceTable_isOwnedBy_Agent_sequence::iterator CorrespondenceTable_isOwnedBy_Agent_iterator;
    typedef CorrespondenceTable_isOwnedBy_Agent_sequence::const_iterator CorrespondenceTable_isOwnedBy_Agent_const_iterator;
    typedef ::xsd::cxx::tree::traits< CorrespondenceTable_isOwnedBy_Agent_type, char > CorrespondenceTable_isOwnedBy_Agent_traits;

    const CorrespondenceTable_isOwnedBy_Agent_sequence&
    CorrespondenceTable_isOwnedBy_Agent () const;

    CorrespondenceTable_isOwnedBy_Agent_sequence&
    CorrespondenceTable_isOwnedBy_Agent ();

    void
    CorrespondenceTable_isOwnedBy_Agent (const CorrespondenceTable_isOwnedBy_Agent_sequence& s);

    // CorrespondenceTable_mapsTo_StatisticalClassification
    //
    typedef ::XMLSchema::CorrespondenceTable_mapsTo_StatisticalClassification CorrespondenceTable_mapsTo_StatisticalClassification_type;
    typedef ::xsd::cxx::tree::sequence< CorrespondenceTable_mapsTo_StatisticalClassification_type > CorrespondenceTable_mapsTo_StatisticalClassification_sequence;
    typedef CorrespondenceTable_mapsTo_StatisticalClassification_sequence::iterator CorrespondenceTable_mapsTo_StatisticalClassification_iterator;
    typedef CorrespondenceTable_mapsTo_StatisticalClassification_sequence::const_iterator CorrespondenceTable_mapsTo_StatisticalClassification_const_iterator;
    typedef ::xsd::cxx::tree::traits< CorrespondenceTable_mapsTo_StatisticalClassification_type, char > CorrespondenceTable_mapsTo_StatisticalClassification_traits;

    const CorrespondenceTable_mapsTo_StatisticalClassification_sequence&
    CorrespondenceTable_mapsTo_StatisticalClassification () const;

    CorrespondenceTable_mapsTo_StatisticalClassification_sequence&
    CorrespondenceTable_mapsTo_StatisticalClassification ();

    void
    CorrespondenceTable_mapsTo_StatisticalClassification (const CorrespondenceTable_mapsTo_StatisticalClassification_sequence& s);

    // CorrespondenceTable_hasContact_Agent
    //
    typedef ::XMLSchema::CorrespondenceTable_hasContact_Agent CorrespondenceTable_hasContact_Agent_type;
    typedef ::xsd::cxx::tree::sequence< CorrespondenceTable_hasContact_Agent_type > CorrespondenceTable_hasContact_Agent_sequence;
    typedef CorrespondenceTable_hasContact_Agent_sequence::iterator CorrespondenceTable_hasContact_Agent_iterator;
    typedef CorrespondenceTable_hasContact_Agent_sequence::const_iterator CorrespondenceTable_hasContact_Agent_const_iterator;
    typedef ::xsd::cxx::tree::traits< CorrespondenceTable_hasContact_Agent_type, char > CorrespondenceTable_hasContact_Agent_traits;

    const CorrespondenceTable_hasContact_Agent_sequence&
    CorrespondenceTable_hasContact_Agent () const;

    CorrespondenceTable_hasContact_Agent_sequence&
    CorrespondenceTable_hasContact_Agent ();

    void
    CorrespondenceTable_hasContact_Agent (const CorrespondenceTable_hasContact_Agent_sequence& s);

    // CorrespondenceTable_isMaintainedBy_Agent
    //
    typedef ::XMLSchema::CorrespondenceTable_isMaintainedBy_Agent CorrespondenceTable_isMaintainedBy_Agent_type;
    typedef ::xsd::cxx::tree::optional< CorrespondenceTable_isMaintainedBy_Agent_type > CorrespondenceTable_isMaintainedBy_Agent_optional;
    typedef ::xsd::cxx::tree::traits< CorrespondenceTable_isMaintainedBy_Agent_type, char > CorrespondenceTable_isMaintainedBy_Agent_traits;

    const CorrespondenceTable_isMaintainedBy_Agent_optional&
    CorrespondenceTable_isMaintainedBy_Agent () const;

    CorrespondenceTable_isMaintainedBy_Agent_optional&
    CorrespondenceTable_isMaintainedBy_Agent ();

    void
    CorrespondenceTable_isMaintainedBy_Agent (const CorrespondenceTable_isMaintainedBy_Agent_type& x);

    void
    CorrespondenceTable_isMaintainedBy_Agent (const CorrespondenceTable_isMaintainedBy_Agent_optional& x);

    void
    CorrespondenceTable_isMaintainedBy_Agent (::std::unique_ptr< CorrespondenceTable_isMaintainedBy_Agent_type > p);

    // CorrespondenceTable_has_ConceptMap
    //
    typedef ::XMLSchema::CorrespondenceTable_has_ConceptMap CorrespondenceTable_has_ConceptMap_type;
    typedef ::xsd::cxx::tree::sequence< CorrespondenceTable_has_ConceptMap_type > CorrespondenceTable_has_ConceptMap_sequence;
    typedef CorrespondenceTable_has_ConceptMap_sequence::iterator CorrespondenceTable_has_ConceptMap_iterator;
    typedef CorrespondenceTable_has_ConceptMap_sequence::const_iterator CorrespondenceTable_has_ConceptMap_const_iterator;
    typedef ::xsd::cxx::tree::traits< CorrespondenceTable_has_ConceptMap_type, char > CorrespondenceTable_has_ConceptMap_traits;

    const CorrespondenceTable_has_ConceptMap_sequence&
    CorrespondenceTable_has_ConceptMap () const;

    CorrespondenceTable_has_ConceptMap_sequence&
    CorrespondenceTable_has_ConceptMap ();

    void
    CorrespondenceTable_has_ConceptMap (const CorrespondenceTable_has_ConceptMap_sequence& s);

    // Constructors.
    //
    CorrespondenceTable ();

    CorrespondenceTable (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    CorrespondenceTable (const CorrespondenceTable& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual CorrespondenceTable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CorrespondenceTable&
    operator= (const CorrespondenceTable& x);

    virtual 
    ~CorrespondenceTable ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    effectiveDates_optional effectiveDates_;
    identifier_optional identifier_;
    CorrespondenceTable_hasSource_Level_optional CorrespondenceTable_hasSource_Level_;
    CorrespondenceTable_hasTarget_Level_optional CorrespondenceTable_hasTarget_Level_;
    CorrespondenceTable_isOwnedBy_Agent_sequence CorrespondenceTable_isOwnedBy_Agent_;
    CorrespondenceTable_mapsTo_StatisticalClassification_sequence CorrespondenceTable_mapsTo_StatisticalClassification_;
    CorrespondenceTable_hasContact_Agent_sequence CorrespondenceTable_hasContact_Agent_;
    CorrespondenceTable_isMaintainedBy_Agent_optional CorrespondenceTable_isMaintainedBy_Agent_;
    CorrespondenceTable_has_ConceptMap_sequence CorrespondenceTable_has_ConceptMap_;
  };

  class ProcessingAgent: public ::XMLSchema::Agent
  {
    public:
    // ProcessingAgent_performs_Activity
    //
    typedef ::XMLSchema::ProcessingAgent_performs_Activity ProcessingAgent_performs_Activity_type;
    typedef ::xsd::cxx::tree::sequence< ProcessingAgent_performs_Activity_type > ProcessingAgent_performs_Activity_sequence;
    typedef ProcessingAgent_performs_Activity_sequence::iterator ProcessingAgent_performs_Activity_iterator;
    typedef ProcessingAgent_performs_Activity_sequence::const_iterator ProcessingAgent_performs_Activity_const_iterator;
    typedef ::xsd::cxx::tree::traits< ProcessingAgent_performs_Activity_type, char > ProcessingAgent_performs_Activity_traits;

    const ProcessingAgent_performs_Activity_sequence&
    ProcessingAgent_performs_Activity () const;

    ProcessingAgent_performs_Activity_sequence&
    ProcessingAgent_performs_Activity ();

    void
    ProcessingAgent_performs_Activity (const ProcessingAgent_performs_Activity_sequence& s);

    // ProcessingAgent_operatesOn_ProductionEnvironment
    //
    typedef ::XMLSchema::ProcessingAgent_operatesOn_ProductionEnvironment ProcessingAgent_operatesOn_ProductionEnvironment_type;
    typedef ::xsd::cxx::tree::sequence< ProcessingAgent_operatesOn_ProductionEnvironment_type > ProcessingAgent_operatesOn_ProductionEnvironment_sequence;
    typedef ProcessingAgent_operatesOn_ProductionEnvironment_sequence::iterator ProcessingAgent_operatesOn_ProductionEnvironment_iterator;
    typedef ProcessingAgent_operatesOn_ProductionEnvironment_sequence::const_iterator ProcessingAgent_operatesOn_ProductionEnvironment_const_iterator;
    typedef ::xsd::cxx::tree::traits< ProcessingAgent_operatesOn_ProductionEnvironment_type, char > ProcessingAgent_operatesOn_ProductionEnvironment_traits;

    const ProcessingAgent_operatesOn_ProductionEnvironment_sequence&
    ProcessingAgent_operatesOn_ProductionEnvironment () const;

    ProcessingAgent_operatesOn_ProductionEnvironment_sequence&
    ProcessingAgent_operatesOn_ProductionEnvironment ();

    void
    ProcessingAgent_operatesOn_ProductionEnvironment (const ProcessingAgent_operatesOn_ProductionEnvironment_sequence& s);

    // Constructors.
    //
    ProcessingAgent ();

    ProcessingAgent (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    ProcessingAgent (const ProcessingAgent& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual ProcessingAgent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ProcessingAgent&
    operator= (const ProcessingAgent& x);

    virtual 
    ~ProcessingAgent ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ProcessingAgent_performs_Activity_sequence ProcessingAgent_performs_Activity_;
    ProcessingAgent_operatesOn_ProductionEnvironment_sequence ProcessingAgent_operatesOn_ProductionEnvironment_;
  };

  class Curator: public ::XMLSchema::ProcessingAgent
  {
    public:
    // Constructors.
    //
    Curator ();

    Curator (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Curator (const Curator& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual Curator*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Curator&
    operator= (const Curator&) = default;
#endif

    virtual 
    ~Curator ();
  };

  class DataPoint: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // DataPoint_correspondsTo_DataStructureComponent
    //
    typedef ::XMLSchema::DataPoint_correspondsTo_DataStructureComponent DataPoint_correspondsTo_DataStructureComponent_type;
    typedef ::xsd::cxx::tree::sequence< DataPoint_correspondsTo_DataStructureComponent_type > DataPoint_correspondsTo_DataStructureComponent_sequence;
    typedef DataPoint_correspondsTo_DataStructureComponent_sequence::iterator DataPoint_correspondsTo_DataStructureComponent_iterator;
    typedef DataPoint_correspondsTo_DataStructureComponent_sequence::const_iterator DataPoint_correspondsTo_DataStructureComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataPoint_correspondsTo_DataStructureComponent_type, char > DataPoint_correspondsTo_DataStructureComponent_traits;

    const DataPoint_correspondsTo_DataStructureComponent_sequence&
    DataPoint_correspondsTo_DataStructureComponent () const;

    DataPoint_correspondsTo_DataStructureComponent_sequence&
    DataPoint_correspondsTo_DataStructureComponent ();

    void
    DataPoint_correspondsTo_DataStructureComponent (const DataPoint_correspondsTo_DataStructureComponent_sequence& s);

    // DataPoint_isDescribedBy_InstanceVariable
    //
    typedef ::XMLSchema::DataPoint_isDescribedBy_InstanceVariable DataPoint_isDescribedBy_InstanceVariable_type;
    typedef ::xsd::cxx::tree::traits< DataPoint_isDescribedBy_InstanceVariable_type, char > DataPoint_isDescribedBy_InstanceVariable_traits;

    const DataPoint_isDescribedBy_InstanceVariable_type&
    DataPoint_isDescribedBy_InstanceVariable () const;

    DataPoint_isDescribedBy_InstanceVariable_type&
    DataPoint_isDescribedBy_InstanceVariable ();

    void
    DataPoint_isDescribedBy_InstanceVariable (const DataPoint_isDescribedBy_InstanceVariable_type& x);

    void
    DataPoint_isDescribedBy_InstanceVariable (::std::unique_ptr< DataPoint_isDescribedBy_InstanceVariable_type > p);

    // Constructors.
    //
    DataPoint (const DataPoint_isDescribedBy_InstanceVariable_type&);

    DataPoint (::std::unique_ptr< DataPoint_isDescribedBy_InstanceVariable_type >);

    DataPoint (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    DataPoint (const DataPoint& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual DataPoint*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DataPoint&
    operator= (const DataPoint& x);

    virtual 
    ~DataPoint ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    identifier_optional identifier_;
    DataPoint_correspondsTo_DataStructureComponent_sequence DataPoint_correspondsTo_DataStructureComponent_;
    ::xsd::cxx::tree::one< DataPoint_isDescribedBy_InstanceVariable_type > DataPoint_isDescribedBy_InstanceVariable_;
  };

  class DataPointPosition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // value
    //
    typedef ::xml_schema::integer value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    // DataPointPosition_indexes_DataPoint
    //
    typedef ::XMLSchema::DataPointPosition_indexes_DataPoint DataPointPosition_indexes_DataPoint_type;
    typedef ::xsd::cxx::tree::optional< DataPointPosition_indexes_DataPoint_type > DataPointPosition_indexes_DataPoint_optional;
    typedef ::xsd::cxx::tree::traits< DataPointPosition_indexes_DataPoint_type, char > DataPointPosition_indexes_DataPoint_traits;

    const DataPointPosition_indexes_DataPoint_optional&
    DataPointPosition_indexes_DataPoint () const;

    DataPointPosition_indexes_DataPoint_optional&
    DataPointPosition_indexes_DataPoint ();

    void
    DataPointPosition_indexes_DataPoint (const DataPointPosition_indexes_DataPoint_type& x);

    void
    DataPointPosition_indexes_DataPoint (const DataPointPosition_indexes_DataPoint_optional& x);

    void
    DataPointPosition_indexes_DataPoint (::std::unique_ptr< DataPointPosition_indexes_DataPoint_type > p);

    // Constructors.
    //
    DataPointPosition (const value_type&);

    DataPointPosition (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    DataPointPosition (const DataPointPosition& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual DataPointPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DataPointPosition&
    operator= (const DataPointPosition& x);

    virtual 
    ~DataPointPosition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< value_type > value_;
    DataPointPosition_indexes_DataPoint_optional DataPointPosition_indexes_DataPoint_;
  };

  class DataPointRelationship: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // DataPointRelationship_hasTarget_DataPoint
    //
    typedef ::XMLSchema::DataPointRelationship_hasTarget_DataPoint DataPointRelationship_hasTarget_DataPoint_type;
    typedef ::xsd::cxx::tree::sequence< DataPointRelationship_hasTarget_DataPoint_type > DataPointRelationship_hasTarget_DataPoint_sequence;
    typedef DataPointRelationship_hasTarget_DataPoint_sequence::iterator DataPointRelationship_hasTarget_DataPoint_iterator;
    typedef DataPointRelationship_hasTarget_DataPoint_sequence::const_iterator DataPointRelationship_hasTarget_DataPoint_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataPointRelationship_hasTarget_DataPoint_type, char > DataPointRelationship_hasTarget_DataPoint_traits;

    const DataPointRelationship_hasTarget_DataPoint_sequence&
    DataPointRelationship_hasTarget_DataPoint () const;

    DataPointRelationship_hasTarget_DataPoint_sequence&
    DataPointRelationship_hasTarget_DataPoint ();

    void
    DataPointRelationship_hasTarget_DataPoint (const DataPointRelationship_hasTarget_DataPoint_sequence& s);

    // DataPointRelationship_hasSource_DataPoint
    //
    typedef ::XMLSchema::DataPointRelationship_hasSource_DataPoint DataPointRelationship_hasSource_DataPoint_type;
    typedef ::xsd::cxx::tree::sequence< DataPointRelationship_hasSource_DataPoint_type > DataPointRelationship_hasSource_DataPoint_sequence;
    typedef DataPointRelationship_hasSource_DataPoint_sequence::iterator DataPointRelationship_hasSource_DataPoint_iterator;
    typedef DataPointRelationship_hasSource_DataPoint_sequence::const_iterator DataPointRelationship_hasSource_DataPoint_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataPointRelationship_hasSource_DataPoint_type, char > DataPointRelationship_hasSource_DataPoint_traits;

    const DataPointRelationship_hasSource_DataPoint_sequence&
    DataPointRelationship_hasSource_DataPoint () const;

    DataPointRelationship_hasSource_DataPoint_sequence&
    DataPointRelationship_hasSource_DataPoint ();

    void
    DataPointRelationship_hasSource_DataPoint (const DataPointRelationship_hasSource_DataPoint_sequence& s);

    // Constructors.
    //
    DataPointRelationship ();

    DataPointRelationship (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    DataPointRelationship (const DataPointRelationship& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual DataPointRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DataPointRelationship&
    operator= (const DataPointRelationship& x);

    virtual 
    ~DataPointRelationship ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    semantics_optional semantics_;
    DataPointRelationship_hasTarget_DataPoint_sequence DataPointRelationship_hasTarget_DataPoint_;
    DataPointRelationship_hasSource_DataPoint_sequence DataPointRelationship_hasSource_DataPoint_;
  };

  class DataSet: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // DataSet_isStructuredBy_DataStructure
    //
    typedef ::XMLSchema::DataSet_isStructuredBy_DataStructure DataSet_isStructuredBy_DataStructure_type;
    typedef ::xsd::cxx::tree::sequence< DataSet_isStructuredBy_DataStructure_type > DataSet_isStructuredBy_DataStructure_sequence;
    typedef DataSet_isStructuredBy_DataStructure_sequence::iterator DataSet_isStructuredBy_DataStructure_iterator;
    typedef DataSet_isStructuredBy_DataStructure_sequence::const_iterator DataSet_isStructuredBy_DataStructure_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataSet_isStructuredBy_DataStructure_type, char > DataSet_isStructuredBy_DataStructure_traits;

    const DataSet_isStructuredBy_DataStructure_sequence&
    DataSet_isStructuredBy_DataStructure () const;

    DataSet_isStructuredBy_DataStructure_sequence&
    DataSet_isStructuredBy_DataStructure ();

    void
    DataSet_isStructuredBy_DataStructure (const DataSet_isStructuredBy_DataStructure_sequence& s);

    // DataSet_has_DataPoint
    //
    typedef ::XMLSchema::DataSet_has_DataPoint DataSet_has_DataPoint_type;
    typedef ::xsd::cxx::tree::sequence< DataSet_has_DataPoint_type > DataSet_has_DataPoint_sequence;
    typedef DataSet_has_DataPoint_sequence::iterator DataSet_has_DataPoint_iterator;
    typedef DataSet_has_DataPoint_sequence::const_iterator DataSet_has_DataPoint_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataSet_has_DataPoint_type, char > DataSet_has_DataPoint_traits;

    const DataSet_has_DataPoint_sequence&
    DataSet_has_DataPoint () const;

    DataSet_has_DataPoint_sequence&
    DataSet_has_DataPoint ();

    void
    DataSet_has_DataPoint (const DataSet_has_DataPoint_sequence& s);

    // DataSet_has_Key
    //
    typedef ::XMLSchema::DataSet_has_Key DataSet_has_Key_type;
    typedef ::xsd::cxx::tree::sequence< DataSet_has_Key_type > DataSet_has_Key_sequence;
    typedef DataSet_has_Key_sequence::iterator DataSet_has_Key_iterator;
    typedef DataSet_has_Key_sequence::const_iterator DataSet_has_Key_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataSet_has_Key_type, char > DataSet_has_Key_traits;

    const DataSet_has_Key_sequence&
    DataSet_has_Key () const;

    DataSet_has_Key_sequence&
    DataSet_has_Key ();

    void
    DataSet_has_Key (const DataSet_has_Key_sequence& s);

    // Constructors.
    //
    DataSet ();

    DataSet (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    DataSet (const DataSet& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual DataSet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DataSet&
    operator= (const DataSet& x);

    virtual 
    ~DataSet ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    identifier_optional identifier_;
    DataSet_isStructuredBy_DataStructure_sequence DataSet_isStructuredBy_DataStructure_;
    DataSet_has_DataPoint_sequence DataSet_has_DataPoint_;
    DataSet_has_Key_sequence DataSet_has_Key_;
  };

  class DataStore: public ::xml_schema::type
  {
    public:
    // aboutMissing
    //
    typedef ::XMLSchema::InternationalString aboutMissing_type;
    typedef ::xsd::cxx::tree::optional< aboutMissing_type > aboutMissing_optional;
    typedef ::xsd::cxx::tree::traits< aboutMissing_type, char > aboutMissing_traits;

    const aboutMissing_optional&
    aboutMissing () const;

    aboutMissing_optional&
    aboutMissing ();

    void
    aboutMissing (const aboutMissing_type& x);

    void
    aboutMissing (const aboutMissing_optional& x);

    void
    aboutMissing (::std::unique_ptr< aboutMissing_type > p);

    // allowsDuplicates
    //
    typedef ::xml_schema::boolean allowsDuplicates_type;
    typedef ::xsd::cxx::tree::traits< allowsDuplicates_type, char > allowsDuplicates_traits;

    const allowsDuplicates_type&
    allowsDuplicates () const;

    allowsDuplicates_type&
    allowsDuplicates ();

    void
    allowsDuplicates (const allowsDuplicates_type& x);

    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // characterSet
    //
    typedef ::xml_schema::string characterSet_type;
    typedef ::xsd::cxx::tree::optional< characterSet_type > characterSet_optional;
    typedef ::xsd::cxx::tree::traits< characterSet_type, char > characterSet_traits;

    const characterSet_optional&
    characterSet () const;

    characterSet_optional&
    characterSet ();

    void
    characterSet (const characterSet_type& x);

    void
    characterSet (const characterSet_optional& x);

    void
    characterSet (::std::unique_ptr< characterSet_type > p);

    // dataStoreType
    //
    typedef ::XMLSchema::ControlledVocabularyEntry dataStoreType_type;
    typedef ::xsd::cxx::tree::optional< dataStoreType_type > dataStoreType_optional;
    typedef ::xsd::cxx::tree::traits< dataStoreType_type, char > dataStoreType_traits;

    const dataStoreType_optional&
    dataStoreType () const;

    dataStoreType_optional&
    dataStoreType ();

    void
    dataStoreType (const dataStoreType_type& x);

    void
    dataStoreType (const dataStoreType_optional& x);

    void
    dataStoreType (::std::unique_ptr< dataStoreType_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // recordCount
    //
    typedef ::xml_schema::integer recordCount_type;
    typedef ::xsd::cxx::tree::optional< recordCount_type > recordCount_optional;
    typedef ::xsd::cxx::tree::traits< recordCount_type, char > recordCount_traits;

    const recordCount_optional&
    recordCount () const;

    recordCount_optional&
    recordCount ();

    void
    recordCount (const recordCount_type& x);

    void
    recordCount (const recordCount_optional& x);

    // DataStore_isDefinedBy_Concept
    //
    typedef ::XMLSchema::DataStore_isDefinedBy_Concept DataStore_isDefinedBy_Concept_type;
    typedef ::xsd::cxx::tree::sequence< DataStore_isDefinedBy_Concept_type > DataStore_isDefinedBy_Concept_sequence;
    typedef DataStore_isDefinedBy_Concept_sequence::iterator DataStore_isDefinedBy_Concept_iterator;
    typedef DataStore_isDefinedBy_Concept_sequence::const_iterator DataStore_isDefinedBy_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataStore_isDefinedBy_Concept_type, char > DataStore_isDefinedBy_Concept_traits;

    const DataStore_isDefinedBy_Concept_sequence&
    DataStore_isDefinedBy_Concept () const;

    DataStore_isDefinedBy_Concept_sequence&
    DataStore_isDefinedBy_Concept ();

    void
    DataStore_isDefinedBy_Concept (const DataStore_isDefinedBy_Concept_sequence& s);

    // DataStore_has_LogicalRecordPosition
    //
    typedef ::XMLSchema::DataStore_has_LogicalRecordPosition DataStore_has_LogicalRecordPosition_type;
    typedef ::xsd::cxx::tree::sequence< DataStore_has_LogicalRecordPosition_type > DataStore_has_LogicalRecordPosition_sequence;
    typedef DataStore_has_LogicalRecordPosition_sequence::iterator DataStore_has_LogicalRecordPosition_iterator;
    typedef DataStore_has_LogicalRecordPosition_sequence::const_iterator DataStore_has_LogicalRecordPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataStore_has_LogicalRecordPosition_type, char > DataStore_has_LogicalRecordPosition_traits;

    const DataStore_has_LogicalRecordPosition_sequence&
    DataStore_has_LogicalRecordPosition () const;

    DataStore_has_LogicalRecordPosition_sequence&
    DataStore_has_LogicalRecordPosition ();

    void
    DataStore_has_LogicalRecordPosition (const DataStore_has_LogicalRecordPosition_sequence& s);

    // DataStore_has_LogicalRecord
    //
    typedef ::XMLSchema::DataStore_has_LogicalRecord DataStore_has_LogicalRecord_type;
    typedef ::xsd::cxx::tree::sequence< DataStore_has_LogicalRecord_type > DataStore_has_LogicalRecord_sequence;
    typedef DataStore_has_LogicalRecord_sequence::iterator DataStore_has_LogicalRecord_iterator;
    typedef DataStore_has_LogicalRecord_sequence::const_iterator DataStore_has_LogicalRecord_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataStore_has_LogicalRecord_type, char > DataStore_has_LogicalRecord_traits;

    const DataStore_has_LogicalRecord_sequence&
    DataStore_has_LogicalRecord () const;

    DataStore_has_LogicalRecord_sequence&
    DataStore_has_LogicalRecord ();

    void
    DataStore_has_LogicalRecord (const DataStore_has_LogicalRecord_sequence& s);

    // DataStore_has_RecordRelation
    //
    typedef ::XMLSchema::DataStore_has_RecordRelation DataStore_has_RecordRelation_type;
    typedef ::xsd::cxx::tree::optional< DataStore_has_RecordRelation_type > DataStore_has_RecordRelation_optional;
    typedef ::xsd::cxx::tree::traits< DataStore_has_RecordRelation_type, char > DataStore_has_RecordRelation_traits;

    const DataStore_has_RecordRelation_optional&
    DataStore_has_RecordRelation () const;

    DataStore_has_RecordRelation_optional&
    DataStore_has_RecordRelation ();

    void
    DataStore_has_RecordRelation (const DataStore_has_RecordRelation_type& x);

    void
    DataStore_has_RecordRelation (const DataStore_has_RecordRelation_optional& x);

    void
    DataStore_has_RecordRelation (::std::unique_ptr< DataStore_has_RecordRelation_type > p);

    // Constructors.
    //
    DataStore (const allowsDuplicates_type&);

    DataStore (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    DataStore (const DataStore& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual DataStore*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DataStore&
    operator= (const DataStore& x);

    virtual 
    ~DataStore ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    aboutMissing_optional aboutMissing_;
    ::xsd::cxx::tree::one< allowsDuplicates_type > allowsDuplicates_;
    catalogDetails_optional catalogDetails_;
    characterSet_optional characterSet_;
    dataStoreType_optional dataStoreType_;
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    recordCount_optional recordCount_;
    DataStore_isDefinedBy_Concept_sequence DataStore_isDefinedBy_Concept_;
    DataStore_has_LogicalRecordPosition_sequence DataStore_has_LogicalRecordPosition_;
    DataStore_has_LogicalRecord_sequence DataStore_has_LogicalRecord_;
    DataStore_has_RecordRelation_optional DataStore_has_RecordRelation_;
  };

  class DataStructure: public ::XMLSchema::DataStructureComponent
  {
    public:
    // DataStructure_has_ForeignKey
    //
    typedef ::XMLSchema::DataStructure_has_ForeignKey DataStructure_has_ForeignKey_type;
    typedef ::xsd::cxx::tree::sequence< DataStructure_has_ForeignKey_type > DataStructure_has_ForeignKey_sequence;
    typedef DataStructure_has_ForeignKey_sequence::iterator DataStructure_has_ForeignKey_iterator;
    typedef DataStructure_has_ForeignKey_sequence::const_iterator DataStructure_has_ForeignKey_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataStructure_has_ForeignKey_type, char > DataStructure_has_ForeignKey_traits;

    const DataStructure_has_ForeignKey_sequence&
    DataStructure_has_ForeignKey () const;

    DataStructure_has_ForeignKey_sequence&
    DataStructure_has_ForeignKey ();

    void
    DataStructure_has_ForeignKey (const DataStructure_has_ForeignKey_sequence& s);

    // DataStructure_has_DataStructureComponent
    //
    typedef ::XMLSchema::DataStructure_has_DataStructureComponent DataStructure_has_DataStructureComponent_type;
    typedef ::xsd::cxx::tree::sequence< DataStructure_has_DataStructureComponent_type > DataStructure_has_DataStructureComponent_sequence;
    typedef DataStructure_has_DataStructureComponent_sequence::iterator DataStructure_has_DataStructureComponent_iterator;
    typedef DataStructure_has_DataStructureComponent_sequence::const_iterator DataStructure_has_DataStructureComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataStructure_has_DataStructureComponent_type, char > DataStructure_has_DataStructureComponent_traits;

    const DataStructure_has_DataStructureComponent_sequence&
    DataStructure_has_DataStructureComponent () const;

    DataStructure_has_DataStructureComponent_sequence&
    DataStructure_has_DataStructureComponent ();

    void
    DataStructure_has_DataStructureComponent (const DataStructure_has_DataStructureComponent_sequence& s);

    // DataStructure_has_ComponentPosition
    //
    typedef ::XMLSchema::DataStructure_has_ComponentPosition DataStructure_has_ComponentPosition_type;
    typedef ::xsd::cxx::tree::sequence< DataStructure_has_ComponentPosition_type > DataStructure_has_ComponentPosition_sequence;
    typedef DataStructure_has_ComponentPosition_sequence::iterator DataStructure_has_ComponentPosition_iterator;
    typedef DataStructure_has_ComponentPosition_sequence::const_iterator DataStructure_has_ComponentPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< DataStructure_has_ComponentPosition_type, char > DataStructure_has_ComponentPosition_traits;

    const DataStructure_has_ComponentPosition_sequence&
    DataStructure_has_ComponentPosition () const;

    DataStructure_has_ComponentPosition_sequence&
    DataStructure_has_ComponentPosition ();

    void
    DataStructure_has_ComponentPosition (const DataStructure_has_ComponentPosition_sequence& s);

    // DataStructure_has_PrimaryKey
    //
    typedef ::XMLSchema::DataStructure_has_PrimaryKey DataStructure_has_PrimaryKey_type;
    typedef ::xsd::cxx::tree::optional< DataStructure_has_PrimaryKey_type > DataStructure_has_PrimaryKey_optional;
    typedef ::xsd::cxx::tree::traits< DataStructure_has_PrimaryKey_type, char > DataStructure_has_PrimaryKey_traits;

    const DataStructure_has_PrimaryKey_optional&
    DataStructure_has_PrimaryKey () const;

    DataStructure_has_PrimaryKey_optional&
    DataStructure_has_PrimaryKey ();

    void
    DataStructure_has_PrimaryKey (const DataStructure_has_PrimaryKey_type& x);

    void
    DataStructure_has_PrimaryKey (const DataStructure_has_PrimaryKey_optional& x);

    void
    DataStructure_has_PrimaryKey (::std::unique_ptr< DataStructure_has_PrimaryKey_type > p);

    // Constructors.
    //
    DataStructure ();

    DataStructure (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    DataStructure (const DataStructure& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual DataStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DataStructure&
    operator= (const DataStructure& x);

    virtual 
    ~DataStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DataStructure_has_ForeignKey_sequence DataStructure_has_ForeignKey_;
    DataStructure_has_DataStructureComponent_sequence DataStructure_has_DataStructureComponent_;
    DataStructure_has_ComponentPosition_sequence DataStructure_has_ComponentPosition_;
    DataStructure_has_PrimaryKey_optional DataStructure_has_PrimaryKey_;
  };

  class Datum: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // Datum_uses_Notation
    //
    typedef ::XMLSchema::Datum_uses_Notation Datum_uses_Notation_type;
    typedef ::xsd::cxx::tree::optional< Datum_uses_Notation_type > Datum_uses_Notation_optional;
    typedef ::xsd::cxx::tree::traits< Datum_uses_Notation_type, char > Datum_uses_Notation_traits;

    const Datum_uses_Notation_optional&
    Datum_uses_Notation () const;

    Datum_uses_Notation_optional&
    Datum_uses_Notation ();

    void
    Datum_uses_Notation (const Datum_uses_Notation_type& x);

    void
    Datum_uses_Notation (const Datum_uses_Notation_optional& x);

    void
    Datum_uses_Notation (::std::unique_ptr< Datum_uses_Notation_type > p);

    // Datum_denotes_ConceptualValue
    //
    typedef ::XMLSchema::Datum_denotes_ConceptualValue Datum_denotes_ConceptualValue_type;
    typedef ::xsd::cxx::tree::traits< Datum_denotes_ConceptualValue_type, char > Datum_denotes_ConceptualValue_traits;

    const Datum_denotes_ConceptualValue_type&
    Datum_denotes_ConceptualValue () const;

    Datum_denotes_ConceptualValue_type&
    Datum_denotes_ConceptualValue ();

    void
    Datum_denotes_ConceptualValue (const Datum_denotes_ConceptualValue_type& x);

    void
    Datum_denotes_ConceptualValue (::std::unique_ptr< Datum_denotes_ConceptualValue_type > p);

    // Datum_uses_InstanceValue
    //
    typedef ::XMLSchema::Datum_uses_InstanceValue Datum_uses_InstanceValue_type;
    typedef ::xsd::cxx::tree::sequence< Datum_uses_InstanceValue_type > Datum_uses_InstanceValue_sequence;
    typedef Datum_uses_InstanceValue_sequence::iterator Datum_uses_InstanceValue_iterator;
    typedef Datum_uses_InstanceValue_sequence::const_iterator Datum_uses_InstanceValue_const_iterator;
    typedef ::xsd::cxx::tree::traits< Datum_uses_InstanceValue_type, char > Datum_uses_InstanceValue_traits;

    const Datum_uses_InstanceValue_sequence&
    Datum_uses_InstanceValue () const;

    Datum_uses_InstanceValue_sequence&
    Datum_uses_InstanceValue ();

    void
    Datum_uses_InstanceValue (const Datum_uses_InstanceValue_sequence& s);

    // Datum_isBoundedBy_InstanceVariable
    //
    typedef ::XMLSchema::Datum_isBoundedBy_InstanceVariable Datum_isBoundedBy_InstanceVariable_type;
    typedef ::xsd::cxx::tree::sequence< Datum_isBoundedBy_InstanceVariable_type > Datum_isBoundedBy_InstanceVariable_sequence;
    typedef Datum_isBoundedBy_InstanceVariable_sequence::iterator Datum_isBoundedBy_InstanceVariable_iterator;
    typedef Datum_isBoundedBy_InstanceVariable_sequence::const_iterator Datum_isBoundedBy_InstanceVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< Datum_isBoundedBy_InstanceVariable_type, char > Datum_isBoundedBy_InstanceVariable_traits;

    const Datum_isBoundedBy_InstanceVariable_sequence&
    Datum_isBoundedBy_InstanceVariable () const;

    Datum_isBoundedBy_InstanceVariable_sequence&
    Datum_isBoundedBy_InstanceVariable ();

    void
    Datum_isBoundedBy_InstanceVariable (const Datum_isBoundedBy_InstanceVariable_sequence& s);

    // Constructors.
    //
    Datum (const Datum_denotes_ConceptualValue_type&);

    Datum (::std::unique_ptr< Datum_denotes_ConceptualValue_type >);

    Datum (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Datum (const Datum& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Datum*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Datum&
    operator= (const Datum& x);

    virtual 
    ~Datum ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    identifier_optional identifier_;
    Datum_uses_Notation_optional Datum_uses_Notation_;
    ::xsd::cxx::tree::one< Datum_denotes_ConceptualValue_type > Datum_denotes_ConceptualValue_;
    Datum_uses_InstanceValue_sequence Datum_uses_InstanceValue_;
    Datum_isBoundedBy_InstanceVariable_sequence Datum_isBoundedBy_InstanceVariable_;
  };

  class InstanceValue: public ::xml_schema::type
  {
    public:
    // content
    //
    typedef ::XMLSchema::TypedString content_type;
    typedef ::xsd::cxx::tree::optional< content_type > content_optional;
    typedef ::xsd::cxx::tree::traits< content_type, char > content_traits;

    const content_optional&
    content () const;

    content_optional&
    content ();

    void
    content (const content_type& x);

    void
    content (const content_optional& x);

    void
    content (::std::unique_ptr< content_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // whiteSpace
    //
    typedef ::XMLSchema::WhiteSpaceRule whiteSpace_type;
    typedef ::xsd::cxx::tree::optional< whiteSpace_type > whiteSpace_optional;
    typedef ::xsd::cxx::tree::traits< whiteSpace_type, char > whiteSpace_traits;

    const whiteSpace_optional&
    whiteSpace () const;

    whiteSpace_optional&
    whiteSpace ();

    void
    whiteSpace (const whiteSpace_type& x);

    void
    whiteSpace (const whiteSpace_optional& x);

    void
    whiteSpace (::std::unique_ptr< whiteSpace_type > p);

    // InstanceValue_hasValueFrom_ValueDomain
    //
    typedef ::XMLSchema::InstanceValue_hasValueFrom_ValueDomain InstanceValue_hasValueFrom_ValueDomain_type;
    typedef ::xsd::cxx::tree::traits< InstanceValue_hasValueFrom_ValueDomain_type, char > InstanceValue_hasValueFrom_ValueDomain_traits;

    const InstanceValue_hasValueFrom_ValueDomain_type&
    InstanceValue_hasValueFrom_ValueDomain () const;

    InstanceValue_hasValueFrom_ValueDomain_type&
    InstanceValue_hasValueFrom_ValueDomain ();

    void
    InstanceValue_hasValueFrom_ValueDomain (const InstanceValue_hasValueFrom_ValueDomain_type& x);

    void
    InstanceValue_hasValueFrom_ValueDomain (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type > p);

    // InstanceValue_isStoredIn_DataPoint
    //
    typedef ::XMLSchema::InstanceValue_isStoredIn_DataPoint InstanceValue_isStoredIn_DataPoint_type;
    typedef ::xsd::cxx::tree::optional< InstanceValue_isStoredIn_DataPoint_type > InstanceValue_isStoredIn_DataPoint_optional;
    typedef ::xsd::cxx::tree::traits< InstanceValue_isStoredIn_DataPoint_type, char > InstanceValue_isStoredIn_DataPoint_traits;

    const InstanceValue_isStoredIn_DataPoint_optional&
    InstanceValue_isStoredIn_DataPoint () const;

    InstanceValue_isStoredIn_DataPoint_optional&
    InstanceValue_isStoredIn_DataPoint ();

    void
    InstanceValue_isStoredIn_DataPoint (const InstanceValue_isStoredIn_DataPoint_type& x);

    void
    InstanceValue_isStoredIn_DataPoint (const InstanceValue_isStoredIn_DataPoint_optional& x);

    void
    InstanceValue_isStoredIn_DataPoint (::std::unique_ptr< InstanceValue_isStoredIn_DataPoint_type > p);

    // InstanceValue_represents_ConceptualValue
    //
    typedef ::XMLSchema::InstanceValue_represents_ConceptualValue InstanceValue_represents_ConceptualValue_type;
    typedef ::xsd::cxx::tree::optional< InstanceValue_represents_ConceptualValue_type > InstanceValue_represents_ConceptualValue_optional;
    typedef ::xsd::cxx::tree::traits< InstanceValue_represents_ConceptualValue_type, char > InstanceValue_represents_ConceptualValue_traits;

    const InstanceValue_represents_ConceptualValue_optional&
    InstanceValue_represents_ConceptualValue () const;

    InstanceValue_represents_ConceptualValue_optional&
    InstanceValue_represents_ConceptualValue ();

    void
    InstanceValue_represents_ConceptualValue (const InstanceValue_represents_ConceptualValue_type& x);

    void
    InstanceValue_represents_ConceptualValue (const InstanceValue_represents_ConceptualValue_optional& x);

    void
    InstanceValue_represents_ConceptualValue (::std::unique_ptr< InstanceValue_represents_ConceptualValue_type > p);

    // Constructors.
    //
    InstanceValue (const InstanceValue_hasValueFrom_ValueDomain_type&);

    InstanceValue (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type >);

    InstanceValue (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    InstanceValue (const InstanceValue& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual InstanceValue*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InstanceValue&
    operator= (const InstanceValue& x);

    virtual 
    ~InstanceValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_optional content_;
    identifier_optional identifier_;
    whiteSpace_optional whiteSpace_;
    ::xsd::cxx::tree::one< InstanceValue_hasValueFrom_ValueDomain_type > InstanceValue_hasValueFrom_ValueDomain_;
    InstanceValue_isStoredIn_DataPoint_optional InstanceValue_isStoredIn_DataPoint_;
    InstanceValue_represents_ConceptualValue_optional InstanceValue_represents_ConceptualValue_;
  };

  class KeyMember: public ::XMLSchema::InstanceValue
  {
    public:
    // KeyMember_isBasedOn_DataStructureComponent
    //
    typedef ::XMLSchema::KeyMember_isBasedOn_DataStructureComponent KeyMember_isBasedOn_DataStructureComponent_type;
    typedef ::xsd::cxx::tree::sequence< KeyMember_isBasedOn_DataStructureComponent_type > KeyMember_isBasedOn_DataStructureComponent_sequence;
    typedef KeyMember_isBasedOn_DataStructureComponent_sequence::iterator KeyMember_isBasedOn_DataStructureComponent_iterator;
    typedef KeyMember_isBasedOn_DataStructureComponent_sequence::const_iterator KeyMember_isBasedOn_DataStructureComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< KeyMember_isBasedOn_DataStructureComponent_type, char > KeyMember_isBasedOn_DataStructureComponent_traits;

    const KeyMember_isBasedOn_DataStructureComponent_sequence&
    KeyMember_isBasedOn_DataStructureComponent () const;

    KeyMember_isBasedOn_DataStructureComponent_sequence&
    KeyMember_isBasedOn_DataStructureComponent ();

    void
    KeyMember_isBasedOn_DataStructureComponent (const KeyMember_isBasedOn_DataStructureComponent_sequence& s);

    // Constructors.
    //
    KeyMember (const InstanceValue_hasValueFrom_ValueDomain_type&);

    KeyMember (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type >);

    KeyMember (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    KeyMember (const KeyMember& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual KeyMember*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    KeyMember&
    operator= (const KeyMember& x);

    virtual 
    ~KeyMember ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    KeyMember_isBasedOn_DataStructureComponent_sequence KeyMember_isBasedOn_DataStructureComponent_;
  };

  class Descriptor: public ::XMLSchema::KeyMember
  {
    public:
    // Descriptor_refersTo_ReferenceValue
    //
    typedef ::XMLSchema::Descriptor_refersTo_ReferenceValue Descriptor_refersTo_ReferenceValue_type;
    typedef ::xsd::cxx::tree::sequence< Descriptor_refersTo_ReferenceValue_type > Descriptor_refersTo_ReferenceValue_sequence;
    typedef Descriptor_refersTo_ReferenceValue_sequence::iterator Descriptor_refersTo_ReferenceValue_iterator;
    typedef Descriptor_refersTo_ReferenceValue_sequence::const_iterator Descriptor_refersTo_ReferenceValue_const_iterator;
    typedef ::xsd::cxx::tree::traits< Descriptor_refersTo_ReferenceValue_type, char > Descriptor_refersTo_ReferenceValue_traits;

    const Descriptor_refersTo_ReferenceValue_sequence&
    Descriptor_refersTo_ReferenceValue () const;

    Descriptor_refersTo_ReferenceValue_sequence&
    Descriptor_refersTo_ReferenceValue ();

    void
    Descriptor_refersTo_ReferenceValue (const Descriptor_refersTo_ReferenceValue_sequence& s);

    // Descriptor_identifies_ReferenceVariable
    //
    typedef ::XMLSchema::Descriptor_identifies_ReferenceVariable Descriptor_identifies_ReferenceVariable_type;
    typedef ::xsd::cxx::tree::traits< Descriptor_identifies_ReferenceVariable_type, char > Descriptor_identifies_ReferenceVariable_traits;

    const Descriptor_identifies_ReferenceVariable_type&
    Descriptor_identifies_ReferenceVariable () const;

    Descriptor_identifies_ReferenceVariable_type&
    Descriptor_identifies_ReferenceVariable ();

    void
    Descriptor_identifies_ReferenceVariable (const Descriptor_identifies_ReferenceVariable_type& x);

    void
    Descriptor_identifies_ReferenceVariable (::std::unique_ptr< Descriptor_identifies_ReferenceVariable_type > p);

    // Descriptor_hasValueFrom_DescriptorValueDomain
    //
    typedef ::XMLSchema::Descriptor_hasValueFrom_DescriptorValueDomain Descriptor_hasValueFrom_DescriptorValueDomain_type;
    typedef ::xsd::cxx::tree::traits< Descriptor_hasValueFrom_DescriptorValueDomain_type, char > Descriptor_hasValueFrom_DescriptorValueDomain_traits;

    const Descriptor_hasValueFrom_DescriptorValueDomain_type&
    Descriptor_hasValueFrom_DescriptorValueDomain () const;

    Descriptor_hasValueFrom_DescriptorValueDomain_type&
    Descriptor_hasValueFrom_DescriptorValueDomain ();

    void
    Descriptor_hasValueFrom_DescriptorValueDomain (const Descriptor_hasValueFrom_DescriptorValueDomain_type& x);

    void
    Descriptor_hasValueFrom_DescriptorValueDomain (::std::unique_ptr< Descriptor_hasValueFrom_DescriptorValueDomain_type > p);

    // Constructors.
    //
    Descriptor (const InstanceValue_hasValueFrom_ValueDomain_type&,
                const Descriptor_identifies_ReferenceVariable_type&,
                const Descriptor_hasValueFrom_DescriptorValueDomain_type&);

    Descriptor (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type >,
                ::std::unique_ptr< Descriptor_identifies_ReferenceVariable_type >,
                ::std::unique_ptr< Descriptor_hasValueFrom_DescriptorValueDomain_type >);

    Descriptor (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    Descriptor (const Descriptor& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual Descriptor*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Descriptor&
    operator= (const Descriptor& x);

    virtual 
    ~Descriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Descriptor_refersTo_ReferenceValue_sequence Descriptor_refersTo_ReferenceValue_;
    ::xsd::cxx::tree::one< Descriptor_identifies_ReferenceVariable_type > Descriptor_identifies_ReferenceVariable_;
    ::xsd::cxx::tree::one< Descriptor_hasValueFrom_DescriptorValueDomain_type > Descriptor_hasValueFrom_DescriptorValueDomain_;
  };

  class ValueDomain: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // displayLabel
    //
    typedef ::XMLSchema::LabelForDisplay displayLabel_type;
    typedef ::xsd::cxx::tree::sequence< displayLabel_type > displayLabel_sequence;
    typedef displayLabel_sequence::iterator displayLabel_iterator;
    typedef displayLabel_sequence::const_iterator displayLabel_const_iterator;
    typedef ::xsd::cxx::tree::traits< displayLabel_type, char > displayLabel_traits;

    const displayLabel_sequence&
    displayLabel () const;

    displayLabel_sequence&
    displayLabel ();

    void
    displayLabel (const displayLabel_sequence& s);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // recommendedDataType
    //
    typedef ::XMLSchema::ControlledVocabularyEntry recommendedDataType_type;
    typedef ::xsd::cxx::tree::sequence< recommendedDataType_type > recommendedDataType_sequence;
    typedef recommendedDataType_sequence::iterator recommendedDataType_iterator;
    typedef recommendedDataType_sequence::const_iterator recommendedDataType_const_iterator;
    typedef ::xsd::cxx::tree::traits< recommendedDataType_type, char > recommendedDataType_traits;

    const recommendedDataType_sequence&
    recommendedDataType () const;

    recommendedDataType_sequence&
    recommendedDataType ();

    void
    recommendedDataType (const recommendedDataType_sequence& s);

    // Constructors.
    //
    ValueDomain ();

    ValueDomain (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    ValueDomain (const ValueDomain& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual ValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ValueDomain&
    operator= (const ValueDomain& x);

    virtual 
    ~ValueDomain ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    displayLabel_sequence displayLabel_;
    identifier_optional identifier_;
    recommendedDataType_sequence recommendedDataType_;
  };

  class SubstantiveValueDomain: public ::XMLSchema::ValueDomain
  {
    public:
    // SubstantiveValueDomain_takesValuesFrom_EnumerationDomain
    //
    typedef ::XMLSchema::SubstantiveValueDomain_takesValuesFrom_EnumerationDomain SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_type;
    typedef ::xsd::cxx::tree::optional< SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_type > SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_optional;
    typedef ::xsd::cxx::tree::traits< SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_type, char > SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_traits;

    const SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_optional&
    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain () const;

    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_optional&
    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain ();

    void
    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain (const SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_type& x);

    void
    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain (const SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_optional& x);

    void
    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain (::std::unique_ptr< SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_type > p);

    // SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription
    //
    typedef ::XMLSchema::SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_type;
    typedef ::xsd::cxx::tree::optional< SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_type > SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_optional;
    typedef ::xsd::cxx::tree::traits< SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_type, char > SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_traits;

    const SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_optional&
    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription () const;

    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_optional&
    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription ();

    void
    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription (const SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_type& x);

    void
    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription (const SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_optional& x);

    void
    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription (::std::unique_ptr< SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_type > p);

    // SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain
    //
    typedef ::XMLSchema::SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_type;
    typedef ::xsd::cxx::tree::optional< SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_type > SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_optional;
    typedef ::xsd::cxx::tree::traits< SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_type, char > SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_traits;

    const SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_optional&
    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain () const;

    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_optional&
    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain ();

    void
    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain (const SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_type& x);

    void
    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain (const SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_optional& x);

    void
    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain (::std::unique_ptr< SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_type > p);

    // Constructors.
    //
    SubstantiveValueDomain ();

    SubstantiveValueDomain (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    SubstantiveValueDomain (const SubstantiveValueDomain& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual SubstantiveValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SubstantiveValueDomain&
    operator= (const SubstantiveValueDomain& x);

    virtual 
    ~SubstantiveValueDomain ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_optional SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_;
    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_optional SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_;
    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_optional SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_;
  };

  class DescriptorValueDomain: public ::XMLSchema::SubstantiveValueDomain
  {
    public:
    // Constructors.
    //
    DescriptorValueDomain ();

    DescriptorValueDomain (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    DescriptorValueDomain (const DescriptorValueDomain& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual DescriptorValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DescriptorValueDomain&
    operator= (const DescriptorValueDomain&) = default;
#endif

    virtual 
    ~DescriptorValueDomain ();
  };

  class RepresentedVariable: public ::XMLSchema::ConceptualVariable
  {
    public:
    // describedUnitOfMeasure
    //
    typedef ::XMLSchema::ControlledVocabularyEntry describedUnitOfMeasure_type;
    typedef ::xsd::cxx::tree::optional< describedUnitOfMeasure_type > describedUnitOfMeasure_optional;
    typedef ::xsd::cxx::tree::traits< describedUnitOfMeasure_type, char > describedUnitOfMeasure_traits;

    const describedUnitOfMeasure_optional&
    describedUnitOfMeasure () const;

    describedUnitOfMeasure_optional&
    describedUnitOfMeasure ();

    void
    describedUnitOfMeasure (const describedUnitOfMeasure_type& x);

    void
    describedUnitOfMeasure (const describedUnitOfMeasure_optional& x);

    void
    describedUnitOfMeasure (::std::unique_ptr< describedUnitOfMeasure_type > p);

    // hasIntendedDataType
    //
    typedef ::XMLSchema::ControlledVocabularyEntry hasIntendedDataType_type;
    typedef ::xsd::cxx::tree::optional< hasIntendedDataType_type > hasIntendedDataType_optional;
    typedef ::xsd::cxx::tree::traits< hasIntendedDataType_type, char > hasIntendedDataType_traits;

    const hasIntendedDataType_optional&
    hasIntendedDataType () const;

    hasIntendedDataType_optional&
    hasIntendedDataType ();

    void
    hasIntendedDataType (const hasIntendedDataType_type& x);

    void
    hasIntendedDataType (const hasIntendedDataType_optional& x);

    void
    hasIntendedDataType (::std::unique_ptr< hasIntendedDataType_type > p);

    // simpleUnitOfMeasure
    //
    typedef ::xml_schema::string simpleUnitOfMeasure_type;
    typedef ::xsd::cxx::tree::optional< simpleUnitOfMeasure_type > simpleUnitOfMeasure_optional;
    typedef ::xsd::cxx::tree::traits< simpleUnitOfMeasure_type, char > simpleUnitOfMeasure_traits;

    const simpleUnitOfMeasure_optional&
    simpleUnitOfMeasure () const;

    simpleUnitOfMeasure_optional&
    simpleUnitOfMeasure ();

    void
    simpleUnitOfMeasure (const simpleUnitOfMeasure_type& x);

    void
    simpleUnitOfMeasure (const simpleUnitOfMeasure_optional& x);

    void
    simpleUnitOfMeasure (::std::unique_ptr< simpleUnitOfMeasure_type > p);

    // RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain
    //
    typedef ::XMLSchema::RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_type;
    typedef ::xsd::cxx::tree::sequence< RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_type > RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_sequence;
    typedef RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_sequence::iterator RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_iterator;
    typedef RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_sequence::const_iterator RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_const_iterator;
    typedef ::xsd::cxx::tree::traits< RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_type, char > RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_traits;

    const RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_sequence&
    RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain () const;

    RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_sequence&
    RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain ();

    void
    RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain (const RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_sequence& s);

    // RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain
    //
    typedef ::XMLSchema::RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_type;
    typedef ::xsd::cxx::tree::optional< RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_type > RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_optional;
    typedef ::xsd::cxx::tree::traits< RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_type, char > RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_traits;

    const RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_optional&
    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain () const;

    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_optional&
    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain ();

    void
    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain (const RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_type& x);

    void
    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain (const RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_optional& x);

    void
    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain (::std::unique_ptr< RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_type > p);

    // Constructors.
    //
    RepresentedVariable ();

    RepresentedVariable (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    RepresentedVariable (const RepresentedVariable& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual RepresentedVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RepresentedVariable&
    operator= (const RepresentedVariable& x);

    virtual 
    ~RepresentedVariable ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    describedUnitOfMeasure_optional describedUnitOfMeasure_;
    hasIntendedDataType_optional hasIntendedDataType_;
    simpleUnitOfMeasure_optional simpleUnitOfMeasure_;
    RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_sequence RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_;
    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_optional RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_;
  };

  class DescriptorVariable: public ::XMLSchema::RepresentedVariable
  {
    public:
    // DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain
    //
    typedef ::XMLSchema::DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_type;
    typedef ::xsd::cxx::tree::optional< DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_type > DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_optional;
    typedef ::xsd::cxx::tree::traits< DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_type, char > DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_traits;

    const DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_optional&
    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain () const;

    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_optional&
    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain ();

    void
    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain (const DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_type& x);

    void
    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain (const DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_optional& x);

    void
    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain (::std::unique_ptr< DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_type > p);

    // Constructors.
    //
    DescriptorVariable ();

    DescriptorVariable (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    DescriptorVariable (const DescriptorVariable& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual DescriptorVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DescriptorVariable&
    operator= (const DescriptorVariable& x);

    virtual 
    ~DescriptorVariable ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_optional DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_;
  };

  class DimensionComponent: public ::XMLSchema::DataStructureComponent
  {
    public:
    // categoricalAdditivity
    //
    typedef ::xml_schema::boolean categoricalAdditivity_type;
    typedef ::xsd::cxx::tree::optional< categoricalAdditivity_type > categoricalAdditivity_optional;
    typedef ::xsd::cxx::tree::traits< categoricalAdditivity_type, char > categoricalAdditivity_traits;

    const categoricalAdditivity_optional&
    categoricalAdditivity () const;

    categoricalAdditivity_optional&
    categoricalAdditivity ();

    void
    categoricalAdditivity (const categoricalAdditivity_type& x);

    void
    categoricalAdditivity (const categoricalAdditivity_optional& x);

    // DimensionComponent_isStructuredBy_ValueDomain
    //
    typedef ::XMLSchema::DimensionComponent_isStructuredBy_ValueDomain DimensionComponent_isStructuredBy_ValueDomain_type;
    typedef ::xsd::cxx::tree::optional< DimensionComponent_isStructuredBy_ValueDomain_type > DimensionComponent_isStructuredBy_ValueDomain_optional;
    typedef ::xsd::cxx::tree::traits< DimensionComponent_isStructuredBy_ValueDomain_type, char > DimensionComponent_isStructuredBy_ValueDomain_traits;

    const DimensionComponent_isStructuredBy_ValueDomain_optional&
    DimensionComponent_isStructuredBy_ValueDomain () const;

    DimensionComponent_isStructuredBy_ValueDomain_optional&
    DimensionComponent_isStructuredBy_ValueDomain ();

    void
    DimensionComponent_isStructuredBy_ValueDomain (const DimensionComponent_isStructuredBy_ValueDomain_type& x);

    void
    DimensionComponent_isStructuredBy_ValueDomain (const DimensionComponent_isStructuredBy_ValueDomain_optional& x);

    void
    DimensionComponent_isStructuredBy_ValueDomain (::std::unique_ptr< DimensionComponent_isStructuredBy_ValueDomain_type > p);

    // Constructors.
    //
    DimensionComponent ();

    DimensionComponent (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    DimensionComponent (const DimensionComponent& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual DimensionComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DimensionComponent&
    operator= (const DimensionComponent& x);

    virtual 
    ~DimensionComponent ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    categoricalAdditivity_optional categoricalAdditivity_;
    DimensionComponent_isStructuredBy_ValueDomain_optional DimensionComponent_isStructuredBy_ValueDomain_;
  };

  class DimensionGroup: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // DimensionGroup_has_DimensionComponent
    //
    typedef ::XMLSchema::DimensionGroup_has_DimensionComponent DimensionGroup_has_DimensionComponent_type;
    typedef ::xsd::cxx::tree::sequence< DimensionGroup_has_DimensionComponent_type > DimensionGroup_has_DimensionComponent_sequence;
    typedef DimensionGroup_has_DimensionComponent_sequence::iterator DimensionGroup_has_DimensionComponent_iterator;
    typedef DimensionGroup_has_DimensionComponent_sequence::const_iterator DimensionGroup_has_DimensionComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionGroup_has_DimensionComponent_type, char > DimensionGroup_has_DimensionComponent_traits;

    const DimensionGroup_has_DimensionComponent_sequence&
    DimensionGroup_has_DimensionComponent () const;

    DimensionGroup_has_DimensionComponent_sequence&
    DimensionGroup_has_DimensionComponent ();

    void
    DimensionGroup_has_DimensionComponent (const DimensionGroup_has_DimensionComponent_sequence& s);

    // Constructors.
    //
    DimensionGroup ();

    DimensionGroup (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    DimensionGroup (const DimensionGroup& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual DimensionGroup*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DimensionGroup&
    operator= (const DimensionGroup& x);

    virtual 
    ~DimensionGroup ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    name_sequence name_;
    DimensionGroup_has_DimensionComponent_sequence DimensionGroup_has_DimensionComponent_;
  };

  class DimensionalDataSet: public ::XMLSchema::DataSet
  {
    public:
    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // DimensionalDataSet_represents_ScopedMeasure
    //
    typedef ::XMLSchema::DimensionalDataSet_represents_ScopedMeasure DimensionalDataSet_represents_ScopedMeasure_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalDataSet_represents_ScopedMeasure_type > DimensionalDataSet_represents_ScopedMeasure_sequence;
    typedef DimensionalDataSet_represents_ScopedMeasure_sequence::iterator DimensionalDataSet_represents_ScopedMeasure_iterator;
    typedef DimensionalDataSet_represents_ScopedMeasure_sequence::const_iterator DimensionalDataSet_represents_ScopedMeasure_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalDataSet_represents_ScopedMeasure_type, char > DimensionalDataSet_represents_ScopedMeasure_traits;

    const DimensionalDataSet_represents_ScopedMeasure_sequence&
    DimensionalDataSet_represents_ScopedMeasure () const;

    DimensionalDataSet_represents_ScopedMeasure_sequence&
    DimensionalDataSet_represents_ScopedMeasure ();

    void
    DimensionalDataSet_represents_ScopedMeasure (const DimensionalDataSet_represents_ScopedMeasure_sequence& s);

    // Constructors.
    //
    DimensionalDataSet ();

    DimensionalDataSet (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    DimensionalDataSet (const DimensionalDataSet& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual DimensionalDataSet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DimensionalDataSet&
    operator= (const DimensionalDataSet& x);

    virtual 
    ~DimensionalDataSet ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    name_sequence name_;
    DimensionalDataSet_represents_ScopedMeasure_sequence DimensionalDataSet_represents_ScopedMeasure_;
  };

  class DimensionalDataStructure: public ::XMLSchema::DataStructure
  {
    public:
    // DimensionalDataStructure_uses_DimensionGroup
    //
    typedef ::XMLSchema::DimensionalDataStructure_uses_DimensionGroup DimensionalDataStructure_uses_DimensionGroup_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalDataStructure_uses_DimensionGroup_type > DimensionalDataStructure_uses_DimensionGroup_sequence;
    typedef DimensionalDataStructure_uses_DimensionGroup_sequence::iterator DimensionalDataStructure_uses_DimensionGroup_iterator;
    typedef DimensionalDataStructure_uses_DimensionGroup_sequence::const_iterator DimensionalDataStructure_uses_DimensionGroup_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalDataStructure_uses_DimensionGroup_type, char > DimensionalDataStructure_uses_DimensionGroup_traits;

    const DimensionalDataStructure_uses_DimensionGroup_sequence&
    DimensionalDataStructure_uses_DimensionGroup () const;

    DimensionalDataStructure_uses_DimensionGroup_sequence&
    DimensionalDataStructure_uses_DimensionGroup ();

    void
    DimensionalDataStructure_uses_DimensionGroup (const DimensionalDataStructure_uses_DimensionGroup_sequence& s);

    // Constructors.
    //
    DimensionalDataStructure ();

    DimensionalDataStructure (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    DimensionalDataStructure (const DimensionalDataStructure& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual DimensionalDataStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DimensionalDataStructure&
    operator= (const DimensionalDataStructure& x);

    virtual 
    ~DimensionalDataStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DimensionalDataStructure_uses_DimensionGroup_sequence DimensionalDataStructure_uses_DimensionGroup_;
  };

  class Key: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // Key_correspondsTo_Unit
    //
    typedef ::XMLSchema::Key_correspondsTo_Unit Key_correspondsTo_Unit_type;
    typedef ::xsd::cxx::tree::optional< Key_correspondsTo_Unit_type > Key_correspondsTo_Unit_optional;
    typedef ::xsd::cxx::tree::traits< Key_correspondsTo_Unit_type, char > Key_correspondsTo_Unit_traits;

    const Key_correspondsTo_Unit_optional&
    Key_correspondsTo_Unit () const;

    Key_correspondsTo_Unit_optional&
    Key_correspondsTo_Unit ();

    void
    Key_correspondsTo_Unit (const Key_correspondsTo_Unit_type& x);

    void
    Key_correspondsTo_Unit (const Key_correspondsTo_Unit_optional& x);

    void
    Key_correspondsTo_Unit (::std::unique_ptr< Key_correspondsTo_Unit_type > p);

    // Key_represents_KeyDefinition
    //
    typedef ::XMLSchema::Key_represents_KeyDefinition Key_represents_KeyDefinition_type;
    typedef ::xsd::cxx::tree::optional< Key_represents_KeyDefinition_type > Key_represents_KeyDefinition_optional;
    typedef ::xsd::cxx::tree::traits< Key_represents_KeyDefinition_type, char > Key_represents_KeyDefinition_traits;

    const Key_represents_KeyDefinition_optional&
    Key_represents_KeyDefinition () const;

    Key_represents_KeyDefinition_optional&
    Key_represents_KeyDefinition ();

    void
    Key_represents_KeyDefinition (const Key_represents_KeyDefinition_type& x);

    void
    Key_represents_KeyDefinition (const Key_represents_KeyDefinition_optional& x);

    void
    Key_represents_KeyDefinition (::std::unique_ptr< Key_represents_KeyDefinition_type > p);

    // Key_identifies_DataPoint
    //
    typedef ::XMLSchema::Key_identifies_DataPoint Key_identifies_DataPoint_type;
    typedef ::xsd::cxx::tree::sequence< Key_identifies_DataPoint_type > Key_identifies_DataPoint_sequence;
    typedef Key_identifies_DataPoint_sequence::iterator Key_identifies_DataPoint_iterator;
    typedef Key_identifies_DataPoint_sequence::const_iterator Key_identifies_DataPoint_const_iterator;
    typedef ::xsd::cxx::tree::traits< Key_identifies_DataPoint_type, char > Key_identifies_DataPoint_traits;

    const Key_identifies_DataPoint_sequence&
    Key_identifies_DataPoint () const;

    Key_identifies_DataPoint_sequence&
    Key_identifies_DataPoint ();

    void
    Key_identifies_DataPoint (const Key_identifies_DataPoint_sequence& s);

    // Key_correspondsTo_Universe
    //
    typedef ::XMLSchema::Key_correspondsTo_Universe Key_correspondsTo_Universe_type;
    typedef ::xsd::cxx::tree::optional< Key_correspondsTo_Universe_type > Key_correspondsTo_Universe_optional;
    typedef ::xsd::cxx::tree::traits< Key_correspondsTo_Universe_type, char > Key_correspondsTo_Universe_traits;

    const Key_correspondsTo_Universe_optional&
    Key_correspondsTo_Universe () const;

    Key_correspondsTo_Universe_optional&
    Key_correspondsTo_Universe ();

    void
    Key_correspondsTo_Universe (const Key_correspondsTo_Universe_type& x);

    void
    Key_correspondsTo_Universe (const Key_correspondsTo_Universe_optional& x);

    void
    Key_correspondsTo_Universe (::std::unique_ptr< Key_correspondsTo_Universe_type > p);

    // Key_has_KeyMember
    //
    typedef ::XMLSchema::Key_has_KeyMember Key_has_KeyMember_type;
    typedef ::xsd::cxx::tree::sequence< Key_has_KeyMember_type > Key_has_KeyMember_sequence;
    typedef Key_has_KeyMember_sequence::iterator Key_has_KeyMember_iterator;
    typedef Key_has_KeyMember_sequence::const_iterator Key_has_KeyMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< Key_has_KeyMember_type, char > Key_has_KeyMember_traits;

    const Key_has_KeyMember_sequence&
    Key_has_KeyMember () const;

    Key_has_KeyMember_sequence&
    Key_has_KeyMember ();

    void
    Key_has_KeyMember (const Key_has_KeyMember_sequence& s);

    // Constructors.
    //
    Key ();

    Key (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    Key (const Key& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    virtual Key*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Key&
    operator= (const Key& x);

    virtual 
    ~Key ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    Key_correspondsTo_Unit_optional Key_correspondsTo_Unit_;
    Key_represents_KeyDefinition_optional Key_represents_KeyDefinition_;
    Key_identifies_DataPoint_sequence Key_identifies_DataPoint_;
    Key_correspondsTo_Universe_optional Key_correspondsTo_Universe_;
    Key_has_KeyMember_sequence Key_has_KeyMember_;
  };

  class DimensionalKey: public ::XMLSchema::Key
  {
    public:
    // Constructors.
    //
    DimensionalKey ();

    DimensionalKey (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    DimensionalKey (const DimensionalKey& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual DimensionalKey*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DimensionalKey&
    operator= (const DimensionalKey&) = default;
#endif

    virtual 
    ~DimensionalKey ();
  };

  class KeyDefinition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // KeyDefinition_correspondsTo_Universe
    //
    typedef ::XMLSchema::KeyDefinition_correspondsTo_Universe KeyDefinition_correspondsTo_Universe_type;
    typedef ::xsd::cxx::tree::optional< KeyDefinition_correspondsTo_Universe_type > KeyDefinition_correspondsTo_Universe_optional;
    typedef ::xsd::cxx::tree::traits< KeyDefinition_correspondsTo_Universe_type, char > KeyDefinition_correspondsTo_Universe_traits;

    const KeyDefinition_correspondsTo_Universe_optional&
    KeyDefinition_correspondsTo_Universe () const;

    KeyDefinition_correspondsTo_Universe_optional&
    KeyDefinition_correspondsTo_Universe ();

    void
    KeyDefinition_correspondsTo_Universe (const KeyDefinition_correspondsTo_Universe_type& x);

    void
    KeyDefinition_correspondsTo_Universe (const KeyDefinition_correspondsTo_Universe_optional& x);

    void
    KeyDefinition_correspondsTo_Universe (::std::unique_ptr< KeyDefinition_correspondsTo_Universe_type > p);

    // KeyDefinition_correspondsTo_Unit
    //
    typedef ::XMLSchema::KeyDefinition_correspondsTo_Unit KeyDefinition_correspondsTo_Unit_type;
    typedef ::xsd::cxx::tree::optional< KeyDefinition_correspondsTo_Unit_type > KeyDefinition_correspondsTo_Unit_optional;
    typedef ::xsd::cxx::tree::traits< KeyDefinition_correspondsTo_Unit_type, char > KeyDefinition_correspondsTo_Unit_traits;

    const KeyDefinition_correspondsTo_Unit_optional&
    KeyDefinition_correspondsTo_Unit () const;

    KeyDefinition_correspondsTo_Unit_optional&
    KeyDefinition_correspondsTo_Unit ();

    void
    KeyDefinition_correspondsTo_Unit (const KeyDefinition_correspondsTo_Unit_type& x);

    void
    KeyDefinition_correspondsTo_Unit (const KeyDefinition_correspondsTo_Unit_optional& x);

    void
    KeyDefinition_correspondsTo_Unit (::std::unique_ptr< KeyDefinition_correspondsTo_Unit_type > p);

    // KeyDefinition_has_KeyDefinitionMember
    //
    typedef ::XMLSchema::KeyDefinition_has_KeyDefinitionMember KeyDefinition_has_KeyDefinitionMember_type;
    typedef ::xsd::cxx::tree::sequence< KeyDefinition_has_KeyDefinitionMember_type > KeyDefinition_has_KeyDefinitionMember_sequence;
    typedef KeyDefinition_has_KeyDefinitionMember_sequence::iterator KeyDefinition_has_KeyDefinitionMember_iterator;
    typedef KeyDefinition_has_KeyDefinitionMember_sequence::const_iterator KeyDefinition_has_KeyDefinitionMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< KeyDefinition_has_KeyDefinitionMember_type, char > KeyDefinition_has_KeyDefinitionMember_traits;

    const KeyDefinition_has_KeyDefinitionMember_sequence&
    KeyDefinition_has_KeyDefinitionMember () const;

    KeyDefinition_has_KeyDefinitionMember_sequence&
    KeyDefinition_has_KeyDefinitionMember ();

    void
    KeyDefinition_has_KeyDefinitionMember (const KeyDefinition_has_KeyDefinitionMember_sequence& s);

    // Constructors.
    //
    KeyDefinition ();

    KeyDefinition (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    KeyDefinition (const KeyDefinition& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual KeyDefinition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    KeyDefinition&
    operator= (const KeyDefinition& x);

    virtual 
    ~KeyDefinition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    KeyDefinition_correspondsTo_Universe_optional KeyDefinition_correspondsTo_Universe_;
    KeyDefinition_correspondsTo_Unit_optional KeyDefinition_correspondsTo_Unit_;
    KeyDefinition_has_KeyDefinitionMember_sequence KeyDefinition_has_KeyDefinitionMember_;
  };

  class DimensionalKeyDefinition: public ::XMLSchema::KeyDefinition
  {
    public:
    // Constructors.
    //
    DimensionalKeyDefinition ();

    DimensionalKeyDefinition (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    DimensionalKeyDefinition (const DimensionalKeyDefinition& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual DimensionalKeyDefinition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DimensionalKeyDefinition&
    operator= (const DimensionalKeyDefinition&) = default;
#endif

    virtual 
    ~DimensionalKeyDefinition ();
  };

  class DimensionalKeyDefinitionMember: public ::XMLSchema::ConceptualValue
  {
    public:
    // DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember
    //
    typedef ::XMLSchema::DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_type;
    typedef ::xsd::cxx::tree::sequence< DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_type > DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_sequence;
    typedef DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_sequence::iterator DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_iterator;
    typedef DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_sequence::const_iterator DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_type, char > DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_traits;

    const DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_sequence&
    DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember () const;

    DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_sequence&
    DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember ();

    void
    DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember (const DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_sequence& s);

    // Constructors.
    //
    DimensionalKeyDefinitionMember (const ConceptualValue_hasConceptFrom_ConceptualDomain_type&);

    DimensionalKeyDefinitionMember (::std::unique_ptr< ConceptualValue_hasConceptFrom_ConceptualDomain_type >);

    DimensionalKeyDefinitionMember (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    DimensionalKeyDefinitionMember (const DimensionalKeyDefinitionMember& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual DimensionalKeyDefinitionMember*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DimensionalKeyDefinitionMember&
    operator= (const DimensionalKeyDefinitionMember& x);

    virtual 
    ~DimensionalKeyDefinitionMember ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_sequence DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_;
  };

  class DimensionalKeyMember: public ::XMLSchema::KeyMember
  {
    public:
    // DimensionalKeyMember_hasValueFrom_CodeList
    //
    typedef ::XMLSchema::DimensionalKeyMember_hasValueFrom_CodeList DimensionalKeyMember_hasValueFrom_CodeList_type;
    typedef ::xsd::cxx::tree::traits< DimensionalKeyMember_hasValueFrom_CodeList_type, char > DimensionalKeyMember_hasValueFrom_CodeList_traits;

    const DimensionalKeyMember_hasValueFrom_CodeList_type&
    DimensionalKeyMember_hasValueFrom_CodeList () const;

    DimensionalKeyMember_hasValueFrom_CodeList_type&
    DimensionalKeyMember_hasValueFrom_CodeList ();

    void
    DimensionalKeyMember_hasValueFrom_CodeList (const DimensionalKeyMember_hasValueFrom_CodeList_type& x);

    void
    DimensionalKeyMember_hasValueFrom_CodeList (::std::unique_ptr< DimensionalKeyMember_hasValueFrom_CodeList_type > p);

    // Constructors.
    //
    DimensionalKeyMember (const InstanceValue_hasValueFrom_ValueDomain_type&,
                          const DimensionalKeyMember_hasValueFrom_CodeList_type&);

    DimensionalKeyMember (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type >,
                          ::std::unique_ptr< DimensionalKeyMember_hasValueFrom_CodeList_type >);

    DimensionalKeyMember (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    DimensionalKeyMember (const DimensionalKeyMember& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual DimensionalKeyMember*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DimensionalKeyMember&
    operator= (const DimensionalKeyMember& x);

    virtual 
    ~DimensionalKeyMember ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< DimensionalKeyMember_hasValueFrom_CodeList_type > DimensionalKeyMember_hasValueFrom_CodeList_;
  };

  class ForeignKey: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // ForeignKey_isComposedOf_ForeignKeyComponent
    //
    typedef ::XMLSchema::ForeignKey_isComposedOf_ForeignKeyComponent ForeignKey_isComposedOf_ForeignKeyComponent_type;
    typedef ::xsd::cxx::tree::sequence< ForeignKey_isComposedOf_ForeignKeyComponent_type > ForeignKey_isComposedOf_ForeignKeyComponent_sequence;
    typedef ForeignKey_isComposedOf_ForeignKeyComponent_sequence::iterator ForeignKey_isComposedOf_ForeignKeyComponent_iterator;
    typedef ForeignKey_isComposedOf_ForeignKeyComponent_sequence::const_iterator ForeignKey_isComposedOf_ForeignKeyComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< ForeignKey_isComposedOf_ForeignKeyComponent_type, char > ForeignKey_isComposedOf_ForeignKeyComponent_traits;

    const ForeignKey_isComposedOf_ForeignKeyComponent_sequence&
    ForeignKey_isComposedOf_ForeignKeyComponent () const;

    ForeignKey_isComposedOf_ForeignKeyComponent_sequence&
    ForeignKey_isComposedOf_ForeignKeyComponent ();

    void
    ForeignKey_isComposedOf_ForeignKeyComponent (const ForeignKey_isComposedOf_ForeignKeyComponent_sequence& s);

    // Constructors.
    //
    ForeignKey ();

    ForeignKey (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    ForeignKey (const ForeignKey& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual ForeignKey*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ForeignKey&
    operator= (const ForeignKey& x);

    virtual 
    ~ForeignKey ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ForeignKey_isComposedOf_ForeignKeyComponent_sequence ForeignKey_isComposedOf_ForeignKeyComponent_;
  };

  class ForeignKeyComponent: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // ForeignKeyComponent_references_PrimaryKeyComponent
    //
    typedef ::XMLSchema::ForeignKeyComponent_references_PrimaryKeyComponent ForeignKeyComponent_references_PrimaryKeyComponent_type;
    typedef ::xsd::cxx::tree::traits< ForeignKeyComponent_references_PrimaryKeyComponent_type, char > ForeignKeyComponent_references_PrimaryKeyComponent_traits;

    const ForeignKeyComponent_references_PrimaryKeyComponent_type&
    ForeignKeyComponent_references_PrimaryKeyComponent () const;

    ForeignKeyComponent_references_PrimaryKeyComponent_type&
    ForeignKeyComponent_references_PrimaryKeyComponent ();

    void
    ForeignKeyComponent_references_PrimaryKeyComponent (const ForeignKeyComponent_references_PrimaryKeyComponent_type& x);

    void
    ForeignKeyComponent_references_PrimaryKeyComponent (::std::unique_ptr< ForeignKeyComponent_references_PrimaryKeyComponent_type > p);

    // ForeignKeyComponent_correspondsTo_DataStructureComponent
    //
    typedef ::XMLSchema::ForeignKeyComponent_correspondsTo_DataStructureComponent ForeignKeyComponent_correspondsTo_DataStructureComponent_type;
    typedef ::xsd::cxx::tree::traits< ForeignKeyComponent_correspondsTo_DataStructureComponent_type, char > ForeignKeyComponent_correspondsTo_DataStructureComponent_traits;

    const ForeignKeyComponent_correspondsTo_DataStructureComponent_type&
    ForeignKeyComponent_correspondsTo_DataStructureComponent () const;

    ForeignKeyComponent_correspondsTo_DataStructureComponent_type&
    ForeignKeyComponent_correspondsTo_DataStructureComponent ();

    void
    ForeignKeyComponent_correspondsTo_DataStructureComponent (const ForeignKeyComponent_correspondsTo_DataStructureComponent_type& x);

    void
    ForeignKeyComponent_correspondsTo_DataStructureComponent (::std::unique_ptr< ForeignKeyComponent_correspondsTo_DataStructureComponent_type > p);

    // Constructors.
    //
    ForeignKeyComponent (const ForeignKeyComponent_references_PrimaryKeyComponent_type&,
                         const ForeignKeyComponent_correspondsTo_DataStructureComponent_type&);

    ForeignKeyComponent (::std::unique_ptr< ForeignKeyComponent_references_PrimaryKeyComponent_type >,
                         ::std::unique_ptr< ForeignKeyComponent_correspondsTo_DataStructureComponent_type >);

    ForeignKeyComponent (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ForeignKeyComponent (const ForeignKeyComponent& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual ForeignKeyComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ForeignKeyComponent&
    operator= (const ForeignKeyComponent& x);

    virtual 
    ~ForeignKeyComponent ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< ForeignKeyComponent_references_PrimaryKeyComponent_type > ForeignKeyComponent_references_PrimaryKeyComponent_;
    ::xsd::cxx::tree::one< ForeignKeyComponent_correspondsTo_DataStructureComponent_type > ForeignKeyComponent_correspondsTo_DataStructureComponent_;
  };

  class IdentifierComponent: public ::XMLSchema::DataStructureComponent
  {
    public:
    // Constructors.
    //
    IdentifierComponent ();

    IdentifierComponent (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    IdentifierComponent (const IdentifierComponent& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual IdentifierComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    IdentifierComponent&
    operator= (const IdentifierComponent&) = default;
#endif

    virtual 
    ~IdentifierComponent ();
  };

  class Individual: public ::XMLSchema::Agent
  {
    public:
    // contactInformation
    //
    typedef ::XMLSchema::ContactInformation contactInformation_type;
    typedef ::xsd::cxx::tree::optional< contactInformation_type > contactInformation_optional;
    typedef ::xsd::cxx::tree::traits< contactInformation_type, char > contactInformation_traits;

    const contactInformation_optional&
    contactInformation () const;

    contactInformation_optional&
    contactInformation ();

    void
    contactInformation (const contactInformation_type& x);

    void
    contactInformation (const contactInformation_optional& x);

    void
    contactInformation (::std::unique_ptr< contactInformation_type > p);

    // individualName
    //
    typedef ::XMLSchema::IndividualName individualName_type;
    typedef ::xsd::cxx::tree::sequence< individualName_type > individualName_sequence;
    typedef individualName_sequence::iterator individualName_iterator;
    typedef individualName_sequence::const_iterator individualName_const_iterator;
    typedef ::xsd::cxx::tree::traits< individualName_type, char > individualName_traits;

    const individualName_sequence&
    individualName () const;

    individualName_sequence&
    individualName ();

    void
    individualName (const individualName_sequence& s);

    // Constructors.
    //
    Individual ();

    Individual (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    Individual (const Individual& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual Individual*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Individual&
    operator= (const Individual& x);

    virtual 
    ~Individual ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    contactInformation_optional contactInformation_;
    individualName_sequence individualName_;
  };

  class InformationFlowDefinition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // InformationFlowDefinition_from_Parameter
    //
    typedef ::XMLSchema::InformationFlowDefinition_from_Parameter InformationFlowDefinition_from_Parameter_type;
    typedef ::xsd::cxx::tree::optional< InformationFlowDefinition_from_Parameter_type > InformationFlowDefinition_from_Parameter_optional;
    typedef ::xsd::cxx::tree::traits< InformationFlowDefinition_from_Parameter_type, char > InformationFlowDefinition_from_Parameter_traits;

    const InformationFlowDefinition_from_Parameter_optional&
    InformationFlowDefinition_from_Parameter () const;

    InformationFlowDefinition_from_Parameter_optional&
    InformationFlowDefinition_from_Parameter ();

    void
    InformationFlowDefinition_from_Parameter (const InformationFlowDefinition_from_Parameter_type& x);

    void
    InformationFlowDefinition_from_Parameter (const InformationFlowDefinition_from_Parameter_optional& x);

    void
    InformationFlowDefinition_from_Parameter (::std::unique_ptr< InformationFlowDefinition_from_Parameter_type > p);

    // InformationFlowDefinition_to_Parameter
    //
    typedef ::XMLSchema::InformationFlowDefinition_to_Parameter InformationFlowDefinition_to_Parameter_type;
    typedef ::xsd::cxx::tree::sequence< InformationFlowDefinition_to_Parameter_type > InformationFlowDefinition_to_Parameter_sequence;
    typedef InformationFlowDefinition_to_Parameter_sequence::iterator InformationFlowDefinition_to_Parameter_iterator;
    typedef InformationFlowDefinition_to_Parameter_sequence::const_iterator InformationFlowDefinition_to_Parameter_const_iterator;
    typedef ::xsd::cxx::tree::traits< InformationFlowDefinition_to_Parameter_type, char > InformationFlowDefinition_to_Parameter_traits;

    const InformationFlowDefinition_to_Parameter_sequence&
    InformationFlowDefinition_to_Parameter () const;

    InformationFlowDefinition_to_Parameter_sequence&
    InformationFlowDefinition_to_Parameter ();

    void
    InformationFlowDefinition_to_Parameter (const InformationFlowDefinition_to_Parameter_sequence& s);

    // Constructors.
    //
    InformationFlowDefinition ();

    InformationFlowDefinition (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    InformationFlowDefinition (const InformationFlowDefinition& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual InformationFlowDefinition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InformationFlowDefinition&
    operator= (const InformationFlowDefinition& x);

    virtual 
    ~InformationFlowDefinition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    InformationFlowDefinition_from_Parameter_optional InformationFlowDefinition_from_Parameter_;
    InformationFlowDefinition_to_Parameter_sequence InformationFlowDefinition_to_Parameter_;
  };

  class InstanceKey: public ::XMLSchema::Key
  {
    public:
    // InstanceKey_has_InstanceValue
    //
    typedef ::XMLSchema::InstanceKey_has_InstanceValue InstanceKey_has_InstanceValue_type;
    typedef ::xsd::cxx::tree::optional< InstanceKey_has_InstanceValue_type > InstanceKey_has_InstanceValue_optional;
    typedef ::xsd::cxx::tree::traits< InstanceKey_has_InstanceValue_type, char > InstanceKey_has_InstanceValue_traits;

    const InstanceKey_has_InstanceValue_optional&
    InstanceKey_has_InstanceValue () const;

    InstanceKey_has_InstanceValue_optional&
    InstanceKey_has_InstanceValue ();

    void
    InstanceKey_has_InstanceValue (const InstanceKey_has_InstanceValue_type& x);

    void
    InstanceKey_has_InstanceValue (const InstanceKey_has_InstanceValue_optional& x);

    void
    InstanceKey_has_InstanceValue (::std::unique_ptr< InstanceKey_has_InstanceValue_type > p);

    // InstanceKey_refersTo_ReferenceValue
    //
    typedef ::XMLSchema::InstanceKey_refersTo_ReferenceValue InstanceKey_refersTo_ReferenceValue_type;
    typedef ::xsd::cxx::tree::traits< InstanceKey_refersTo_ReferenceValue_type, char > InstanceKey_refersTo_ReferenceValue_traits;

    const InstanceKey_refersTo_ReferenceValue_type&
    InstanceKey_refersTo_ReferenceValue () const;

    InstanceKey_refersTo_ReferenceValue_type&
    InstanceKey_refersTo_ReferenceValue ();

    void
    InstanceKey_refersTo_ReferenceValue (const InstanceKey_refersTo_ReferenceValue_type& x);

    void
    InstanceKey_refersTo_ReferenceValue (::std::unique_ptr< InstanceKey_refersTo_ReferenceValue_type > p);

    // Constructors.
    //
    InstanceKey (const InstanceKey_refersTo_ReferenceValue_type&);

    InstanceKey (::std::unique_ptr< InstanceKey_refersTo_ReferenceValue_type >);

    InstanceKey (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    InstanceKey (const InstanceKey& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual InstanceKey*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InstanceKey&
    operator= (const InstanceKey& x);

    virtual 
    ~InstanceKey ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    InstanceKey_has_InstanceValue_optional InstanceKey_has_InstanceValue_;
    ::xsd::cxx::tree::one< InstanceKey_refersTo_ReferenceValue_type > InstanceKey_refersTo_ReferenceValue_;
  };

  class InstanceVariable: public ::XMLSchema::RepresentedVariable
  {
    public:
    // physicalDataType
    //
    typedef ::XMLSchema::ControlledVocabularyEntry physicalDataType_type;
    typedef ::xsd::cxx::tree::optional< physicalDataType_type > physicalDataType_optional;
    typedef ::xsd::cxx::tree::traits< physicalDataType_type, char > physicalDataType_traits;

    const physicalDataType_optional&
    physicalDataType () const;

    physicalDataType_optional&
    physicalDataType ();

    void
    physicalDataType (const physicalDataType_type& x);

    void
    physicalDataType (const physicalDataType_optional& x);

    void
    physicalDataType (::std::unique_ptr< physicalDataType_type > p);

    // platformType
    //
    typedef ::XMLSchema::ControlledVocabularyEntry platformType_type;
    typedef ::xsd::cxx::tree::optional< platformType_type > platformType_optional;
    typedef ::xsd::cxx::tree::traits< platformType_type, char > platformType_traits;

    const platformType_optional&
    platformType () const;

    platformType_optional&
    platformType ();

    void
    platformType (const platformType_type& x);

    void
    platformType (const platformType_optional& x);

    void
    platformType (::std::unique_ptr< platformType_type > p);

    // source
    //
    typedef ::XMLSchema::source source_type;
    typedef ::xsd::cxx::tree::optional< source_type > source_optional;
    typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

    const source_optional&
    source () const;

    source_optional&
    source ();

    void
    source (const source_type& x);

    void
    source (const source_optional& x);

    void
    source (::std::unique_ptr< source_type > p);

    // variableFunction
    //
    typedef ::XMLSchema::ControlledVocabularyEntry variableFunction_type;
    typedef ::xsd::cxx::tree::sequence< variableFunction_type > variableFunction_sequence;
    typedef variableFunction_sequence::iterator variableFunction_iterator;
    typedef variableFunction_sequence::const_iterator variableFunction_const_iterator;
    typedef ::xsd::cxx::tree::traits< variableFunction_type, char > variableFunction_traits;

    const variableFunction_sequence&
    variableFunction () const;

    variableFunction_sequence&
    variableFunction ();

    void
    variableFunction (const variableFunction_sequence& s);

    // Constructors.
    //
    InstanceVariable ();

    InstanceVariable (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    InstanceVariable (const InstanceVariable& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual InstanceVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InstanceVariable&
    operator= (const InstanceVariable& x);

    virtual 
    ~InstanceVariable ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    physicalDataType_optional physicalDataType_;
    platformType_optional platformType_;
    source_optional source_;
    variableFunction_sequence variableFunction_;
  };

  class InstanceVariableMap: public ::xml_schema::type
  {
    public:
    // comparison
    //
    typedef ::XMLSchema::ComparisonOperator comparison_type;
    typedef ::xsd::cxx::tree::traits< comparison_type, char > comparison_traits;

    const comparison_type&
    comparison () const;

    comparison_type&
    comparison ();

    void
    comparison (const comparison_type& x);

    void
    comparison (::std::unique_ptr< comparison_type > p);

    // correspondence
    //
    typedef ::XMLSchema::CorrespondenceDefinition correspondence_type;
    typedef ::xsd::cxx::tree::traits< correspondence_type, char > correspondence_traits;

    const correspondence_type&
    correspondence () const;

    correspondence_type&
    correspondence ();

    void
    correspondence (const correspondence_type& x);

    void
    correspondence (::std::unique_ptr< correspondence_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // setValue
    //
    typedef ::xml_schema::string setValue_type;
    typedef ::xsd::cxx::tree::traits< setValue_type, char > setValue_traits;

    const setValue_type&
    setValue () const;

    setValue_type&
    setValue ();

    void
    setValue (const setValue_type& x);

    void
    setValue (::std::unique_ptr< setValue_type > p);

    // InstanceVariableMap_hasTarget_InstanceVariable
    //
    typedef ::XMLSchema::InstanceVariableMap_hasTarget_InstanceVariable InstanceVariableMap_hasTarget_InstanceVariable_type;
    typedef ::xsd::cxx::tree::sequence< InstanceVariableMap_hasTarget_InstanceVariable_type > InstanceVariableMap_hasTarget_InstanceVariable_sequence;
    typedef InstanceVariableMap_hasTarget_InstanceVariable_sequence::iterator InstanceVariableMap_hasTarget_InstanceVariable_iterator;
    typedef InstanceVariableMap_hasTarget_InstanceVariable_sequence::const_iterator InstanceVariableMap_hasTarget_InstanceVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< InstanceVariableMap_hasTarget_InstanceVariable_type, char > InstanceVariableMap_hasTarget_InstanceVariable_traits;

    const InstanceVariableMap_hasTarget_InstanceVariable_sequence&
    InstanceVariableMap_hasTarget_InstanceVariable () const;

    InstanceVariableMap_hasTarget_InstanceVariable_sequence&
    InstanceVariableMap_hasTarget_InstanceVariable ();

    void
    InstanceVariableMap_hasTarget_InstanceVariable (const InstanceVariableMap_hasTarget_InstanceVariable_sequence& s);

    // InstanceVariableMap_hasSource_InstanceVariable
    //
    typedef ::XMLSchema::InstanceVariableMap_hasSource_InstanceVariable InstanceVariableMap_hasSource_InstanceVariable_type;
    typedef ::xsd::cxx::tree::sequence< InstanceVariableMap_hasSource_InstanceVariable_type > InstanceVariableMap_hasSource_InstanceVariable_sequence;
    typedef InstanceVariableMap_hasSource_InstanceVariable_sequence::iterator InstanceVariableMap_hasSource_InstanceVariable_iterator;
    typedef InstanceVariableMap_hasSource_InstanceVariable_sequence::const_iterator InstanceVariableMap_hasSource_InstanceVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< InstanceVariableMap_hasSource_InstanceVariable_type, char > InstanceVariableMap_hasSource_InstanceVariable_traits;

    const InstanceVariableMap_hasSource_InstanceVariable_sequence&
    InstanceVariableMap_hasSource_InstanceVariable () const;

    InstanceVariableMap_hasSource_InstanceVariable_sequence&
    InstanceVariableMap_hasSource_InstanceVariable ();

    void
    InstanceVariableMap_hasSource_InstanceVariable (const InstanceVariableMap_hasSource_InstanceVariable_sequence& s);

    // Constructors.
    //
    InstanceVariableMap (const comparison_type&,
                         const correspondence_type&,
                         const setValue_type&);

    InstanceVariableMap (const comparison_type&,
                         ::std::unique_ptr< correspondence_type >,
                         const setValue_type&);

    InstanceVariableMap (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    InstanceVariableMap (const InstanceVariableMap& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual InstanceVariableMap*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InstanceVariableMap&
    operator= (const InstanceVariableMap& x);

    virtual 
    ~InstanceVariableMap ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< comparison_type > comparison_;
    ::xsd::cxx::tree::one< correspondence_type > correspondence_;
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< setValue_type > setValue_;
    InstanceVariableMap_hasTarget_InstanceVariable_sequence InstanceVariableMap_hasTarget_InstanceVariable_;
    InstanceVariableMap_hasSource_InstanceVariable_sequence InstanceVariableMap_hasSource_InstanceVariable_;
  };

  class KeyDefinitionMember: public ::XMLSchema::ConceptualValue
  {
    public:
    // Constructors.
    //
    KeyDefinitionMember (const ConceptualValue_hasConceptFrom_ConceptualDomain_type&);

    KeyDefinitionMember (::std::unique_ptr< ConceptualValue_hasConceptFrom_ConceptualDomain_type >);

    KeyDefinitionMember (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    KeyDefinitionMember (const KeyDefinitionMember& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual KeyDefinitionMember*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    KeyDefinitionMember&
    operator= (const KeyDefinitionMember&) = default;
#endif

    virtual 
    ~KeyDefinitionMember ();
  };

  class KeyValueDataStore: public ::XMLSchema::DataSet
  {
    public:
    // Constructors.
    //
    KeyValueDataStore ();

    KeyValueDataStore (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    KeyValueDataStore (const KeyValueDataStore& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual KeyValueDataStore*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    KeyValueDataStore&
    operator= (const KeyValueDataStore&) = default;
#endif

    virtual 
    ~KeyValueDataStore ();
  };

  class KeyValueStructure: public ::XMLSchema::DataStructure
  {
    public:
    // Constructors.
    //
    KeyValueStructure ();

    KeyValueStructure (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    KeyValueStructure (const KeyValueStructure& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual KeyValueStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    KeyValueStructure&
    operator= (const KeyValueStructure&) = default;
#endif

    virtual 
    ~KeyValueStructure ();
  };

  class Level: public ::xml_schema::type
  {
    public:
    // displayLabel
    //
    typedef ::XMLSchema::LabelForDisplay displayLabel_type;
    typedef ::xsd::cxx::tree::sequence< displayLabel_type > displayLabel_sequence;
    typedef displayLabel_sequence::iterator displayLabel_iterator;
    typedef displayLabel_sequence::const_iterator displayLabel_const_iterator;
    typedef ::xsd::cxx::tree::traits< displayLabel_type, char > displayLabel_traits;

    const displayLabel_sequence&
    displayLabel () const;

    displayLabel_sequence&
    displayLabel ();

    void
    displayLabel (const displayLabel_sequence& s);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // levelNumber
    //
    typedef ::xml_schema::integer levelNumber_type;
    typedef ::xsd::cxx::tree::traits< levelNumber_type, char > levelNumber_traits;

    const levelNumber_type&
    levelNumber () const;

    levelNumber_type&
    levelNumber ();

    void
    levelNumber (const levelNumber_type& x);

    // Level_isDefinedBy_Concept
    //
    typedef ::XMLSchema::Level_isDefinedBy_Concept Level_isDefinedBy_Concept_type;
    typedef ::xsd::cxx::tree::optional< Level_isDefinedBy_Concept_type > Level_isDefinedBy_Concept_optional;
    typedef ::xsd::cxx::tree::traits< Level_isDefinedBy_Concept_type, char > Level_isDefinedBy_Concept_traits;

    const Level_isDefinedBy_Concept_optional&
    Level_isDefinedBy_Concept () const;

    Level_isDefinedBy_Concept_optional&
    Level_isDefinedBy_Concept ();

    void
    Level_isDefinedBy_Concept (const Level_isDefinedBy_Concept_type& x);

    void
    Level_isDefinedBy_Concept (const Level_isDefinedBy_Concept_optional& x);

    void
    Level_isDefinedBy_Concept (::std::unique_ptr< Level_isDefinedBy_Concept_type > p);

    // Level_groups_ClassificationItem
    //
    typedef ::XMLSchema::Level_groups_ClassificationItem Level_groups_ClassificationItem_type;
    typedef ::xsd::cxx::tree::sequence< Level_groups_ClassificationItem_type > Level_groups_ClassificationItem_sequence;
    typedef Level_groups_ClassificationItem_sequence::iterator Level_groups_ClassificationItem_iterator;
    typedef Level_groups_ClassificationItem_sequence::const_iterator Level_groups_ClassificationItem_const_iterator;
    typedef ::xsd::cxx::tree::traits< Level_groups_ClassificationItem_type, char > Level_groups_ClassificationItem_traits;

    const Level_groups_ClassificationItem_sequence&
    Level_groups_ClassificationItem () const;

    Level_groups_ClassificationItem_sequence&
    Level_groups_ClassificationItem ();

    void
    Level_groups_ClassificationItem (const Level_groups_ClassificationItem_sequence& s);

    // Constructors.
    //
    Level (const levelNumber_type&);

    Level (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Level (const Level& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Level*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Level&
    operator= (const Level& x);

    virtual 
    ~Level ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    displayLabel_sequence displayLabel_;
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< levelNumber_type > levelNumber_;
    Level_isDefinedBy_Concept_optional Level_isDefinedBy_Concept_;
    Level_groups_ClassificationItem_sequence Level_groups_ClassificationItem_;
  };

  class LevelStructure: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // usage
    //
    typedef ::XMLSchema::InternationalString usage_type;
    typedef ::xsd::cxx::tree::optional< usage_type > usage_optional;
    typedef ::xsd::cxx::tree::traits< usage_type, char > usage_traits;

    const usage_optional&
    usage () const;

    usage_optional&
    usage ();

    void
    usage (const usage_type& x);

    void
    usage (const usage_optional& x);

    void
    usage (::std::unique_ptr< usage_type > p);

    // validDateRange
    //
    typedef ::XMLSchema::DateRange validDateRange_type;
    typedef ::xsd::cxx::tree::optional< validDateRange_type > validDateRange_optional;
    typedef ::xsd::cxx::tree::traits< validDateRange_type, char > validDateRange_traits;

    const validDateRange_optional&
    validDateRange () const;

    validDateRange_optional&
    validDateRange ();

    void
    validDateRange (const validDateRange_type& x);

    void
    validDateRange (const validDateRange_optional& x);

    void
    validDateRange (::std::unique_ptr< validDateRange_type > p);

    // LevelStructure_has_Level
    //
    typedef ::XMLSchema::LevelStructure_has_Level LevelStructure_has_Level_type;
    typedef ::xsd::cxx::tree::sequence< LevelStructure_has_Level_type > LevelStructure_has_Level_sequence;
    typedef LevelStructure_has_Level_sequence::iterator LevelStructure_has_Level_iterator;
    typedef LevelStructure_has_Level_sequence::const_iterator LevelStructure_has_Level_const_iterator;
    typedef ::xsd::cxx::tree::traits< LevelStructure_has_Level_type, char > LevelStructure_has_Level_traits;

    const LevelStructure_has_Level_sequence&
    LevelStructure_has_Level () const;

    LevelStructure_has_Level_sequence&
    LevelStructure_has_Level ();

    void
    LevelStructure_has_Level (const LevelStructure_has_Level_sequence& s);

    // Constructors.
    //
    LevelStructure ();

    LevelStructure (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    LevelStructure (const LevelStructure& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual LevelStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LevelStructure&
    operator= (const LevelStructure& x);

    virtual 
    ~LevelStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    identifier_optional identifier_;
    name_sequence name_;
    usage_optional usage_;
    validDateRange_optional validDateRange_;
    LevelStructure_has_Level_sequence LevelStructure_has_Level_;
  };

  class LogicalRecord: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // LogicalRecord_organizes_DataSet
    //
    typedef ::XMLSchema::LogicalRecord_organizes_DataSet LogicalRecord_organizes_DataSet_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecord_organizes_DataSet_type > LogicalRecord_organizes_DataSet_sequence;
    typedef LogicalRecord_organizes_DataSet_sequence::iterator LogicalRecord_organizes_DataSet_iterator;
    typedef LogicalRecord_organizes_DataSet_sequence::const_iterator LogicalRecord_organizes_DataSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecord_organizes_DataSet_type, char > LogicalRecord_organizes_DataSet_traits;

    const LogicalRecord_organizes_DataSet_sequence&
    LogicalRecord_organizes_DataSet () const;

    LogicalRecord_organizes_DataSet_sequence&
    LogicalRecord_organizes_DataSet ();

    void
    LogicalRecord_organizes_DataSet (const LogicalRecord_organizes_DataSet_sequence& s);

    // LogicalRecord_isDefinedBy_Concept
    //
    typedef ::XMLSchema::LogicalRecord_isDefinedBy_Concept LogicalRecord_isDefinedBy_Concept_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecord_isDefinedBy_Concept_type > LogicalRecord_isDefinedBy_Concept_sequence;
    typedef LogicalRecord_isDefinedBy_Concept_sequence::iterator LogicalRecord_isDefinedBy_Concept_iterator;
    typedef LogicalRecord_isDefinedBy_Concept_sequence::const_iterator LogicalRecord_isDefinedBy_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecord_isDefinedBy_Concept_type, char > LogicalRecord_isDefinedBy_Concept_traits;

    const LogicalRecord_isDefinedBy_Concept_sequence&
    LogicalRecord_isDefinedBy_Concept () const;

    LogicalRecord_isDefinedBy_Concept_sequence&
    LogicalRecord_isDefinedBy_Concept ();

    void
    LogicalRecord_isDefinedBy_Concept (const LogicalRecord_isDefinedBy_Concept_sequence& s);

    // LogicalRecord_has_InstanceVariable
    //
    typedef ::XMLSchema::LogicalRecord_has_InstanceVariable LogicalRecord_has_InstanceVariable_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecord_has_InstanceVariable_type > LogicalRecord_has_InstanceVariable_sequence;
    typedef LogicalRecord_has_InstanceVariable_sequence::iterator LogicalRecord_has_InstanceVariable_iterator;
    typedef LogicalRecord_has_InstanceVariable_sequence::const_iterator LogicalRecord_has_InstanceVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecord_has_InstanceVariable_type, char > LogicalRecord_has_InstanceVariable_traits;

    const LogicalRecord_has_InstanceVariable_sequence&
    LogicalRecord_has_InstanceVariable () const;

    LogicalRecord_has_InstanceVariable_sequence&
    LogicalRecord_has_InstanceVariable ();

    void
    LogicalRecord_has_InstanceVariable (const LogicalRecord_has_InstanceVariable_sequence& s);

    // Constructors.
    //
    LogicalRecord ();

    LogicalRecord (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    LogicalRecord (const LogicalRecord& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual LogicalRecord*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LogicalRecord&
    operator= (const LogicalRecord& x);

    virtual 
    ~LogicalRecord ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    LogicalRecord_organizes_DataSet_sequence LogicalRecord_organizes_DataSet_;
    LogicalRecord_isDefinedBy_Concept_sequence LogicalRecord_isDefinedBy_Concept_;
    LogicalRecord_has_InstanceVariable_sequence LogicalRecord_has_InstanceVariable_;
  };

  class LogicalRecordPosition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // value
    //
    typedef ::xml_schema::integer value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    // LogicalRecordPosition_indexes_LogicalRecord
    //
    typedef ::XMLSchema::LogicalRecordPosition_indexes_LogicalRecord LogicalRecordPosition_indexes_LogicalRecord_type;
    typedef ::xsd::cxx::tree::traits< LogicalRecordPosition_indexes_LogicalRecord_type, char > LogicalRecordPosition_indexes_LogicalRecord_traits;

    const LogicalRecordPosition_indexes_LogicalRecord_type&
    LogicalRecordPosition_indexes_LogicalRecord () const;

    LogicalRecordPosition_indexes_LogicalRecord_type&
    LogicalRecordPosition_indexes_LogicalRecord ();

    void
    LogicalRecordPosition_indexes_LogicalRecord (const LogicalRecordPosition_indexes_LogicalRecord_type& x);

    void
    LogicalRecordPosition_indexes_LogicalRecord (::std::unique_ptr< LogicalRecordPosition_indexes_LogicalRecord_type > p);

    // Constructors.
    //
    LogicalRecordPosition (const value_type&,
                           const LogicalRecordPosition_indexes_LogicalRecord_type&);

    LogicalRecordPosition (const value_type&,
                           ::std::unique_ptr< LogicalRecordPosition_indexes_LogicalRecord_type >);

    LogicalRecordPosition (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    LogicalRecordPosition (const LogicalRecordPosition& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual LogicalRecordPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LogicalRecordPosition&
    operator= (const LogicalRecordPosition& x);

    virtual 
    ~LogicalRecordPosition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< value_type > value_;
    ::xsd::cxx::tree::one< LogicalRecordPosition_indexes_LogicalRecord_type > LogicalRecordPosition_indexes_LogicalRecord_;
  };

  class LogicalRecordRelationStructure: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // specification
    //
    typedef ::XMLSchema::StructureSpecification specification_type;
    typedef ::xsd::cxx::tree::optional< specification_type > specification_optional;
    typedef ::xsd::cxx::tree::traits< specification_type, char > specification_traits;

    const specification_optional&
    specification () const;

    specification_optional&
    specification ();

    void
    specification (const specification_type& x);

    void
    specification (const specification_optional& x);

    void
    specification (::std::unique_ptr< specification_type > p);

    // topology
    //
    typedef ::XMLSchema::ControlledVocabularyEntry topology_type;
    typedef ::xsd::cxx::tree::optional< topology_type > topology_optional;
    typedef ::xsd::cxx::tree::traits< topology_type, char > topology_traits;

    const topology_optional&
    topology () const;

    topology_optional&
    topology ();

    void
    topology (const topology_type& x);

    void
    topology (const topology_optional& x);

    void
    topology (::std::unique_ptr< topology_type > p);

    // totality
    //
    typedef ::XMLSchema::StructureExtent totality_type;
    typedef ::xsd::cxx::tree::optional< totality_type > totality_optional;
    typedef ::xsd::cxx::tree::traits< totality_type, char > totality_traits;

    const totality_optional&
    totality () const;

    totality_optional&
    totality ();

    void
    totality (const totality_type& x);

    void
    totality (const totality_optional& x);

    void
    totality (::std::unique_ptr< totality_type > p);

    // LogicalRecordRelationStructure_structures_DataStore
    //
    typedef ::XMLSchema::LogicalRecordRelationStructure_structures_DataStore LogicalRecordRelationStructure_structures_DataStore_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecordRelationStructure_structures_DataStore_type > LogicalRecordRelationStructure_structures_DataStore_sequence;
    typedef LogicalRecordRelationStructure_structures_DataStore_sequence::iterator LogicalRecordRelationStructure_structures_DataStore_iterator;
    typedef LogicalRecordRelationStructure_structures_DataStore_sequence::const_iterator LogicalRecordRelationStructure_structures_DataStore_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecordRelationStructure_structures_DataStore_type, char > LogicalRecordRelationStructure_structures_DataStore_traits;

    const LogicalRecordRelationStructure_structures_DataStore_sequence&
    LogicalRecordRelationStructure_structures_DataStore () const;

    LogicalRecordRelationStructure_structures_DataStore_sequence&
    LogicalRecordRelationStructure_structures_DataStore ();

    void
    LogicalRecordRelationStructure_structures_DataStore (const LogicalRecordRelationStructure_structures_DataStore_sequence& s);

    // LogicalRecordRelationStructure_has_LogicalRecordRelationship
    //
    typedef ::XMLSchema::LogicalRecordRelationStructure_has_LogicalRecordRelationship LogicalRecordRelationStructure_has_LogicalRecordRelationship_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecordRelationStructure_has_LogicalRecordRelationship_type > LogicalRecordRelationStructure_has_LogicalRecordRelationship_sequence;
    typedef LogicalRecordRelationStructure_has_LogicalRecordRelationship_sequence::iterator LogicalRecordRelationStructure_has_LogicalRecordRelationship_iterator;
    typedef LogicalRecordRelationStructure_has_LogicalRecordRelationship_sequence::const_iterator LogicalRecordRelationStructure_has_LogicalRecordRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecordRelationStructure_has_LogicalRecordRelationship_type, char > LogicalRecordRelationStructure_has_LogicalRecordRelationship_traits;

    const LogicalRecordRelationStructure_has_LogicalRecordRelationship_sequence&
    LogicalRecordRelationStructure_has_LogicalRecordRelationship () const;

    LogicalRecordRelationStructure_has_LogicalRecordRelationship_sequence&
    LogicalRecordRelationStructure_has_LogicalRecordRelationship ();

    void
    LogicalRecordRelationStructure_has_LogicalRecordRelationship (const LogicalRecordRelationStructure_has_LogicalRecordRelationship_sequence& s);

    // Constructors.
    //
    LogicalRecordRelationStructure ();

    LogicalRecordRelationStructure (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    LogicalRecordRelationStructure (const LogicalRecordRelationStructure& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual LogicalRecordRelationStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LogicalRecordRelationStructure&
    operator= (const LogicalRecordRelationStructure& x);

    virtual 
    ~LogicalRecordRelationStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    semantics_optional semantics_;
    specification_optional specification_;
    topology_optional topology_;
    totality_optional totality_;
    LogicalRecordRelationStructure_structures_DataStore_sequence LogicalRecordRelationStructure_structures_DataStore_;
    LogicalRecordRelationStructure_has_LogicalRecordRelationship_sequence LogicalRecordRelationStructure_has_LogicalRecordRelationship_;
  };

  class LogicalRecordRelationship: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // LogicalRecordRelationship_hasTarget_LogicalRecord
    //
    typedef ::XMLSchema::LogicalRecordRelationship_hasTarget_LogicalRecord LogicalRecordRelationship_hasTarget_LogicalRecord_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecordRelationship_hasTarget_LogicalRecord_type > LogicalRecordRelationship_hasTarget_LogicalRecord_sequence;
    typedef LogicalRecordRelationship_hasTarget_LogicalRecord_sequence::iterator LogicalRecordRelationship_hasTarget_LogicalRecord_iterator;
    typedef LogicalRecordRelationship_hasTarget_LogicalRecord_sequence::const_iterator LogicalRecordRelationship_hasTarget_LogicalRecord_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecordRelationship_hasTarget_LogicalRecord_type, char > LogicalRecordRelationship_hasTarget_LogicalRecord_traits;

    const LogicalRecordRelationship_hasTarget_LogicalRecord_sequence&
    LogicalRecordRelationship_hasTarget_LogicalRecord () const;

    LogicalRecordRelationship_hasTarget_LogicalRecord_sequence&
    LogicalRecordRelationship_hasTarget_LogicalRecord ();

    void
    LogicalRecordRelationship_hasTarget_LogicalRecord (const LogicalRecordRelationship_hasTarget_LogicalRecord_sequence& s);

    // LogicalRecordRelationship_hasSource_LogicalRecord
    //
    typedef ::XMLSchema::LogicalRecordRelationship_hasSource_LogicalRecord LogicalRecordRelationship_hasSource_LogicalRecord_type;
    typedef ::xsd::cxx::tree::sequence< LogicalRecordRelationship_hasSource_LogicalRecord_type > LogicalRecordRelationship_hasSource_LogicalRecord_sequence;
    typedef LogicalRecordRelationship_hasSource_LogicalRecord_sequence::iterator LogicalRecordRelationship_hasSource_LogicalRecord_iterator;
    typedef LogicalRecordRelationship_hasSource_LogicalRecord_sequence::const_iterator LogicalRecordRelationship_hasSource_LogicalRecord_const_iterator;
    typedef ::xsd::cxx::tree::traits< LogicalRecordRelationship_hasSource_LogicalRecord_type, char > LogicalRecordRelationship_hasSource_LogicalRecord_traits;

    const LogicalRecordRelationship_hasSource_LogicalRecord_sequence&
    LogicalRecordRelationship_hasSource_LogicalRecord () const;

    LogicalRecordRelationship_hasSource_LogicalRecord_sequence&
    LogicalRecordRelationship_hasSource_LogicalRecord ();

    void
    LogicalRecordRelationship_hasSource_LogicalRecord (const LogicalRecordRelationship_hasSource_LogicalRecord_sequence& s);

    // Constructors.
    //
    LogicalRecordRelationship ();

    LogicalRecordRelationship (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    LogicalRecordRelationship (const LogicalRecordRelationship& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual LogicalRecordRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LogicalRecordRelationship&
    operator= (const LogicalRecordRelationship& x);

    virtual 
    ~LogicalRecordRelationship ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    semantics_optional semantics_;
    LogicalRecordRelationship_hasTarget_LogicalRecord_sequence LogicalRecordRelationship_hasTarget_LogicalRecord_;
    LogicalRecordRelationship_hasSource_LogicalRecord_sequence LogicalRecordRelationship_hasSource_LogicalRecord_;
  };

  class LongDataSet: public ::XMLSchema::DataSet
  {
    public:
    // Constructors.
    //
    LongDataSet ();

    LongDataSet (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    LongDataSet (const LongDataSet& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual LongDataSet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    LongDataSet&
    operator= (const LongDataSet&) = default;
#endif

    virtual 
    ~LongDataSet ();
  };

  class LongDataStructure: public ::XMLSchema::DataStructure
  {
    public:
    // Constructors.
    //
    LongDataStructure ();

    LongDataStructure (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    LongDataStructure (const LongDataStructure& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual LongDataStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    LongDataStructure&
    operator= (const LongDataStructure&) = default;
#endif

    virtual 
    ~LongDataStructure ();
  };

  class LongKey: public ::XMLSchema::Key
  {
    public:
    // Constructors.
    //
    LongKey ();

    LongKey (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    LongKey (const LongKey& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual LongKey*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    LongKey&
    operator= (const LongKey&) = default;
#endif

    virtual 
    ~LongKey ();
  };

  class LongMainKeyMember: public ::XMLSchema::KeyMember
  {
    public:
    // Constructors.
    //
    LongMainKeyMember (const InstanceValue_hasValueFrom_ValueDomain_type&);

    LongMainKeyMember (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type >);

    LongMainKeyMember (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    LongMainKeyMember (const LongMainKeyMember& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual LongMainKeyMember*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    LongMainKeyMember&
    operator= (const LongMainKeyMember&) = default;
#endif

    virtual 
    ~LongMainKeyMember ();
  };

  class Machine: public ::XMLSchema::Agent
  {
    public:
    // accessLocation
    //
    typedef ::XMLSchema::AccessLocation accessLocation_type;
    typedef ::xsd::cxx::tree::optional< accessLocation_type > accessLocation_optional;
    typedef ::xsd::cxx::tree::traits< accessLocation_type, char > accessLocation_traits;

    const accessLocation_optional&
    accessLocation () const;

    accessLocation_optional&
    accessLocation ();

    void
    accessLocation (const accessLocation_type& x);

    void
    accessLocation (const accessLocation_optional& x);

    void
    accessLocation (::std::unique_ptr< accessLocation_type > p);

    // function
    //
    typedef ::XMLSchema::ControlledVocabularyEntry function_type;
    typedef ::xsd::cxx::tree::sequence< function_type > function_sequence;
    typedef function_sequence::iterator function_iterator;
    typedef function_sequence::const_iterator function_const_iterator;
    typedef ::xsd::cxx::tree::traits< function_type, char > function_traits;

    const function_sequence&
    function () const;

    function_sequence&
    function ();

    void
    function (const function_sequence& s);

    // machineInterface
    //
    typedef ::XMLSchema::ControlledVocabularyEntry machineInterface_type;
    typedef ::xsd::cxx::tree::sequence< machineInterface_type > machineInterface_sequence;
    typedef machineInterface_sequence::iterator machineInterface_iterator;
    typedef machineInterface_sequence::const_iterator machineInterface_const_iterator;
    typedef ::xsd::cxx::tree::traits< machineInterface_type, char > machineInterface_traits;

    const machineInterface_sequence&
    machineInterface () const;

    machineInterface_sequence&
    machineInterface ();

    void
    machineInterface (const machineInterface_sequence& s);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // ownerOperatorContact
    //
    typedef ::XMLSchema::ContactInformation ownerOperatorContact_type;
    typedef ::xsd::cxx::tree::optional< ownerOperatorContact_type > ownerOperatorContact_optional;
    typedef ::xsd::cxx::tree::traits< ownerOperatorContact_type, char > ownerOperatorContact_traits;

    const ownerOperatorContact_optional&
    ownerOperatorContact () const;

    ownerOperatorContact_optional&
    ownerOperatorContact ();

    void
    ownerOperatorContact (const ownerOperatorContact_type& x);

    void
    ownerOperatorContact (const ownerOperatorContact_optional& x);

    void
    ownerOperatorContact (::std::unique_ptr< ownerOperatorContact_type > p);

    // typeOfMachine
    //
    typedef ::XMLSchema::ControlledVocabularyEntry typeOfMachine_type;
    typedef ::xsd::cxx::tree::optional< typeOfMachine_type > typeOfMachine_optional;
    typedef ::xsd::cxx::tree::traits< typeOfMachine_type, char > typeOfMachine_traits;

    const typeOfMachine_optional&
    typeOfMachine () const;

    typeOfMachine_optional&
    typeOfMachine ();

    void
    typeOfMachine (const typeOfMachine_type& x);

    void
    typeOfMachine (const typeOfMachine_optional& x);

    void
    typeOfMachine (::std::unique_ptr< typeOfMachine_type > p);

    // Constructors.
    //
    Machine ();

    Machine (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Machine (const Machine& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual Machine*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Machine&
    operator= (const Machine& x);

    virtual 
    ~Machine ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    accessLocation_optional accessLocation_;
    function_sequence function_;
    machineInterface_sequence machineInterface_;
    name_sequence name_;
    ownerOperatorContact_optional ownerOperatorContact_;
    typeOfMachine_optional typeOfMachine_;
  };

  class MainKeyMember: public ::XMLSchema::KeyMember
  {
    public:
    // MainKeyMember_hasValueFrom_SubstantiveValueDomain
    //
    typedef ::XMLSchema::MainKeyMember_hasValueFrom_SubstantiveValueDomain MainKeyMember_hasValueFrom_SubstantiveValueDomain_type;
    typedef ::xsd::cxx::tree::optional< MainKeyMember_hasValueFrom_SubstantiveValueDomain_type > MainKeyMember_hasValueFrom_SubstantiveValueDomain_optional;
    typedef ::xsd::cxx::tree::traits< MainKeyMember_hasValueFrom_SubstantiveValueDomain_type, char > MainKeyMember_hasValueFrom_SubstantiveValueDomain_traits;

    const MainKeyMember_hasValueFrom_SubstantiveValueDomain_optional&
    MainKeyMember_hasValueFrom_SubstantiveValueDomain () const;

    MainKeyMember_hasValueFrom_SubstantiveValueDomain_optional&
    MainKeyMember_hasValueFrom_SubstantiveValueDomain ();

    void
    MainKeyMember_hasValueFrom_SubstantiveValueDomain (const MainKeyMember_hasValueFrom_SubstantiveValueDomain_type& x);

    void
    MainKeyMember_hasValueFrom_SubstantiveValueDomain (const MainKeyMember_hasValueFrom_SubstantiveValueDomain_optional& x);

    void
    MainKeyMember_hasValueFrom_SubstantiveValueDomain (::std::unique_ptr< MainKeyMember_hasValueFrom_SubstantiveValueDomain_type > p);

    // Constructors.
    //
    MainKeyMember (const InstanceValue_hasValueFrom_ValueDomain_type&);

    MainKeyMember (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type >);

    MainKeyMember (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    MainKeyMember (const MainKeyMember& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual MainKeyMember*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MainKeyMember&
    operator= (const MainKeyMember& x);

    virtual 
    ~MainKeyMember ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    MainKeyMember_hasValueFrom_SubstantiveValueDomain_optional MainKeyMember_hasValueFrom_SubstantiveValueDomain_;
  };

  class MeasureComponent: public ::XMLSchema::DataStructureComponent
  {
    public:
    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // Constructors.
    //
    MeasureComponent ();

    MeasureComponent (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    MeasureComponent (const MeasureComponent& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual MeasureComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MeasureComponent&
    operator= (const MeasureComponent& x);

    virtual 
    ~MeasureComponent ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    name_sequence name_;
  };

  class Notation: public ::xml_schema::type
  {
    public:
    // content
    //
    typedef ::XMLSchema::TypedString content_type;
    typedef ::xsd::cxx::tree::optional< content_type > content_optional;
    typedef ::xsd::cxx::tree::traits< content_type, char > content_traits;

    const content_optional&
    content () const;

    content_optional&
    content ();

    void
    content (const content_type& x);

    void
    content (const content_optional& x);

    void
    content (::std::unique_ptr< content_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // whiteSpace
    //
    typedef ::XMLSchema::WhiteSpaceRule whiteSpace_type;
    typedef ::xsd::cxx::tree::optional< whiteSpace_type > whiteSpace_optional;
    typedef ::xsd::cxx::tree::traits< whiteSpace_type, char > whiteSpace_traits;

    const whiteSpace_optional&
    whiteSpace () const;

    whiteSpace_optional&
    whiteSpace ();

    void
    whiteSpace (const whiteSpace_type& x);

    void
    whiteSpace (const whiteSpace_optional& x);

    void
    whiteSpace (::std::unique_ptr< whiteSpace_type > p);

    // Notation_represents_Category
    //
    typedef ::XMLSchema::Notation_represents_Category Notation_represents_Category_type;
    typedef ::xsd::cxx::tree::sequence< Notation_represents_Category_type > Notation_represents_Category_sequence;
    typedef Notation_represents_Category_sequence::iterator Notation_represents_Category_iterator;
    typedef Notation_represents_Category_sequence::const_iterator Notation_represents_Category_const_iterator;
    typedef ::xsd::cxx::tree::traits< Notation_represents_Category_type, char > Notation_represents_Category_traits;

    const Notation_represents_Category_sequence&
    Notation_represents_Category () const;

    Notation_represents_Category_sequence&
    Notation_represents_Category ();

    void
    Notation_represents_Category (const Notation_represents_Category_sequence& s);

    // Constructors.
    //
    Notation ();

    Notation (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Notation (const Notation& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual Notation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Notation&
    operator= (const Notation& x);

    virtual 
    ~Notation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_optional content_;
    identifier_optional identifier_;
    whiteSpace_optional whiteSpace_;
    Notation_represents_Category_sequence Notation_represents_Category_;
  };

  class Organization: public ::XMLSchema::Agent
  {
    public:
    // contactInformation
    //
    typedef ::XMLSchema::ContactInformation contactInformation_type;
    typedef ::xsd::cxx::tree::optional< contactInformation_type > contactInformation_optional;
    typedef ::xsd::cxx::tree::traits< contactInformation_type, char > contactInformation_traits;

    const contactInformation_optional&
    contactInformation () const;

    contactInformation_optional&
    contactInformation ();

    void
    contactInformation (const contactInformation_type& x);

    void
    contactInformation (const contactInformation_optional& x);

    void
    contactInformation (::std::unique_ptr< contactInformation_type > p);

    // organizationName
    //
    typedef ::XMLSchema::OrganizationName organizationName_type;
    typedef ::xsd::cxx::tree::sequence< organizationName_type > organizationName_sequence;
    typedef organizationName_sequence::iterator organizationName_iterator;
    typedef organizationName_sequence::const_iterator organizationName_const_iterator;
    typedef ::xsd::cxx::tree::traits< organizationName_type, char > organizationName_traits;

    const organizationName_sequence&
    organizationName () const;

    organizationName_sequence&
    organizationName ();

    void
    organizationName (const organizationName_sequence& s);

    // Constructors.
    //
    Organization ();

    Organization (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    Organization (const Organization& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual Organization*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Organization&
    operator= (const Organization& x);

    virtual 
    ~Organization ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    contactInformation_optional contactInformation_;
    organizationName_sequence organizationName_;
  };

  class Parameter: public ::xml_schema::type
  {
    public:
    // entityBound
    //
    typedef ::XMLSchema::entityBound entityBound_type;
    typedef ::xsd::cxx::tree::sequence< entityBound_type > entityBound_sequence;
    typedef entityBound_sequence::iterator entityBound_iterator;
    typedef entityBound_sequence::const_iterator entityBound_const_iterator;
    typedef ::xsd::cxx::tree::traits< entityBound_type, char > entityBound_traits;

    const entityBound_sequence&
    entityBound () const;

    entityBound_sequence&
    entityBound ();

    void
    entityBound (const entityBound_sequence& s);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // Constructors.
    //
    Parameter ();

    Parameter (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    Parameter (const Parameter& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual Parameter*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Parameter&
    operator= (const Parameter& x);

    virtual 
    ~Parameter ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    entityBound_sequence entityBound_;
    identifier_optional identifier_;
    name_sequence name_;
  };

  class PhysicalDataSet: public ::xml_schema::type
  {
    public:
    // allowsDuplicates
    //
    typedef ::xml_schema::boolean allowsDuplicates_type;
    typedef ::xsd::cxx::tree::traits< allowsDuplicates_type, char > allowsDuplicates_traits;

    const allowsDuplicates_type&
    allowsDuplicates () const;

    allowsDuplicates_type&
    allowsDuplicates ();

    void
    allowsDuplicates (const allowsDuplicates_type& x);

    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::unique_ptr< name_type > p);

    // numberOfSegments
    //
    typedef ::xml_schema::integer numberOfSegments_type;
    typedef ::xsd::cxx::tree::optional< numberOfSegments_type > numberOfSegments_optional;
    typedef ::xsd::cxx::tree::traits< numberOfSegments_type, char > numberOfSegments_traits;

    const numberOfSegments_optional&
    numberOfSegments () const;

    numberOfSegments_optional&
    numberOfSegments ();

    void
    numberOfSegments (const numberOfSegments_type& x);

    void
    numberOfSegments (const numberOfSegments_optional& x);

    // overview
    //
    typedef ::XMLSchema::InternationalString overview_type;
    typedef ::xsd::cxx::tree::optional< overview_type > overview_optional;
    typedef ::xsd::cxx::tree::traits< overview_type, char > overview_traits;

    const overview_optional&
    overview () const;

    overview_optional&
    overview ();

    void
    overview (const overview_type& x);

    void
    overview (const overview_optional& x);

    void
    overview (::std::unique_ptr< overview_type > p);

    // physicalFileName
    //
    typedef ::xml_schema::string physicalFileName_type;
    typedef ::xsd::cxx::tree::optional< physicalFileName_type > physicalFileName_optional;
    typedef ::xsd::cxx::tree::traits< physicalFileName_type, char > physicalFileName_traits;

    const physicalFileName_optional&
    physicalFileName () const;

    physicalFileName_optional&
    physicalFileName ();

    void
    physicalFileName (const physicalFileName_type& x);

    void
    physicalFileName (const physicalFileName_optional& x);

    void
    physicalFileName (::std::unique_ptr< physicalFileName_type > p);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // PhysicalDataSet_isDefinedBy_Concept
    //
    typedef ::XMLSchema::PhysicalDataSet_isDefinedBy_Concept PhysicalDataSet_isDefinedBy_Concept_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalDataSet_isDefinedBy_Concept_type > PhysicalDataSet_isDefinedBy_Concept_sequence;
    typedef PhysicalDataSet_isDefinedBy_Concept_sequence::iterator PhysicalDataSet_isDefinedBy_Concept_iterator;
    typedef PhysicalDataSet_isDefinedBy_Concept_sequence::const_iterator PhysicalDataSet_isDefinedBy_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalDataSet_isDefinedBy_Concept_type, char > PhysicalDataSet_isDefinedBy_Concept_traits;

    const PhysicalDataSet_isDefinedBy_Concept_sequence&
    PhysicalDataSet_isDefinedBy_Concept () const;

    PhysicalDataSet_isDefinedBy_Concept_sequence&
    PhysicalDataSet_isDefinedBy_Concept ();

    void
    PhysicalDataSet_isDefinedBy_Concept (const PhysicalDataSet_isDefinedBy_Concept_sequence& s);

    // PhysicalDataSet_formats_DataStore
    //
    typedef ::XMLSchema::PhysicalDataSet_formats_DataStore PhysicalDataSet_formats_DataStore_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalDataSet_formats_DataStore_type > PhysicalDataSet_formats_DataStore_sequence;
    typedef PhysicalDataSet_formats_DataStore_sequence::iterator PhysicalDataSet_formats_DataStore_iterator;
    typedef PhysicalDataSet_formats_DataStore_sequence::const_iterator PhysicalDataSet_formats_DataStore_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalDataSet_formats_DataStore_type, char > PhysicalDataSet_formats_DataStore_traits;

    const PhysicalDataSet_formats_DataStore_sequence&
    PhysicalDataSet_formats_DataStore () const;

    PhysicalDataSet_formats_DataStore_sequence&
    PhysicalDataSet_formats_DataStore ();

    void
    PhysicalDataSet_formats_DataStore (const PhysicalDataSet_formats_DataStore_sequence& s);

    // PhysicalDataSet_has_InstanceVariable
    //
    typedef ::XMLSchema::PhysicalDataSet_has_InstanceVariable PhysicalDataSet_has_InstanceVariable_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalDataSet_has_InstanceVariable_type > PhysicalDataSet_has_InstanceVariable_sequence;
    typedef PhysicalDataSet_has_InstanceVariable_sequence::iterator PhysicalDataSet_has_InstanceVariable_iterator;
    typedef PhysicalDataSet_has_InstanceVariable_sequence::const_iterator PhysicalDataSet_has_InstanceVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalDataSet_has_InstanceVariable_type, char > PhysicalDataSet_has_InstanceVariable_traits;

    const PhysicalDataSet_has_InstanceVariable_sequence&
    PhysicalDataSet_has_InstanceVariable () const;

    PhysicalDataSet_has_InstanceVariable_sequence&
    PhysicalDataSet_has_InstanceVariable ();

    void
    PhysicalDataSet_has_InstanceVariable (const PhysicalDataSet_has_InstanceVariable_sequence& s);

    // PhysicalDataSet_has_PhysicalRecordSegment
    //
    typedef ::XMLSchema::PhysicalDataSet_has_PhysicalRecordSegment PhysicalDataSet_has_PhysicalRecordSegment_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalDataSet_has_PhysicalRecordSegment_type > PhysicalDataSet_has_PhysicalRecordSegment_sequence;
    typedef PhysicalDataSet_has_PhysicalRecordSegment_sequence::iterator PhysicalDataSet_has_PhysicalRecordSegment_iterator;
    typedef PhysicalDataSet_has_PhysicalRecordSegment_sequence::const_iterator PhysicalDataSet_has_PhysicalRecordSegment_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalDataSet_has_PhysicalRecordSegment_type, char > PhysicalDataSet_has_PhysicalRecordSegment_traits;

    const PhysicalDataSet_has_PhysicalRecordSegment_sequence&
    PhysicalDataSet_has_PhysicalRecordSegment () const;

    PhysicalDataSet_has_PhysicalRecordSegment_sequence&
    PhysicalDataSet_has_PhysicalRecordSegment ();

    void
    PhysicalDataSet_has_PhysicalRecordSegment (const PhysicalDataSet_has_PhysicalRecordSegment_sequence& s);

    // PhysicalDataSet_has_PhysicalRecordSegmentPosition
    //
    typedef ::XMLSchema::PhysicalDataSet_has_PhysicalRecordSegmentPosition PhysicalDataSet_has_PhysicalRecordSegmentPosition_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalDataSet_has_PhysicalRecordSegmentPosition_type > PhysicalDataSet_has_PhysicalRecordSegmentPosition_sequence;
    typedef PhysicalDataSet_has_PhysicalRecordSegmentPosition_sequence::iterator PhysicalDataSet_has_PhysicalRecordSegmentPosition_iterator;
    typedef PhysicalDataSet_has_PhysicalRecordSegmentPosition_sequence::const_iterator PhysicalDataSet_has_PhysicalRecordSegmentPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalDataSet_has_PhysicalRecordSegmentPosition_type, char > PhysicalDataSet_has_PhysicalRecordSegmentPosition_traits;

    const PhysicalDataSet_has_PhysicalRecordSegmentPosition_sequence&
    PhysicalDataSet_has_PhysicalRecordSegmentPosition () const;

    PhysicalDataSet_has_PhysicalRecordSegmentPosition_sequence&
    PhysicalDataSet_has_PhysicalRecordSegmentPosition ();

    void
    PhysicalDataSet_has_PhysicalRecordSegmentPosition (const PhysicalDataSet_has_PhysicalRecordSegmentPosition_sequence& s);

    // Constructors.
    //
    PhysicalDataSet (const allowsDuplicates_type&);

    PhysicalDataSet (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    PhysicalDataSet (const PhysicalDataSet& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual PhysicalDataSet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PhysicalDataSet&
    operator= (const PhysicalDataSet& x);

    virtual 
    ~PhysicalDataSet ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< allowsDuplicates_type > allowsDuplicates_;
    catalogDetails_optional catalogDetails_;
    identifier_optional identifier_;
    name_optional name_;
    numberOfSegments_optional numberOfSegments_;
    overview_optional overview_;
    physicalFileName_optional physicalFileName_;
    purpose_optional purpose_;
    PhysicalDataSet_isDefinedBy_Concept_sequence PhysicalDataSet_isDefinedBy_Concept_;
    PhysicalDataSet_formats_DataStore_sequence PhysicalDataSet_formats_DataStore_;
    PhysicalDataSet_has_InstanceVariable_sequence PhysicalDataSet_has_InstanceVariable_;
    PhysicalDataSet_has_PhysicalRecordSegment_sequence PhysicalDataSet_has_PhysicalRecordSegment_;
    PhysicalDataSet_has_PhysicalRecordSegmentPosition_sequence PhysicalDataSet_has_PhysicalRecordSegmentPosition_;
  };

  class PhysicalDataSetStructure: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::unique_ptr< name_type > p);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // specification
    //
    typedef ::XMLSchema::StructureSpecification specification_type;
    typedef ::xsd::cxx::tree::optional< specification_type > specification_optional;
    typedef ::xsd::cxx::tree::traits< specification_type, char > specification_traits;

    const specification_optional&
    specification () const;

    specification_optional&
    specification ();

    void
    specification (const specification_type& x);

    void
    specification (const specification_optional& x);

    void
    specification (::std::unique_ptr< specification_type > p);

    // topology
    //
    typedef ::XMLSchema::ControlledVocabularyEntry topology_type;
    typedef ::xsd::cxx::tree::optional< topology_type > topology_optional;
    typedef ::xsd::cxx::tree::traits< topology_type, char > topology_traits;

    const topology_optional&
    topology () const;

    topology_optional&
    topology ();

    void
    topology (const topology_type& x);

    void
    topology (const topology_optional& x);

    void
    topology (::std::unique_ptr< topology_type > p);

    // totality
    //
    typedef ::XMLSchema::StructureExtent totality_type;
    typedef ::xsd::cxx::tree::optional< totality_type > totality_optional;
    typedef ::xsd::cxx::tree::traits< totality_type, char > totality_traits;

    const totality_optional&
    totality () const;

    totality_optional&
    totality ();

    void
    totality (const totality_type& x);

    void
    totality (const totality_optional& x);

    void
    totality (::std::unique_ptr< totality_type > p);

    // PhysicalDataSetStructure_structures_PhysicalDataSet
    //
    typedef ::XMLSchema::PhysicalDataSetStructure_structures_PhysicalDataSet PhysicalDataSetStructure_structures_PhysicalDataSet_type;
    typedef ::xsd::cxx::tree::optional< PhysicalDataSetStructure_structures_PhysicalDataSet_type > PhysicalDataSetStructure_structures_PhysicalDataSet_optional;
    typedef ::xsd::cxx::tree::traits< PhysicalDataSetStructure_structures_PhysicalDataSet_type, char > PhysicalDataSetStructure_structures_PhysicalDataSet_traits;

    const PhysicalDataSetStructure_structures_PhysicalDataSet_optional&
    PhysicalDataSetStructure_structures_PhysicalDataSet () const;

    PhysicalDataSetStructure_structures_PhysicalDataSet_optional&
    PhysicalDataSetStructure_structures_PhysicalDataSet ();

    void
    PhysicalDataSetStructure_structures_PhysicalDataSet (const PhysicalDataSetStructure_structures_PhysicalDataSet_type& x);

    void
    PhysicalDataSetStructure_structures_PhysicalDataSet (const PhysicalDataSetStructure_structures_PhysicalDataSet_optional& x);

    void
    PhysicalDataSetStructure_structures_PhysicalDataSet (::std::unique_ptr< PhysicalDataSetStructure_structures_PhysicalDataSet_type > p);

    // PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship
    //
    typedef ::XMLSchema::PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_type > PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_sequence;
    typedef PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_sequence::iterator PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_iterator;
    typedef PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_sequence::const_iterator PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_type, char > PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_traits;

    const PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_sequence&
    PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship () const;

    PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_sequence&
    PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship ();

    void
    PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship (const PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_sequence& s);

    // Constructors.
    //
    PhysicalDataSetStructure ();

    PhysicalDataSetStructure (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    PhysicalDataSetStructure (const PhysicalDataSetStructure& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual PhysicalDataSetStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PhysicalDataSetStructure&
    operator= (const PhysicalDataSetStructure& x);

    virtual 
    ~PhysicalDataSetStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    name_optional name_;
    purpose_optional purpose_;
    semantics_optional semantics_;
    specification_optional specification_;
    topology_optional topology_;
    totality_optional totality_;
    PhysicalDataSetStructure_structures_PhysicalDataSet_optional PhysicalDataSetStructure_structures_PhysicalDataSet_;
    PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_sequence PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_;
  };

  class PhysicalLayoutRelationStructure: public ::xml_schema::type
  {
    public:
    // criteria
    //
    typedef ::XMLSchema::InternationalString criteria_type;
    typedef ::xsd::cxx::tree::optional< criteria_type > criteria_optional;
    typedef ::xsd::cxx::tree::traits< criteria_type, char > criteria_traits;

    const criteria_optional&
    criteria () const;

    criteria_optional&
    criteria ();

    void
    criteria (const criteria_type& x);

    void
    criteria (const criteria_optional& x);

    void
    criteria (::std::unique_ptr< criteria_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // specification
    //
    typedef ::XMLSchema::StructureSpecification specification_type;
    typedef ::xsd::cxx::tree::optional< specification_type > specification_optional;
    typedef ::xsd::cxx::tree::traits< specification_type, char > specification_traits;

    const specification_optional&
    specification () const;

    specification_optional&
    specification ();

    void
    specification (const specification_type& x);

    void
    specification (const specification_optional& x);

    void
    specification (::std::unique_ptr< specification_type > p);

    // topology
    //
    typedef ::XMLSchema::ControlledVocabularyEntry topology_type;
    typedef ::xsd::cxx::tree::traits< topology_type, char > topology_traits;

    const topology_type&
    topology () const;

    topology_type&
    topology ();

    void
    topology (const topology_type& x);

    void
    topology (::std::unique_ptr< topology_type > p);

    // totality
    //
    typedef ::XMLSchema::StructureExtent totality_type;
    typedef ::xsd::cxx::tree::optional< totality_type > totality_optional;
    typedef ::xsd::cxx::tree::traits< totality_type, char > totality_traits;

    const totality_optional&
    totality () const;

    totality_optional&
    totality ();

    void
    totality (const totality_type& x);

    void
    totality (const totality_optional& x);

    void
    totality (::std::unique_ptr< totality_type > p);

    // PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout
    //
    typedef ::XMLSchema::PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_type;
    typedef ::xsd::cxx::tree::optional< PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_type > PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_optional;
    typedef ::xsd::cxx::tree::traits< PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_type, char > PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_traits;

    const PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_optional&
    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout () const;

    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_optional&
    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout ();

    void
    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout (const PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_type& x);

    void
    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout (const PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_optional& x);

    void
    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout (::std::unique_ptr< PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_type > p);

    // PhysicalLayoutRelationStructure_has_ValueMappingRelationship
    //
    typedef ::XMLSchema::PhysicalLayoutRelationStructure_has_ValueMappingRelationship PhysicalLayoutRelationStructure_has_ValueMappingRelationship_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalLayoutRelationStructure_has_ValueMappingRelationship_type > PhysicalLayoutRelationStructure_has_ValueMappingRelationship_sequence;
    typedef PhysicalLayoutRelationStructure_has_ValueMappingRelationship_sequence::iterator PhysicalLayoutRelationStructure_has_ValueMappingRelationship_iterator;
    typedef PhysicalLayoutRelationStructure_has_ValueMappingRelationship_sequence::const_iterator PhysicalLayoutRelationStructure_has_ValueMappingRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalLayoutRelationStructure_has_ValueMappingRelationship_type, char > PhysicalLayoutRelationStructure_has_ValueMappingRelationship_traits;

    const PhysicalLayoutRelationStructure_has_ValueMappingRelationship_sequence&
    PhysicalLayoutRelationStructure_has_ValueMappingRelationship () const;

    PhysicalLayoutRelationStructure_has_ValueMappingRelationship_sequence&
    PhysicalLayoutRelationStructure_has_ValueMappingRelationship ();

    void
    PhysicalLayoutRelationStructure_has_ValueMappingRelationship (const PhysicalLayoutRelationStructure_has_ValueMappingRelationship_sequence& s);

    // Constructors.
    //
    PhysicalLayoutRelationStructure (const topology_type&);

    PhysicalLayoutRelationStructure (::std::unique_ptr< topology_type >);

    PhysicalLayoutRelationStructure (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    PhysicalLayoutRelationStructure (const PhysicalLayoutRelationStructure& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual PhysicalLayoutRelationStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PhysicalLayoutRelationStructure&
    operator= (const PhysicalLayoutRelationStructure& x);

    virtual 
    ~PhysicalLayoutRelationStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    criteria_optional criteria_;
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    semantics_optional semantics_;
    specification_optional specification_;
    ::xsd::cxx::tree::one< topology_type > topology_;
    totality_optional totality_;
    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_optional PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_;
    PhysicalLayoutRelationStructure_has_ValueMappingRelationship_sequence PhysicalLayoutRelationStructure_has_ValueMappingRelationship_;
  };

  class PhysicalRecordSegment: public ::xml_schema::type
  {
    public:
    // allowsDuplicates
    //
    typedef ::xml_schema::boolean allowsDuplicates_type;
    typedef ::xsd::cxx::tree::traits< allowsDuplicates_type, char > allowsDuplicates_traits;

    const allowsDuplicates_type&
    allowsDuplicates () const;

    allowsDuplicates_type&
    allowsDuplicates ();

    void
    allowsDuplicates (const allowsDuplicates_type& x);

    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // physicalFileName
    //
    typedef ::xml_schema::string physicalFileName_type;
    typedef ::xsd::cxx::tree::optional< physicalFileName_type > physicalFileName_optional;
    typedef ::xsd::cxx::tree::traits< physicalFileName_type, char > physicalFileName_traits;

    const physicalFileName_optional&
    physicalFileName () const;

    physicalFileName_optional&
    physicalFileName ();

    void
    physicalFileName (const physicalFileName_type& x);

    void
    physicalFileName (const physicalFileName_optional& x);

    void
    physicalFileName (::std::unique_ptr< physicalFileName_type > p);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // PhysicalRecordSegment_represents_Population
    //
    typedef ::XMLSchema::PhysicalRecordSegment_represents_Population PhysicalRecordSegment_represents_Population_type;
    typedef ::xsd::cxx::tree::optional< PhysicalRecordSegment_represents_Population_type > PhysicalRecordSegment_represents_Population_optional;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegment_represents_Population_type, char > PhysicalRecordSegment_represents_Population_traits;

    const PhysicalRecordSegment_represents_Population_optional&
    PhysicalRecordSegment_represents_Population () const;

    PhysicalRecordSegment_represents_Population_optional&
    PhysicalRecordSegment_represents_Population ();

    void
    PhysicalRecordSegment_represents_Population (const PhysicalRecordSegment_represents_Population_type& x);

    void
    PhysicalRecordSegment_represents_Population (const PhysicalRecordSegment_represents_Population_optional& x);

    void
    PhysicalRecordSegment_represents_Population (::std::unique_ptr< PhysicalRecordSegment_represents_Population_type > p);

    // PhysicalRecordSegment_isDefinedBy_Concept
    //
    typedef ::XMLSchema::PhysicalRecordSegment_isDefinedBy_Concept PhysicalRecordSegment_isDefinedBy_Concept_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalRecordSegment_isDefinedBy_Concept_type > PhysicalRecordSegment_isDefinedBy_Concept_sequence;
    typedef PhysicalRecordSegment_isDefinedBy_Concept_sequence::iterator PhysicalRecordSegment_isDefinedBy_Concept_iterator;
    typedef PhysicalRecordSegment_isDefinedBy_Concept_sequence::const_iterator PhysicalRecordSegment_isDefinedBy_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegment_isDefinedBy_Concept_type, char > PhysicalRecordSegment_isDefinedBy_Concept_traits;

    const PhysicalRecordSegment_isDefinedBy_Concept_sequence&
    PhysicalRecordSegment_isDefinedBy_Concept () const;

    PhysicalRecordSegment_isDefinedBy_Concept_sequence&
    PhysicalRecordSegment_isDefinedBy_Concept ();

    void
    PhysicalRecordSegment_isDefinedBy_Concept (const PhysicalRecordSegment_isDefinedBy_Concept_sequence& s);

    // PhysicalRecordSegment_has_PhysicalSegmentLayout
    //
    typedef ::XMLSchema::PhysicalRecordSegment_has_PhysicalSegmentLayout PhysicalRecordSegment_has_PhysicalSegmentLayout_type;
    typedef ::xsd::cxx::tree::optional< PhysicalRecordSegment_has_PhysicalSegmentLayout_type > PhysicalRecordSegment_has_PhysicalSegmentLayout_optional;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegment_has_PhysicalSegmentLayout_type, char > PhysicalRecordSegment_has_PhysicalSegmentLayout_traits;

    const PhysicalRecordSegment_has_PhysicalSegmentLayout_optional&
    PhysicalRecordSegment_has_PhysicalSegmentLayout () const;

    PhysicalRecordSegment_has_PhysicalSegmentLayout_optional&
    PhysicalRecordSegment_has_PhysicalSegmentLayout ();

    void
    PhysicalRecordSegment_has_PhysicalSegmentLayout (const PhysicalRecordSegment_has_PhysicalSegmentLayout_type& x);

    void
    PhysicalRecordSegment_has_PhysicalSegmentLayout (const PhysicalRecordSegment_has_PhysicalSegmentLayout_optional& x);

    void
    PhysicalRecordSegment_has_PhysicalSegmentLayout (::std::unique_ptr< PhysicalRecordSegment_has_PhysicalSegmentLayout_type > p);

    // PhysicalRecordSegment_mapsTo_LogicalRecord
    //
    typedef ::XMLSchema::PhysicalRecordSegment_mapsTo_LogicalRecord PhysicalRecordSegment_mapsTo_LogicalRecord_type;
    typedef ::xsd::cxx::tree::optional< PhysicalRecordSegment_mapsTo_LogicalRecord_type > PhysicalRecordSegment_mapsTo_LogicalRecord_optional;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegment_mapsTo_LogicalRecord_type, char > PhysicalRecordSegment_mapsTo_LogicalRecord_traits;

    const PhysicalRecordSegment_mapsTo_LogicalRecord_optional&
    PhysicalRecordSegment_mapsTo_LogicalRecord () const;

    PhysicalRecordSegment_mapsTo_LogicalRecord_optional&
    PhysicalRecordSegment_mapsTo_LogicalRecord ();

    void
    PhysicalRecordSegment_mapsTo_LogicalRecord (const PhysicalRecordSegment_mapsTo_LogicalRecord_type& x);

    void
    PhysicalRecordSegment_mapsTo_LogicalRecord (const PhysicalRecordSegment_mapsTo_LogicalRecord_optional& x);

    void
    PhysicalRecordSegment_mapsTo_LogicalRecord (::std::unique_ptr< PhysicalRecordSegment_mapsTo_LogicalRecord_type > p);

    // PhysicalRecordSegment_has_DataPointPosition
    //
    typedef ::XMLSchema::PhysicalRecordSegment_has_DataPointPosition PhysicalRecordSegment_has_DataPointPosition_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalRecordSegment_has_DataPointPosition_type > PhysicalRecordSegment_has_DataPointPosition_sequence;
    typedef PhysicalRecordSegment_has_DataPointPosition_sequence::iterator PhysicalRecordSegment_has_DataPointPosition_iterator;
    typedef PhysicalRecordSegment_has_DataPointPosition_sequence::const_iterator PhysicalRecordSegment_has_DataPointPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegment_has_DataPointPosition_type, char > PhysicalRecordSegment_has_DataPointPosition_traits;

    const PhysicalRecordSegment_has_DataPointPosition_sequence&
    PhysicalRecordSegment_has_DataPointPosition () const;

    PhysicalRecordSegment_has_DataPointPosition_sequence&
    PhysicalRecordSegment_has_DataPointPosition ();

    void
    PhysicalRecordSegment_has_DataPointPosition (const PhysicalRecordSegment_has_DataPointPosition_sequence& s);

    // PhysicalRecordSegment_has_DataPoint
    //
    typedef ::XMLSchema::PhysicalRecordSegment_has_DataPoint PhysicalRecordSegment_has_DataPoint_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalRecordSegment_has_DataPoint_type > PhysicalRecordSegment_has_DataPoint_sequence;
    typedef PhysicalRecordSegment_has_DataPoint_sequence::iterator PhysicalRecordSegment_has_DataPoint_iterator;
    typedef PhysicalRecordSegment_has_DataPoint_sequence::const_iterator PhysicalRecordSegment_has_DataPoint_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegment_has_DataPoint_type, char > PhysicalRecordSegment_has_DataPoint_traits;

    const PhysicalRecordSegment_has_DataPoint_sequence&
    PhysicalRecordSegment_has_DataPoint () const;

    PhysicalRecordSegment_has_DataPoint_sequence&
    PhysicalRecordSegment_has_DataPoint ();

    void
    PhysicalRecordSegment_has_DataPoint (const PhysicalRecordSegment_has_DataPoint_sequence& s);

    // Constructors.
    //
    PhysicalRecordSegment (const allowsDuplicates_type&);

    PhysicalRecordSegment (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    PhysicalRecordSegment (const PhysicalRecordSegment& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegment*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PhysicalRecordSegment&
    operator= (const PhysicalRecordSegment& x);

    virtual 
    ~PhysicalRecordSegment ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< allowsDuplicates_type > allowsDuplicates_;
    catalogDetails_optional catalogDetails_;
    identifier_optional identifier_;
    name_sequence name_;
    physicalFileName_optional physicalFileName_;
    purpose_optional purpose_;
    PhysicalRecordSegment_represents_Population_optional PhysicalRecordSegment_represents_Population_;
    PhysicalRecordSegment_isDefinedBy_Concept_sequence PhysicalRecordSegment_isDefinedBy_Concept_;
    PhysicalRecordSegment_has_PhysicalSegmentLayout_optional PhysicalRecordSegment_has_PhysicalSegmentLayout_;
    PhysicalRecordSegment_mapsTo_LogicalRecord_optional PhysicalRecordSegment_mapsTo_LogicalRecord_;
    PhysicalRecordSegment_has_DataPointPosition_sequence PhysicalRecordSegment_has_DataPointPosition_;
    PhysicalRecordSegment_has_DataPoint_sequence PhysicalRecordSegment_has_DataPoint_;
  };

  class PhysicalRecordSegmentPosition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // value
    //
    typedef ::xml_schema::integer value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    // PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment
    //
    typedef ::XMLSchema::PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type, char > PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_traits;

    const PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type&
    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment () const;

    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type&
    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment ();

    void
    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment (const PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type& x);

    void
    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment (::std::unique_ptr< PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type > p);

    // Constructors.
    //
    PhysicalRecordSegmentPosition (const value_type&,
                                   const PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type&);

    PhysicalRecordSegmentPosition (const value_type&,
                                   ::std::unique_ptr< PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type >);

    PhysicalRecordSegmentPosition (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    PhysicalRecordSegmentPosition (const PhysicalRecordSegmentPosition& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegmentPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PhysicalRecordSegmentPosition&
    operator= (const PhysicalRecordSegmentPosition& x);

    virtual 
    ~PhysicalRecordSegmentPosition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< value_type > value_;
    ::xsd::cxx::tree::one< PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_type > PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_;
  };

  class PhysicalRecordSegmentRelationship: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment
    //
    typedef ::XMLSchema::PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_type > PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_sequence;
    typedef PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_sequence::iterator PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_iterator;
    typedef PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_sequence::const_iterator PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_type, char > PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_traits;

    const PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_sequence&
    PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment () const;

    PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_sequence&
    PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment ();

    void
    PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment (const PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_sequence& s);

    // PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment
    //
    typedef ::XMLSchema::PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_type;
    typedef ::xsd::cxx::tree::optional< PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_type > PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_optional;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_type, char > PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_traits;

    const PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_optional&
    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment () const;

    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_optional&
    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment ();

    void
    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment (const PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_type& x);

    void
    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment (const PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_optional& x);

    void
    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment (::std::unique_ptr< PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_type > p);

    // Constructors.
    //
    PhysicalRecordSegmentRelationship ();

    PhysicalRecordSegmentRelationship (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    PhysicalRecordSegmentRelationship (const PhysicalRecordSegmentRelationship& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegmentRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PhysicalRecordSegmentRelationship&
    operator= (const PhysicalRecordSegmentRelationship& x);

    virtual 
    ~PhysicalRecordSegmentRelationship ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    semantics_optional semantics_;
    PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_sequence PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_;
    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_optional PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_;
  };

  class PhysicalRecordSegmentStructure: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::unique_ptr< name_type > p);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // specification
    //
    typedef ::XMLSchema::StructureSpecification specification_type;
    typedef ::xsd::cxx::tree::optional< specification_type > specification_optional;
    typedef ::xsd::cxx::tree::traits< specification_type, char > specification_traits;

    const specification_optional&
    specification () const;

    specification_optional&
    specification ();

    void
    specification (const specification_type& x);

    void
    specification (const specification_optional& x);

    void
    specification (::std::unique_ptr< specification_type > p);

    // topology
    //
    typedef ::XMLSchema::ControlledVocabularyEntry topology_type;
    typedef ::xsd::cxx::tree::optional< topology_type > topology_optional;
    typedef ::xsd::cxx::tree::traits< topology_type, char > topology_traits;

    const topology_optional&
    topology () const;

    topology_optional&
    topology ();

    void
    topology (const topology_type& x);

    void
    topology (const topology_optional& x);

    void
    topology (::std::unique_ptr< topology_type > p);

    // totality
    //
    typedef ::XMLSchema::StructureExtent totality_type;
    typedef ::xsd::cxx::tree::optional< totality_type > totality_optional;
    typedef ::xsd::cxx::tree::traits< totality_type, char > totality_traits;

    const totality_optional&
    totality () const;

    totality_optional&
    totality ();

    void
    totality (const totality_type& x);

    void
    totality (const totality_optional& x);

    void
    totality (::std::unique_ptr< totality_type > p);

    // PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment
    //
    typedef ::XMLSchema::PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_type;
    typedef ::xsd::cxx::tree::optional< PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_type > PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_optional;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_type, char > PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_traits;

    const PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_optional&
    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment () const;

    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_optional&
    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment ();

    void
    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment (const PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_type& x);

    void
    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment (const PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_optional& x);

    void
    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment (::std::unique_ptr< PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_type > p);

    // PhysicalRecordSegmentStructure_has_DataPointRelationship
    //
    typedef ::XMLSchema::PhysicalRecordSegmentStructure_has_DataPointRelationship PhysicalRecordSegmentStructure_has_DataPointRelationship_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalRecordSegmentStructure_has_DataPointRelationship_type > PhysicalRecordSegmentStructure_has_DataPointRelationship_sequence;
    typedef PhysicalRecordSegmentStructure_has_DataPointRelationship_sequence::iterator PhysicalRecordSegmentStructure_has_DataPointRelationship_iterator;
    typedef PhysicalRecordSegmentStructure_has_DataPointRelationship_sequence::const_iterator PhysicalRecordSegmentStructure_has_DataPointRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalRecordSegmentStructure_has_DataPointRelationship_type, char > PhysicalRecordSegmentStructure_has_DataPointRelationship_traits;

    const PhysicalRecordSegmentStructure_has_DataPointRelationship_sequence&
    PhysicalRecordSegmentStructure_has_DataPointRelationship () const;

    PhysicalRecordSegmentStructure_has_DataPointRelationship_sequence&
    PhysicalRecordSegmentStructure_has_DataPointRelationship ();

    void
    PhysicalRecordSegmentStructure_has_DataPointRelationship (const PhysicalRecordSegmentStructure_has_DataPointRelationship_sequence& s);

    // Constructors.
    //
    PhysicalRecordSegmentStructure ();

    PhysicalRecordSegmentStructure (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    PhysicalRecordSegmentStructure (const PhysicalRecordSegmentStructure& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegmentStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PhysicalRecordSegmentStructure&
    operator= (const PhysicalRecordSegmentStructure& x);

    virtual 
    ~PhysicalRecordSegmentStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    name_optional name_;
    purpose_optional purpose_;
    semantics_optional semantics_;
    specification_optional specification_;
    topology_optional topology_;
    totality_optional totality_;
    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_optional PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_;
    PhysicalRecordSegmentStructure_has_DataPointRelationship_sequence PhysicalRecordSegmentStructure_has_DataPointRelationship_;
  };

  class PhysicalSegmentLayout: public ::xml_schema::type
  {
    public:
    // allowsDuplicates
    //
    typedef ::xml_schema::boolean allowsDuplicates_type;
    typedef ::xsd::cxx::tree::traits< allowsDuplicates_type, char > allowsDuplicates_traits;

    const allowsDuplicates_type&
    allowsDuplicates () const;

    allowsDuplicates_type&
    allowsDuplicates ();

    void
    allowsDuplicates (const allowsDuplicates_type& x);

    // arrayBase
    //
    typedef ::xml_schema::integer arrayBase_type;
    typedef ::xsd::cxx::tree::optional< arrayBase_type > arrayBase_optional;
    typedef ::xsd::cxx::tree::traits< arrayBase_type, char > arrayBase_traits;

    const arrayBase_optional&
    arrayBase () const;

    arrayBase_optional&
    arrayBase ();

    void
    arrayBase (const arrayBase_type& x);

    void
    arrayBase (const arrayBase_optional& x);

    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // commentPrefix
    //
    typedef ::xml_schema::string commentPrefix_type;
    typedef ::xsd::cxx::tree::optional< commentPrefix_type > commentPrefix_optional;
    typedef ::xsd::cxx::tree::traits< commentPrefix_type, char > commentPrefix_traits;

    const commentPrefix_optional&
    commentPrefix () const;

    commentPrefix_optional&
    commentPrefix ();

    void
    commentPrefix (const commentPrefix_type& x);

    void
    commentPrefix (const commentPrefix_optional& x);

    void
    commentPrefix (::std::unique_ptr< commentPrefix_type > p);

    // delimiter
    //
    typedef ::xml_schema::string delimiter_type;
    typedef ::xsd::cxx::tree::optional< delimiter_type > delimiter_optional;
    typedef ::xsd::cxx::tree::traits< delimiter_type, char > delimiter_traits;

    const delimiter_optional&
    delimiter () const;

    delimiter_optional&
    delimiter ();

    void
    delimiter (const delimiter_type& x);

    void
    delimiter (const delimiter_optional& x);

    void
    delimiter (::std::unique_ptr< delimiter_type > p);

    // encoding
    //
    typedef ::XMLSchema::ControlledVocabularyEntry encoding_type;
    typedef ::xsd::cxx::tree::optional< encoding_type > encoding_optional;
    typedef ::xsd::cxx::tree::traits< encoding_type, char > encoding_traits;

    const encoding_optional&
    encoding () const;

    encoding_optional&
    encoding ();

    void
    encoding (const encoding_type& x);

    void
    encoding (const encoding_optional& x);

    void
    encoding (::std::unique_ptr< encoding_type > p);

    // escapeCharacter
    //
    typedef ::xml_schema::string escapeCharacter_type;
    typedef ::xsd::cxx::tree::optional< escapeCharacter_type > escapeCharacter_optional;
    typedef ::xsd::cxx::tree::traits< escapeCharacter_type, char > escapeCharacter_traits;

    const escapeCharacter_optional&
    escapeCharacter () const;

    escapeCharacter_optional&
    escapeCharacter ();

    void
    escapeCharacter (const escapeCharacter_type& x);

    void
    escapeCharacter (const escapeCharacter_optional& x);

    void
    escapeCharacter (::std::unique_ptr< escapeCharacter_type > p);

    // hasHeader
    //
    typedef ::xml_schema::boolean hasHeader_type;
    typedef ::xsd::cxx::tree::optional< hasHeader_type > hasHeader_optional;
    typedef ::xsd::cxx::tree::traits< hasHeader_type, char > hasHeader_traits;

    const hasHeader_optional&
    hasHeader () const;

    hasHeader_optional&
    hasHeader ();

    void
    hasHeader (const hasHeader_type& x);

    void
    hasHeader (const hasHeader_optional& x);

    // headerIsCaseSensitive
    //
    typedef ::xml_schema::boolean headerIsCaseSensitive_type;
    typedef ::xsd::cxx::tree::optional< headerIsCaseSensitive_type > headerIsCaseSensitive_optional;
    typedef ::xsd::cxx::tree::traits< headerIsCaseSensitive_type, char > headerIsCaseSensitive_traits;

    const headerIsCaseSensitive_optional&
    headerIsCaseSensitive () const;

    headerIsCaseSensitive_optional&
    headerIsCaseSensitive ();

    void
    headerIsCaseSensitive (const headerIsCaseSensitive_type& x);

    void
    headerIsCaseSensitive (const headerIsCaseSensitive_optional& x);

    // headerRowCount
    //
    typedef ::xml_schema::integer headerRowCount_type;
    typedef ::xsd::cxx::tree::optional< headerRowCount_type > headerRowCount_optional;
    typedef ::xsd::cxx::tree::traits< headerRowCount_type, char > headerRowCount_traits;

    const headerRowCount_optional&
    headerRowCount () const;

    headerRowCount_optional&
    headerRowCount ();

    void
    headerRowCount (const headerRowCount_type& x);

    void
    headerRowCount (const headerRowCount_optional& x);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // isDelimited
    //
    typedef ::xml_schema::boolean isDelimited_type;
    typedef ::xsd::cxx::tree::traits< isDelimited_type, char > isDelimited_traits;

    const isDelimited_type&
    isDelimited () const;

    isDelimited_type&
    isDelimited ();

    void
    isDelimited (const isDelimited_type& x);

    // isFixedWidth
    //
    typedef ::xml_schema::boolean isFixedWidth_type;
    typedef ::xsd::cxx::tree::traits< isFixedWidth_type, char > isFixedWidth_traits;

    const isFixedWidth_type&
    isFixedWidth () const;

    isFixedWidth_type&
    isFixedWidth ();

    void
    isFixedWidth (const isFixedWidth_type& x);

    // lineTerminator
    //
    typedef ::xml_schema::string lineTerminator_type;
    typedef ::xsd::cxx::tree::sequence< lineTerminator_type > lineTerminator_sequence;
    typedef lineTerminator_sequence::iterator lineTerminator_iterator;
    typedef lineTerminator_sequence::const_iterator lineTerminator_const_iterator;
    typedef ::xsd::cxx::tree::traits< lineTerminator_type, char > lineTerminator_traits;

    const lineTerminator_sequence&
    lineTerminator () const;

    lineTerminator_sequence&
    lineTerminator ();

    void
    lineTerminator (const lineTerminator_sequence& s);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // nullSequence
    //
    typedef ::xml_schema::string nullSequence_type;
    typedef ::xsd::cxx::tree::optional< nullSequence_type > nullSequence_optional;
    typedef ::xsd::cxx::tree::traits< nullSequence_type, char > nullSequence_traits;

    const nullSequence_optional&
    nullSequence () const;

    nullSequence_optional&
    nullSequence ();

    void
    nullSequence (const nullSequence_type& x);

    void
    nullSequence (const nullSequence_optional& x);

    void
    nullSequence (::std::unique_ptr< nullSequence_type > p);

    // overview
    //
    typedef ::XMLSchema::InternationalString overview_type;
    typedef ::xsd::cxx::tree::optional< overview_type > overview_optional;
    typedef ::xsd::cxx::tree::traits< overview_type, char > overview_traits;

    const overview_optional&
    overview () const;

    overview_optional&
    overview ();

    void
    overview (const overview_type& x);

    void
    overview (const overview_optional& x);

    void
    overview (::std::unique_ptr< overview_type > p);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // quoteCharacter
    //
    typedef ::xml_schema::string quoteCharacter_type;
    typedef ::xsd::cxx::tree::optional< quoteCharacter_type > quoteCharacter_optional;
    typedef ::xsd::cxx::tree::traits< quoteCharacter_type, char > quoteCharacter_traits;

    const quoteCharacter_optional&
    quoteCharacter () const;

    quoteCharacter_optional&
    quoteCharacter ();

    void
    quoteCharacter (const quoteCharacter_type& x);

    void
    quoteCharacter (const quoteCharacter_optional& x);

    void
    quoteCharacter (::std::unique_ptr< quoteCharacter_type > p);

    // skipBlankRows
    //
    typedef ::xml_schema::boolean skipBlankRows_type;
    typedef ::xsd::cxx::tree::optional< skipBlankRows_type > skipBlankRows_optional;
    typedef ::xsd::cxx::tree::traits< skipBlankRows_type, char > skipBlankRows_traits;

    const skipBlankRows_optional&
    skipBlankRows () const;

    skipBlankRows_optional&
    skipBlankRows ();

    void
    skipBlankRows (const skipBlankRows_type& x);

    void
    skipBlankRows (const skipBlankRows_optional& x);

    // skipDataColumns
    //
    typedef ::xml_schema::integer skipDataColumns_type;
    typedef ::xsd::cxx::tree::optional< skipDataColumns_type > skipDataColumns_optional;
    typedef ::xsd::cxx::tree::traits< skipDataColumns_type, char > skipDataColumns_traits;

    const skipDataColumns_optional&
    skipDataColumns () const;

    skipDataColumns_optional&
    skipDataColumns ();

    void
    skipDataColumns (const skipDataColumns_type& x);

    void
    skipDataColumns (const skipDataColumns_optional& x);

    // skipInitialSpace
    //
    typedef ::xml_schema::boolean skipInitialSpace_type;
    typedef ::xsd::cxx::tree::optional< skipInitialSpace_type > skipInitialSpace_optional;
    typedef ::xsd::cxx::tree::traits< skipInitialSpace_type, char > skipInitialSpace_traits;

    const skipInitialSpace_optional&
    skipInitialSpace () const;

    skipInitialSpace_optional&
    skipInitialSpace ();

    void
    skipInitialSpace (const skipInitialSpace_type& x);

    void
    skipInitialSpace (const skipInitialSpace_optional& x);

    // skipRows
    //
    typedef ::xml_schema::integer skipRows_type;
    typedef ::xsd::cxx::tree::optional< skipRows_type > skipRows_optional;
    typedef ::xsd::cxx::tree::traits< skipRows_type, char > skipRows_traits;

    const skipRows_optional&
    skipRows () const;

    skipRows_optional&
    skipRows ();

    void
    skipRows (const skipRows_type& x);

    void
    skipRows (const skipRows_optional& x);

    // tableDirection
    //
    typedef ::XMLSchema::TableDirectionValues tableDirection_type;
    typedef ::xsd::cxx::tree::optional< tableDirection_type > tableDirection_optional;
    typedef ::xsd::cxx::tree::traits< tableDirection_type, char > tableDirection_traits;

    const tableDirection_optional&
    tableDirection () const;

    tableDirection_optional&
    tableDirection ();

    void
    tableDirection (const tableDirection_type& x);

    void
    tableDirection (const tableDirection_optional& x);

    void
    tableDirection (::std::unique_ptr< tableDirection_type > p);

    // textDirection
    //
    typedef ::XMLSchema::TextDirectionValues textDirection_type;
    typedef ::xsd::cxx::tree::optional< textDirection_type > textDirection_optional;
    typedef ::xsd::cxx::tree::traits< textDirection_type, char > textDirection_traits;

    const textDirection_optional&
    textDirection () const;

    textDirection_optional&
    textDirection ();

    void
    textDirection (const textDirection_type& x);

    void
    textDirection (const textDirection_optional& x);

    void
    textDirection (::std::unique_ptr< textDirection_type > p);

    // treatConsecutiveDelimitersAsOne
    //
    typedef ::xml_schema::boolean treatConsecutiveDelimitersAsOne_type;
    typedef ::xsd::cxx::tree::optional< treatConsecutiveDelimitersAsOne_type > treatConsecutiveDelimitersAsOne_optional;
    typedef ::xsd::cxx::tree::traits< treatConsecutiveDelimitersAsOne_type, char > treatConsecutiveDelimitersAsOne_traits;

    const treatConsecutiveDelimitersAsOne_optional&
    treatConsecutiveDelimitersAsOne () const;

    treatConsecutiveDelimitersAsOne_optional&
    treatConsecutiveDelimitersAsOne ();

    void
    treatConsecutiveDelimitersAsOne (const treatConsecutiveDelimitersAsOne_type& x);

    void
    treatConsecutiveDelimitersAsOne (const treatConsecutiveDelimitersAsOne_optional& x);

    // trim
    //
    typedef ::XMLSchema::TrimValues trim_type;
    typedef ::xsd::cxx::tree::optional< trim_type > trim_optional;
    typedef ::xsd::cxx::tree::traits< trim_type, char > trim_traits;

    const trim_optional&
    trim () const;

    trim_optional&
    trim ();

    void
    trim (const trim_type& x);

    void
    trim (const trim_optional& x);

    void
    trim (::std::unique_ptr< trim_type > p);

    // PhysicalSegmentLayout_isDefinedBy_Concept
    //
    typedef ::XMLSchema::PhysicalSegmentLayout_isDefinedBy_Concept PhysicalSegmentLayout_isDefinedBy_Concept_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalSegmentLayout_isDefinedBy_Concept_type > PhysicalSegmentLayout_isDefinedBy_Concept_sequence;
    typedef PhysicalSegmentLayout_isDefinedBy_Concept_sequence::iterator PhysicalSegmentLayout_isDefinedBy_Concept_iterator;
    typedef PhysicalSegmentLayout_isDefinedBy_Concept_sequence::const_iterator PhysicalSegmentLayout_isDefinedBy_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalSegmentLayout_isDefinedBy_Concept_type, char > PhysicalSegmentLayout_isDefinedBy_Concept_traits;

    const PhysicalSegmentLayout_isDefinedBy_Concept_sequence&
    PhysicalSegmentLayout_isDefinedBy_Concept () const;

    PhysicalSegmentLayout_isDefinedBy_Concept_sequence&
    PhysicalSegmentLayout_isDefinedBy_Concept ();

    void
    PhysicalSegmentLayout_isDefinedBy_Concept (const PhysicalSegmentLayout_isDefinedBy_Concept_sequence& s);

    // PhysicalSegmentLayout_formats_LogicalRecord
    //
    typedef ::XMLSchema::PhysicalSegmentLayout_formats_LogicalRecord PhysicalSegmentLayout_formats_LogicalRecord_type;
    typedef ::xsd::cxx::tree::optional< PhysicalSegmentLayout_formats_LogicalRecord_type > PhysicalSegmentLayout_formats_LogicalRecord_optional;
    typedef ::xsd::cxx::tree::traits< PhysicalSegmentLayout_formats_LogicalRecord_type, char > PhysicalSegmentLayout_formats_LogicalRecord_traits;

    const PhysicalSegmentLayout_formats_LogicalRecord_optional&
    PhysicalSegmentLayout_formats_LogicalRecord () const;

    PhysicalSegmentLayout_formats_LogicalRecord_optional&
    PhysicalSegmentLayout_formats_LogicalRecord ();

    void
    PhysicalSegmentLayout_formats_LogicalRecord (const PhysicalSegmentLayout_formats_LogicalRecord_type& x);

    void
    PhysicalSegmentLayout_formats_LogicalRecord (const PhysicalSegmentLayout_formats_LogicalRecord_optional& x);

    void
    PhysicalSegmentLayout_formats_LogicalRecord (::std::unique_ptr< PhysicalSegmentLayout_formats_LogicalRecord_type > p);

    // PhysicalSegmentLayout_has_ValueMapping
    //
    typedef ::XMLSchema::PhysicalSegmentLayout_has_ValueMapping PhysicalSegmentLayout_has_ValueMapping_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalSegmentLayout_has_ValueMapping_type > PhysicalSegmentLayout_has_ValueMapping_sequence;
    typedef PhysicalSegmentLayout_has_ValueMapping_sequence::iterator PhysicalSegmentLayout_has_ValueMapping_iterator;
    typedef PhysicalSegmentLayout_has_ValueMapping_sequence::const_iterator PhysicalSegmentLayout_has_ValueMapping_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalSegmentLayout_has_ValueMapping_type, char > PhysicalSegmentLayout_has_ValueMapping_traits;

    const PhysicalSegmentLayout_has_ValueMapping_sequence&
    PhysicalSegmentLayout_has_ValueMapping () const;

    PhysicalSegmentLayout_has_ValueMapping_sequence&
    PhysicalSegmentLayout_has_ValueMapping ();

    void
    PhysicalSegmentLayout_has_ValueMapping (const PhysicalSegmentLayout_has_ValueMapping_sequence& s);

    // PhysicalSegmentLayout_has_ValueMappingPosition
    //
    typedef ::XMLSchema::PhysicalSegmentLayout_has_ValueMappingPosition PhysicalSegmentLayout_has_ValueMappingPosition_type;
    typedef ::xsd::cxx::tree::sequence< PhysicalSegmentLayout_has_ValueMappingPosition_type > PhysicalSegmentLayout_has_ValueMappingPosition_sequence;
    typedef PhysicalSegmentLayout_has_ValueMappingPosition_sequence::iterator PhysicalSegmentLayout_has_ValueMappingPosition_iterator;
    typedef PhysicalSegmentLayout_has_ValueMappingPosition_sequence::const_iterator PhysicalSegmentLayout_has_ValueMappingPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< PhysicalSegmentLayout_has_ValueMappingPosition_type, char > PhysicalSegmentLayout_has_ValueMappingPosition_traits;

    const PhysicalSegmentLayout_has_ValueMappingPosition_sequence&
    PhysicalSegmentLayout_has_ValueMappingPosition () const;

    PhysicalSegmentLayout_has_ValueMappingPosition_sequence&
    PhysicalSegmentLayout_has_ValueMappingPosition ();

    void
    PhysicalSegmentLayout_has_ValueMappingPosition (const PhysicalSegmentLayout_has_ValueMappingPosition_sequence& s);

    // Constructors.
    //
    PhysicalSegmentLayout (const allowsDuplicates_type&,
                           const isDelimited_type&,
                           const isFixedWidth_type&);

    PhysicalSegmentLayout (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    PhysicalSegmentLayout (const PhysicalSegmentLayout& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual PhysicalSegmentLayout*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PhysicalSegmentLayout&
    operator= (const PhysicalSegmentLayout& x);

    virtual 
    ~PhysicalSegmentLayout ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< allowsDuplicates_type > allowsDuplicates_;
    arrayBase_optional arrayBase_;
    catalogDetails_optional catalogDetails_;
    commentPrefix_optional commentPrefix_;
    delimiter_optional delimiter_;
    encoding_optional encoding_;
    escapeCharacter_optional escapeCharacter_;
    hasHeader_optional hasHeader_;
    headerIsCaseSensitive_optional headerIsCaseSensitive_;
    headerRowCount_optional headerRowCount_;
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< isDelimited_type > isDelimited_;
    ::xsd::cxx::tree::one< isFixedWidth_type > isFixedWidth_;
    lineTerminator_sequence lineTerminator_;
    name_sequence name_;
    nullSequence_optional nullSequence_;
    overview_optional overview_;
    purpose_optional purpose_;
    quoteCharacter_optional quoteCharacter_;
    skipBlankRows_optional skipBlankRows_;
    skipDataColumns_optional skipDataColumns_;
    skipInitialSpace_optional skipInitialSpace_;
    skipRows_optional skipRows_;
    tableDirection_optional tableDirection_;
    textDirection_optional textDirection_;
    treatConsecutiveDelimitersAsOne_optional treatConsecutiveDelimitersAsOne_;
    trim_optional trim_;
    PhysicalSegmentLayout_isDefinedBy_Concept_sequence PhysicalSegmentLayout_isDefinedBy_Concept_;
    PhysicalSegmentLayout_formats_LogicalRecord_optional PhysicalSegmentLayout_formats_LogicalRecord_;
    PhysicalSegmentLayout_has_ValueMapping_sequence PhysicalSegmentLayout_has_ValueMapping_;
    PhysicalSegmentLayout_has_ValueMappingPosition_sequence PhysicalSegmentLayout_has_ValueMappingPosition_;
  };

  class PhysicalSegmentLocation: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // Constructors.
    //
    PhysicalSegmentLocation ();

    PhysicalSegmentLocation (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    PhysicalSegmentLocation (const PhysicalSegmentLocation& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual PhysicalSegmentLocation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PhysicalSegmentLocation&
    operator= (const PhysicalSegmentLocation& x);

    virtual 
    ~PhysicalSegmentLocation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    identifier_optional identifier_;
  };

  class UnitType: public ::XMLSchema::Concept
  {
    public:
    // descriptiveText
    //
    typedef ::XMLSchema::InternationalString descriptiveText_type;
    typedef ::xsd::cxx::tree::optional< descriptiveText_type > descriptiveText_optional;
    typedef ::xsd::cxx::tree::traits< descriptiveText_type, char > descriptiveText_traits;

    const descriptiveText_optional&
    descriptiveText () const;

    descriptiveText_optional&
    descriptiveText ();

    void
    descriptiveText (const descriptiveText_type& x);

    void
    descriptiveText (const descriptiveText_optional& x);

    void
    descriptiveText (::std::unique_ptr< descriptiveText_type > p);

    // Constructors.
    //
    UnitType ();

    UnitType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    UnitType (const UnitType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual UnitType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    UnitType&
    operator= (const UnitType& x);

    virtual 
    ~UnitType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    descriptiveText_optional descriptiveText_;
  };

  class Universe: public ::XMLSchema::UnitType
  {
    public:
    // isInclusive
    //
    typedef ::xml_schema::boolean isInclusive_type;
    typedef ::xsd::cxx::tree::optional< isInclusive_type > isInclusive_optional;
    typedef ::xsd::cxx::tree::traits< isInclusive_type, char > isInclusive_traits;

    const isInclusive_optional&
    isInclusive () const;

    isInclusive_optional&
    isInclusive ();

    void
    isInclusive (const isInclusive_type& x);

    void
    isInclusive (const isInclusive_optional& x);

    // Constructors.
    //
    Universe ();

    Universe (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Universe (const Universe& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual Universe*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Universe&
    operator= (const Universe& x);

    virtual 
    ~Universe ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    isInclusive_optional isInclusive_;
  };

  class Population: public ::XMLSchema::Universe
  {
    public:
    // timePeriodOfPopulation
    //
    typedef ::XMLSchema::DateRange timePeriodOfPopulation_type;
    typedef ::xsd::cxx::tree::sequence< timePeriodOfPopulation_type > timePeriodOfPopulation_sequence;
    typedef timePeriodOfPopulation_sequence::iterator timePeriodOfPopulation_iterator;
    typedef timePeriodOfPopulation_sequence::const_iterator timePeriodOfPopulation_const_iterator;
    typedef ::xsd::cxx::tree::traits< timePeriodOfPopulation_type, char > timePeriodOfPopulation_traits;

    const timePeriodOfPopulation_sequence&
    timePeriodOfPopulation () const;

    timePeriodOfPopulation_sequence&
    timePeriodOfPopulation ();

    void
    timePeriodOfPopulation (const timePeriodOfPopulation_sequence& s);

    // Population_isComposedOf_Unit
    //
    typedef ::XMLSchema::Population_isComposedOf_Unit Population_isComposedOf_Unit_type;
    typedef ::xsd::cxx::tree::sequence< Population_isComposedOf_Unit_type > Population_isComposedOf_Unit_sequence;
    typedef Population_isComposedOf_Unit_sequence::iterator Population_isComposedOf_Unit_iterator;
    typedef Population_isComposedOf_Unit_sequence::const_iterator Population_isComposedOf_Unit_const_iterator;
    typedef ::xsd::cxx::tree::traits< Population_isComposedOf_Unit_type, char > Population_isComposedOf_Unit_traits;

    const Population_isComposedOf_Unit_sequence&
    Population_isComposedOf_Unit () const;

    Population_isComposedOf_Unit_sequence&
    Population_isComposedOf_Unit ();

    void
    Population_isComposedOf_Unit (const Population_isComposedOf_Unit_sequence& s);

    // Constructors.
    //
    Population ();

    Population (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    Population (const Population& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual Population*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Population&
    operator= (const Population& x);

    virtual 
    ~Population ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    timePeriodOfPopulation_sequence timePeriodOfPopulation_;
    Population_isComposedOf_Unit_sequence Population_isComposedOf_Unit_;
  };

  class PrimaryKey: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // PrimaryKey_isComposedOf_PrimaryKeyComponent
    //
    typedef ::XMLSchema::PrimaryKey_isComposedOf_PrimaryKeyComponent PrimaryKey_isComposedOf_PrimaryKeyComponent_type;
    typedef ::xsd::cxx::tree::sequence< PrimaryKey_isComposedOf_PrimaryKeyComponent_type > PrimaryKey_isComposedOf_PrimaryKeyComponent_sequence;
    typedef PrimaryKey_isComposedOf_PrimaryKeyComponent_sequence::iterator PrimaryKey_isComposedOf_PrimaryKeyComponent_iterator;
    typedef PrimaryKey_isComposedOf_PrimaryKeyComponent_sequence::const_iterator PrimaryKey_isComposedOf_PrimaryKeyComponent_const_iterator;
    typedef ::xsd::cxx::tree::traits< PrimaryKey_isComposedOf_PrimaryKeyComponent_type, char > PrimaryKey_isComposedOf_PrimaryKeyComponent_traits;

    const PrimaryKey_isComposedOf_PrimaryKeyComponent_sequence&
    PrimaryKey_isComposedOf_PrimaryKeyComponent () const;

    PrimaryKey_isComposedOf_PrimaryKeyComponent_sequence&
    PrimaryKey_isComposedOf_PrimaryKeyComponent ();

    void
    PrimaryKey_isComposedOf_PrimaryKeyComponent (const PrimaryKey_isComposedOf_PrimaryKeyComponent_sequence& s);

    // Constructors.
    //
    PrimaryKey ();

    PrimaryKey (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    PrimaryKey (const PrimaryKey& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual PrimaryKey*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PrimaryKey&
    operator= (const PrimaryKey& x);

    virtual 
    ~PrimaryKey ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    PrimaryKey_isComposedOf_PrimaryKeyComponent_sequence PrimaryKey_isComposedOf_PrimaryKeyComponent_;
  };

  class PrimaryKeyComponent: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // PrimaryKeyComponent_correspondsTo_DataStructureComponent
    //
    typedef ::XMLSchema::PrimaryKeyComponent_correspondsTo_DataStructureComponent PrimaryKeyComponent_correspondsTo_DataStructureComponent_type;
    typedef ::xsd::cxx::tree::traits< PrimaryKeyComponent_correspondsTo_DataStructureComponent_type, char > PrimaryKeyComponent_correspondsTo_DataStructureComponent_traits;

    const PrimaryKeyComponent_correspondsTo_DataStructureComponent_type&
    PrimaryKeyComponent_correspondsTo_DataStructureComponent () const;

    PrimaryKeyComponent_correspondsTo_DataStructureComponent_type&
    PrimaryKeyComponent_correspondsTo_DataStructureComponent ();

    void
    PrimaryKeyComponent_correspondsTo_DataStructureComponent (const PrimaryKeyComponent_correspondsTo_DataStructureComponent_type& x);

    void
    PrimaryKeyComponent_correspondsTo_DataStructureComponent (::std::unique_ptr< PrimaryKeyComponent_correspondsTo_DataStructureComponent_type > p);

    // Constructors.
    //
    PrimaryKeyComponent (const PrimaryKeyComponent_correspondsTo_DataStructureComponent_type&);

    PrimaryKeyComponent (::std::unique_ptr< PrimaryKeyComponent_correspondsTo_DataStructureComponent_type >);

    PrimaryKeyComponent (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    PrimaryKeyComponent (const PrimaryKeyComponent& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual PrimaryKeyComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PrimaryKeyComponent&
    operator= (const PrimaryKeyComponent& x);

    virtual 
    ~PrimaryKeyComponent ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< PrimaryKeyComponent_correspondsTo_DataStructureComponent_type > PrimaryKeyComponent_correspondsTo_DataStructureComponent_;
  };

  class ProductionEnvironment: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // Constructors.
    //
    ProductionEnvironment ();

    ProductionEnvironment (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    ProductionEnvironment (const ProductionEnvironment& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual ProductionEnvironment*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ProductionEnvironment&
    operator= (const ProductionEnvironment& x);

    virtual 
    ~ProductionEnvironment ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
  };

  class QualifiedMeasure: public ::XMLSchema::MeasureComponent
  {
    public:
    // QualifiedMeasure_refines_MeasureComponent
    //
    typedef ::XMLSchema::QualifiedMeasure_refines_MeasureComponent QualifiedMeasure_refines_MeasureComponent_type;
    typedef ::xsd::cxx::tree::optional< QualifiedMeasure_refines_MeasureComponent_type > QualifiedMeasure_refines_MeasureComponent_optional;
    typedef ::xsd::cxx::tree::traits< QualifiedMeasure_refines_MeasureComponent_type, char > QualifiedMeasure_refines_MeasureComponent_traits;

    const QualifiedMeasure_refines_MeasureComponent_optional&
    QualifiedMeasure_refines_MeasureComponent () const;

    QualifiedMeasure_refines_MeasureComponent_optional&
    QualifiedMeasure_refines_MeasureComponent ();

    void
    QualifiedMeasure_refines_MeasureComponent (const QualifiedMeasure_refines_MeasureComponent_type& x);

    void
    QualifiedMeasure_refines_MeasureComponent (const QualifiedMeasure_refines_MeasureComponent_optional& x);

    void
    QualifiedMeasure_refines_MeasureComponent (::std::unique_ptr< QualifiedMeasure_refines_MeasureComponent_type > p);

    // Constructors.
    //
    QualifiedMeasure ();

    QualifiedMeasure (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    QualifiedMeasure (const QualifiedMeasure& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual QualifiedMeasure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    QualifiedMeasure&
    operator= (const QualifiedMeasure& x);

    virtual 
    ~QualifiedMeasure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    QualifiedMeasure_refines_MeasureComponent_optional QualifiedMeasure_refines_MeasureComponent_;
  };

  class RecordRelation: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // displayLabel
    //
    typedef ::XMLSchema::LabelForDisplay displayLabel_type;
    typedef ::xsd::cxx::tree::sequence< displayLabel_type > displayLabel_sequence;
    typedef displayLabel_sequence::iterator displayLabel_iterator;
    typedef displayLabel_sequence::const_iterator displayLabel_const_iterator;
    typedef ::xsd::cxx::tree::traits< displayLabel_type, char > displayLabel_traits;

    const displayLabel_sequence&
    displayLabel () const;

    displayLabel_sequence&
    displayLabel ();

    void
    displayLabel (const displayLabel_sequence& s);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // usage
    //
    typedef ::XMLSchema::InternationalString usage_type;
    typedef ::xsd::cxx::tree::optional< usage_type > usage_optional;
    typedef ::xsd::cxx::tree::traits< usage_type, char > usage_traits;

    const usage_optional&
    usage () const;

    usage_optional&
    usage ();

    void
    usage (const usage_type& x);

    void
    usage (const usage_optional& x);

    void
    usage (::std::unique_ptr< usage_type > p);

    // RecordRelation_maps_LogicalRecord
    //
    typedef ::XMLSchema::RecordRelation_maps_LogicalRecord RecordRelation_maps_LogicalRecord_type;
    typedef ::xsd::cxx::tree::sequence< RecordRelation_maps_LogicalRecord_type > RecordRelation_maps_LogicalRecord_sequence;
    typedef RecordRelation_maps_LogicalRecord_sequence::iterator RecordRelation_maps_LogicalRecord_iterator;
    typedef RecordRelation_maps_LogicalRecord_sequence::const_iterator RecordRelation_maps_LogicalRecord_const_iterator;
    typedef ::xsd::cxx::tree::traits< RecordRelation_maps_LogicalRecord_type, char > RecordRelation_maps_LogicalRecord_traits;

    const RecordRelation_maps_LogicalRecord_sequence&
    RecordRelation_maps_LogicalRecord () const;

    RecordRelation_maps_LogicalRecord_sequence&
    RecordRelation_maps_LogicalRecord ();

    void
    RecordRelation_maps_LogicalRecord (const RecordRelation_maps_LogicalRecord_sequence& s);

    // RecordRelation_has_InstanceVariableMap
    //
    typedef ::XMLSchema::RecordRelation_has_InstanceVariableMap RecordRelation_has_InstanceVariableMap_type;
    typedef ::xsd::cxx::tree::sequence< RecordRelation_has_InstanceVariableMap_type > RecordRelation_has_InstanceVariableMap_sequence;
    typedef RecordRelation_has_InstanceVariableMap_sequence::iterator RecordRelation_has_InstanceVariableMap_iterator;
    typedef RecordRelation_has_InstanceVariableMap_sequence::const_iterator RecordRelation_has_InstanceVariableMap_const_iterator;
    typedef ::xsd::cxx::tree::traits< RecordRelation_has_InstanceVariableMap_type, char > RecordRelation_has_InstanceVariableMap_traits;

    const RecordRelation_has_InstanceVariableMap_sequence&
    RecordRelation_has_InstanceVariableMap () const;

    RecordRelation_has_InstanceVariableMap_sequence&
    RecordRelation_has_InstanceVariableMap ();

    void
    RecordRelation_has_InstanceVariableMap (const RecordRelation_has_InstanceVariableMap_sequence& s);

    // Constructors.
    //
    RecordRelation ();

    RecordRelation (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    RecordRelation (const RecordRelation& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual RecordRelation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RecordRelation&
    operator= (const RecordRelation& x);

    virtual 
    ~RecordRelation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    displayLabel_sequence displayLabel_;
    identifier_optional identifier_;
    purpose_optional purpose_;
    usage_optional usage_;
    RecordRelation_maps_LogicalRecord_sequence RecordRelation_maps_LogicalRecord_;
    RecordRelation_has_InstanceVariableMap_sequence RecordRelation_has_InstanceVariableMap_;
  };

  class ReferenceValue: public ::XMLSchema::InstanceValue
  {
    public:
    // ReferenceValue_correspondsTo_VariableValueComponent
    //
    typedef ::XMLSchema::ReferenceValue_correspondsTo_VariableValueComponent ReferenceValue_correspondsTo_VariableValueComponent_type;
    typedef ::xsd::cxx::tree::traits< ReferenceValue_correspondsTo_VariableValueComponent_type, char > ReferenceValue_correspondsTo_VariableValueComponent_traits;

    const ReferenceValue_correspondsTo_VariableValueComponent_type&
    ReferenceValue_correspondsTo_VariableValueComponent () const;

    ReferenceValue_correspondsTo_VariableValueComponent_type&
    ReferenceValue_correspondsTo_VariableValueComponent ();

    void
    ReferenceValue_correspondsTo_VariableValueComponent (const ReferenceValue_correspondsTo_VariableValueComponent_type& x);

    void
    ReferenceValue_correspondsTo_VariableValueComponent (::std::unique_ptr< ReferenceValue_correspondsTo_VariableValueComponent_type > p);

    // ReferenceValue_hasValueFrom_ReferenceValueDomain
    //
    typedef ::XMLSchema::ReferenceValue_hasValueFrom_ReferenceValueDomain ReferenceValue_hasValueFrom_ReferenceValueDomain_type;
    typedef ::xsd::cxx::tree::traits< ReferenceValue_hasValueFrom_ReferenceValueDomain_type, char > ReferenceValue_hasValueFrom_ReferenceValueDomain_traits;

    const ReferenceValue_hasValueFrom_ReferenceValueDomain_type&
    ReferenceValue_hasValueFrom_ReferenceValueDomain () const;

    ReferenceValue_hasValueFrom_ReferenceValueDomain_type&
    ReferenceValue_hasValueFrom_ReferenceValueDomain ();

    void
    ReferenceValue_hasValueFrom_ReferenceValueDomain (const ReferenceValue_hasValueFrom_ReferenceValueDomain_type& x);

    void
    ReferenceValue_hasValueFrom_ReferenceValueDomain (::std::unique_ptr< ReferenceValue_hasValueFrom_ReferenceValueDomain_type > p);

    // Constructors.
    //
    ReferenceValue (const InstanceValue_hasValueFrom_ValueDomain_type&,
                    const ReferenceValue_correspondsTo_VariableValueComponent_type&,
                    const ReferenceValue_hasValueFrom_ReferenceValueDomain_type&);

    ReferenceValue (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type >,
                    ::std::unique_ptr< ReferenceValue_correspondsTo_VariableValueComponent_type >,
                    ::std::unique_ptr< ReferenceValue_hasValueFrom_ReferenceValueDomain_type >);

    ReferenceValue (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    ReferenceValue (const ReferenceValue& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual ReferenceValue*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReferenceValue&
    operator= (const ReferenceValue& x);

    virtual 
    ~ReferenceValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ReferenceValue_correspondsTo_VariableValueComponent_type > ReferenceValue_correspondsTo_VariableValueComponent_;
    ::xsd::cxx::tree::one< ReferenceValue_hasValueFrom_ReferenceValueDomain_type > ReferenceValue_hasValueFrom_ReferenceValueDomain_;
  };

  class ReferenceValueDomain: public ::XMLSchema::ValueDomain
  {
    public:
    // Constructors.
    //
    ReferenceValueDomain ();

    ReferenceValueDomain (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    ReferenceValueDomain (const ReferenceValueDomain& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual ReferenceValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ReferenceValueDomain&
    operator= (const ReferenceValueDomain&) = default;
#endif

    virtual 
    ~ReferenceValueDomain ();
  };

  class ReferenceVariable: public ::XMLSchema::RepresentedVariable
  {
    public:
    // ReferenceVariable_takesValuesFrom_ReferenceValueDomain
    //
    typedef ::XMLSchema::ReferenceVariable_takesValuesFrom_ReferenceValueDomain ReferenceVariable_takesValuesFrom_ReferenceValueDomain_type;
    typedef ::xsd::cxx::tree::optional< ReferenceVariable_takesValuesFrom_ReferenceValueDomain_type > ReferenceVariable_takesValuesFrom_ReferenceValueDomain_optional;
    typedef ::xsd::cxx::tree::traits< ReferenceVariable_takesValuesFrom_ReferenceValueDomain_type, char > ReferenceVariable_takesValuesFrom_ReferenceValueDomain_traits;

    const ReferenceVariable_takesValuesFrom_ReferenceValueDomain_optional&
    ReferenceVariable_takesValuesFrom_ReferenceValueDomain () const;

    ReferenceVariable_takesValuesFrom_ReferenceValueDomain_optional&
    ReferenceVariable_takesValuesFrom_ReferenceValueDomain ();

    void
    ReferenceVariable_takesValuesFrom_ReferenceValueDomain (const ReferenceVariable_takesValuesFrom_ReferenceValueDomain_type& x);

    void
    ReferenceVariable_takesValuesFrom_ReferenceValueDomain (const ReferenceVariable_takesValuesFrom_ReferenceValueDomain_optional& x);

    void
    ReferenceVariable_takesValuesFrom_ReferenceValueDomain (::std::unique_ptr< ReferenceVariable_takesValuesFrom_ReferenceValueDomain_type > p);

    // Constructors.
    //
    ReferenceVariable ();

    ReferenceVariable (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    ReferenceVariable (const ReferenceVariable& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual ReferenceVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ReferenceVariable&
    operator= (const ReferenceVariable& x);

    virtual 
    ~ReferenceVariable ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ReferenceVariable_takesValuesFrom_ReferenceValueDomain_optional ReferenceVariable_takesValuesFrom_ReferenceValueDomain_;
  };

  class RevisableDatum: public ::XMLSchema::Datum
  {
    public:
    // vintage
    //
    typedef ::xml_schema::integer vintage_type;
    typedef ::xsd::cxx::tree::traits< vintage_type, char > vintage_traits;

    const vintage_type&
    vintage () const;

    vintage_type&
    vintage ();

    void
    vintage (const vintage_type& x);

    // RevisableDatum_correspondsTo_Revision
    //
    typedef ::XMLSchema::RevisableDatum_correspondsTo_Revision RevisableDatum_correspondsTo_Revision_type;
    typedef ::xsd::cxx::tree::optional< RevisableDatum_correspondsTo_Revision_type > RevisableDatum_correspondsTo_Revision_optional;
    typedef ::xsd::cxx::tree::traits< RevisableDatum_correspondsTo_Revision_type, char > RevisableDatum_correspondsTo_Revision_traits;

    const RevisableDatum_correspondsTo_Revision_optional&
    RevisableDatum_correspondsTo_Revision () const;

    RevisableDatum_correspondsTo_Revision_optional&
    RevisableDatum_correspondsTo_Revision ();

    void
    RevisableDatum_correspondsTo_Revision (const RevisableDatum_correspondsTo_Revision_type& x);

    void
    RevisableDatum_correspondsTo_Revision (const RevisableDatum_correspondsTo_Revision_optional& x);

    void
    RevisableDatum_correspondsTo_Revision (::std::unique_ptr< RevisableDatum_correspondsTo_Revision_type > p);

    // Constructors.
    //
    RevisableDatum (const Datum_denotes_ConceptualValue_type&,
                    const vintage_type&);

    RevisableDatum (::std::unique_ptr< Datum_denotes_ConceptualValue_type >,
                    const vintage_type&);

    RevisableDatum (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    RevisableDatum (const RevisableDatum& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual RevisableDatum*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RevisableDatum&
    operator= (const RevisableDatum& x);

    virtual 
    ~RevisableDatum ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< vintage_type > vintage_;
    RevisableDatum_correspondsTo_Revision_optional RevisableDatum_correspondsTo_Revision_;
  };

  class Revision: public ::xml_schema::type
  {
    public:
    // algorithm
    //
    typedef ::xml_schema::string algorithm_type;
    typedef ::xsd::cxx::tree::optional< algorithm_type > algorithm_optional;
    typedef ::xsd::cxx::tree::traits< algorithm_type, char > algorithm_traits;

    const algorithm_optional&
    algorithm () const;

    algorithm_optional&
    algorithm ();

    void
    algorithm (const algorithm_type& x);

    void
    algorithm (const algorithm_optional& x);

    void
    algorithm (::std::unique_ptr< algorithm_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // overview
    //
    typedef ::XMLSchema::InternationalString overview_type;
    typedef ::xsd::cxx::tree::optional< overview_type > overview_optional;
    typedef ::xsd::cxx::tree::traits< overview_type, char > overview_traits;

    const overview_optional&
    overview () const;

    overview_optional&
    overview ();

    void
    overview (const overview_type& x);

    void
    overview (const overview_optional& x);

    void
    overview (::std::unique_ptr< overview_type > p);

    // Constructors.
    //
    Revision ();

    Revision (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Revision (const Revision& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual Revision*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Revision&
    operator= (const Revision& x);

    virtual 
    ~Revision ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    algorithm_optional algorithm_;
    identifier_optional identifier_;
    overview_optional overview_;
  };

  class Rule: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // Rule_hasPrecondition_ConditionalControlLogic
    //
    typedef ::XMLSchema::Rule_hasPrecondition_ConditionalControlLogic Rule_hasPrecondition_ConditionalControlLogic_type;
    typedef ::xsd::cxx::tree::sequence< Rule_hasPrecondition_ConditionalControlLogic_type > Rule_hasPrecondition_ConditionalControlLogic_sequence;
    typedef Rule_hasPrecondition_ConditionalControlLogic_sequence::iterator Rule_hasPrecondition_ConditionalControlLogic_iterator;
    typedef Rule_hasPrecondition_ConditionalControlLogic_sequence::const_iterator Rule_hasPrecondition_ConditionalControlLogic_const_iterator;
    typedef ::xsd::cxx::tree::traits< Rule_hasPrecondition_ConditionalControlLogic_type, char > Rule_hasPrecondition_ConditionalControlLogic_traits;

    const Rule_hasPrecondition_ConditionalControlLogic_sequence&
    Rule_hasPrecondition_ConditionalControlLogic () const;

    Rule_hasPrecondition_ConditionalControlLogic_sequence&
    Rule_hasPrecondition_ConditionalControlLogic ();

    void
    Rule_hasPrecondition_ConditionalControlLogic (const Rule_hasPrecondition_ConditionalControlLogic_sequence& s);

    // Constructors.
    //
    Rule ();

    Rule (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    Rule (const Rule& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual Rule*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Rule&
    operator= (const Rule& x);

    virtual 
    ~Rule ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    Rule_hasPrecondition_ConditionalControlLogic_sequence Rule_hasPrecondition_ConditionalControlLogic_;
  };

  class RuleBasedScheduling: public ::XMLSchema::NonDeterministicDeclarative
  {
    public:
    // schedulingType
    //
    typedef ::XMLSchema::SchedulingStrategy schedulingType_type;
    typedef ::xsd::cxx::tree::traits< schedulingType_type, char > schedulingType_traits;

    const schedulingType_type&
    schedulingType () const;

    schedulingType_type&
    schedulingType ();

    void
    schedulingType (const schedulingType_type& x);

    void
    schedulingType (::std::unique_ptr< schedulingType_type > p);

    // RuleBasedScheduling_has_RuleSet
    //
    typedef ::XMLSchema::RuleBasedScheduling_has_RuleSet RuleBasedScheduling_has_RuleSet_type;
    typedef ::xsd::cxx::tree::sequence< RuleBasedScheduling_has_RuleSet_type > RuleBasedScheduling_has_RuleSet_sequence;
    typedef RuleBasedScheduling_has_RuleSet_sequence::iterator RuleBasedScheduling_has_RuleSet_iterator;
    typedef RuleBasedScheduling_has_RuleSet_sequence::const_iterator RuleBasedScheduling_has_RuleSet_const_iterator;
    typedef ::xsd::cxx::tree::traits< RuleBasedScheduling_has_RuleSet_type, char > RuleBasedScheduling_has_RuleSet_traits;

    const RuleBasedScheduling_has_RuleSet_sequence&
    RuleBasedScheduling_has_RuleSet () const;

    RuleBasedScheduling_has_RuleSet_sequence&
    RuleBasedScheduling_has_RuleSet ();

    void
    RuleBasedScheduling_has_RuleSet (const RuleBasedScheduling_has_RuleSet_sequence& s);

    // RuleBasedScheduling_has_Curator
    //
    typedef ::XMLSchema::RuleBasedScheduling_has_Curator RuleBasedScheduling_has_Curator_type;
    typedef ::xsd::cxx::tree::sequence< RuleBasedScheduling_has_Curator_type > RuleBasedScheduling_has_Curator_sequence;
    typedef RuleBasedScheduling_has_Curator_sequence::iterator RuleBasedScheduling_has_Curator_iterator;
    typedef RuleBasedScheduling_has_Curator_sequence::const_iterator RuleBasedScheduling_has_Curator_const_iterator;
    typedef ::xsd::cxx::tree::traits< RuleBasedScheduling_has_Curator_type, char > RuleBasedScheduling_has_Curator_traits;

    const RuleBasedScheduling_has_Curator_sequence&
    RuleBasedScheduling_has_Curator () const;

    RuleBasedScheduling_has_Curator_sequence&
    RuleBasedScheduling_has_Curator ();

    void
    RuleBasedScheduling_has_Curator (const RuleBasedScheduling_has_Curator_sequence& s);

    // Constructors.
    //
    RuleBasedScheduling (const schedulingType_type&);

    RuleBasedScheduling (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    RuleBasedScheduling (const RuleBasedScheduling& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual RuleBasedScheduling*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RuleBasedScheduling&
    operator= (const RuleBasedScheduling& x);

    virtual 
    ~RuleBasedScheduling ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< schedulingType_type > schedulingType_;
    RuleBasedScheduling_has_RuleSet_sequence RuleBasedScheduling_has_RuleSet_;
    RuleBasedScheduling_has_Curator_sequence RuleBasedScheduling_has_Curator_;
  };

  class RuleSet: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // RuleSet_has_Rule
    //
    typedef ::XMLSchema::RuleSet_has_Rule RuleSet_has_Rule_type;
    typedef ::xsd::cxx::tree::sequence< RuleSet_has_Rule_type > RuleSet_has_Rule_sequence;
    typedef RuleSet_has_Rule_sequence::iterator RuleSet_has_Rule_iterator;
    typedef RuleSet_has_Rule_sequence::const_iterator RuleSet_has_Rule_const_iterator;
    typedef ::xsd::cxx::tree::traits< RuleSet_has_Rule_type, char > RuleSet_has_Rule_traits;

    const RuleSet_has_Rule_sequence&
    RuleSet_has_Rule () const;

    RuleSet_has_Rule_sequence&
    RuleSet_has_Rule ();

    void
    RuleSet_has_Rule (const RuleSet_has_Rule_sequence& s);

    // Constructors.
    //
    RuleSet ();

    RuleSet (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    RuleSet (const RuleSet& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual RuleSet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RuleSet&
    operator= (const RuleSet& x);

    virtual 
    ~RuleSet ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    RuleSet_has_Rule_sequence RuleSet_has_Rule_;
  };

  class ScopedMeasure: public ::xml_schema::type
  {
    public:
    // frequency
    //
    typedef ::XMLSchema::InternationalString frequency_type;
    typedef ::xsd::cxx::tree::optional< frequency_type > frequency_optional;
    typedef ::xsd::cxx::tree::traits< frequency_type, char > frequency_traits;

    const frequency_optional&
    frequency () const;

    frequency_optional&
    frequency ();

    void
    frequency (const frequency_type& x);

    void
    frequency (const frequency_optional& x);

    void
    frequency (::std::unique_ptr< frequency_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // ScopedMeasure_circumscribes_DimensionalKeyDefinition
    //
    typedef ::XMLSchema::ScopedMeasure_circumscribes_DimensionalKeyDefinition ScopedMeasure_circumscribes_DimensionalKeyDefinition_type;
    typedef ::xsd::cxx::tree::optional< ScopedMeasure_circumscribes_DimensionalKeyDefinition_type > ScopedMeasure_circumscribes_DimensionalKeyDefinition_optional;
    typedef ::xsd::cxx::tree::traits< ScopedMeasure_circumscribes_DimensionalKeyDefinition_type, char > ScopedMeasure_circumscribes_DimensionalKeyDefinition_traits;

    const ScopedMeasure_circumscribes_DimensionalKeyDefinition_optional&
    ScopedMeasure_circumscribes_DimensionalKeyDefinition () const;

    ScopedMeasure_circumscribes_DimensionalKeyDefinition_optional&
    ScopedMeasure_circumscribes_DimensionalKeyDefinition ();

    void
    ScopedMeasure_circumscribes_DimensionalKeyDefinition (const ScopedMeasure_circumscribes_DimensionalKeyDefinition_type& x);

    void
    ScopedMeasure_circumscribes_DimensionalKeyDefinition (const ScopedMeasure_circumscribes_DimensionalKeyDefinition_optional& x);

    void
    ScopedMeasure_circumscribes_DimensionalKeyDefinition (::std::unique_ptr< ScopedMeasure_circumscribes_DimensionalKeyDefinition_type > p);

    // ScopedMeasure_restricts_QualifiedMeasure
    //
    typedef ::XMLSchema::ScopedMeasure_restricts_QualifiedMeasure ScopedMeasure_restricts_QualifiedMeasure_type;
    typedef ::xsd::cxx::tree::optional< ScopedMeasure_restricts_QualifiedMeasure_type > ScopedMeasure_restricts_QualifiedMeasure_optional;
    typedef ::xsd::cxx::tree::traits< ScopedMeasure_restricts_QualifiedMeasure_type, char > ScopedMeasure_restricts_QualifiedMeasure_traits;

    const ScopedMeasure_restricts_QualifiedMeasure_optional&
    ScopedMeasure_restricts_QualifiedMeasure () const;

    ScopedMeasure_restricts_QualifiedMeasure_optional&
    ScopedMeasure_restricts_QualifiedMeasure ();

    void
    ScopedMeasure_restricts_QualifiedMeasure (const ScopedMeasure_restricts_QualifiedMeasure_type& x);

    void
    ScopedMeasure_restricts_QualifiedMeasure (const ScopedMeasure_restricts_QualifiedMeasure_optional& x);

    void
    ScopedMeasure_restricts_QualifiedMeasure (::std::unique_ptr< ScopedMeasure_restricts_QualifiedMeasure_type > p);

    // ScopedMeasure_generates_RevisableDatum
    //
    typedef ::XMLSchema::ScopedMeasure_generates_RevisableDatum ScopedMeasure_generates_RevisableDatum_type;
    typedef ::xsd::cxx::tree::traits< ScopedMeasure_generates_RevisableDatum_type, char > ScopedMeasure_generates_RevisableDatum_traits;

    const ScopedMeasure_generates_RevisableDatum_type&
    ScopedMeasure_generates_RevisableDatum () const;

    ScopedMeasure_generates_RevisableDatum_type&
    ScopedMeasure_generates_RevisableDatum ();

    void
    ScopedMeasure_generates_RevisableDatum (const ScopedMeasure_generates_RevisableDatum_type& x);

    void
    ScopedMeasure_generates_RevisableDatum (::std::unique_ptr< ScopedMeasure_generates_RevisableDatum_type > p);

    // Constructors.
    //
    ScopedMeasure (const ScopedMeasure_generates_RevisableDatum_type&);

    ScopedMeasure (::std::unique_ptr< ScopedMeasure_generates_RevisableDatum_type >);

    ScopedMeasure (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    ScopedMeasure (const ScopedMeasure& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual ScopedMeasure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ScopedMeasure&
    operator= (const ScopedMeasure& x);

    virtual 
    ~ScopedMeasure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    frequency_optional frequency_;
    identifier_optional identifier_;
    ScopedMeasure_circumscribes_DimensionalKeyDefinition_optional ScopedMeasure_circumscribes_DimensionalKeyDefinition_;
    ScopedMeasure_restricts_QualifiedMeasure_optional ScopedMeasure_restricts_QualifiedMeasure_;
    ::xsd::cxx::tree::one< ScopedMeasure_generates_RevisableDatum_type > ScopedMeasure_generates_RevisableDatum_;
  };

  class SegmentByText: public ::XMLSchema::PhysicalSegmentLocation
  {
    public:
    // characterLength
    //
    typedef ::xml_schema::integer characterLength_type;
    typedef ::xsd::cxx::tree::optional< characterLength_type > characterLength_optional;
    typedef ::xsd::cxx::tree::traits< characterLength_type, char > characterLength_traits;

    const characterLength_optional&
    characterLength () const;

    characterLength_optional&
    characterLength ();

    void
    characterLength (const characterLength_type& x);

    void
    characterLength (const characterLength_optional& x);

    // endCharacterPosition
    //
    typedef ::xml_schema::integer endCharacterPosition_type;
    typedef ::xsd::cxx::tree::optional< endCharacterPosition_type > endCharacterPosition_optional;
    typedef ::xsd::cxx::tree::traits< endCharacterPosition_type, char > endCharacterPosition_traits;

    const endCharacterPosition_optional&
    endCharacterPosition () const;

    endCharacterPosition_optional&
    endCharacterPosition ();

    void
    endCharacterPosition (const endCharacterPosition_type& x);

    void
    endCharacterPosition (const endCharacterPosition_optional& x);

    // endLine
    //
    typedef ::xml_schema::integer endLine_type;
    typedef ::xsd::cxx::tree::optional< endLine_type > endLine_optional;
    typedef ::xsd::cxx::tree::traits< endLine_type, char > endLine_traits;

    const endLine_optional&
    endLine () const;

    endLine_optional&
    endLine ();

    void
    endLine (const endLine_type& x);

    void
    endLine (const endLine_optional& x);

    // startCharacterPosition
    //
    typedef ::xml_schema::integer startCharacterPosition_type;
    typedef ::xsd::cxx::tree::optional< startCharacterPosition_type > startCharacterPosition_optional;
    typedef ::xsd::cxx::tree::traits< startCharacterPosition_type, char > startCharacterPosition_traits;

    const startCharacterPosition_optional&
    startCharacterPosition () const;

    startCharacterPosition_optional&
    startCharacterPosition ();

    void
    startCharacterPosition (const startCharacterPosition_type& x);

    void
    startCharacterPosition (const startCharacterPosition_optional& x);

    // startLine
    //
    typedef ::xml_schema::integer startLine_type;
    typedef ::xsd::cxx::tree::optional< startLine_type > startLine_optional;
    typedef ::xsd::cxx::tree::traits< startLine_type, char > startLine_traits;

    const startLine_optional&
    startLine () const;

    startLine_optional&
    startLine ();

    void
    startLine (const startLine_type& x);

    void
    startLine (const startLine_optional& x);

    // Constructors.
    //
    SegmentByText ();

    SegmentByText (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    SegmentByText (const SegmentByText& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual SegmentByText*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SegmentByText&
    operator= (const SegmentByText& x);

    virtual 
    ~SegmentByText ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    characterLength_optional characterLength_;
    endCharacterPosition_optional endCharacterPosition_;
    endLine_optional endLine_;
    startCharacterPosition_optional startCharacterPosition_;
    startLine_optional startLine_;
  };

  class SentinelConceptualDomain: public ::XMLSchema::ConceptualDomain
  {
    public:
    // Constructors.
    //
    SentinelConceptualDomain ();

    SentinelConceptualDomain (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    SentinelConceptualDomain (const SentinelConceptualDomain& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual SentinelConceptualDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    SentinelConceptualDomain&
    operator= (const SentinelConceptualDomain&) = default;
#endif

    virtual 
    ~SentinelConceptualDomain ();
  };

  class SentinelValueDomain: public ::XMLSchema::ValueDomain
  {
    public:
    // platformType
    //
    typedef ::XMLSchema::ControlledVocabularyEntry platformType_type;
    typedef ::xsd::cxx::tree::optional< platformType_type > platformType_optional;
    typedef ::xsd::cxx::tree::traits< platformType_type, char > platformType_traits;

    const platformType_optional&
    platformType () const;

    platformType_optional&
    platformType ();

    void
    platformType (const platformType_type& x);

    void
    platformType (const platformType_optional& x);

    void
    platformType (::std::unique_ptr< platformType_type > p);

    // SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain
    //
    typedef ::XMLSchema::SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_type;
    typedef ::xsd::cxx::tree::optional< SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_type > SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_optional;
    typedef ::xsd::cxx::tree::traits< SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_type, char > SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_traits;

    const SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_optional&
    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain () const;

    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_optional&
    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain ();

    void
    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain (const SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_type& x);

    void
    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain (const SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_optional& x);

    void
    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain (::std::unique_ptr< SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_type > p);

    // SentinelValueDomain_takesValuesFrom_EnumerationDomain
    //
    typedef ::XMLSchema::SentinelValueDomain_takesValuesFrom_EnumerationDomain SentinelValueDomain_takesValuesFrom_EnumerationDomain_type;
    typedef ::xsd::cxx::tree::optional< SentinelValueDomain_takesValuesFrom_EnumerationDomain_type > SentinelValueDomain_takesValuesFrom_EnumerationDomain_optional;
    typedef ::xsd::cxx::tree::traits< SentinelValueDomain_takesValuesFrom_EnumerationDomain_type, char > SentinelValueDomain_takesValuesFrom_EnumerationDomain_traits;

    const SentinelValueDomain_takesValuesFrom_EnumerationDomain_optional&
    SentinelValueDomain_takesValuesFrom_EnumerationDomain () const;

    SentinelValueDomain_takesValuesFrom_EnumerationDomain_optional&
    SentinelValueDomain_takesValuesFrom_EnumerationDomain ();

    void
    SentinelValueDomain_takesValuesFrom_EnumerationDomain (const SentinelValueDomain_takesValuesFrom_EnumerationDomain_type& x);

    void
    SentinelValueDomain_takesValuesFrom_EnumerationDomain (const SentinelValueDomain_takesValuesFrom_EnumerationDomain_optional& x);

    void
    SentinelValueDomain_takesValuesFrom_EnumerationDomain (::std::unique_ptr< SentinelValueDomain_takesValuesFrom_EnumerationDomain_type > p);

    // SentinelValueDomain_isDescribedBy_ValueAndConceptDescription
    //
    typedef ::XMLSchema::SentinelValueDomain_isDescribedBy_ValueAndConceptDescription SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_type;
    typedef ::xsd::cxx::tree::optional< SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_type > SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_optional;
    typedef ::xsd::cxx::tree::traits< SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_type, char > SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_traits;

    const SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_optional&
    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription () const;

    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_optional&
    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription ();

    void
    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription (const SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_type& x);

    void
    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription (const SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_optional& x);

    void
    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription (::std::unique_ptr< SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_type > p);

    // Constructors.
    //
    SentinelValueDomain ();

    SentinelValueDomain (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    SentinelValueDomain (const SentinelValueDomain& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual SentinelValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SentinelValueDomain&
    operator= (const SentinelValueDomain& x);

    virtual 
    ~SentinelValueDomain ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    platformType_optional platformType_;
    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_optional SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_;
    SentinelValueDomain_takesValuesFrom_EnumerationDomain_optional SentinelValueDomain_takesValuesFrom_EnumerationDomain_;
    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_optional SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_;
  };

  class Sequence: public ::XMLSchema::DeterministicImperative
  {
    public:
    // Sequence_has_SequencePosition
    //
    typedef ::XMLSchema::Sequence_has_SequencePosition Sequence_has_SequencePosition_type;
    typedef ::xsd::cxx::tree::sequence< Sequence_has_SequencePosition_type > Sequence_has_SequencePosition_sequence;
    typedef Sequence_has_SequencePosition_sequence::iterator Sequence_has_SequencePosition_iterator;
    typedef Sequence_has_SequencePosition_sequence::const_iterator Sequence_has_SequencePosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< Sequence_has_SequencePosition_type, char > Sequence_has_SequencePosition_traits;

    const Sequence_has_SequencePosition_sequence&
    Sequence_has_SequencePosition () const;

    Sequence_has_SequencePosition_sequence&
    Sequence_has_SequencePosition ();

    void
    Sequence_has_SequencePosition (const Sequence_has_SequencePosition_sequence& s);

    // Constructors.
    //
    Sequence ();

    Sequence (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Sequence (const Sequence& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual Sequence*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Sequence&
    operator= (const Sequence& x);

    virtual 
    ~Sequence ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Sequence_has_SequencePosition_sequence Sequence_has_SequencePosition_;
  };

  class SequencePosition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // value
    //
    typedef ::xml_schema::integer value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    // Constructors.
    //
    SequencePosition (const value_type&);

    SequencePosition (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    SequencePosition (const SequencePosition& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual SequencePosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SequencePosition&
    operator= (const SequencePosition& x);

    virtual 
    ~SequencePosition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< value_type > value_;
  };

  class Service: public ::XMLSchema::ProcessingAgent
  {
    public:
    // Constructors.
    //
    Service ();

    Service (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Service (const Service& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual Service*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Service&
    operator= (const Service&) = default;
#endif

    virtual 
    ~Service ();
  };

  class StatisticalClassification: public ::XMLSchema::EnumerationDomain
  {
    public:
    // allowsDuplicates
    //
    typedef ::xml_schema::boolean allowsDuplicates_type;
    typedef ::xsd::cxx::tree::traits< allowsDuplicates_type, char > allowsDuplicates_traits;

    const allowsDuplicates_type&
    allowsDuplicates () const;

    allowsDuplicates_type&
    allowsDuplicates ();

    void
    allowsDuplicates (const allowsDuplicates_type& x);

    // availableLanguage
    //
    typedef ::xml_schema::language availableLanguage_type;
    typedef ::xsd::cxx::tree::sequence< availableLanguage_type > availableLanguage_sequence;
    typedef availableLanguage_sequence::iterator availableLanguage_iterator;
    typedef availableLanguage_sequence::const_iterator availableLanguage_const_iterator;
    typedef ::xsd::cxx::tree::traits< availableLanguage_type, char > availableLanguage_traits;

    const availableLanguage_sequence&
    availableLanguage () const;

    availableLanguage_sequence&
    availableLanguage ();

    void
    availableLanguage (const availableLanguage_sequence& s);

    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // changeFromBase
    //
    typedef ::XMLSchema::InternationalString changeFromBase_type;
    typedef ::xsd::cxx::tree::optional< changeFromBase_type > changeFromBase_optional;
    typedef ::xsd::cxx::tree::traits< changeFromBase_type, char > changeFromBase_traits;

    const changeFromBase_optional&
    changeFromBase () const;

    changeFromBase_optional&
    changeFromBase ();

    void
    changeFromBase (const changeFromBase_type& x);

    void
    changeFromBase (const changeFromBase_optional& x);

    void
    changeFromBase (::std::unique_ptr< changeFromBase_type > p);

    // copyright
    //
    typedef ::XMLSchema::InternationalString copyright_type;
    typedef ::xsd::cxx::tree::sequence< copyright_type > copyright_sequence;
    typedef copyright_sequence::iterator copyright_iterator;
    typedef copyright_sequence::const_iterator copyright_const_iterator;
    typedef ::xsd::cxx::tree::traits< copyright_type, char > copyright_traits;

    const copyright_sequence&
    copyright () const;

    copyright_sequence&
    copyright ();

    void
    copyright (const copyright_sequence& s);

    // displayLabel
    //
    typedef ::XMLSchema::LabelForDisplay displayLabel_type;
    typedef ::xsd::cxx::tree::sequence< displayLabel_type > displayLabel_sequence;
    typedef displayLabel_sequence::iterator displayLabel_iterator;
    typedef displayLabel_sequence::const_iterator displayLabel_const_iterator;
    typedef ::xsd::cxx::tree::traits< displayLabel_type, char > displayLabel_traits;

    const displayLabel_sequence&
    displayLabel () const;

    displayLabel_sequence&
    displayLabel ();

    void
    displayLabel (const displayLabel_sequence& s);

    // isCurrent
    //
    typedef ::xml_schema::boolean isCurrent_type;
    typedef ::xsd::cxx::tree::optional< isCurrent_type > isCurrent_optional;
    typedef ::xsd::cxx::tree::traits< isCurrent_type, char > isCurrent_traits;

    const isCurrent_optional&
    isCurrent () const;

    isCurrent_optional&
    isCurrent ();

    void
    isCurrent (const isCurrent_type& x);

    void
    isCurrent (const isCurrent_optional& x);

    // isFloating
    //
    typedef ::xml_schema::boolean isFloating_type;
    typedef ::xsd::cxx::tree::optional< isFloating_type > isFloating_optional;
    typedef ::xsd::cxx::tree::traits< isFloating_type, char > isFloating_traits;

    const isFloating_optional&
    isFloating () const;

    isFloating_optional&
    isFloating ();

    void
    isFloating (const isFloating_type& x);

    void
    isFloating (const isFloating_optional& x);

    // purposeOfVariant
    //
    typedef ::XMLSchema::InternationalString purposeOfVariant_type;
    typedef ::xsd::cxx::tree::optional< purposeOfVariant_type > purposeOfVariant_optional;
    typedef ::xsd::cxx::tree::traits< purposeOfVariant_type, char > purposeOfVariant_traits;

    const purposeOfVariant_optional&
    purposeOfVariant () const;

    purposeOfVariant_optional&
    purposeOfVariant ();

    void
    purposeOfVariant (const purposeOfVariant_type& x);

    void
    purposeOfVariant (const purposeOfVariant_optional& x);

    void
    purposeOfVariant (::std::unique_ptr< purposeOfVariant_type > p);

    // rationale
    //
    typedef ::XMLSchema::InternationalString rationale_type;
    typedef ::xsd::cxx::tree::optional< rationale_type > rationale_optional;
    typedef ::xsd::cxx::tree::traits< rationale_type, char > rationale_traits;

    const rationale_optional&
    rationale () const;

    rationale_optional&
    rationale ();

    void
    rationale (const rationale_type& x);

    void
    rationale (const rationale_optional& x);

    void
    rationale (::std::unique_ptr< rationale_type > p);

    // releaseDate
    //
    typedef ::XMLSchema::CombinedDate releaseDate_type;
    typedef ::xsd::cxx::tree::optional< releaseDate_type > releaseDate_optional;
    typedef ::xsd::cxx::tree::traits< releaseDate_type, char > releaseDate_traits;

    const releaseDate_optional&
    releaseDate () const;

    releaseDate_optional&
    releaseDate ();

    void
    releaseDate (const releaseDate_type& x);

    void
    releaseDate (const releaseDate_optional& x);

    void
    releaseDate (::std::unique_ptr< releaseDate_type > p);

    // updateChanges
    //
    typedef ::XMLSchema::InternationalString updateChanges_type;
    typedef ::xsd::cxx::tree::sequence< updateChanges_type > updateChanges_sequence;
    typedef updateChanges_sequence::iterator updateChanges_iterator;
    typedef updateChanges_sequence::const_iterator updateChanges_const_iterator;
    typedef ::xsd::cxx::tree::traits< updateChanges_type, char > updateChanges_traits;

    const updateChanges_sequence&
    updateChanges () const;

    updateChanges_sequence&
    updateChanges ();

    void
    updateChanges (const updateChanges_sequence& s);

    // usage
    //
    typedef ::XMLSchema::InternationalString usage_type;
    typedef ::xsd::cxx::tree::optional< usage_type > usage_optional;
    typedef ::xsd::cxx::tree::traits< usage_type, char > usage_traits;

    const usage_optional&
    usage () const;

    usage_optional&
    usage ();

    void
    usage (const usage_type& x);

    void
    usage (const usage_optional& x);

    void
    usage (::std::unique_ptr< usage_type > p);

    // validDates
    //
    typedef ::XMLSchema::DateRange validDates_type;
    typedef ::xsd::cxx::tree::optional< validDates_type > validDates_optional;
    typedef ::xsd::cxx::tree::traits< validDates_type, char > validDates_traits;

    const validDates_optional&
    validDates () const;

    validDates_optional&
    validDates ();

    void
    validDates (const validDates_type& x);

    void
    validDates (const validDates_optional& x);

    void
    validDates (::std::unique_ptr< validDates_type > p);

    // StatisticalClassification_isMaintainedBy_Organization
    //
    typedef ::XMLSchema::StatisticalClassification_isMaintainedBy_Organization StatisticalClassification_isMaintainedBy_Organization_type;
    typedef ::xsd::cxx::tree::sequence< StatisticalClassification_isMaintainedBy_Organization_type > StatisticalClassification_isMaintainedBy_Organization_sequence;
    typedef StatisticalClassification_isMaintainedBy_Organization_sequence::iterator StatisticalClassification_isMaintainedBy_Organization_iterator;
    typedef StatisticalClassification_isMaintainedBy_Organization_sequence::const_iterator StatisticalClassification_isMaintainedBy_Organization_const_iterator;
    typedef ::xsd::cxx::tree::traits< StatisticalClassification_isMaintainedBy_Organization_type, char > StatisticalClassification_isMaintainedBy_Organization_traits;

    const StatisticalClassification_isMaintainedBy_Organization_sequence&
    StatisticalClassification_isMaintainedBy_Organization () const;

    StatisticalClassification_isMaintainedBy_Organization_sequence&
    StatisticalClassification_isMaintainedBy_Organization ();

    void
    StatisticalClassification_isMaintainedBy_Organization (const StatisticalClassification_isMaintainedBy_Organization_sequence& s);

    // StatisticalClassification_isIndexedBy_ClassificationIndex
    //
    typedef ::XMLSchema::StatisticalClassification_isIndexedBy_ClassificationIndex StatisticalClassification_isIndexedBy_ClassificationIndex_type;
    typedef ::xsd::cxx::tree::sequence< StatisticalClassification_isIndexedBy_ClassificationIndex_type > StatisticalClassification_isIndexedBy_ClassificationIndex_sequence;
    typedef StatisticalClassification_isIndexedBy_ClassificationIndex_sequence::iterator StatisticalClassification_isIndexedBy_ClassificationIndex_iterator;
    typedef StatisticalClassification_isIndexedBy_ClassificationIndex_sequence::const_iterator StatisticalClassification_isIndexedBy_ClassificationIndex_const_iterator;
    typedef ::xsd::cxx::tree::traits< StatisticalClassification_isIndexedBy_ClassificationIndex_type, char > StatisticalClassification_isIndexedBy_ClassificationIndex_traits;

    const StatisticalClassification_isIndexedBy_ClassificationIndex_sequence&
    StatisticalClassification_isIndexedBy_ClassificationIndex () const;

    StatisticalClassification_isIndexedBy_ClassificationIndex_sequence&
    StatisticalClassification_isIndexedBy_ClassificationIndex ();

    void
    StatisticalClassification_isIndexedBy_ClassificationIndex (const StatisticalClassification_isIndexedBy_ClassificationIndex_sequence& s);

    // StatisticalClassification_isVariantOf_StatisticalClassification
    //
    typedef ::XMLSchema::StatisticalClassification_isVariantOf_StatisticalClassification StatisticalClassification_isVariantOf_StatisticalClassification_type;
    typedef ::xsd::cxx::tree::optional< StatisticalClassification_isVariantOf_StatisticalClassification_type > StatisticalClassification_isVariantOf_StatisticalClassification_optional;
    typedef ::xsd::cxx::tree::traits< StatisticalClassification_isVariantOf_StatisticalClassification_type, char > StatisticalClassification_isVariantOf_StatisticalClassification_traits;

    const StatisticalClassification_isVariantOf_StatisticalClassification_optional&
    StatisticalClassification_isVariantOf_StatisticalClassification () const;

    StatisticalClassification_isVariantOf_StatisticalClassification_optional&
    StatisticalClassification_isVariantOf_StatisticalClassification ();

    void
    StatisticalClassification_isVariantOf_StatisticalClassification (const StatisticalClassification_isVariantOf_StatisticalClassification_type& x);

    void
    StatisticalClassification_isVariantOf_StatisticalClassification (const StatisticalClassification_isVariantOf_StatisticalClassification_optional& x);

    void
    StatisticalClassification_isVariantOf_StatisticalClassification (::std::unique_ptr< StatisticalClassification_isVariantOf_StatisticalClassification_type > p);

    // StatisticalClassification_isSuccessorOf_StatisticalClassification
    //
    typedef ::XMLSchema::StatisticalClassification_isSuccessorOf_StatisticalClassification StatisticalClassification_isSuccessorOf_StatisticalClassification_type;
    typedef ::xsd::cxx::tree::sequence< StatisticalClassification_isSuccessorOf_StatisticalClassification_type > StatisticalClassification_isSuccessorOf_StatisticalClassification_sequence;
    typedef StatisticalClassification_isSuccessorOf_StatisticalClassification_sequence::iterator StatisticalClassification_isSuccessorOf_StatisticalClassification_iterator;
    typedef StatisticalClassification_isSuccessorOf_StatisticalClassification_sequence::const_iterator StatisticalClassification_isSuccessorOf_StatisticalClassification_const_iterator;
    typedef ::xsd::cxx::tree::traits< StatisticalClassification_isSuccessorOf_StatisticalClassification_type, char > StatisticalClassification_isSuccessorOf_StatisticalClassification_traits;

    const StatisticalClassification_isSuccessorOf_StatisticalClassification_sequence&
    StatisticalClassification_isSuccessorOf_StatisticalClassification () const;

    StatisticalClassification_isSuccessorOf_StatisticalClassification_sequence&
    StatisticalClassification_isSuccessorOf_StatisticalClassification ();

    void
    StatisticalClassification_isSuccessorOf_StatisticalClassification (const StatisticalClassification_isSuccessorOf_StatisticalClassification_sequence& s);

    // StatisticalClassification_isPredecessorOf_StatisticalClassification
    //
    typedef ::XMLSchema::StatisticalClassification_isPredecessorOf_StatisticalClassification StatisticalClassification_isPredecessorOf_StatisticalClassification_type;
    typedef ::xsd::cxx::tree::sequence< StatisticalClassification_isPredecessorOf_StatisticalClassification_type > StatisticalClassification_isPredecessorOf_StatisticalClassification_sequence;
    typedef StatisticalClassification_isPredecessorOf_StatisticalClassification_sequence::iterator StatisticalClassification_isPredecessorOf_StatisticalClassification_iterator;
    typedef StatisticalClassification_isPredecessorOf_StatisticalClassification_sequence::const_iterator StatisticalClassification_isPredecessorOf_StatisticalClassification_const_iterator;
    typedef ::xsd::cxx::tree::traits< StatisticalClassification_isPredecessorOf_StatisticalClassification_type, char > StatisticalClassification_isPredecessorOf_StatisticalClassification_traits;

    const StatisticalClassification_isPredecessorOf_StatisticalClassification_sequence&
    StatisticalClassification_isPredecessorOf_StatisticalClassification () const;

    StatisticalClassification_isPredecessorOf_StatisticalClassification_sequence&
    StatisticalClassification_isPredecessorOf_StatisticalClassification ();

    void
    StatisticalClassification_isPredecessorOf_StatisticalClassification (const StatisticalClassification_isPredecessorOf_StatisticalClassification_sequence& s);

    // StatisticalClassification_has_ClassificationItemPosition
    //
    typedef ::XMLSchema::StatisticalClassification_has_ClassificationItemPosition StatisticalClassification_has_ClassificationItemPosition_type;
    typedef ::xsd::cxx::tree::sequence< StatisticalClassification_has_ClassificationItemPosition_type > StatisticalClassification_has_ClassificationItemPosition_sequence;
    typedef StatisticalClassification_has_ClassificationItemPosition_sequence::iterator StatisticalClassification_has_ClassificationItemPosition_iterator;
    typedef StatisticalClassification_has_ClassificationItemPosition_sequence::const_iterator StatisticalClassification_has_ClassificationItemPosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< StatisticalClassification_has_ClassificationItemPosition_type, char > StatisticalClassification_has_ClassificationItemPosition_traits;

    const StatisticalClassification_has_ClassificationItemPosition_sequence&
    StatisticalClassification_has_ClassificationItemPosition () const;

    StatisticalClassification_has_ClassificationItemPosition_sequence&
    StatisticalClassification_has_ClassificationItemPosition ();

    void
    StatisticalClassification_has_ClassificationItemPosition (const StatisticalClassification_has_ClassificationItemPosition_sequence& s);

    // StatisticalClassification_has_ClassificationItem
    //
    typedef ::XMLSchema::StatisticalClassification_has_ClassificationItem StatisticalClassification_has_ClassificationItem_type;
    typedef ::xsd::cxx::tree::sequence< StatisticalClassification_has_ClassificationItem_type > StatisticalClassification_has_ClassificationItem_sequence;
    typedef StatisticalClassification_has_ClassificationItem_sequence::iterator StatisticalClassification_has_ClassificationItem_iterator;
    typedef StatisticalClassification_has_ClassificationItem_sequence::const_iterator StatisticalClassification_has_ClassificationItem_const_iterator;
    typedef ::xsd::cxx::tree::traits< StatisticalClassification_has_ClassificationItem_type, char > StatisticalClassification_has_ClassificationItem_traits;

    const StatisticalClassification_has_ClassificationItem_sequence&
    StatisticalClassification_has_ClassificationItem () const;

    StatisticalClassification_has_ClassificationItem_sequence&
    StatisticalClassification_has_ClassificationItem ();

    void
    StatisticalClassification_has_ClassificationItem (const StatisticalClassification_has_ClassificationItem_sequence& s);

    // StatisticalClassification_has_LevelStructure
    //
    typedef ::XMLSchema::StatisticalClassification_has_LevelStructure StatisticalClassification_has_LevelStructure_type;
    typedef ::xsd::cxx::tree::optional< StatisticalClassification_has_LevelStructure_type > StatisticalClassification_has_LevelStructure_optional;
    typedef ::xsd::cxx::tree::traits< StatisticalClassification_has_LevelStructure_type, char > StatisticalClassification_has_LevelStructure_traits;

    const StatisticalClassification_has_LevelStructure_optional&
    StatisticalClassification_has_LevelStructure () const;

    StatisticalClassification_has_LevelStructure_optional&
    StatisticalClassification_has_LevelStructure ();

    void
    StatisticalClassification_has_LevelStructure (const StatisticalClassification_has_LevelStructure_type& x);

    void
    StatisticalClassification_has_LevelStructure (const StatisticalClassification_has_LevelStructure_optional& x);

    void
    StatisticalClassification_has_LevelStructure (::std::unique_ptr< StatisticalClassification_has_LevelStructure_type > p);

    // Constructors.
    //
    StatisticalClassification (const allowsDuplicates_type&);

    StatisticalClassification (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    StatisticalClassification (const StatisticalClassification& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual StatisticalClassification*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    StatisticalClassification&
    operator= (const StatisticalClassification& x);

    virtual 
    ~StatisticalClassification ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< allowsDuplicates_type > allowsDuplicates_;
    availableLanguage_sequence availableLanguage_;
    catalogDetails_optional catalogDetails_;
    changeFromBase_optional changeFromBase_;
    copyright_sequence copyright_;
    displayLabel_sequence displayLabel_;
    isCurrent_optional isCurrent_;
    isFloating_optional isFloating_;
    purposeOfVariant_optional purposeOfVariant_;
    rationale_optional rationale_;
    releaseDate_optional releaseDate_;
    updateChanges_sequence updateChanges_;
    usage_optional usage_;
    validDates_optional validDates_;
    StatisticalClassification_isMaintainedBy_Organization_sequence StatisticalClassification_isMaintainedBy_Organization_;
    StatisticalClassification_isIndexedBy_ClassificationIndex_sequence StatisticalClassification_isIndexedBy_ClassificationIndex_;
    StatisticalClassification_isVariantOf_StatisticalClassification_optional StatisticalClassification_isVariantOf_StatisticalClassification_;
    StatisticalClassification_isSuccessorOf_StatisticalClassification_sequence StatisticalClassification_isSuccessorOf_StatisticalClassification_;
    StatisticalClassification_isPredecessorOf_StatisticalClassification_sequence StatisticalClassification_isPredecessorOf_StatisticalClassification_;
    StatisticalClassification_has_ClassificationItemPosition_sequence StatisticalClassification_has_ClassificationItemPosition_;
    StatisticalClassification_has_ClassificationItem_sequence StatisticalClassification_has_ClassificationItem_;
    StatisticalClassification_has_LevelStructure_optional StatisticalClassification_has_LevelStructure_;
  };

  class StatisticalClassificationRelationship: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // StatisticalClassificationRelationship_hasTarget_StatisticalClassification
    //
    typedef ::XMLSchema::StatisticalClassificationRelationship_hasTarget_StatisticalClassification StatisticalClassificationRelationship_hasTarget_StatisticalClassification_type;
    typedef ::xsd::cxx::tree::sequence< StatisticalClassificationRelationship_hasTarget_StatisticalClassification_type > StatisticalClassificationRelationship_hasTarget_StatisticalClassification_sequence;
    typedef StatisticalClassificationRelationship_hasTarget_StatisticalClassification_sequence::iterator StatisticalClassificationRelationship_hasTarget_StatisticalClassification_iterator;
    typedef StatisticalClassificationRelationship_hasTarget_StatisticalClassification_sequence::const_iterator StatisticalClassificationRelationship_hasTarget_StatisticalClassification_const_iterator;
    typedef ::xsd::cxx::tree::traits< StatisticalClassificationRelationship_hasTarget_StatisticalClassification_type, char > StatisticalClassificationRelationship_hasTarget_StatisticalClassification_traits;

    const StatisticalClassificationRelationship_hasTarget_StatisticalClassification_sequence&
    StatisticalClassificationRelationship_hasTarget_StatisticalClassification () const;

    StatisticalClassificationRelationship_hasTarget_StatisticalClassification_sequence&
    StatisticalClassificationRelationship_hasTarget_StatisticalClassification ();

    void
    StatisticalClassificationRelationship_hasTarget_StatisticalClassification (const StatisticalClassificationRelationship_hasTarget_StatisticalClassification_sequence& s);

    // StatisticalClassificationRelationship_hasSource_StatisticalClassification
    //
    typedef ::XMLSchema::StatisticalClassificationRelationship_hasSource_StatisticalClassification StatisticalClassificationRelationship_hasSource_StatisticalClassification_type;
    typedef ::xsd::cxx::tree::sequence< StatisticalClassificationRelationship_hasSource_StatisticalClassification_type > StatisticalClassificationRelationship_hasSource_StatisticalClassification_sequence;
    typedef StatisticalClassificationRelationship_hasSource_StatisticalClassification_sequence::iterator StatisticalClassificationRelationship_hasSource_StatisticalClassification_iterator;
    typedef StatisticalClassificationRelationship_hasSource_StatisticalClassification_sequence::const_iterator StatisticalClassificationRelationship_hasSource_StatisticalClassification_const_iterator;
    typedef ::xsd::cxx::tree::traits< StatisticalClassificationRelationship_hasSource_StatisticalClassification_type, char > StatisticalClassificationRelationship_hasSource_StatisticalClassification_traits;

    const StatisticalClassificationRelationship_hasSource_StatisticalClassification_sequence&
    StatisticalClassificationRelationship_hasSource_StatisticalClassification () const;

    StatisticalClassificationRelationship_hasSource_StatisticalClassification_sequence&
    StatisticalClassificationRelationship_hasSource_StatisticalClassification ();

    void
    StatisticalClassificationRelationship_hasSource_StatisticalClassification (const StatisticalClassificationRelationship_hasSource_StatisticalClassification_sequence& s);

    // Constructors.
    //
    StatisticalClassificationRelationship ();

    StatisticalClassificationRelationship (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    StatisticalClassificationRelationship (const StatisticalClassificationRelationship& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual StatisticalClassificationRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    StatisticalClassificationRelationship&
    operator= (const StatisticalClassificationRelationship& x);

    virtual 
    ~StatisticalClassificationRelationship ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    semantics_optional semantics_;
    StatisticalClassificationRelationship_hasTarget_StatisticalClassification_sequence StatisticalClassificationRelationship_hasTarget_StatisticalClassification_;
    StatisticalClassificationRelationship_hasSource_StatisticalClassification_sequence StatisticalClassificationRelationship_hasSource_StatisticalClassification_;
  };

  class Step: public ::XMLSchema::Activity
  {
    public:
    // script
    //
    typedef ::XMLSchema::CommandCode script_type;
    typedef ::xsd::cxx::tree::optional< script_type > script_optional;
    typedef ::xsd::cxx::tree::traits< script_type, char > script_traits;

    const script_optional&
    script () const;

    script_optional&
    script ();

    void
    script (const script_type& x);

    void
    script (const script_optional& x);

    void
    script (::std::unique_ptr< script_type > p);

    // scriptingLanguage
    //
    typedef ::XMLSchema::ControlledVocabularyEntry scriptingLanguage_type;
    typedef ::xsd::cxx::tree::optional< scriptingLanguage_type > scriptingLanguage_optional;
    typedef ::xsd::cxx::tree::traits< scriptingLanguage_type, char > scriptingLanguage_traits;

    const scriptingLanguage_optional&
    scriptingLanguage () const;

    scriptingLanguage_optional&
    scriptingLanguage ();

    void
    scriptingLanguage (const scriptingLanguage_type& x);

    void
    scriptingLanguage (const scriptingLanguage_optional& x);

    void
    scriptingLanguage (::std::unique_ptr< scriptingLanguage_type > p);

    // Step_produces_Parameter
    //
    typedef ::XMLSchema::Step_produces_Parameter Step_produces_Parameter_type;
    typedef ::xsd::cxx::tree::sequence< Step_produces_Parameter_type > Step_produces_Parameter_sequence;
    typedef Step_produces_Parameter_sequence::iterator Step_produces_Parameter_iterator;
    typedef Step_produces_Parameter_sequence::const_iterator Step_produces_Parameter_const_iterator;
    typedef ::xsd::cxx::tree::traits< Step_produces_Parameter_type, char > Step_produces_Parameter_traits;

    const Step_produces_Parameter_sequence&
    Step_produces_Parameter () const;

    Step_produces_Parameter_sequence&
    Step_produces_Parameter ();

    void
    Step_produces_Parameter (const Step_produces_Parameter_sequence& s);

    // Step_receives_Parameter
    //
    typedef ::XMLSchema::Step_receives_Parameter Step_receives_Parameter_type;
    typedef ::xsd::cxx::tree::sequence< Step_receives_Parameter_type > Step_receives_Parameter_sequence;
    typedef Step_receives_Parameter_sequence::iterator Step_receives_Parameter_iterator;
    typedef Step_receives_Parameter_sequence::const_iterator Step_receives_Parameter_const_iterator;
    typedef ::xsd::cxx::tree::traits< Step_receives_Parameter_type, char > Step_receives_Parameter_traits;

    const Step_receives_Parameter_sequence&
    Step_receives_Parameter () const;

    Step_receives_Parameter_sequence&
    Step_receives_Parameter ();

    void
    Step_receives_Parameter (const Step_receives_Parameter_sequence& s);

    // Step_hasSubStep_Step
    //
    typedef ::XMLSchema::Step_hasSubStep_Step Step_hasSubStep_Step_type;
    typedef ::xsd::cxx::tree::sequence< Step_hasSubStep_Step_type > Step_hasSubStep_Step_sequence;
    typedef Step_hasSubStep_Step_sequence::iterator Step_hasSubStep_Step_iterator;
    typedef Step_hasSubStep_Step_sequence::const_iterator Step_hasSubStep_Step_const_iterator;
    typedef ::xsd::cxx::tree::traits< Step_hasSubStep_Step_type, char > Step_hasSubStep_Step_traits;

    const Step_hasSubStep_Step_sequence&
    Step_hasSubStep_Step () const;

    Step_hasSubStep_Step_sequence&
    Step_hasSubStep_Step ();

    void
    Step_hasSubStep_Step (const Step_hasSubStep_Step_sequence& s);

    // Constructors.
    //
    Step ();

    Step (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    Step (const Step& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual Step*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Step&
    operator= (const Step& x);

    virtual 
    ~Step ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    script_optional script_;
    scriptingLanguage_optional scriptingLanguage_;
    Step_produces_Parameter_sequence Step_produces_Parameter_;
    Step_receives_Parameter_sequence Step_receives_Parameter_;
    Step_hasSubStep_Step_sequence Step_hasSubStep_Step_;
  };

  class SubstantiveConceptualDomain: public ::XMLSchema::ConceptualDomain
  {
    public:
    // Constructors.
    //
    SubstantiveConceptualDomain ();

    SubstantiveConceptualDomain (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    SubstantiveConceptualDomain (const SubstantiveConceptualDomain& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual SubstantiveConceptualDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    SubstantiveConceptualDomain&
    operator= (const SubstantiveConceptualDomain&) = default;
#endif

    virtual 
    ~SubstantiveConceptualDomain ();
  };

  class SyntheticIdComponent: public ::XMLSchema::DataStructureComponent
  {
    public:
    // Constructors.
    //
    SyntheticIdComponent ();

    SyntheticIdComponent (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    SyntheticIdComponent (const SyntheticIdComponent& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual SyntheticIdComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    SyntheticIdComponent&
    operator= (const SyntheticIdComponent&) = default;
#endif

    virtual 
    ~SyntheticIdComponent ();
  };

  class TemporalControlConstruct: public ::XMLSchema::TemporalConstraints
  {
    public:
    // temporalControl
    //
    typedef ::XMLSchema::TemporalOperator temporalControl_type;
    typedef ::xsd::cxx::tree::traits< temporalControl_type, char > temporalControl_traits;

    const temporalControl_type&
    temporalControl () const;

    temporalControl_type&
    temporalControl ();

    void
    temporalControl (const temporalControl_type& x);

    void
    temporalControl (::std::unique_ptr< temporalControl_type > p);

    // Constructors.
    //
    TemporalControlConstruct (const temporalControl_type&);

    TemporalControlConstruct (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    TemporalControlConstruct (const TemporalControlConstruct& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual TemporalControlConstruct*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TemporalControlConstruct&
    operator= (const TemporalControlConstruct& x);

    virtual 
    ~TemporalControlConstruct ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< temporalControl_type > temporalControl_;
  };

  class Unit: public ::xml_schema::type
  {
    public:
    // catalogDetails
    //
    typedef ::XMLSchema::CatalogDetails catalogDetails_type;
    typedef ::xsd::cxx::tree::optional< catalogDetails_type > catalogDetails_optional;
    typedef ::xsd::cxx::tree::traits< catalogDetails_type, char > catalogDetails_traits;

    const catalogDetails_optional&
    catalogDetails () const;

    catalogDetails_optional&
    catalogDetails ();

    void
    catalogDetails (const catalogDetails_type& x);

    void
    catalogDetails (const catalogDetails_optional& x);

    void
    catalogDetails (::std::unique_ptr< catalogDetails_type > p);

    // definition
    //
    typedef ::XMLSchema::InternationalString definition_type;
    typedef ::xsd::cxx::tree::optional< definition_type > definition_optional;
    typedef ::xsd::cxx::tree::traits< definition_type, char > definition_traits;

    const definition_optional&
    definition () const;

    definition_optional&
    definition ();

    void
    definition (const definition_type& x);

    void
    definition (const definition_optional& x);

    void
    definition (::std::unique_ptr< definition_type > p);

    // displayLabel
    //
    typedef ::XMLSchema::LabelForDisplay displayLabel_type;
    typedef ::xsd::cxx::tree::sequence< displayLabel_type > displayLabel_sequence;
    typedef displayLabel_sequence::iterator displayLabel_iterator;
    typedef displayLabel_sequence::const_iterator displayLabel_const_iterator;
    typedef ::xsd::cxx::tree::traits< displayLabel_type, char > displayLabel_traits;

    const displayLabel_sequence&
    displayLabel () const;

    displayLabel_sequence&
    displayLabel ();

    void
    displayLabel (const displayLabel_sequence& s);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // Unit_has_UnitType
    //
    typedef ::XMLSchema::Unit_has_UnitType Unit_has_UnitType_type;
    typedef ::xsd::cxx::tree::sequence< Unit_has_UnitType_type > Unit_has_UnitType_sequence;
    typedef Unit_has_UnitType_sequence::iterator Unit_has_UnitType_iterator;
    typedef Unit_has_UnitType_sequence::const_iterator Unit_has_UnitType_const_iterator;
    typedef ::xsd::cxx::tree::traits< Unit_has_UnitType_type, char > Unit_has_UnitType_traits;

    const Unit_has_UnitType_sequence&
    Unit_has_UnitType () const;

    Unit_has_UnitType_sequence&
    Unit_has_UnitType ();

    void
    Unit_has_UnitType (const Unit_has_UnitType_sequence& s);

    // Constructors.
    //
    Unit ();

    Unit (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    Unit (const Unit& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual Unit*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Unit&
    operator= (const Unit& x);

    virtual 
    ~Unit ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    catalogDetails_optional catalogDetails_;
    definition_optional definition_;
    displayLabel_sequence displayLabel_;
    identifier_optional identifier_;
    name_sequence name_;
    Unit_has_UnitType_sequence Unit_has_UnitType_;
  };

  class UnitSegmentLayout: public ::XMLSchema::PhysicalSegmentLayout
  {
    public:
    // Constructors.
    //
    UnitSegmentLayout (const allowsDuplicates_type&,
                       const isDelimited_type&,
                       const isFixedWidth_type&);

    UnitSegmentLayout (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    UnitSegmentLayout (const UnitSegmentLayout& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual UnitSegmentLayout*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    UnitSegmentLayout&
    operator= (const UnitSegmentLayout&) = default;
#endif

    virtual 
    ~UnitSegmentLayout ();
  };

  class ValueAndConceptDescription: public ::xml_schema::type
  {
    public:
    // classificationLevel
    //
    typedef ::XMLSchema::CategoryRelationCode classificationLevel_type;
    typedef ::xsd::cxx::tree::optional< classificationLevel_type > classificationLevel_optional;
    typedef ::xsd::cxx::tree::traits< classificationLevel_type, char > classificationLevel_traits;

    const classificationLevel_optional&
    classificationLevel () const;

    classificationLevel_optional&
    classificationLevel ();

    void
    classificationLevel (const classificationLevel_type& x);

    void
    classificationLevel (const classificationLevel_optional& x);

    void
    classificationLevel (::std::unique_ptr< classificationLevel_type > p);

    // description
    //
    typedef ::XMLSchema::InternationalString description_type;
    typedef ::xsd::cxx::tree::optional< description_type > description_optional;
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    const description_optional&
    description () const;

    description_optional&
    description ();

    void
    description (const description_type& x);

    void
    description (const description_optional& x);

    void
    description (::std::unique_ptr< description_type > p);

    // formatPattern
    //
    typedef ::XMLSchema::ControlledVocabularyEntry formatPattern_type;
    typedef ::xsd::cxx::tree::optional< formatPattern_type > formatPattern_optional;
    typedef ::xsd::cxx::tree::traits< formatPattern_type, char > formatPattern_traits;

    const formatPattern_optional&
    formatPattern () const;

    formatPattern_optional&
    formatPattern ();

    void
    formatPattern (const formatPattern_type& x);

    void
    formatPattern (const formatPattern_optional& x);

    void
    formatPattern (::std::unique_ptr< formatPattern_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // logicalExpression
    //
    typedef ::XMLSchema::ControlledVocabularyEntry logicalExpression_type;
    typedef ::xsd::cxx::tree::optional< logicalExpression_type > logicalExpression_optional;
    typedef ::xsd::cxx::tree::traits< logicalExpression_type, char > logicalExpression_traits;

    const logicalExpression_optional&
    logicalExpression () const;

    logicalExpression_optional&
    logicalExpression ();

    void
    logicalExpression (const logicalExpression_type& x);

    void
    logicalExpression (const logicalExpression_optional& x);

    void
    logicalExpression (::std::unique_ptr< logicalExpression_type > p);

    // maximumValueExclusive
    //
    typedef ::xml_schema::string maximumValueExclusive_type;
    typedef ::xsd::cxx::tree::optional< maximumValueExclusive_type > maximumValueExclusive_optional;
    typedef ::xsd::cxx::tree::traits< maximumValueExclusive_type, char > maximumValueExclusive_traits;

    const maximumValueExclusive_optional&
    maximumValueExclusive () const;

    maximumValueExclusive_optional&
    maximumValueExclusive ();

    void
    maximumValueExclusive (const maximumValueExclusive_type& x);

    void
    maximumValueExclusive (const maximumValueExclusive_optional& x);

    void
    maximumValueExclusive (::std::unique_ptr< maximumValueExclusive_type > p);

    // maximumValueInclusive
    //
    typedef ::xml_schema::string maximumValueInclusive_type;
    typedef ::xsd::cxx::tree::optional< maximumValueInclusive_type > maximumValueInclusive_optional;
    typedef ::xsd::cxx::tree::traits< maximumValueInclusive_type, char > maximumValueInclusive_traits;

    const maximumValueInclusive_optional&
    maximumValueInclusive () const;

    maximumValueInclusive_optional&
    maximumValueInclusive ();

    void
    maximumValueInclusive (const maximumValueInclusive_type& x);

    void
    maximumValueInclusive (const maximumValueInclusive_optional& x);

    void
    maximumValueInclusive (::std::unique_ptr< maximumValueInclusive_type > p);

    // minimumValueExclusive
    //
    typedef ::xml_schema::string minimumValueExclusive_type;
    typedef ::xsd::cxx::tree::optional< minimumValueExclusive_type > minimumValueExclusive_optional;
    typedef ::xsd::cxx::tree::traits< minimumValueExclusive_type, char > minimumValueExclusive_traits;

    const minimumValueExclusive_optional&
    minimumValueExclusive () const;

    minimumValueExclusive_optional&
    minimumValueExclusive ();

    void
    minimumValueExclusive (const minimumValueExclusive_type& x);

    void
    minimumValueExclusive (const minimumValueExclusive_optional& x);

    void
    minimumValueExclusive (::std::unique_ptr< minimumValueExclusive_type > p);

    // minimumValueInclusive
    //
    typedef ::xml_schema::string minimumValueInclusive_type;
    typedef ::xsd::cxx::tree::optional< minimumValueInclusive_type > minimumValueInclusive_optional;
    typedef ::xsd::cxx::tree::traits< minimumValueInclusive_type, char > minimumValueInclusive_traits;

    const minimumValueInclusive_optional&
    minimumValueInclusive () const;

    minimumValueInclusive_optional&
    minimumValueInclusive ();

    void
    minimumValueInclusive (const minimumValueInclusive_type& x);

    void
    minimumValueInclusive (const minimumValueInclusive_optional& x);

    void
    minimumValueInclusive (::std::unique_ptr< minimumValueInclusive_type > p);

    // regularExpression
    //
    typedef ::XMLSchema::TypedString regularExpression_type;
    typedef ::xsd::cxx::tree::optional< regularExpression_type > regularExpression_optional;
    typedef ::xsd::cxx::tree::traits< regularExpression_type, char > regularExpression_traits;

    const regularExpression_optional&
    regularExpression () const;

    regularExpression_optional&
    regularExpression ();

    void
    regularExpression (const regularExpression_type& x);

    void
    regularExpression (const regularExpression_optional& x);

    void
    regularExpression (::std::unique_ptr< regularExpression_type > p);

    // Constructors.
    //
    ValueAndConceptDescription ();

    ValueAndConceptDescription (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    ValueAndConceptDescription (const ValueAndConceptDescription& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual ValueAndConceptDescription*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ValueAndConceptDescription&
    operator= (const ValueAndConceptDescription& x);

    virtual 
    ~ValueAndConceptDescription ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    classificationLevel_optional classificationLevel_;
    description_optional description_;
    formatPattern_optional formatPattern_;
    identifier_optional identifier_;
    logicalExpression_optional logicalExpression_;
    maximumValueExclusive_optional maximumValueExclusive_;
    maximumValueInclusive_optional maximumValueInclusive_;
    minimumValueExclusive_optional minimumValueExclusive_;
    minimumValueInclusive_optional minimumValueInclusive_;
    regularExpression_optional regularExpression_;
  };

  class ValueMapping: public ::xml_schema::type
  {
    public:
    // decimalPositions
    //
    typedef ::xml_schema::integer decimalPositions_type;
    typedef ::xsd::cxx::tree::optional< decimalPositions_type > decimalPositions_optional;
    typedef ::xsd::cxx::tree::traits< decimalPositions_type, char > decimalPositions_traits;

    const decimalPositions_optional&
    decimalPositions () const;

    decimalPositions_optional&
    decimalPositions ();

    void
    decimalPositions (const decimalPositions_type& x);

    void
    decimalPositions (const decimalPositions_optional& x);

    // defaultDecimalSeparator
    //
    typedef ::xml_schema::string defaultDecimalSeparator_type;
    typedef ::xsd::cxx::tree::optional< defaultDecimalSeparator_type > defaultDecimalSeparator_optional;
    typedef ::xsd::cxx::tree::traits< defaultDecimalSeparator_type, char > defaultDecimalSeparator_traits;

    const defaultDecimalSeparator_optional&
    defaultDecimalSeparator () const;

    defaultDecimalSeparator_optional&
    defaultDecimalSeparator ();

    void
    defaultDecimalSeparator (const defaultDecimalSeparator_type& x);

    void
    defaultDecimalSeparator (const defaultDecimalSeparator_optional& x);

    void
    defaultDecimalSeparator (::std::unique_ptr< defaultDecimalSeparator_type > p);

    // defaultDigitGroupSeparator
    //
    typedef ::xml_schema::string defaultDigitGroupSeparator_type;
    typedef ::xsd::cxx::tree::optional< defaultDigitGroupSeparator_type > defaultDigitGroupSeparator_optional;
    typedef ::xsd::cxx::tree::traits< defaultDigitGroupSeparator_type, char > defaultDigitGroupSeparator_traits;

    const defaultDigitGroupSeparator_optional&
    defaultDigitGroupSeparator () const;

    defaultDigitGroupSeparator_optional&
    defaultDigitGroupSeparator ();

    void
    defaultDigitGroupSeparator (const defaultDigitGroupSeparator_type& x);

    void
    defaultDigitGroupSeparator (const defaultDigitGroupSeparator_optional& x);

    void
    defaultDigitGroupSeparator (::std::unique_ptr< defaultDigitGroupSeparator_type > p);

    // defaultValue
    //
    typedef ::xml_schema::string defaultValue_type;
    typedef ::xsd::cxx::tree::traits< defaultValue_type, char > defaultValue_traits;

    const defaultValue_type&
    defaultValue () const;

    defaultValue_type&
    defaultValue ();

    void
    defaultValue (const defaultValue_type& x);

    void
    defaultValue (::std::unique_ptr< defaultValue_type > p);

    // format
    //
    typedef ::XMLSchema::ControlledVocabularyEntry format_type;
    typedef ::xsd::cxx::tree::optional< format_type > format_optional;
    typedef ::xsd::cxx::tree::traits< format_type, char > format_traits;

    const format_optional&
    format () const;

    format_optional&
    format ();

    void
    format (const format_type& x);

    void
    format (const format_optional& x);

    void
    format (::std::unique_ptr< format_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // isRequired
    //
    typedef ::xml_schema::boolean isRequired_type;
    typedef ::xsd::cxx::tree::optional< isRequired_type > isRequired_optional;
    typedef ::xsd::cxx::tree::traits< isRequired_type, char > isRequired_traits;

    const isRequired_optional&
    isRequired () const;

    isRequired_optional&
    isRequired ();

    void
    isRequired (const isRequired_type& x);

    void
    isRequired (const isRequired_optional& x);

    // length
    //
    typedef ::xml_schema::integer length_type;
    typedef ::xsd::cxx::tree::optional< length_type > length_optional;
    typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

    const length_optional&
    length () const;

    length_optional&
    length ();

    void
    length (const length_type& x);

    void
    length (const length_optional& x);

    // maximumLength
    //
    typedef ::xml_schema::integer maximumLength_type;
    typedef ::xsd::cxx::tree::optional< maximumLength_type > maximumLength_optional;
    typedef ::xsd::cxx::tree::traits< maximumLength_type, char > maximumLength_traits;

    const maximumLength_optional&
    maximumLength () const;

    maximumLength_optional&
    maximumLength ();

    void
    maximumLength (const maximumLength_type& x);

    void
    maximumLength (const maximumLength_optional& x);

    // minimumLength
    //
    typedef ::xml_schema::integer minimumLength_type;
    typedef ::xsd::cxx::tree::optional< minimumLength_type > minimumLength_optional;
    typedef ::xsd::cxx::tree::traits< minimumLength_type, char > minimumLength_traits;

    const minimumLength_optional&
    minimumLength () const;

    minimumLength_optional&
    minimumLength ();

    void
    minimumLength (const minimumLength_type& x);

    void
    minimumLength (const minimumLength_optional& x);

    // nullSequence
    //
    typedef ::xml_schema::string nullSequence_type;
    typedef ::xsd::cxx::tree::optional< nullSequence_type > nullSequence_optional;
    typedef ::xsd::cxx::tree::traits< nullSequence_type, char > nullSequence_traits;

    const nullSequence_optional&
    nullSequence () const;

    nullSequence_optional&
    nullSequence ();

    void
    nullSequence (const nullSequence_type& x);

    void
    nullSequence (const nullSequence_optional& x);

    void
    nullSequence (::std::unique_ptr< nullSequence_type > p);

    // numberPattern
    //
    typedef ::xml_schema::string numberPattern_type;
    typedef ::xsd::cxx::tree::optional< numberPattern_type > numberPattern_optional;
    typedef ::xsd::cxx::tree::traits< numberPattern_type, char > numberPattern_traits;

    const numberPattern_optional&
    numberPattern () const;

    numberPattern_optional&
    numberPattern ();

    void
    numberPattern (const numberPattern_type& x);

    void
    numberPattern (const numberPattern_optional& x);

    void
    numberPattern (::std::unique_ptr< numberPattern_type > p);

    // physicalDataType
    //
    typedef ::XMLSchema::ControlledVocabularyEntry physicalDataType_type;
    typedef ::xsd::cxx::tree::optional< physicalDataType_type > physicalDataType_optional;
    typedef ::xsd::cxx::tree::traits< physicalDataType_type, char > physicalDataType_traits;

    const physicalDataType_optional&
    physicalDataType () const;

    physicalDataType_optional&
    physicalDataType ();

    void
    physicalDataType (const physicalDataType_type& x);

    void
    physicalDataType (const physicalDataType_optional& x);

    void
    physicalDataType (::std::unique_ptr< physicalDataType_type > p);

    // scale
    //
    typedef ::xml_schema::integer scale_type;
    typedef ::xsd::cxx::tree::optional< scale_type > scale_optional;
    typedef ::xsd::cxx::tree::traits< scale_type, char > scale_traits;

    const scale_optional&
    scale () const;

    scale_optional&
    scale ();

    void
    scale (const scale_type& x);

    void
    scale (const scale_optional& x);

    // ValueMapping_formats_DataPoint
    //
    typedef ::XMLSchema::ValueMapping_formats_DataPoint ValueMapping_formats_DataPoint_type;
    typedef ::xsd::cxx::tree::sequence< ValueMapping_formats_DataPoint_type > ValueMapping_formats_DataPoint_sequence;
    typedef ValueMapping_formats_DataPoint_sequence::iterator ValueMapping_formats_DataPoint_iterator;
    typedef ValueMapping_formats_DataPoint_sequence::const_iterator ValueMapping_formats_DataPoint_const_iterator;
    typedef ::xsd::cxx::tree::traits< ValueMapping_formats_DataPoint_type, char > ValueMapping_formats_DataPoint_traits;

    const ValueMapping_formats_DataPoint_sequence&
    ValueMapping_formats_DataPoint () const;

    ValueMapping_formats_DataPoint_sequence&
    ValueMapping_formats_DataPoint ();

    void
    ValueMapping_formats_DataPoint (const ValueMapping_formats_DataPoint_sequence& s);

    // ValueMapping_uses_PhysicalSegmentLocation
    //
    typedef ::XMLSchema::ValueMapping_uses_PhysicalSegmentLocation ValueMapping_uses_PhysicalSegmentLocation_type;
    typedef ::xsd::cxx::tree::optional< ValueMapping_uses_PhysicalSegmentLocation_type > ValueMapping_uses_PhysicalSegmentLocation_optional;
    typedef ::xsd::cxx::tree::traits< ValueMapping_uses_PhysicalSegmentLocation_type, char > ValueMapping_uses_PhysicalSegmentLocation_traits;

    const ValueMapping_uses_PhysicalSegmentLocation_optional&
    ValueMapping_uses_PhysicalSegmentLocation () const;

    ValueMapping_uses_PhysicalSegmentLocation_optional&
    ValueMapping_uses_PhysicalSegmentLocation ();

    void
    ValueMapping_uses_PhysicalSegmentLocation (const ValueMapping_uses_PhysicalSegmentLocation_type& x);

    void
    ValueMapping_uses_PhysicalSegmentLocation (const ValueMapping_uses_PhysicalSegmentLocation_optional& x);

    void
    ValueMapping_uses_PhysicalSegmentLocation (::std::unique_ptr< ValueMapping_uses_PhysicalSegmentLocation_type > p);

    // Constructors.
    //
    ValueMapping (const defaultValue_type&);

    ValueMapping (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    ValueMapping (const ValueMapping& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual ValueMapping*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ValueMapping&
    operator= (const ValueMapping& x);

    virtual 
    ~ValueMapping ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    decimalPositions_optional decimalPositions_;
    defaultDecimalSeparator_optional defaultDecimalSeparator_;
    defaultDigitGroupSeparator_optional defaultDigitGroupSeparator_;
    ::xsd::cxx::tree::one< defaultValue_type > defaultValue_;
    format_optional format_;
    identifier_optional identifier_;
    isRequired_optional isRequired_;
    length_optional length_;
    maximumLength_optional maximumLength_;
    minimumLength_optional minimumLength_;
    nullSequence_optional nullSequence_;
    numberPattern_optional numberPattern_;
    physicalDataType_optional physicalDataType_;
    scale_optional scale_;
    ValueMapping_formats_DataPoint_sequence ValueMapping_formats_DataPoint_;
    ValueMapping_uses_PhysicalSegmentLocation_optional ValueMapping_uses_PhysicalSegmentLocation_;
  };

  class ValueMappingPosition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // value
    //
    typedef ::xml_schema::integer value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    // ValueMappingPosition_indexes_ValueMapping
    //
    typedef ::XMLSchema::ValueMappingPosition_indexes_ValueMapping ValueMappingPosition_indexes_ValueMapping_type;
    typedef ::xsd::cxx::tree::traits< ValueMappingPosition_indexes_ValueMapping_type, char > ValueMappingPosition_indexes_ValueMapping_traits;

    const ValueMappingPosition_indexes_ValueMapping_type&
    ValueMappingPosition_indexes_ValueMapping () const;

    ValueMappingPosition_indexes_ValueMapping_type&
    ValueMappingPosition_indexes_ValueMapping ();

    void
    ValueMappingPosition_indexes_ValueMapping (const ValueMappingPosition_indexes_ValueMapping_type& x);

    void
    ValueMappingPosition_indexes_ValueMapping (::std::unique_ptr< ValueMappingPosition_indexes_ValueMapping_type > p);

    // Constructors.
    //
    ValueMappingPosition (const value_type&,
                          const ValueMappingPosition_indexes_ValueMapping_type&);

    ValueMappingPosition (const value_type&,
                          ::std::unique_ptr< ValueMappingPosition_indexes_ValueMapping_type >);

    ValueMappingPosition (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    ValueMappingPosition (const ValueMappingPosition& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual ValueMappingPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ValueMappingPosition&
    operator= (const ValueMappingPosition& x);

    virtual 
    ~ValueMappingPosition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< value_type > value_;
    ::xsd::cxx::tree::one< ValueMappingPosition_indexes_ValueMapping_type > ValueMappingPosition_indexes_ValueMapping_;
  };

  class ValueMappingRelationship: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // ValueMappingRelationship_hasTarget_ValueMapping
    //
    typedef ::XMLSchema::ValueMappingRelationship_hasTarget_ValueMapping ValueMappingRelationship_hasTarget_ValueMapping_type;
    typedef ::xsd::cxx::tree::sequence< ValueMappingRelationship_hasTarget_ValueMapping_type > ValueMappingRelationship_hasTarget_ValueMapping_sequence;
    typedef ValueMappingRelationship_hasTarget_ValueMapping_sequence::iterator ValueMappingRelationship_hasTarget_ValueMapping_iterator;
    typedef ValueMappingRelationship_hasTarget_ValueMapping_sequence::const_iterator ValueMappingRelationship_hasTarget_ValueMapping_const_iterator;
    typedef ::xsd::cxx::tree::traits< ValueMappingRelationship_hasTarget_ValueMapping_type, char > ValueMappingRelationship_hasTarget_ValueMapping_traits;

    const ValueMappingRelationship_hasTarget_ValueMapping_sequence&
    ValueMappingRelationship_hasTarget_ValueMapping () const;

    ValueMappingRelationship_hasTarget_ValueMapping_sequence&
    ValueMappingRelationship_hasTarget_ValueMapping ();

    void
    ValueMappingRelationship_hasTarget_ValueMapping (const ValueMappingRelationship_hasTarget_ValueMapping_sequence& s);

    // ValueMappingRelationship_hasSource_ValueMapping
    //
    typedef ::XMLSchema::ValueMappingRelationship_hasSource_ValueMapping ValueMappingRelationship_hasSource_ValueMapping_type;
    typedef ::xsd::cxx::tree::sequence< ValueMappingRelationship_hasSource_ValueMapping_type > ValueMappingRelationship_hasSource_ValueMapping_sequence;
    typedef ValueMappingRelationship_hasSource_ValueMapping_sequence::iterator ValueMappingRelationship_hasSource_ValueMapping_iterator;
    typedef ValueMappingRelationship_hasSource_ValueMapping_sequence::const_iterator ValueMappingRelationship_hasSource_ValueMapping_const_iterator;
    typedef ::xsd::cxx::tree::traits< ValueMappingRelationship_hasSource_ValueMapping_type, char > ValueMappingRelationship_hasSource_ValueMapping_traits;

    const ValueMappingRelationship_hasSource_ValueMapping_sequence&
    ValueMappingRelationship_hasSource_ValueMapping () const;

    ValueMappingRelationship_hasSource_ValueMapping_sequence&
    ValueMappingRelationship_hasSource_ValueMapping ();

    void
    ValueMappingRelationship_hasSource_ValueMapping (const ValueMappingRelationship_hasSource_ValueMapping_sequence& s);

    // Constructors.
    //
    ValueMappingRelationship ();

    ValueMappingRelationship (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    ValueMappingRelationship (const ValueMappingRelationship& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual ValueMappingRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ValueMappingRelationship&
    operator= (const ValueMappingRelationship& x);

    virtual 
    ~ValueMappingRelationship ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    semantics_optional semantics_;
    ValueMappingRelationship_hasTarget_ValueMapping_sequence ValueMappingRelationship_hasTarget_ValueMapping_;
    ValueMappingRelationship_hasSource_ValueMapping_sequence ValueMappingRelationship_hasSource_ValueMapping_;
  };

  class VariableCollection: public ::xml_schema::type
  {
    public:
    // allowsDuplicates
    //
    typedef ::xml_schema::boolean allowsDuplicates_type;
    typedef ::xsd::cxx::tree::traits< allowsDuplicates_type, char > allowsDuplicates_traits;

    const allowsDuplicates_type&
    allowsDuplicates () const;

    allowsDuplicates_type&
    allowsDuplicates ();

    void
    allowsDuplicates (const allowsDuplicates_type& x);

    // displayLabel
    //
    typedef ::XMLSchema::LabelForDisplay displayLabel_type;
    typedef ::xsd::cxx::tree::sequence< displayLabel_type > displayLabel_sequence;
    typedef displayLabel_sequence::iterator displayLabel_iterator;
    typedef displayLabel_sequence::const_iterator displayLabel_const_iterator;
    typedef ::xsd::cxx::tree::traits< displayLabel_type, char > displayLabel_traits;

    const displayLabel_sequence&
    displayLabel () const;

    displayLabel_sequence&
    displayLabel ();

    void
    displayLabel (const displayLabel_sequence& s);

    // groupingSemantic
    //
    typedef ::XMLSchema::ControlledVocabularyEntry groupingSemantic_type;
    typedef ::xsd::cxx::tree::optional< groupingSemantic_type > groupingSemantic_optional;
    typedef ::xsd::cxx::tree::traits< groupingSemantic_type, char > groupingSemantic_traits;

    const groupingSemantic_optional&
    groupingSemantic () const;

    groupingSemantic_optional&
    groupingSemantic ();

    void
    groupingSemantic (const groupingSemantic_type& x);

    void
    groupingSemantic (const groupingSemantic_optional& x);

    void
    groupingSemantic (::std::unique_ptr< groupingSemantic_type > p);

    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::ObjectName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // usage
    //
    typedef ::XMLSchema::InternationalString usage_type;
    typedef ::xsd::cxx::tree::optional< usage_type > usage_optional;
    typedef ::xsd::cxx::tree::traits< usage_type, char > usage_traits;

    const usage_optional&
    usage () const;

    usage_optional&
    usage ();

    void
    usage (const usage_type& x);

    void
    usage (const usage_optional& x);

    void
    usage (::std::unique_ptr< usage_type > p);

    // VariableCollection_isDefinedBy_Concept
    //
    typedef ::XMLSchema::VariableCollection_isDefinedBy_Concept VariableCollection_isDefinedBy_Concept_type;
    typedef ::xsd::cxx::tree::sequence< VariableCollection_isDefinedBy_Concept_type > VariableCollection_isDefinedBy_Concept_sequence;
    typedef VariableCollection_isDefinedBy_Concept_sequence::iterator VariableCollection_isDefinedBy_Concept_iterator;
    typedef VariableCollection_isDefinedBy_Concept_sequence::const_iterator VariableCollection_isDefinedBy_Concept_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableCollection_isDefinedBy_Concept_type, char > VariableCollection_isDefinedBy_Concept_traits;

    const VariableCollection_isDefinedBy_Concept_sequence&
    VariableCollection_isDefinedBy_Concept () const;

    VariableCollection_isDefinedBy_Concept_sequence&
    VariableCollection_isDefinedBy_Concept ();

    void
    VariableCollection_isDefinedBy_Concept (const VariableCollection_isDefinedBy_Concept_sequence& s);

    // VariableCollection_has_ConceptualVariable
    //
    typedef ::XMLSchema::VariableCollection_has_ConceptualVariable VariableCollection_has_ConceptualVariable_type;
    typedef ::xsd::cxx::tree::sequence< VariableCollection_has_ConceptualVariable_type > VariableCollection_has_ConceptualVariable_sequence;
    typedef VariableCollection_has_ConceptualVariable_sequence::iterator VariableCollection_has_ConceptualVariable_iterator;
    typedef VariableCollection_has_ConceptualVariable_sequence::const_iterator VariableCollection_has_ConceptualVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableCollection_has_ConceptualVariable_type, char > VariableCollection_has_ConceptualVariable_traits;

    const VariableCollection_has_ConceptualVariable_sequence&
    VariableCollection_has_ConceptualVariable () const;

    VariableCollection_has_ConceptualVariable_sequence&
    VariableCollection_has_ConceptualVariable ();

    void
    VariableCollection_has_ConceptualVariable (const VariableCollection_has_ConceptualVariable_sequence& s);

    // VariableCollection_has_VariablePosition
    //
    typedef ::XMLSchema::VariableCollection_has_VariablePosition VariableCollection_has_VariablePosition_type;
    typedef ::xsd::cxx::tree::sequence< VariableCollection_has_VariablePosition_type > VariableCollection_has_VariablePosition_sequence;
    typedef VariableCollection_has_VariablePosition_sequence::iterator VariableCollection_has_VariablePosition_iterator;
    typedef VariableCollection_has_VariablePosition_sequence::const_iterator VariableCollection_has_VariablePosition_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableCollection_has_VariablePosition_type, char > VariableCollection_has_VariablePosition_traits;

    const VariableCollection_has_VariablePosition_sequence&
    VariableCollection_has_VariablePosition () const;

    VariableCollection_has_VariablePosition_sequence&
    VariableCollection_has_VariablePosition ();

    void
    VariableCollection_has_VariablePosition (const VariableCollection_has_VariablePosition_sequence& s);

    // Constructors.
    //
    VariableCollection (const allowsDuplicates_type&);

    VariableCollection (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    VariableCollection (const VariableCollection& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual VariableCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    VariableCollection&
    operator= (const VariableCollection& x);

    virtual 
    ~VariableCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< allowsDuplicates_type > allowsDuplicates_;
    displayLabel_sequence displayLabel_;
    groupingSemantic_optional groupingSemantic_;
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    usage_optional usage_;
    VariableCollection_isDefinedBy_Concept_sequence VariableCollection_isDefinedBy_Concept_;
    VariableCollection_has_ConceptualVariable_sequence VariableCollection_has_ConceptualVariable_;
    VariableCollection_has_VariablePosition_sequence VariableCollection_has_VariablePosition_;
  };

  class VariableDescriptorComponent: public ::XMLSchema::DataStructureComponent
  {
    public:
    // VariableDescriptorComponent_isDefinedBy_DescriptorVariable
    //
    typedef ::XMLSchema::VariableDescriptorComponent_isDefinedBy_DescriptorVariable VariableDescriptorComponent_isDefinedBy_DescriptorVariable_type;
    typedef ::xsd::cxx::tree::optional< VariableDescriptorComponent_isDefinedBy_DescriptorVariable_type > VariableDescriptorComponent_isDefinedBy_DescriptorVariable_optional;
    typedef ::xsd::cxx::tree::traits< VariableDescriptorComponent_isDefinedBy_DescriptorVariable_type, char > VariableDescriptorComponent_isDefinedBy_DescriptorVariable_traits;

    const VariableDescriptorComponent_isDefinedBy_DescriptorVariable_optional&
    VariableDescriptorComponent_isDefinedBy_DescriptorVariable () const;

    VariableDescriptorComponent_isDefinedBy_DescriptorVariable_optional&
    VariableDescriptorComponent_isDefinedBy_DescriptorVariable ();

    void
    VariableDescriptorComponent_isDefinedBy_DescriptorVariable (const VariableDescriptorComponent_isDefinedBy_DescriptorVariable_type& x);

    void
    VariableDescriptorComponent_isDefinedBy_DescriptorVariable (const VariableDescriptorComponent_isDefinedBy_DescriptorVariable_optional& x);

    void
    VariableDescriptorComponent_isDefinedBy_DescriptorVariable (::std::unique_ptr< VariableDescriptorComponent_isDefinedBy_DescriptorVariable_type > p);

    // VariableDescriptorComponent_refersTo_VariableValueComponent
    //
    typedef ::XMLSchema::VariableDescriptorComponent_refersTo_VariableValueComponent VariableDescriptorComponent_refersTo_VariableValueComponent_type;
    typedef ::xsd::cxx::tree::traits< VariableDescriptorComponent_refersTo_VariableValueComponent_type, char > VariableDescriptorComponent_refersTo_VariableValueComponent_traits;

    const VariableDescriptorComponent_refersTo_VariableValueComponent_type&
    VariableDescriptorComponent_refersTo_VariableValueComponent () const;

    VariableDescriptorComponent_refersTo_VariableValueComponent_type&
    VariableDescriptorComponent_refersTo_VariableValueComponent ();

    void
    VariableDescriptorComponent_refersTo_VariableValueComponent (const VariableDescriptorComponent_refersTo_VariableValueComponent_type& x);

    void
    VariableDescriptorComponent_refersTo_VariableValueComponent (::std::unique_ptr< VariableDescriptorComponent_refersTo_VariableValueComponent_type > p);

    // Constructors.
    //
    VariableDescriptorComponent (const VariableDescriptorComponent_refersTo_VariableValueComponent_type&);

    VariableDescriptorComponent (::std::unique_ptr< VariableDescriptorComponent_refersTo_VariableValueComponent_type >);

    VariableDescriptorComponent (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    VariableDescriptorComponent (const VariableDescriptorComponent& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual VariableDescriptorComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    VariableDescriptorComponent&
    operator= (const VariableDescriptorComponent& x);

    virtual 
    ~VariableDescriptorComponent ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    VariableDescriptorComponent_isDefinedBy_DescriptorVariable_optional VariableDescriptorComponent_isDefinedBy_DescriptorVariable_;
    ::xsd::cxx::tree::one< VariableDescriptorComponent_refersTo_VariableValueComponent_type > VariableDescriptorComponent_refersTo_VariableValueComponent_;
  };

  class VariablePosition: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // value
    //
    typedef ::xml_schema::integer value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    // VariablePosition_indexes_ConceptualVariable
    //
    typedef ::XMLSchema::VariablePosition_indexes_ConceptualVariable VariablePosition_indexes_ConceptualVariable_type;
    typedef ::xsd::cxx::tree::traits< VariablePosition_indexes_ConceptualVariable_type, char > VariablePosition_indexes_ConceptualVariable_traits;

    const VariablePosition_indexes_ConceptualVariable_type&
    VariablePosition_indexes_ConceptualVariable () const;

    VariablePosition_indexes_ConceptualVariable_type&
    VariablePosition_indexes_ConceptualVariable ();

    void
    VariablePosition_indexes_ConceptualVariable (const VariablePosition_indexes_ConceptualVariable_type& x);

    void
    VariablePosition_indexes_ConceptualVariable (::std::unique_ptr< VariablePosition_indexes_ConceptualVariable_type > p);

    // Constructors.
    //
    VariablePosition (const value_type&,
                      const VariablePosition_indexes_ConceptualVariable_type&);

    VariablePosition (const value_type&,
                      ::std::unique_ptr< VariablePosition_indexes_ConceptualVariable_type >);

    VariablePosition (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    VariablePosition (const VariablePosition& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual VariablePosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    VariablePosition&
    operator= (const VariablePosition& x);

    virtual 
    ~VariablePosition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    ::xsd::cxx::tree::one< value_type > value_;
    ::xsd::cxx::tree::one< VariablePosition_indexes_ConceptualVariable_type > VariablePosition_indexes_ConceptualVariable_;
  };

  class VariableRelationship: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // VariableRelationship_hasTarget_ConceptualVariable
    //
    typedef ::XMLSchema::VariableRelationship_hasTarget_ConceptualVariable VariableRelationship_hasTarget_ConceptualVariable_type;
    typedef ::xsd::cxx::tree::sequence< VariableRelationship_hasTarget_ConceptualVariable_type > VariableRelationship_hasTarget_ConceptualVariable_sequence;
    typedef VariableRelationship_hasTarget_ConceptualVariable_sequence::iterator VariableRelationship_hasTarget_ConceptualVariable_iterator;
    typedef VariableRelationship_hasTarget_ConceptualVariable_sequence::const_iterator VariableRelationship_hasTarget_ConceptualVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableRelationship_hasTarget_ConceptualVariable_type, char > VariableRelationship_hasTarget_ConceptualVariable_traits;

    const VariableRelationship_hasTarget_ConceptualVariable_sequence&
    VariableRelationship_hasTarget_ConceptualVariable () const;

    VariableRelationship_hasTarget_ConceptualVariable_sequence&
    VariableRelationship_hasTarget_ConceptualVariable ();

    void
    VariableRelationship_hasTarget_ConceptualVariable (const VariableRelationship_hasTarget_ConceptualVariable_sequence& s);

    // VariableRelationship_hasSource_ConceptualVariable
    //
    typedef ::XMLSchema::VariableRelationship_hasSource_ConceptualVariable VariableRelationship_hasSource_ConceptualVariable_type;
    typedef ::xsd::cxx::tree::sequence< VariableRelationship_hasSource_ConceptualVariable_type > VariableRelationship_hasSource_ConceptualVariable_sequence;
    typedef VariableRelationship_hasSource_ConceptualVariable_sequence::iterator VariableRelationship_hasSource_ConceptualVariable_iterator;
    typedef VariableRelationship_hasSource_ConceptualVariable_sequence::const_iterator VariableRelationship_hasSource_ConceptualVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableRelationship_hasSource_ConceptualVariable_type, char > VariableRelationship_hasSource_ConceptualVariable_traits;

    const VariableRelationship_hasSource_ConceptualVariable_sequence&
    VariableRelationship_hasSource_ConceptualVariable () const;

    VariableRelationship_hasSource_ConceptualVariable_sequence&
    VariableRelationship_hasSource_ConceptualVariable ();

    void
    VariableRelationship_hasSource_ConceptualVariable (const VariableRelationship_hasSource_ConceptualVariable_sequence& s);

    // Constructors.
    //
    VariableRelationship ();

    VariableRelationship (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    VariableRelationship (const VariableRelationship& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual VariableRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    VariableRelationship&
    operator= (const VariableRelationship& x);

    virtual 
    ~VariableRelationship ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    semantics_optional semantics_;
    VariableRelationship_hasTarget_ConceptualVariable_sequence VariableRelationship_hasTarget_ConceptualVariable_;
    VariableRelationship_hasSource_ConceptualVariable_sequence VariableRelationship_hasSource_ConceptualVariable_;
  };

  class VariableStructure: public ::xml_schema::type
  {
    public:
    // identifier
    //
    typedef ::XMLSchema::Identifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // name
    //
    typedef ::XMLSchema::OrganizationName name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // purpose
    //
    typedef ::XMLSchema::InternationalString purpose_type;
    typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
    typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

    const purpose_optional&
    purpose () const;

    purpose_optional&
    purpose ();

    void
    purpose (const purpose_type& x);

    void
    purpose (const purpose_optional& x);

    void
    purpose (::std::unique_ptr< purpose_type > p);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // specification
    //
    typedef ::XMLSchema::StructureSpecification specification_type;
    typedef ::xsd::cxx::tree::optional< specification_type > specification_optional;
    typedef ::xsd::cxx::tree::traits< specification_type, char > specification_traits;

    const specification_optional&
    specification () const;

    specification_optional&
    specification ();

    void
    specification (const specification_type& x);

    void
    specification (const specification_optional& x);

    void
    specification (::std::unique_ptr< specification_type > p);

    // topology
    //
    typedef ::XMLSchema::ControlledVocabularyEntry topology_type;
    typedef ::xsd::cxx::tree::optional< topology_type > topology_optional;
    typedef ::xsd::cxx::tree::traits< topology_type, char > topology_traits;

    const topology_optional&
    topology () const;

    topology_optional&
    topology ();

    void
    topology (const topology_type& x);

    void
    topology (const topology_optional& x);

    void
    topology (::std::unique_ptr< topology_type > p);

    // totality
    //
    typedef ::XMLSchema::StructureExtent totality_type;
    typedef ::xsd::cxx::tree::optional< totality_type > totality_optional;
    typedef ::xsd::cxx::tree::traits< totality_type, char > totality_traits;

    const totality_optional&
    totality () const;

    totality_optional&
    totality ();

    void
    totality (const totality_type& x);

    void
    totality (const totality_optional& x);

    void
    totality (::std::unique_ptr< totality_type > p);

    // VariableStructure_structures_VariableCollection
    //
    typedef ::XMLSchema::VariableStructure_structures_VariableCollection VariableStructure_structures_VariableCollection_type;
    typedef ::xsd::cxx::tree::optional< VariableStructure_structures_VariableCollection_type > VariableStructure_structures_VariableCollection_optional;
    typedef ::xsd::cxx::tree::traits< VariableStructure_structures_VariableCollection_type, char > VariableStructure_structures_VariableCollection_traits;

    const VariableStructure_structures_VariableCollection_optional&
    VariableStructure_structures_VariableCollection () const;

    VariableStructure_structures_VariableCollection_optional&
    VariableStructure_structures_VariableCollection ();

    void
    VariableStructure_structures_VariableCollection (const VariableStructure_structures_VariableCollection_type& x);

    void
    VariableStructure_structures_VariableCollection (const VariableStructure_structures_VariableCollection_optional& x);

    void
    VariableStructure_structures_VariableCollection (::std::unique_ptr< VariableStructure_structures_VariableCollection_type > p);

    // VariableStructure_has_VariableRelationship
    //
    typedef ::XMLSchema::VariableStructure_has_VariableRelationship VariableStructure_has_VariableRelationship_type;
    typedef ::xsd::cxx::tree::sequence< VariableStructure_has_VariableRelationship_type > VariableStructure_has_VariableRelationship_sequence;
    typedef VariableStructure_has_VariableRelationship_sequence::iterator VariableStructure_has_VariableRelationship_iterator;
    typedef VariableStructure_has_VariableRelationship_sequence::const_iterator VariableStructure_has_VariableRelationship_const_iterator;
    typedef ::xsd::cxx::tree::traits< VariableStructure_has_VariableRelationship_type, char > VariableStructure_has_VariableRelationship_traits;

    const VariableStructure_has_VariableRelationship_sequence&
    VariableStructure_has_VariableRelationship () const;

    VariableStructure_has_VariableRelationship_sequence&
    VariableStructure_has_VariableRelationship ();

    void
    VariableStructure_has_VariableRelationship (const VariableStructure_has_VariableRelationship_sequence& s);

    // Constructors.
    //
    VariableStructure ();

    VariableStructure (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    VariableStructure (const VariableStructure& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual VariableStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    VariableStructure&
    operator= (const VariableStructure& x);

    virtual 
    ~VariableStructure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifier_optional identifier_;
    name_sequence name_;
    purpose_optional purpose_;
    semantics_optional semantics_;
    specification_optional specification_;
    topology_optional topology_;
    totality_optional totality_;
    VariableStructure_structures_VariableCollection_optional VariableStructure_structures_VariableCollection_;
    VariableStructure_has_VariableRelationship_sequence VariableStructure_has_VariableRelationship_;
  };

  class VariableValueComponent: public ::XMLSchema::DataStructureComponent
  {
    public:
    // Constructors.
    //
    VariableValueComponent ();

    VariableValueComponent (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    VariableValueComponent (const VariableValueComponent& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual VariableValueComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    VariableValueComponent&
    operator= (const VariableValueComponent&) = default;
#endif

    virtual 
    ~VariableValueComponent ();
  };

  class WideDataSet: public ::XMLSchema::DataSet
  {
    public:
    // Constructors.
    //
    WideDataSet ();

    WideDataSet (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    WideDataSet (const WideDataSet& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual WideDataSet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    WideDataSet&
    operator= (const WideDataSet&) = default;
#endif

    virtual 
    ~WideDataSet ();
  };

  class WideDataStructure: public ::XMLSchema::DataStructure
  {
    public:
    // Constructors.
    //
    WideDataStructure ();

    WideDataStructure (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    WideDataStructure (const WideDataStructure& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual WideDataStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    WideDataStructure&
    operator= (const WideDataStructure&) = default;
#endif

    virtual 
    ~WideDataStructure ();
  };

  class WideKey: public ::XMLSchema::Key
  {
    public:
    // Constructors.
    //
    WideKey ();

    WideKey (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    WideKey (const WideKey& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual WideKey*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    WideKey&
    operator= (const WideKey&) = default;
#endif

    virtual 
    ~WideKey ();
  };

  class WideKeyMember: public ::XMLSchema::KeyMember
  {
    public:
    // Constructors.
    //
    WideKeyMember (const InstanceValue_hasValueFrom_ValueDomain_type&);

    WideKeyMember (::std::unique_ptr< InstanceValue_hasValueFrom_ValueDomain_type >);

    WideKeyMember (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    WideKeyMember (const WideKeyMember& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual WideKeyMember*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    WideKeyMember&
    operator= (const WideKeyMember&) = default;
#endif

    virtual 
    ~WideKeyMember ();
  };

  class CategoryRelationCode: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      Continuous,
      Interval,
      Nominal,
      Ordinal,
      Ratio
    };

    CategoryRelationCode (value v);

    CategoryRelationCode (const char* v);

    CategoryRelationCode (const ::std::string& v);

    CategoryRelationCode (const ::xml_schema::nmtoken& v);

    CategoryRelationCode (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    CategoryRelationCode (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    CategoryRelationCode (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    CategoryRelationCode (const CategoryRelationCode& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    CategoryRelationCode&
    operator= (const CategoryRelationCode&) = default;
#endif

    virtual CategoryRelationCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CategoryRelationCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_CategoryRelationCode_convert ();
    }

    protected:
    value
    _xsd_CategoryRelationCode_convert () const;

    public:
    static const char* const _xsd_CategoryRelationCode_literals_[5];
    static const value _xsd_CategoryRelationCode_indexes_[5];
  };

  class ComparisonOperator: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      Equal,
      GreaterThan,
      GreaterThanOrEqualTo,
      LessThan,
      LessThanOrEqualTo,
      NotEqual
    };

    ComparisonOperator (value v);

    ComparisonOperator (const char* v);

    ComparisonOperator (const ::std::string& v);

    ComparisonOperator (const ::xml_schema::nmtoken& v);

    ComparisonOperator (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    ComparisonOperator (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    ComparisonOperator (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    ComparisonOperator (const ComparisonOperator& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    ComparisonOperator&
    operator= (const ComparisonOperator&) = default;
#endif

    virtual ComparisonOperator*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ComparisonOperator&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ComparisonOperator_convert ();
    }

    protected:
    value
    _xsd_ComparisonOperator_convert () const;

    public:
    static const char* const _xsd_ComparisonOperator_literals_[6];
    static const value _xsd_ComparisonOperator_indexes_[6];
  };

  class ComputationBaseList: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      MissingOnly,
      Total,
      ValidOnly
    };

    ComputationBaseList (value v);

    ComputationBaseList (const char* v);

    ComputationBaseList (const ::std::string& v);

    ComputationBaseList (const ::xml_schema::nmtoken& v);

    ComputationBaseList (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ComputationBaseList (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ComputationBaseList (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ComputationBaseList (const ComputationBaseList& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    ComputationBaseList&
    operator= (const ComputationBaseList&) = default;
#endif

    virtual ComputationBaseList*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ComputationBaseList&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ComputationBaseList_convert ();
    }

    protected:
    value
    _xsd_ComputationBaseList_convert () const;

    public:
    static const char* const _xsd_ComputationBaseList_literals_[3];
    static const value _xsd_ComputationBaseList_indexes_[3];
  };

  class ControlConstruct: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      Else,
      IfThen,
      Loop,
      RepeatUntil,
      RepeatWhile
    };

    ControlConstruct (value v);

    ControlConstruct (const char* v);

    ControlConstruct (const ::std::string& v);

    ControlConstruct (const ::xml_schema::nmtoken& v);

    ControlConstruct (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    ControlConstruct (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    ControlConstruct (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    ControlConstruct (const ControlConstruct& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    ControlConstruct&
    operator= (const ControlConstruct&) = default;
#endif

    virtual ControlConstruct*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ControlConstruct&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ControlConstruct_convert ();
    }

    protected:
    value
    _xsd_ControlConstruct_convert () const;

    public:
    static const char* const _xsd_ControlConstruct_literals_[5];
    static const value _xsd_ControlConstruct_indexes_[5];
  };

  class MatchingCriterion: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      CloseMatch,
      Disjoint,
      ExactMatch
    };

    MatchingCriterion (value v);

    MatchingCriterion (const char* v);

    MatchingCriterion (const ::std::string& v);

    MatchingCriterion (const ::xml_schema::nmtoken& v);

    MatchingCriterion (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    MatchingCriterion (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    MatchingCriterion (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    MatchingCriterion (const MatchingCriterion& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    MatchingCriterion&
    operator= (const MatchingCriterion&) = default;
#endif

    virtual MatchingCriterion*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MatchingCriterion&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MatchingCriterion_convert ();
    }

    protected:
    value
    _xsd_MatchingCriterion_convert () const;

    public:
    static const char* const _xsd_MatchingCriterion_literals_[3];
    static const value _xsd_MatchingCriterion_indexes_[3];
  };

  class MemberRelationshipScope: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      All,
      None,
      Some
    };

    MemberRelationshipScope (value v);

    MemberRelationshipScope (const char* v);

    MemberRelationshipScope (const ::std::string& v);

    MemberRelationshipScope (const ::xml_schema::nmtoken& v);

    MemberRelationshipScope (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    MemberRelationshipScope (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    MemberRelationshipScope (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    MemberRelationshipScope (const MemberRelationshipScope& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    MemberRelationshipScope&
    operator= (const MemberRelationshipScope&) = default;
#endif

    virtual MemberRelationshipScope*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MemberRelationshipScope&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_MemberRelationshipScope_convert ();
    }

    protected:
    value
    _xsd_MemberRelationshipScope_convert () const;

    public:
    static const char* const _xsd_MemberRelationshipScope_literals_[3];
    static const value _xsd_MemberRelationshipScope_indexes_[3];
  };

  class PointFormat: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      DecimalDegree,
      DecimalMinutes,
      DegreesMinutesSeconds,
      Feet,
      Meters
    };

    PointFormat (value v);

    PointFormat (const char* v);

    PointFormat (const ::std::string& v);

    PointFormat (const ::xml_schema::nmtoken& v);

    PointFormat (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    PointFormat (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    PointFormat (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    PointFormat (const PointFormat& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    PointFormat&
    operator= (const PointFormat&) = default;
#endif

    virtual PointFormat*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PointFormat&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_PointFormat_convert ();
    }

    protected:
    value
    _xsd_PointFormat_convert () const;

    public:
    static const char* const _xsd_PointFormat_literals_[5];
    static const value _xsd_PointFormat_indexes_[5];
  };

  class SchedulingStrategy: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      BackwardChaining,
      ForwardChaining
    };

    SchedulingStrategy (value v);

    SchedulingStrategy (const char* v);

    SchedulingStrategy (const ::std::string& v);

    SchedulingStrategy (const ::xml_schema::nmtoken& v);

    SchedulingStrategy (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    SchedulingStrategy (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    SchedulingStrategy (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    SchedulingStrategy (const SchedulingStrategy& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    SchedulingStrategy&
    operator= (const SchedulingStrategy&) = default;
#endif

    virtual SchedulingStrategy*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SchedulingStrategy&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SchedulingStrategy_convert ();
    }

    protected:
    value
    _xsd_SchedulingStrategy_convert () const;

    public:
    static const char* const _xsd_SchedulingStrategy_literals_[2];
    static const value _xsd_SchedulingStrategy_indexes_[2];
  };

  class SexSpecification: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      Feminine,
      GenderNeutral,
      Masculine
    };

    SexSpecification (value v);

    SexSpecification (const char* v);

    SexSpecification (const ::std::string& v);

    SexSpecification (const ::xml_schema::nmtoken& v);

    SexSpecification (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    SexSpecification (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    SexSpecification (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    SexSpecification (const SexSpecification& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    SexSpecification&
    operator= (const SexSpecification&) = default;
#endif

    virtual SexSpecification*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SexSpecification&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_SexSpecification_convert ();
    }

    protected:
    value
    _xsd_SexSpecification_convert () const;

    public:
    static const char* const _xsd_SexSpecification_literals_[3];
    static const value _xsd_SexSpecification_indexes_[3];
  };

  class StructureExtent: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      Partial,
      Total
    };

    StructureExtent (value v);

    StructureExtent (const char* v);

    StructureExtent (const ::std::string& v);

    StructureExtent (const ::xml_schema::nmtoken& v);

    StructureExtent (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    StructureExtent (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    StructureExtent (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    StructureExtent (const StructureExtent& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    StructureExtent&
    operator= (const StructureExtent&) = default;
#endif

    virtual StructureExtent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    StructureExtent&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_StructureExtent_convert ();
    }

    protected:
    value
    _xsd_StructureExtent_convert () const;

    public:
    static const char* const _xsd_StructureExtent_literals_[2];
    static const value _xsd_StructureExtent_indexes_[2];
  };

  class TableDirectionValues: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      Auto,
      Ltr,
      Rtl
    };

    TableDirectionValues (value v);

    TableDirectionValues (const char* v);

    TableDirectionValues (const ::std::string& v);

    TableDirectionValues (const ::xml_schema::nmtoken& v);

    TableDirectionValues (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    TableDirectionValues (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    TableDirectionValues (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    TableDirectionValues (const TableDirectionValues& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    TableDirectionValues&
    operator= (const TableDirectionValues&) = default;
#endif

    virtual TableDirectionValues*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TableDirectionValues&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_TableDirectionValues_convert ();
    }

    protected:
    value
    _xsd_TableDirectionValues_convert () const;

    public:
    static const char* const _xsd_TableDirectionValues_literals_[3];
    static const value _xsd_TableDirectionValues_indexes_[3];
  };

  class TemporalOperator: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      AndJoin,
      AndSplit,
      XorJoin,
      XorSplit
    };

    TemporalOperator (value v);

    TemporalOperator (const char* v);

    TemporalOperator (const ::std::string& v);

    TemporalOperator (const ::xml_schema::nmtoken& v);

    TemporalOperator (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    TemporalOperator (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    TemporalOperator (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    TemporalOperator (const TemporalOperator& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    TemporalOperator&
    operator= (const TemporalOperator&) = default;
#endif

    virtual TemporalOperator*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TemporalOperator&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_TemporalOperator_convert ();
    }

    protected:
    value
    _xsd_TemporalOperator_convert () const;

    public:
    static const char* const _xsd_TemporalOperator_literals_[4];
    static const value _xsd_TemporalOperator_indexes_[4];
  };

  class TemporalRelation: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      Contains,
      Equals,
      Finishes,
      Meets,
      Overlaps,
      Precedes,
      Starts
    };

    TemporalRelation (value v);

    TemporalRelation (const char* v);

    TemporalRelation (const ::std::string& v);

    TemporalRelation (const ::xml_schema::nmtoken& v);

    TemporalRelation (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    TemporalRelation (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    TemporalRelation (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    TemporalRelation (const TemporalRelation& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    TemporalRelation&
    operator= (const TemporalRelation&) = default;
#endif

    virtual TemporalRelation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TemporalRelation&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_TemporalRelation_convert ();
    }

    protected:
    value
    _xsd_TemporalRelation_convert () const;

    public:
    static const char* const _xsd_TemporalRelation_literals_[7];
    static const value _xsd_TemporalRelation_indexes_[7];
  };

  class TextDirectionValues: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      Auto,
      Inherit,
      Ltr,
      Rtl
    };

    TextDirectionValues (value v);

    TextDirectionValues (const char* v);

    TextDirectionValues (const ::std::string& v);

    TextDirectionValues (const ::xml_schema::nmtoken& v);

    TextDirectionValues (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    TextDirectionValues (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    TextDirectionValues (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    TextDirectionValues (const TextDirectionValues& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    TextDirectionValues&
    operator= (const TextDirectionValues&) = default;
#endif

    virtual TextDirectionValues*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TextDirectionValues&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_TextDirectionValues_convert ();
    }

    protected:
    value
    _xsd_TextDirectionValues_convert () const;

    public:
    static const char* const _xsd_TextDirectionValues_literals_[4];
    static const value _xsd_TextDirectionValues_indexes_[4];
  };

  class TrimValues: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      Both,
      End,
      Neither,
      Start
    };

    TrimValues (value v);

    TrimValues (const char* v);

    TrimValues (const ::std::string& v);

    TrimValues (const ::xml_schema::nmtoken& v);

    TrimValues (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    TrimValues (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    TrimValues (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    TrimValues (const TrimValues& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    TrimValues&
    operator= (const TrimValues&) = default;
#endif

    virtual TrimValues*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TrimValues&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_TrimValues_convert ();
    }

    protected:
    value
    _xsd_TrimValues_convert () const;

    public:
    static const char* const _xsd_TrimValues_literals_[4];
    static const value _xsd_TrimValues_indexes_[4];
  };

  class WhiteSpaceRule: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      Collapse,
      Preserve,
      Replace
    };

    WhiteSpaceRule (value v);

    WhiteSpaceRule (const char* v);

    WhiteSpaceRule (const ::std::string& v);

    WhiteSpaceRule (const ::xml_schema::nmtoken& v);

    WhiteSpaceRule (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    WhiteSpaceRule (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    WhiteSpaceRule (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    WhiteSpaceRule (const WhiteSpaceRule& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
    WhiteSpaceRule&
    operator= (const WhiteSpaceRule&) = default;
#endif

    virtual WhiteSpaceRule*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    WhiteSpaceRule&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_WhiteSpaceRule_convert ();
    }

    protected:
    value
    _xsd_WhiteSpaceRule_convert () const;

    public:
    static const char* const _xsd_WhiteSpaceRule_literals_[3];
    static const value _xsd_WhiteSpaceRule_indexes_[3];
  };

  class AccessInformation: public ::xml_schema::type
  {
    public:
    // copyright
    //
    typedef ::XMLSchema::InternationalString copyright_type;
    typedef ::xsd::cxx::tree::sequence< copyright_type > copyright_sequence;
    typedef copyright_sequence::iterator copyright_iterator;
    typedef copyright_sequence::const_iterator copyright_const_iterator;
    typedef ::xsd::cxx::tree::traits< copyright_type, char > copyright_traits;

    const copyright_sequence&
    copyright () const;

    copyright_sequence&
    copyright ();

    void
    copyright (const copyright_sequence& s);

    // embargo
    //
    typedef ::XMLSchema::EmbargoInformation embargo_type;
    typedef ::xsd::cxx::tree::sequence< embargo_type > embargo_sequence;
    typedef embargo_sequence::iterator embargo_iterator;
    typedef embargo_sequence::const_iterator embargo_const_iterator;
    typedef ::xsd::cxx::tree::traits< embargo_type, char > embargo_traits;

    const embargo_sequence&
    embargo () const;

    embargo_sequence&
    embargo ();

    void
    embargo (const embargo_sequence& s);

    // license
    //
    typedef ::XMLSchema::LicenseInformation license_type;
    typedef ::xsd::cxx::tree::sequence< license_type > license_sequence;
    typedef license_sequence::iterator license_iterator;
    typedef license_sequence::const_iterator license_const_iterator;
    typedef ::xsd::cxx::tree::traits< license_type, char > license_traits;

    const license_sequence&
    license () const;

    license_sequence&
    license ();

    void
    license (const license_sequence& s);

    // rights
    //
    typedef ::XMLSchema::InternationalString rights_type;
    typedef ::xsd::cxx::tree::sequence< rights_type > rights_sequence;
    typedef rights_sequence::iterator rights_iterator;
    typedef rights_sequence::const_iterator rights_const_iterator;
    typedef ::xsd::cxx::tree::traits< rights_type, char > rights_traits;

    const rights_sequence&
    rights () const;

    rights_sequence&
    rights ();

    void
    rights (const rights_sequence& s);

    // Constructors.
    //
    AccessInformation ();

    AccessInformation (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    AccessInformation (const AccessInformation& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual AccessInformation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AccessInformation&
    operator= (const AccessInformation& x);

    virtual 
    ~AccessInformation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    copyright_sequence copyright_;
    embargo_sequence embargo_;
    license_sequence license_;
    rights_sequence rights_;
  };

  class AccessLocation: public ::xml_schema::type
  {
    public:
    // mimeType
    //
    typedef ::XMLSchema::ControlledVocabularyEntry mimeType_type;
    typedef ::xsd::cxx::tree::optional< mimeType_type > mimeType_optional;
    typedef ::xsd::cxx::tree::traits< mimeType_type, char > mimeType_traits;

    const mimeType_optional&
    mimeType () const;

    mimeType_optional&
    mimeType ();

    void
    mimeType (const mimeType_type& x);

    void
    mimeType (const mimeType_optional& x);

    void
    mimeType (::std::unique_ptr< mimeType_type > p);

    // physicalLocation
    //
    typedef ::XMLSchema::InternationalString physicalLocation_type;
    typedef ::xsd::cxx::tree::sequence< physicalLocation_type > physicalLocation_sequence;
    typedef physicalLocation_sequence::iterator physicalLocation_iterator;
    typedef physicalLocation_sequence::const_iterator physicalLocation_const_iterator;
    typedef ::xsd::cxx::tree::traits< physicalLocation_type, char > physicalLocation_traits;

    const physicalLocation_sequence&
    physicalLocation () const;

    physicalLocation_sequence&
    physicalLocation ();

    void
    physicalLocation (const physicalLocation_sequence& s);

    // uri
    //
    typedef ::xml_schema::uri uri_type;
    typedef ::xsd::cxx::tree::sequence< uri_type > uri_sequence;
    typedef uri_sequence::iterator uri_iterator;
    typedef uri_sequence::const_iterator uri_const_iterator;
    typedef ::xsd::cxx::tree::traits< uri_type, char > uri_traits;

    const uri_sequence&
    uri () const;

    uri_sequence&
    uri ();

    void
    uri (const uri_sequence& s);

    // Constructors.
    //
    AccessLocation ();

    AccessLocation (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    AccessLocation (const AccessLocation& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual AccessLocation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AccessLocation&
    operator= (const AccessLocation& x);

    virtual 
    ~AccessLocation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    mimeType_optional mimeType_;
    physicalLocation_sequence physicalLocation_;
    uri_sequence uri_;
  };

  class Address: public ::xml_schema::type
  {
    public:
    // cityPlaceLocal
    //
    typedef ::xml_schema::string cityPlaceLocal_type;
    typedef ::xsd::cxx::tree::optional< cityPlaceLocal_type > cityPlaceLocal_optional;
    typedef ::xsd::cxx::tree::traits< cityPlaceLocal_type, char > cityPlaceLocal_traits;

    const cityPlaceLocal_optional&
    cityPlaceLocal () const;

    cityPlaceLocal_optional&
    cityPlaceLocal ();

    void
    cityPlaceLocal (const cityPlaceLocal_type& x);

    void
    cityPlaceLocal (const cityPlaceLocal_optional& x);

    void
    cityPlaceLocal (::std::unique_ptr< cityPlaceLocal_type > p);

    // countryCode
    //
    typedef ::XMLSchema::ControlledVocabularyEntry countryCode_type;
    typedef ::xsd::cxx::tree::optional< countryCode_type > countryCode_optional;
    typedef ::xsd::cxx::tree::traits< countryCode_type, char > countryCode_traits;

    const countryCode_optional&
    countryCode () const;

    countryCode_optional&
    countryCode ();

    void
    countryCode (const countryCode_type& x);

    void
    countryCode (const countryCode_optional& x);

    void
    countryCode (::std::unique_ptr< countryCode_type > p);

    // effectiveDates
    //
    typedef ::XMLSchema::DateRange effectiveDates_type;
    typedef ::xsd::cxx::tree::optional< effectiveDates_type > effectiveDates_optional;
    typedef ::xsd::cxx::tree::traits< effectiveDates_type, char > effectiveDates_traits;

    const effectiveDates_optional&
    effectiveDates () const;

    effectiveDates_optional&
    effectiveDates ();

    void
    effectiveDates (const effectiveDates_type& x);

    void
    effectiveDates (const effectiveDates_optional& x);

    void
    effectiveDates (::std::unique_ptr< effectiveDates_type > p);

    // geographicPoint
    //
    typedef ::XMLSchema::SpatialPoint geographicPoint_type;
    typedef ::xsd::cxx::tree::optional< geographicPoint_type > geographicPoint_optional;
    typedef ::xsd::cxx::tree::traits< geographicPoint_type, char > geographicPoint_traits;

    const geographicPoint_optional&
    geographicPoint () const;

    geographicPoint_optional&
    geographicPoint ();

    void
    geographicPoint (const geographicPoint_type& x);

    void
    geographicPoint (const geographicPoint_optional& x);

    void
    geographicPoint (::std::unique_ptr< geographicPoint_type > p);

    // isPreferred
    //
    typedef ::xml_schema::boolean isPreferred_type;
    typedef ::xsd::cxx::tree::optional< isPreferred_type > isPreferred_optional;
    typedef ::xsd::cxx::tree::traits< isPreferred_type, char > isPreferred_traits;

    const isPreferred_optional&
    isPreferred () const;

    isPreferred_optional&
    isPreferred ();

    void
    isPreferred (const isPreferred_type& x);

    void
    isPreferred (const isPreferred_optional& x);

    // line
    //
    typedef ::xml_schema::string line_type;
    typedef ::xsd::cxx::tree::sequence< line_type > line_sequence;
    typedef line_sequence::iterator line_iterator;
    typedef line_sequence::const_iterator line_const_iterator;
    typedef ::xsd::cxx::tree::traits< line_type, char > line_traits;

    const line_sequence&
    line () const;

    line_sequence&
    line ();

    void
    line (const line_sequence& s);

    // locationName
    //
    typedef ::XMLSchema::ObjectName locationName_type;
    typedef ::xsd::cxx::tree::optional< locationName_type > locationName_optional;
    typedef ::xsd::cxx::tree::traits< locationName_type, char > locationName_traits;

    const locationName_optional&
    locationName () const;

    locationName_optional&
    locationName ();

    void
    locationName (const locationName_type& x);

    void
    locationName (const locationName_optional& x);

    void
    locationName (::std::unique_ptr< locationName_type > p);

    // postalCode
    //
    typedef ::xml_schema::string postalCode_type;
    typedef ::xsd::cxx::tree::optional< postalCode_type > postalCode_optional;
    typedef ::xsd::cxx::tree::traits< postalCode_type, char > postalCode_traits;

    const postalCode_optional&
    postalCode () const;

    postalCode_optional&
    postalCode ();

    void
    postalCode (const postalCode_type& x);

    void
    postalCode (const postalCode_optional& x);

    void
    postalCode (::std::unique_ptr< postalCode_type > p);

    // privacy
    //
    typedef ::XMLSchema::ControlledVocabularyEntry privacy_type;
    typedef ::xsd::cxx::tree::optional< privacy_type > privacy_optional;
    typedef ::xsd::cxx::tree::traits< privacy_type, char > privacy_traits;

    const privacy_optional&
    privacy () const;

    privacy_optional&
    privacy ();

    void
    privacy (const privacy_type& x);

    void
    privacy (const privacy_optional& x);

    void
    privacy (::std::unique_ptr< privacy_type > p);

    // regionalCoverage
    //
    typedef ::XMLSchema::ControlledVocabularyEntry regionalCoverage_type;
    typedef ::xsd::cxx::tree::optional< regionalCoverage_type > regionalCoverage_optional;
    typedef ::xsd::cxx::tree::traits< regionalCoverage_type, char > regionalCoverage_traits;

    const regionalCoverage_optional&
    regionalCoverage () const;

    regionalCoverage_optional&
    regionalCoverage ();

    void
    regionalCoverage (const regionalCoverage_type& x);

    void
    regionalCoverage (const regionalCoverage_optional& x);

    void
    regionalCoverage (::std::unique_ptr< regionalCoverage_type > p);

    // stateProvince
    //
    typedef ::xml_schema::string stateProvince_type;
    typedef ::xsd::cxx::tree::optional< stateProvince_type > stateProvince_optional;
    typedef ::xsd::cxx::tree::traits< stateProvince_type, char > stateProvince_traits;

    const stateProvince_optional&
    stateProvince () const;

    stateProvince_optional&
    stateProvince ();

    void
    stateProvince (const stateProvince_type& x);

    void
    stateProvince (const stateProvince_optional& x);

    void
    stateProvince (::std::unique_ptr< stateProvince_type > p);

    // timeZone
    //
    typedef ::XMLSchema::ControlledVocabularyEntry timeZone_type;
    typedef ::xsd::cxx::tree::optional< timeZone_type > timeZone_optional;
    typedef ::xsd::cxx::tree::traits< timeZone_type, char > timeZone_traits;

    const timeZone_optional&
    timeZone () const;

    timeZone_optional&
    timeZone ();

    void
    timeZone (const timeZone_type& x);

    void
    timeZone (const timeZone_optional& x);

    void
    timeZone (::std::unique_ptr< timeZone_type > p);

    // typeOfAddress
    //
    typedef ::XMLSchema::ControlledVocabularyEntry typeOfAddress_type;
    typedef ::xsd::cxx::tree::optional< typeOfAddress_type > typeOfAddress_optional;
    typedef ::xsd::cxx::tree::traits< typeOfAddress_type, char > typeOfAddress_traits;

    const typeOfAddress_optional&
    typeOfAddress () const;

    typeOfAddress_optional&
    typeOfAddress ();

    void
    typeOfAddress (const typeOfAddress_type& x);

    void
    typeOfAddress (const typeOfAddress_optional& x);

    void
    typeOfAddress (::std::unique_ptr< typeOfAddress_type > p);

    // typeOfLocation
    //
    typedef ::XMLSchema::ControlledVocabularyEntry typeOfLocation_type;
    typedef ::xsd::cxx::tree::optional< typeOfLocation_type > typeOfLocation_optional;
    typedef ::xsd::cxx::tree::traits< typeOfLocation_type, char > typeOfLocation_traits;

    const typeOfLocation_optional&
    typeOfLocation () const;

    typeOfLocation_optional&
    typeOfLocation ();

    void
    typeOfLocation (const typeOfLocation_type& x);

    void
    typeOfLocation (const typeOfLocation_optional& x);

    void
    typeOfLocation (::std::unique_ptr< typeOfLocation_type > p);

    // Constructors.
    //
    Address ();

    Address (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Address (const Address& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual Address*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Address&
    operator= (const Address& x);

    virtual 
    ~Address ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    cityPlaceLocal_optional cityPlaceLocal_;
    countryCode_optional countryCode_;
    effectiveDates_optional effectiveDates_;
    geographicPoint_optional geographicPoint_;
    isPreferred_optional isPreferred_;
    line_sequence line_;
    locationName_optional locationName_;
    postalCode_optional postalCode_;
    privacy_optional privacy_;
    regionalCoverage_optional regionalCoverage_;
    stateProvince_optional stateProvince_;
    timeZone_optional timeZone_;
    typeOfAddress_optional typeOfAddress_;
    typeOfLocation_optional typeOfLocation_;
  };

  class AgentInRole: public ::xml_schema::type
  {
    public:
    // agentName
    //
    typedef ::XMLSchema::BibliographicName agentName_type;
    typedef ::xsd::cxx::tree::optional< agentName_type > agentName_optional;
    typedef ::xsd::cxx::tree::traits< agentName_type, char > agentName_traits;

    const agentName_optional&
    agentName () const;

    agentName_optional&
    agentName ();

    void
    agentName (const agentName_type& x);

    void
    agentName (const agentName_optional& x);

    void
    agentName (::std::unique_ptr< agentName_type > p);

    // reference
    //
    typedef ::XMLSchema::reference reference_type;
    typedef ::xsd::cxx::tree::optional< reference_type > reference_optional;
    typedef ::xsd::cxx::tree::traits< reference_type, char > reference_traits;

    const reference_optional&
    reference () const;

    reference_optional&
    reference ();

    void
    reference (const reference_type& x);

    void
    reference (const reference_optional& x);

    void
    reference (::std::unique_ptr< reference_type > p);

    // role
    //
    typedef ::XMLSchema::PairedControlledVocabularyEntry role_type;
    typedef ::xsd::cxx::tree::sequence< role_type > role_sequence;
    typedef role_sequence::iterator role_iterator;
    typedef role_sequence::const_iterator role_const_iterator;
    typedef ::xsd::cxx::tree::traits< role_type, char > role_traits;

    const role_sequence&
    role () const;

    role_sequence&
    role ();

    void
    role (const role_sequence& s);

    // Constructors.
    //
    AgentInRole ();

    AgentInRole (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    AgentInRole (const AgentInRole& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual AgentInRole*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AgentInRole&
    operator= (const AgentInRole& x);

    virtual 
    ~AgentInRole ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    agentName_optional agentName_;
    reference_optional reference_;
    role_sequence role_;
  };

  class InternationalString: public ::xml_schema::type
  {
    public:
    // languageSpecificString
    //
    typedef ::XMLSchema::LanguageString languageSpecificString_type;
    typedef ::xsd::cxx::tree::sequence< languageSpecificString_type > languageSpecificString_sequence;
    typedef languageSpecificString_sequence::iterator languageSpecificString_iterator;
    typedef languageSpecificString_sequence::const_iterator languageSpecificString_const_iterator;
    typedef ::xsd::cxx::tree::traits< languageSpecificString_type, char > languageSpecificString_traits;

    const languageSpecificString_sequence&
    languageSpecificString () const;

    languageSpecificString_sequence&
    languageSpecificString ();

    void
    languageSpecificString (const languageSpecificString_sequence& s);

    // Constructors.
    //
    InternationalString ();

    InternationalString (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    InternationalString (const InternationalString& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual InternationalString*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InternationalString&
    operator= (const InternationalString& x);

    virtual 
    ~InternationalString ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    languageSpecificString_sequence languageSpecificString_;
  };

  class BibliographicName: public ::XMLSchema::InternationalString
  {
    public:
    // affiliation
    //
    typedef ::xml_schema::string affiliation_type;
    typedef ::xsd::cxx::tree::optional< affiliation_type > affiliation_optional;
    typedef ::xsd::cxx::tree::traits< affiliation_type, char > affiliation_traits;

    const affiliation_optional&
    affiliation () const;

    affiliation_optional&
    affiliation ();

    void
    affiliation (const affiliation_type& x);

    void
    affiliation (const affiliation_optional& x);

    void
    affiliation (::std::unique_ptr< affiliation_type > p);

    // Constructors.
    //
    BibliographicName ();

    BibliographicName (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    BibliographicName (const BibliographicName& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual BibliographicName*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    BibliographicName&
    operator= (const BibliographicName& x);

    virtual 
    ~BibliographicName ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    affiliation_optional affiliation_;
  };

  class CatalogDetails: public ::xml_schema::type
  {
    public:
    // access
    //
    typedef ::XMLSchema::AccessInformation access_type;
    typedef ::xsd::cxx::tree::sequence< access_type > access_sequence;
    typedef access_sequence::iterator access_iterator;
    typedef access_sequence::const_iterator access_const_iterator;
    typedef ::xsd::cxx::tree::traits< access_type, char > access_traits;

    const access_sequence&
    access () const;

    access_sequence&
    access ();

    void
    access (const access_sequence& s);

    // alternativeTitle
    //
    typedef ::XMLSchema::InternationalString alternativeTitle_type;
    typedef ::xsd::cxx::tree::sequence< alternativeTitle_type > alternativeTitle_sequence;
    typedef alternativeTitle_sequence::iterator alternativeTitle_iterator;
    typedef alternativeTitle_sequence::const_iterator alternativeTitle_const_iterator;
    typedef ::xsd::cxx::tree::traits< alternativeTitle_type, char > alternativeTitle_traits;

    const alternativeTitle_sequence&
    alternativeTitle () const;

    alternativeTitle_sequence&
    alternativeTitle ();

    void
    alternativeTitle (const alternativeTitle_sequence& s);

    // contributor
    //
    typedef ::XMLSchema::AgentInRole contributor_type;
    typedef ::xsd::cxx::tree::sequence< contributor_type > contributor_sequence;
    typedef contributor_sequence::iterator contributor_iterator;
    typedef contributor_sequence::const_iterator contributor_const_iterator;
    typedef ::xsd::cxx::tree::traits< contributor_type, char > contributor_traits;

    const contributor_sequence&
    contributor () const;

    contributor_sequence&
    contributor ();

    void
    contributor (const contributor_sequence& s);

    // creator
    //
    typedef ::XMLSchema::AgentInRole creator_type;
    typedef ::xsd::cxx::tree::sequence< creator_type > creator_sequence;
    typedef creator_sequence::iterator creator_iterator;
    typedef creator_sequence::const_iterator creator_const_iterator;
    typedef ::xsd::cxx::tree::traits< creator_type, char > creator_traits;

    const creator_sequence&
    creator () const;

    creator_sequence&
    creator ();

    void
    creator (const creator_sequence& s);

    // date
    //
    typedef ::XMLSchema::CombinedDate date_type;
    typedef ::xsd::cxx::tree::sequence< date_type > date_sequence;
    typedef date_sequence::iterator date_iterator;
    typedef date_sequence::const_iterator date_const_iterator;
    typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

    const date_sequence&
    date () const;

    date_sequence&
    date ();

    void
    date (const date_sequence& s);

    // identifier
    //
    typedef ::XMLSchema::InternationalIdentifier identifier_type;
    typedef ::xsd::cxx::tree::optional< identifier_type > identifier_optional;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_optional&
    identifier () const;

    identifier_optional&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (const identifier_optional& x);

    void
    identifier (::std::unique_ptr< identifier_type > p);

    // informationSource
    //
    typedef ::XMLSchema::InternationalString informationSource_type;
    typedef ::xsd::cxx::tree::sequence< informationSource_type > informationSource_sequence;
    typedef informationSource_sequence::iterator informationSource_iterator;
    typedef informationSource_sequence::const_iterator informationSource_const_iterator;
    typedef ::xsd::cxx::tree::traits< informationSource_type, char > informationSource_traits;

    const informationSource_sequence&
    informationSource () const;

    informationSource_sequence&
    informationSource ();

    void
    informationSource (const informationSource_sequence& s);

    // languageOfObject
    //
    typedef ::xml_schema::language languageOfObject_type;
    typedef ::xsd::cxx::tree::sequence< languageOfObject_type > languageOfObject_sequence;
    typedef languageOfObject_sequence::iterator languageOfObject_iterator;
    typedef languageOfObject_sequence::const_iterator languageOfObject_const_iterator;
    typedef ::xsd::cxx::tree::traits< languageOfObject_type, char > languageOfObject_traits;

    const languageOfObject_sequence&
    languageOfObject () const;

    languageOfObject_sequence&
    languageOfObject ();

    void
    languageOfObject (const languageOfObject_sequence& s);

    // provenance
    //
    typedef ::XMLSchema::ProvenanceInformation provenance_type;
    typedef ::xsd::cxx::tree::optional< provenance_type > provenance_optional;
    typedef ::xsd::cxx::tree::traits< provenance_type, char > provenance_traits;

    const provenance_optional&
    provenance () const;

    provenance_optional&
    provenance ();

    void
    provenance (const provenance_type& x);

    void
    provenance (const provenance_optional& x);

    void
    provenance (::std::unique_ptr< provenance_type > p);

    // publisher
    //
    typedef ::XMLSchema::AgentInRole publisher_type;
    typedef ::xsd::cxx::tree::sequence< publisher_type > publisher_sequence;
    typedef publisher_sequence::iterator publisher_iterator;
    typedef publisher_sequence::const_iterator publisher_const_iterator;
    typedef ::xsd::cxx::tree::traits< publisher_type, char > publisher_traits;

    const publisher_sequence&
    publisher () const;

    publisher_sequence&
    publisher ();

    void
    publisher (const publisher_sequence& s);

    // relatedResource
    //
    typedef ::XMLSchema::relatedResource relatedResource_type;
    typedef ::xsd::cxx::tree::sequence< relatedResource_type > relatedResource_sequence;
    typedef relatedResource_sequence::iterator relatedResource_iterator;
    typedef relatedResource_sequence::const_iterator relatedResource_const_iterator;
    typedef ::xsd::cxx::tree::traits< relatedResource_type, char > relatedResource_traits;

    const relatedResource_sequence&
    relatedResource () const;

    relatedResource_sequence&
    relatedResource ();

    void
    relatedResource (const relatedResource_sequence& s);

    // subTitle
    //
    typedef ::XMLSchema::InternationalString subTitle_type;
    typedef ::xsd::cxx::tree::sequence< subTitle_type > subTitle_sequence;
    typedef subTitle_sequence::iterator subTitle_iterator;
    typedef subTitle_sequence::const_iterator subTitle_const_iterator;
    typedef ::xsd::cxx::tree::traits< subTitle_type, char > subTitle_traits;

    const subTitle_sequence&
    subTitle () const;

    subTitle_sequence&
    subTitle ();

    void
    subTitle (const subTitle_sequence& s);

    // summary
    //
    typedef ::XMLSchema::InternationalString summary_type;
    typedef ::xsd::cxx::tree::optional< summary_type > summary_optional;
    typedef ::xsd::cxx::tree::traits< summary_type, char > summary_traits;

    const summary_optional&
    summary () const;

    summary_optional&
    summary ();

    void
    summary (const summary_type& x);

    void
    summary (const summary_optional& x);

    void
    summary (::std::unique_ptr< summary_type > p);

    // title
    //
    typedef ::XMLSchema::InternationalString title_type;
    typedef ::xsd::cxx::tree::optional< title_type > title_optional;
    typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

    const title_optional&
    title () const;

    title_optional&
    title ();

    void
    title (const title_type& x);

    void
    title (const title_optional& x);

    void
    title (::std::unique_ptr< title_type > p);

    // typeOfResource
    //
    typedef ::XMLSchema::ControlledVocabularyEntry typeOfResource_type;
    typedef ::xsd::cxx::tree::sequence< typeOfResource_type > typeOfResource_sequence;
    typedef typeOfResource_sequence::iterator typeOfResource_iterator;
    typedef typeOfResource_sequence::const_iterator typeOfResource_const_iterator;
    typedef ::xsd::cxx::tree::traits< typeOfResource_type, char > typeOfResource_traits;

    const typeOfResource_sequence&
    typeOfResource () const;

    typeOfResource_sequence&
    typeOfResource ();

    void
    typeOfResource (const typeOfResource_sequence& s);

    // Constructors.
    //
    CatalogDetails ();

    CatalogDetails (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    CatalogDetails (const CatalogDetails& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual CatalogDetails*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CatalogDetails&
    operator= (const CatalogDetails& x);

    virtual 
    ~CatalogDetails ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    access_sequence access_;
    alternativeTitle_sequence alternativeTitle_;
    contributor_sequence contributor_;
    creator_sequence creator_;
    date_sequence date_;
    identifier_optional identifier_;
    informationSource_sequence informationSource_;
    languageOfObject_sequence languageOfObject_;
    provenance_optional provenance_;
    publisher_sequence publisher_;
    relatedResource_sequence relatedResource_;
    subTitle_sequence subTitle_;
    summary_optional summary_;
    title_optional title_;
    typeOfResource_sequence typeOfResource_;
  };

  class CombinedDate: public ::xml_schema::type
  {
    public:
    // isoDate
    //
    typedef ::xml_schema::date isoDate_type;
    typedef ::xsd::cxx::tree::optional< isoDate_type > isoDate_optional;
    typedef ::xsd::cxx::tree::traits< isoDate_type, char > isoDate_traits;

    const isoDate_optional&
    isoDate () const;

    isoDate_optional&
    isoDate ();

    void
    isoDate (const isoDate_type& x);

    void
    isoDate (const isoDate_optional& x);

    void
    isoDate (::std::unique_ptr< isoDate_type > p);

    // nonIsoDate
    //
    typedef ::XMLSchema::NonIsoDate nonIsoDate_type;
    typedef ::xsd::cxx::tree::sequence< nonIsoDate_type > nonIsoDate_sequence;
    typedef nonIsoDate_sequence::iterator nonIsoDate_iterator;
    typedef nonIsoDate_sequence::const_iterator nonIsoDate_const_iterator;
    typedef ::xsd::cxx::tree::traits< nonIsoDate_type, char > nonIsoDate_traits;

    const nonIsoDate_sequence&
    nonIsoDate () const;

    nonIsoDate_sequence&
    nonIsoDate ();

    void
    nonIsoDate (const nonIsoDate_sequence& s);

    // semantics
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantics_type;
    typedef ::xsd::cxx::tree::optional< semantics_type > semantics_optional;
    typedef ::xsd::cxx::tree::traits< semantics_type, char > semantics_traits;

    const semantics_optional&
    semantics () const;

    semantics_optional&
    semantics ();

    void
    semantics (const semantics_type& x);

    void
    semantics (const semantics_optional& x);

    void
    semantics (::std::unique_ptr< semantics_type > p);

    // Constructors.
    //
    CombinedDate ();

    CombinedDate (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    CombinedDate (const CombinedDate& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual CombinedDate*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CombinedDate&
    operator= (const CombinedDate& x);

    virtual 
    ~CombinedDate ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    isoDate_optional isoDate_;
    nonIsoDate_sequence nonIsoDate_;
    semantics_optional semantics_;
  };

  class Command: public ::xml_schema::type
  {
    public:
    // commandContent
    //
    typedef ::XMLSchema::TypedString commandContent_type;
    typedef ::xsd::cxx::tree::optional< commandContent_type > commandContent_optional;
    typedef ::xsd::cxx::tree::traits< commandContent_type, char > commandContent_traits;

    const commandContent_optional&
    commandContent () const;

    commandContent_optional&
    commandContent ();

    void
    commandContent (const commandContent_type& x);

    void
    commandContent (const commandContent_optional& x);

    void
    commandContent (::std::unique_ptr< commandContent_type > p);

    // programLanguage
    //
    typedef ::XMLSchema::ControlledVocabularyEntry programLanguage_type;
    typedef ::xsd::cxx::tree::optional< programLanguage_type > programLanguage_optional;
    typedef ::xsd::cxx::tree::traits< programLanguage_type, char > programLanguage_traits;

    const programLanguage_optional&
    programLanguage () const;

    programLanguage_optional&
    programLanguage ();

    void
    programLanguage (const programLanguage_type& x);

    void
    programLanguage (const programLanguage_optional& x);

    void
    programLanguage (::std::unique_ptr< programLanguage_type > p);

    // Constructors.
    //
    Command ();

    Command (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Command (const Command& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual Command*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Command&
    operator= (const Command& x);

    virtual 
    ~Command ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    commandContent_optional commandContent_;
    programLanguage_optional programLanguage_;
  };

  class CommandCode: public ::xml_schema::type
  {
    public:
    // command
    //
    typedef ::XMLSchema::Command command_type;
    typedef ::xsd::cxx::tree::sequence< command_type > command_sequence;
    typedef command_sequence::iterator command_iterator;
    typedef command_sequence::const_iterator command_const_iterator;
    typedef ::xsd::cxx::tree::traits< command_type, char > command_traits;

    const command_sequence&
    command () const;

    command_sequence&
    command ();

    void
    command (const command_sequence& s);

    // commandFile
    //
    typedef ::XMLSchema::CommandFile commandFile_type;
    typedef ::xsd::cxx::tree::sequence< commandFile_type > commandFile_sequence;
    typedef commandFile_sequence::iterator commandFile_iterator;
    typedef commandFile_sequence::const_iterator commandFile_const_iterator;
    typedef ::xsd::cxx::tree::traits< commandFile_type, char > commandFile_traits;

    const commandFile_sequence&
    commandFile () const;

    commandFile_sequence&
    commandFile ();

    void
    commandFile (const commandFile_sequence& s);

    // description
    //
    typedef ::XMLSchema::InternationalString description_type;
    typedef ::xsd::cxx::tree::optional< description_type > description_optional;
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    const description_optional&
    description () const;

    description_optional&
    description ();

    void
    description (const description_type& x);

    void
    description (const description_optional& x);

    void
    description (::std::unique_ptr< description_type > p);

    // Constructors.
    //
    CommandCode ();

    CommandCode (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    CommandCode (const CommandCode& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual CommandCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CommandCode&
    operator= (const CommandCode& x);

    virtual 
    ~CommandCode ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    command_sequence command_;
    commandFile_sequence commandFile_;
    description_optional description_;
  };

  class CommandFile: public ::xml_schema::type
  {
    public:
    // location
    //
    typedef ::XMLSchema::InternationalString location_type;
    typedef ::xsd::cxx::tree::optional< location_type > location_optional;
    typedef ::xsd::cxx::tree::traits< location_type, char > location_traits;

    const location_optional&
    location () const;

    location_optional&
    location ();

    void
    location (const location_type& x);

    void
    location (const location_optional& x);

    void
    location (::std::unique_ptr< location_type > p);

    // uri
    //
    typedef ::xml_schema::uri uri_type;
    typedef ::xsd::cxx::tree::optional< uri_type > uri_optional;
    typedef ::xsd::cxx::tree::traits< uri_type, char > uri_traits;

    const uri_optional&
    uri () const;

    uri_optional&
    uri ();

    void
    uri (const uri_type& x);

    void
    uri (const uri_optional& x);

    void
    uri (::std::unique_ptr< uri_type > p);

    // Constructors.
    //
    CommandFile ();

    CommandFile (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    CommandFile (const CommandFile& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual CommandFile*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CommandFile&
    operator= (const CommandFile& x);

    virtual 
    ~CommandFile ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    location_optional location_;
    uri_optional uri_;
  };

  class ContactInformation: public ::xml_schema::type
  {
    public:
    // address
    //
    typedef ::XMLSchema::Address address_type;
    typedef ::xsd::cxx::tree::sequence< address_type > address_sequence;
    typedef address_sequence::iterator address_iterator;
    typedef address_sequence::const_iterator address_const_iterator;
    typedef ::xsd::cxx::tree::traits< address_type, char > address_traits;

    const address_sequence&
    address () const;

    address_sequence&
    address ();

    void
    address (const address_sequence& s);

    // email
    //
    typedef ::XMLSchema::Email email_type;
    typedef ::xsd::cxx::tree::sequence< email_type > email_sequence;
    typedef email_sequence::iterator email_iterator;
    typedef email_sequence::const_iterator email_const_iterator;
    typedef ::xsd::cxx::tree::traits< email_type, char > email_traits;

    const email_sequence&
    email () const;

    email_sequence&
    email ();

    void
    email (const email_sequence& s);

    // emessaging
    //
    typedef ::XMLSchema::ElectronicMessageSystem emessaging_type;
    typedef ::xsd::cxx::tree::sequence< emessaging_type > emessaging_sequence;
    typedef emessaging_sequence::iterator emessaging_iterator;
    typedef emessaging_sequence::const_iterator emessaging_const_iterator;
    typedef ::xsd::cxx::tree::traits< emessaging_type, char > emessaging_traits;

    const emessaging_sequence&
    emessaging () const;

    emessaging_sequence&
    emessaging ();

    void
    emessaging (const emessaging_sequence& s);

    // telephone
    //
    typedef ::XMLSchema::Telephone telephone_type;
    typedef ::xsd::cxx::tree::sequence< telephone_type > telephone_sequence;
    typedef telephone_sequence::iterator telephone_iterator;
    typedef telephone_sequence::const_iterator telephone_const_iterator;
    typedef ::xsd::cxx::tree::traits< telephone_type, char > telephone_traits;

    const telephone_sequence&
    telephone () const;

    telephone_sequence&
    telephone ();

    void
    telephone (const telephone_sequence& s);

    // website
    //
    typedef ::XMLSchema::WebLink website_type;
    typedef ::xsd::cxx::tree::sequence< website_type > website_sequence;
    typedef website_sequence::iterator website_iterator;
    typedef website_sequence::const_iterator website_const_iterator;
    typedef ::xsd::cxx::tree::traits< website_type, char > website_traits;

    const website_sequence&
    website () const;

    website_sequence&
    website ();

    void
    website (const website_sequence& s);

    // Constructors.
    //
    ContactInformation ();

    ContactInformation (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    ContactInformation (const ContactInformation& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual ContactInformation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ContactInformation&
    operator= (const ContactInformation& x);

    virtual 
    ~ContactInformation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    address_sequence address_;
    email_sequence email_;
    emessaging_sequence emessaging_;
    telephone_sequence telephone_;
    website_sequence website_;
  };

  class ControlledVocabularyEntry: public ::xml_schema::type
  {
    public:
    // entryReference
    //
    typedef ::XMLSchema::entryReference entryReference_type;
    typedef ::xsd::cxx::tree::sequence< entryReference_type > entryReference_sequence;
    typedef entryReference_sequence::iterator entryReference_iterator;
    typedef entryReference_sequence::const_iterator entryReference_const_iterator;
    typedef ::xsd::cxx::tree::traits< entryReference_type, char > entryReference_traits;

    const entryReference_sequence&
    entryReference () const;

    entryReference_sequence&
    entryReference ();

    void
    entryReference (const entryReference_sequence& s);

    // entryValue
    //
    typedef ::xml_schema::string entryValue_type;
    typedef ::xsd::cxx::tree::sequence< entryValue_type > entryValue_sequence;
    typedef entryValue_sequence::iterator entryValue_iterator;
    typedef entryValue_sequence::const_iterator entryValue_const_iterator;
    typedef ::xsd::cxx::tree::traits< entryValue_type, char > entryValue_traits;

    const entryValue_sequence&
    entryValue () const;

    entryValue_sequence&
    entryValue ();

    void
    entryValue (const entryValue_sequence& s);

    // name
    //
    typedef ::xml_schema::string name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::unique_ptr< name_type > p);

    // valueForOther
    //
    typedef ::xml_schema::string valueForOther_type;
    typedef ::xsd::cxx::tree::optional< valueForOther_type > valueForOther_optional;
    typedef ::xsd::cxx::tree::traits< valueForOther_type, char > valueForOther_traits;

    const valueForOther_optional&
    valueForOther () const;

    valueForOther_optional&
    valueForOther ();

    void
    valueForOther (const valueForOther_type& x);

    void
    valueForOther (const valueForOther_optional& x);

    void
    valueForOther (::std::unique_ptr< valueForOther_type > p);

    // vocabulary
    //
    typedef ::XMLSchema::vocabulary vocabulary_type;
    typedef ::xsd::cxx::tree::optional< vocabulary_type > vocabulary_optional;
    typedef ::xsd::cxx::tree::traits< vocabulary_type, char > vocabulary_traits;

    const vocabulary_optional&
    vocabulary () const;

    vocabulary_optional&
    vocabulary ();

    void
    vocabulary (const vocabulary_type& x);

    void
    vocabulary (const vocabulary_optional& x);

    void
    vocabulary (::std::unique_ptr< vocabulary_type > p);

    // Constructors.
    //
    ControlledVocabularyEntry ();

    ControlledVocabularyEntry (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ControlledVocabularyEntry (const ControlledVocabularyEntry& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual ControlledVocabularyEntry*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ControlledVocabularyEntry&
    operator= (const ControlledVocabularyEntry& x);

    virtual 
    ~ControlledVocabularyEntry ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    entryReference_sequence entryReference_;
    entryValue_sequence entryValue_;
    name_optional name_;
    valueForOther_optional valueForOther_;
    vocabulary_optional vocabulary_;
  };

  class CorrespondenceDefinition: public ::xml_schema::type
  {
    public:
    // commonality
    //
    typedef ::XMLSchema::InternationalString commonality_type;
    typedef ::xsd::cxx::tree::optional< commonality_type > commonality_optional;
    typedef ::xsd::cxx::tree::traits< commonality_type, char > commonality_traits;

    const commonality_optional&
    commonality () const;

    commonality_optional&
    commonality ();

    void
    commonality (const commonality_type& x);

    void
    commonality (const commonality_optional& x);

    void
    commonality (::std::unique_ptr< commonality_type > p);

    // commonalityCode
    //
    typedef ::XMLSchema::ControlledVocabularyEntry commonalityCode_type;
    typedef ::xsd::cxx::tree::sequence< commonalityCode_type > commonalityCode_sequence;
    typedef commonalityCode_sequence::iterator commonalityCode_iterator;
    typedef commonalityCode_sequence::const_iterator commonalityCode_const_iterator;
    typedef ::xsd::cxx::tree::traits< commonalityCode_type, char > commonalityCode_traits;

    const commonalityCode_sequence&
    commonalityCode () const;

    commonalityCode_sequence&
    commonalityCode ();

    void
    commonalityCode (const commonalityCode_sequence& s);

    // difference
    //
    typedef ::XMLSchema::InternationalString difference_type;
    typedef ::xsd::cxx::tree::optional< difference_type > difference_optional;
    typedef ::xsd::cxx::tree::traits< difference_type, char > difference_traits;

    const difference_optional&
    difference () const;

    difference_optional&
    difference ();

    void
    difference (const difference_type& x);

    void
    difference (const difference_optional& x);

    void
    difference (::std::unique_ptr< difference_type > p);

    // matching
    //
    typedef ::XMLSchema::MatchingCriterion matching_type;
    typedef ::xsd::cxx::tree::optional< matching_type > matching_optional;
    typedef ::xsd::cxx::tree::traits< matching_type, char > matching_traits;

    const matching_optional&
    matching () const;

    matching_optional&
    matching ();

    void
    matching (const matching_type& x);

    void
    matching (const matching_optional& x);

    void
    matching (::std::unique_ptr< matching_type > p);

    // Constructors.
    //
    CorrespondenceDefinition ();

    CorrespondenceDefinition (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    CorrespondenceDefinition (const CorrespondenceDefinition& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual CorrespondenceDefinition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CorrespondenceDefinition&
    operator= (const CorrespondenceDefinition& x);

    virtual 
    ~CorrespondenceDefinition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    commonality_optional commonality_;
    commonalityCode_sequence commonalityCode_;
    difference_optional difference_;
    matching_optional matching_;
  };

  class DateRange: public ::xml_schema::type
  {
    public:
    // endDate
    //
    typedef ::XMLSchema::CombinedDate endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::unique_ptr< endDate_type > p);

    // startDate
    //
    typedef ::XMLSchema::CombinedDate startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::unique_ptr< startDate_type > p);

    // Constructors.
    //
    DateRange ();

    DateRange (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    DateRange (const DateRange& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual DateRange*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DateRange&
    operator= (const DateRange& x);

    virtual 
    ~DateRange ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    endDate_optional endDate_;
    startDate_optional startDate_;
  };

  class ElectronicMessageSystem: public ::xml_schema::type
  {
    public:
    // contactAddress
    //
    typedef ::xml_schema::string contactAddress_type;
    typedef ::xsd::cxx::tree::optional< contactAddress_type > contactAddress_optional;
    typedef ::xsd::cxx::tree::traits< contactAddress_type, char > contactAddress_traits;

    const contactAddress_optional&
    contactAddress () const;

    contactAddress_optional&
    contactAddress ();

    void
    contactAddress (const contactAddress_type& x);

    void
    contactAddress (const contactAddress_optional& x);

    void
    contactAddress (::std::unique_ptr< contactAddress_type > p);

    // effectiveDates
    //
    typedef ::XMLSchema::DateRange effectiveDates_type;
    typedef ::xsd::cxx::tree::optional< effectiveDates_type > effectiveDates_optional;
    typedef ::xsd::cxx::tree::traits< effectiveDates_type, char > effectiveDates_traits;

    const effectiveDates_optional&
    effectiveDates () const;

    effectiveDates_optional&
    effectiveDates ();

    void
    effectiveDates (const effectiveDates_type& x);

    void
    effectiveDates (const effectiveDates_optional& x);

    void
    effectiveDates (::std::unique_ptr< effectiveDates_type > p);

    // isPreferred
    //
    typedef ::xml_schema::boolean isPreferred_type;
    typedef ::xsd::cxx::tree::optional< isPreferred_type > isPreferred_optional;
    typedef ::xsd::cxx::tree::traits< isPreferred_type, char > isPreferred_traits;

    const isPreferred_optional&
    isPreferred () const;

    isPreferred_optional&
    isPreferred ();

    void
    isPreferred (const isPreferred_type& x);

    void
    isPreferred (const isPreferred_optional& x);

    // privacy
    //
    typedef ::XMLSchema::ControlledVocabularyEntry privacy_type;
    typedef ::xsd::cxx::tree::optional< privacy_type > privacy_optional;
    typedef ::xsd::cxx::tree::traits< privacy_type, char > privacy_traits;

    const privacy_optional&
    privacy () const;

    privacy_optional&
    privacy ();

    void
    privacy (const privacy_type& x);

    void
    privacy (const privacy_optional& x);

    void
    privacy (::std::unique_ptr< privacy_type > p);

    // typeOfService
    //
    typedef ::XMLSchema::ControlledVocabularyEntry typeOfService_type;
    typedef ::xsd::cxx::tree::optional< typeOfService_type > typeOfService_optional;
    typedef ::xsd::cxx::tree::traits< typeOfService_type, char > typeOfService_traits;

    const typeOfService_optional&
    typeOfService () const;

    typeOfService_optional&
    typeOfService ();

    void
    typeOfService (const typeOfService_type& x);

    void
    typeOfService (const typeOfService_optional& x);

    void
    typeOfService (::std::unique_ptr< typeOfService_type > p);

    // Constructors.
    //
    ElectronicMessageSystem ();

    ElectronicMessageSystem (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ElectronicMessageSystem (const ElectronicMessageSystem& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual ElectronicMessageSystem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ElectronicMessageSystem&
    operator= (const ElectronicMessageSystem& x);

    virtual 
    ~ElectronicMessageSystem ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    contactAddress_optional contactAddress_;
    effectiveDates_optional effectiveDates_;
    isPreferred_optional isPreferred_;
    privacy_optional privacy_;
    typeOfService_optional typeOfService_;
  };

  class Email: public ::xml_schema::type
  {
    public:
    // effectiveDates
    //
    typedef ::XMLSchema::DateRange effectiveDates_type;
    typedef ::xsd::cxx::tree::optional< effectiveDates_type > effectiveDates_optional;
    typedef ::xsd::cxx::tree::traits< effectiveDates_type, char > effectiveDates_traits;

    const effectiveDates_optional&
    effectiveDates () const;

    effectiveDates_optional&
    effectiveDates ();

    void
    effectiveDates (const effectiveDates_type& x);

    void
    effectiveDates (const effectiveDates_optional& x);

    void
    effectiveDates (::std::unique_ptr< effectiveDates_type > p);

    // internetEmail
    //
    typedef ::xml_schema::string internetEmail_type;
    typedef ::xsd::cxx::tree::optional< internetEmail_type > internetEmail_optional;
    typedef ::xsd::cxx::tree::traits< internetEmail_type, char > internetEmail_traits;

    const internetEmail_optional&
    internetEmail () const;

    internetEmail_optional&
    internetEmail ();

    void
    internetEmail (const internetEmail_type& x);

    void
    internetEmail (const internetEmail_optional& x);

    void
    internetEmail (::std::unique_ptr< internetEmail_type > p);

    // isPreferred
    //
    typedef ::xml_schema::boolean isPreferred_type;
    typedef ::xsd::cxx::tree::optional< isPreferred_type > isPreferred_optional;
    typedef ::xsd::cxx::tree::traits< isPreferred_type, char > isPreferred_traits;

    const isPreferred_optional&
    isPreferred () const;

    isPreferred_optional&
    isPreferred ();

    void
    isPreferred (const isPreferred_type& x);

    void
    isPreferred (const isPreferred_optional& x);

    // privacy
    //
    typedef ::XMLSchema::ControlledVocabularyEntry privacy_type;
    typedef ::xsd::cxx::tree::optional< privacy_type > privacy_optional;
    typedef ::xsd::cxx::tree::traits< privacy_type, char > privacy_traits;

    const privacy_optional&
    privacy () const;

    privacy_optional&
    privacy ();

    void
    privacy (const privacy_type& x);

    void
    privacy (const privacy_optional& x);

    void
    privacy (::std::unique_ptr< privacy_type > p);

    // typeOfEmail
    //
    typedef ::XMLSchema::ControlledVocabularyEntry typeOfEmail_type;
    typedef ::xsd::cxx::tree::optional< typeOfEmail_type > typeOfEmail_optional;
    typedef ::xsd::cxx::tree::traits< typeOfEmail_type, char > typeOfEmail_traits;

    const typeOfEmail_optional&
    typeOfEmail () const;

    typeOfEmail_optional&
    typeOfEmail ();

    void
    typeOfEmail (const typeOfEmail_type& x);

    void
    typeOfEmail (const typeOfEmail_optional& x);

    void
    typeOfEmail (::std::unique_ptr< typeOfEmail_type > p);

    // Constructors.
    //
    Email ();

    Email (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Email (const Email& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Email*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Email&
    operator= (const Email& x);

    virtual 
    ~Email ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    effectiveDates_optional effectiveDates_;
    internetEmail_optional internetEmail_;
    isPreferred_optional isPreferred_;
    privacy_optional privacy_;
    typeOfEmail_optional typeOfEmail_;
  };

  class EmbargoInformation: public ::xml_schema::type
  {
    public:
    // description
    //
    typedef ::XMLSchema::InternationalString description_type;
    typedef ::xsd::cxx::tree::optional< description_type > description_optional;
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    const description_optional&
    description () const;

    description_optional&
    description ();

    void
    description (const description_type& x);

    void
    description (const description_optional& x);

    void
    description (::std::unique_ptr< description_type > p);

    // period
    //
    typedef ::XMLSchema::DateRange period_type;
    typedef ::xsd::cxx::tree::sequence< period_type > period_sequence;
    typedef period_sequence::iterator period_iterator;
    typedef period_sequence::const_iterator period_const_iterator;
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    const period_sequence&
    period () const;

    period_sequence&
    period ();

    void
    period (const period_sequence& s);

    // Constructors.
    //
    EmbargoInformation ();

    EmbargoInformation (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    EmbargoInformation (const EmbargoInformation& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual EmbargoInformation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    EmbargoInformation&
    operator= (const EmbargoInformation& x);

    virtual 
    ~EmbargoInformation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    description_optional description_;
    period_sequence period_;
  };

  class FundingInformation: public ::xml_schema::type
  {
    public:
    // fundingAgent
    //
    typedef ::XMLSchema::AgentInRole fundingAgent_type;
    typedef ::xsd::cxx::tree::sequence< fundingAgent_type > fundingAgent_sequence;
    typedef fundingAgent_sequence::iterator fundingAgent_iterator;
    typedef fundingAgent_sequence::const_iterator fundingAgent_const_iterator;
    typedef ::xsd::cxx::tree::traits< fundingAgent_type, char > fundingAgent_traits;

    const fundingAgent_sequence&
    fundingAgent () const;

    fundingAgent_sequence&
    fundingAgent ();

    void
    fundingAgent (const fundingAgent_sequence& s);

    // grantNumber
    //
    typedef ::xml_schema::string grantNumber_type;
    typedef ::xsd::cxx::tree::optional< grantNumber_type > grantNumber_optional;
    typedef ::xsd::cxx::tree::traits< grantNumber_type, char > grantNumber_traits;

    const grantNumber_optional&
    grantNumber () const;

    grantNumber_optional&
    grantNumber ();

    void
    grantNumber (const grantNumber_type& x);

    void
    grantNumber (const grantNumber_optional& x);

    void
    grantNumber (::std::unique_ptr< grantNumber_type > p);

    // Constructors.
    //
    FundingInformation ();

    FundingInformation (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    FundingInformation (const FundingInformation& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual FundingInformation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FundingInformation&
    operator= (const FundingInformation& x);

    virtual 
    ~FundingInformation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    fundingAgent_sequence fundingAgent_;
    grantNumber_optional grantNumber_;
  };

  class SpecializationRole: public ::xml_schema::type
  {
    public:
    // Constructors.
    //
    SpecializationRole ();

    SpecializationRole (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    SpecializationRole (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    SpecializationRole (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    SpecializationRole (const SpecializationRole& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual SpecializationRole*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    SpecializationRole&
    operator= (const SpecializationRole&) = default;
#endif

    virtual 
    ~SpecializationRole ();
  };

  class GeoRole: public ::XMLSchema::SpecializationRole
  {
    public:
    // geography
    //
    typedef ::XMLSchema::ControlledVocabularyEntry geography_type;
    typedef ::xsd::cxx::tree::optional< geography_type > geography_optional;
    typedef ::xsd::cxx::tree::traits< geography_type, char > geography_traits;

    const geography_optional&
    geography () const;

    geography_optional&
    geography ();

    void
    geography (const geography_type& x);

    void
    geography (const geography_optional& x);

    void
    geography (::std::unique_ptr< geography_type > p);

    // Constructors.
    //
    GeoRole ();

    GeoRole (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    GeoRole (const GeoRole& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual GeoRole*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GeoRole&
    operator= (const GeoRole& x);

    virtual 
    ~GeoRole ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    geography_optional geography_;
  };

  class Identifier: public ::xml_schema::type
  {
    public:
    // ddiIdentifier
    //
    typedef ::XMLSchema::InternationalRegistrationDataIdentifier ddiIdentifier_type;
    typedef ::xsd::cxx::tree::optional< ddiIdentifier_type > ddiIdentifier_optional;
    typedef ::xsd::cxx::tree::traits< ddiIdentifier_type, char > ddiIdentifier_traits;

    const ddiIdentifier_optional&
    ddiIdentifier () const;

    ddiIdentifier_optional&
    ddiIdentifier ();

    void
    ddiIdentifier (const ddiIdentifier_type& x);

    void
    ddiIdentifier (const ddiIdentifier_optional& x);

    void
    ddiIdentifier (::std::unique_ptr< ddiIdentifier_type > p);

    // isDdiIdentifierPersistent
    //
    typedef ::xml_schema::boolean isDdiIdentifierPersistent_type;
    typedef ::xsd::cxx::tree::optional< isDdiIdentifierPersistent_type > isDdiIdentifierPersistent_optional;
    typedef ::xsd::cxx::tree::traits< isDdiIdentifierPersistent_type, char > isDdiIdentifierPersistent_traits;

    const isDdiIdentifierPersistent_optional&
    isDdiIdentifierPersistent () const;

    isDdiIdentifierPersistent_optional&
    isDdiIdentifierPersistent ();

    void
    isDdiIdentifierPersistent (const isDdiIdentifierPersistent_type& x);

    void
    isDdiIdentifierPersistent (const isDdiIdentifierPersistent_optional& x);

    // isDdiIdentifierUniversallyUnique
    //
    typedef ::xml_schema::boolean isDdiIdentifierUniversallyUnique_type;
    typedef ::xsd::cxx::tree::optional< isDdiIdentifierUniversallyUnique_type > isDdiIdentifierUniversallyUnique_optional;
    typedef ::xsd::cxx::tree::traits< isDdiIdentifierUniversallyUnique_type, char > isDdiIdentifierUniversallyUnique_traits;

    const isDdiIdentifierUniversallyUnique_optional&
    isDdiIdentifierUniversallyUnique () const;

    isDdiIdentifierUniversallyUnique_optional&
    isDdiIdentifierUniversallyUnique ();

    void
    isDdiIdentifierUniversallyUnique (const isDdiIdentifierUniversallyUnique_type& x);

    void
    isDdiIdentifierUniversallyUnique (const isDdiIdentifierUniversallyUnique_optional& x);

    // nonDdiIdentifier
    //
    typedef ::XMLSchema::NonDdiIdentifier nonDdiIdentifier_type;
    typedef ::xsd::cxx::tree::sequence< nonDdiIdentifier_type > nonDdiIdentifier_sequence;
    typedef nonDdiIdentifier_sequence::iterator nonDdiIdentifier_iterator;
    typedef nonDdiIdentifier_sequence::const_iterator nonDdiIdentifier_const_iterator;
    typedef ::xsd::cxx::tree::traits< nonDdiIdentifier_type, char > nonDdiIdentifier_traits;

    const nonDdiIdentifier_sequence&
    nonDdiIdentifier () const;

    nonDdiIdentifier_sequence&
    nonDdiIdentifier ();

    void
    nonDdiIdentifier (const nonDdiIdentifier_sequence& s);

    // uri
    //
    typedef ::xml_schema::uri uri_type;
    typedef ::xsd::cxx::tree::optional< uri_type > uri_optional;
    typedef ::xsd::cxx::tree::traits< uri_type, char > uri_traits;

    const uri_optional&
    uri () const;

    uri_optional&
    uri ();

    void
    uri (const uri_type& x);

    void
    uri (const uri_optional& x);

    void
    uri (::std::unique_ptr< uri_type > p);

    // versionDate
    //
    typedef ::xml_schema::date versionDate_type;
    typedef ::xsd::cxx::tree::optional< versionDate_type > versionDate_optional;
    typedef ::xsd::cxx::tree::traits< versionDate_type, char > versionDate_traits;

    const versionDate_optional&
    versionDate () const;

    versionDate_optional&
    versionDate ();

    void
    versionDate (const versionDate_type& x);

    void
    versionDate (const versionDate_optional& x);

    void
    versionDate (::std::unique_ptr< versionDate_type > p);

    // versionRationale
    //
    typedef ::XMLSchema::RationaleDefinition versionRationale_type;
    typedef ::xsd::cxx::tree::optional< versionRationale_type > versionRationale_optional;
    typedef ::xsd::cxx::tree::traits< versionRationale_type, char > versionRationale_traits;

    const versionRationale_optional&
    versionRationale () const;

    versionRationale_optional&
    versionRationale ();

    void
    versionRationale (const versionRationale_type& x);

    void
    versionRationale (const versionRationale_optional& x);

    void
    versionRationale (::std::unique_ptr< versionRationale_type > p);

    // versionResponsibility
    //
    typedef ::XMLSchema::AgentInRole versionResponsibility_type;
    typedef ::xsd::cxx::tree::optional< versionResponsibility_type > versionResponsibility_optional;
    typedef ::xsd::cxx::tree::traits< versionResponsibility_type, char > versionResponsibility_traits;

    const versionResponsibility_optional&
    versionResponsibility () const;

    versionResponsibility_optional&
    versionResponsibility ();

    void
    versionResponsibility (const versionResponsibility_type& x);

    void
    versionResponsibility (const versionResponsibility_optional& x);

    void
    versionResponsibility (::std::unique_ptr< versionResponsibility_type > p);

    // Constructors.
    //
    Identifier ();

    Identifier (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    Identifier (const Identifier& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual Identifier*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Identifier&
    operator= (const Identifier& x);

    virtual 
    ~Identifier ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ddiIdentifier_optional ddiIdentifier_;
    isDdiIdentifierPersistent_optional isDdiIdentifierPersistent_;
    isDdiIdentifierUniversallyUnique_optional isDdiIdentifierUniversallyUnique_;
    nonDdiIdentifier_sequence nonDdiIdentifier_;
    uri_optional uri_;
    versionDate_optional versionDate_;
    versionRationale_optional versionRationale_;
    versionResponsibility_optional versionResponsibility_;
  };

  class IndividualName: public ::xml_schema::type
  {
    public:
    // abbreviation
    //
    typedef ::XMLSchema::InternationalString abbreviation_type;
    typedef ::xsd::cxx::tree::optional< abbreviation_type > abbreviation_optional;
    typedef ::xsd::cxx::tree::traits< abbreviation_type, char > abbreviation_traits;

    const abbreviation_optional&
    abbreviation () const;

    abbreviation_optional&
    abbreviation ();

    void
    abbreviation (const abbreviation_type& x);

    void
    abbreviation (const abbreviation_optional& x);

    void
    abbreviation (::std::unique_ptr< abbreviation_type > p);

    // context
    //
    typedef ::XMLSchema::ControlledVocabularyEntry context_type;
    typedef ::xsd::cxx::tree::optional< context_type > context_optional;
    typedef ::xsd::cxx::tree::traits< context_type, char > context_traits;

    const context_optional&
    context () const;

    context_optional&
    context ();

    void
    context (const context_type& x);

    void
    context (const context_optional& x);

    void
    context (::std::unique_ptr< context_type > p);

    // effectiveDates
    //
    typedef ::XMLSchema::DateRange effectiveDates_type;
    typedef ::xsd::cxx::tree::optional< effectiveDates_type > effectiveDates_optional;
    typedef ::xsd::cxx::tree::traits< effectiveDates_type, char > effectiveDates_traits;

    const effectiveDates_optional&
    effectiveDates () const;

    effectiveDates_optional&
    effectiveDates ();

    void
    effectiveDates (const effectiveDates_type& x);

    void
    effectiveDates (const effectiveDates_optional& x);

    void
    effectiveDates (::std::unique_ptr< effectiveDates_type > p);

    // firstGiven
    //
    typedef ::xml_schema::string firstGiven_type;
    typedef ::xsd::cxx::tree::optional< firstGiven_type > firstGiven_optional;
    typedef ::xsd::cxx::tree::traits< firstGiven_type, char > firstGiven_traits;

    const firstGiven_optional&
    firstGiven () const;

    firstGiven_optional&
    firstGiven ();

    void
    firstGiven (const firstGiven_type& x);

    void
    firstGiven (const firstGiven_optional& x);

    void
    firstGiven (::std::unique_ptr< firstGiven_type > p);

    // fullName
    //
    typedef ::XMLSchema::InternationalString fullName_type;
    typedef ::xsd::cxx::tree::optional< fullName_type > fullName_optional;
    typedef ::xsd::cxx::tree::traits< fullName_type, char > fullName_traits;

    const fullName_optional&
    fullName () const;

    fullName_optional&
    fullName ();

    void
    fullName (const fullName_type& x);

    void
    fullName (const fullName_optional& x);

    void
    fullName (::std::unique_ptr< fullName_type > p);

    // isFormal
    //
    typedef ::xml_schema::boolean isFormal_type;
    typedef ::xsd::cxx::tree::optional< isFormal_type > isFormal_optional;
    typedef ::xsd::cxx::tree::traits< isFormal_type, char > isFormal_traits;

    const isFormal_optional&
    isFormal () const;

    isFormal_optional&
    isFormal ();

    void
    isFormal (const isFormal_type& x);

    void
    isFormal (const isFormal_optional& x);

    // isPreferred
    //
    typedef ::xml_schema::boolean isPreferred_type;
    typedef ::xsd::cxx::tree::optional< isPreferred_type > isPreferred_optional;
    typedef ::xsd::cxx::tree::traits< isPreferred_type, char > isPreferred_traits;

    const isPreferred_optional&
    isPreferred () const;

    isPreferred_optional&
    isPreferred ();

    void
    isPreferred (const isPreferred_type& x);

    void
    isPreferred (const isPreferred_optional& x);

    // lastFamily
    //
    typedef ::xml_schema::string lastFamily_type;
    typedef ::xsd::cxx::tree::optional< lastFamily_type > lastFamily_optional;
    typedef ::xsd::cxx::tree::traits< lastFamily_type, char > lastFamily_traits;

    const lastFamily_optional&
    lastFamily () const;

    lastFamily_optional&
    lastFamily ();

    void
    lastFamily (const lastFamily_type& x);

    void
    lastFamily (const lastFamily_optional& x);

    void
    lastFamily (::std::unique_ptr< lastFamily_type > p);

    // middle
    //
    typedef ::xml_schema::string middle_type;
    typedef ::xsd::cxx::tree::sequence< middle_type > middle_sequence;
    typedef middle_sequence::iterator middle_iterator;
    typedef middle_sequence::const_iterator middle_const_iterator;
    typedef ::xsd::cxx::tree::traits< middle_type, char > middle_traits;

    const middle_sequence&
    middle () const;

    middle_sequence&
    middle ();

    void
    middle (const middle_sequence& s);

    // prefix
    //
    typedef ::xml_schema::string prefix_type;
    typedef ::xsd::cxx::tree::optional< prefix_type > prefix_optional;
    typedef ::xsd::cxx::tree::traits< prefix_type, char > prefix_traits;

    const prefix_optional&
    prefix () const;

    prefix_optional&
    prefix ();

    void
    prefix (const prefix_type& x);

    void
    prefix (const prefix_optional& x);

    void
    prefix (::std::unique_ptr< prefix_type > p);

    // sex
    //
    typedef ::XMLSchema::SexSpecification sex_type;
    typedef ::xsd::cxx::tree::optional< sex_type > sex_optional;
    typedef ::xsd::cxx::tree::traits< sex_type, char > sex_traits;

    const sex_optional&
    sex () const;

    sex_optional&
    sex ();

    void
    sex (const sex_type& x);

    void
    sex (const sex_optional& x);

    void
    sex (::std::unique_ptr< sex_type > p);

    // suffix
    //
    typedef ::xml_schema::string suffix_type;
    typedef ::xsd::cxx::tree::optional< suffix_type > suffix_optional;
    typedef ::xsd::cxx::tree::traits< suffix_type, char > suffix_traits;

    const suffix_optional&
    suffix () const;

    suffix_optional&
    suffix ();

    void
    suffix (const suffix_type& x);

    void
    suffix (const suffix_optional& x);

    void
    suffix (::std::unique_ptr< suffix_type > p);

    // typeOfIndividualName
    //
    typedef ::XMLSchema::ControlledVocabularyEntry typeOfIndividualName_type;
    typedef ::xsd::cxx::tree::optional< typeOfIndividualName_type > typeOfIndividualName_optional;
    typedef ::xsd::cxx::tree::traits< typeOfIndividualName_type, char > typeOfIndividualName_traits;

    const typeOfIndividualName_optional&
    typeOfIndividualName () const;

    typeOfIndividualName_optional&
    typeOfIndividualName ();

    void
    typeOfIndividualName (const typeOfIndividualName_type& x);

    void
    typeOfIndividualName (const typeOfIndividualName_optional& x);

    void
    typeOfIndividualName (::std::unique_ptr< typeOfIndividualName_type > p);

    // Constructors.
    //
    IndividualName ();

    IndividualName (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    IndividualName (const IndividualName& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual IndividualName*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    IndividualName&
    operator= (const IndividualName& x);

    virtual 
    ~IndividualName ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    abbreviation_optional abbreviation_;
    context_optional context_;
    effectiveDates_optional effectiveDates_;
    firstGiven_optional firstGiven_;
    fullName_optional fullName_;
    isFormal_optional isFormal_;
    isPreferred_optional isPreferred_;
    lastFamily_optional lastFamily_;
    middle_sequence middle_;
    prefix_optional prefix_;
    sex_optional sex_;
    suffix_optional suffix_;
    typeOfIndividualName_optional typeOfIndividualName_;
  };

  class InternationalIdentifier: public ::xml_schema::type
  {
    public:
    // identifierContent
    //
    typedef ::xml_schema::string identifierContent_type;
    typedef ::xsd::cxx::tree::optional< identifierContent_type > identifierContent_optional;
    typedef ::xsd::cxx::tree::traits< identifierContent_type, char > identifierContent_traits;

    const identifierContent_optional&
    identifierContent () const;

    identifierContent_optional&
    identifierContent ();

    void
    identifierContent (const identifierContent_type& x);

    void
    identifierContent (const identifierContent_optional& x);

    void
    identifierContent (::std::unique_ptr< identifierContent_type > p);

    // isURI
    //
    typedef ::xml_schema::boolean isURI_type;
    typedef ::xsd::cxx::tree::optional< isURI_type > isURI_optional;
    typedef ::xsd::cxx::tree::traits< isURI_type, char > isURI_traits;

    const isURI_optional&
    isURI () const;

    isURI_optional&
    isURI ();

    void
    isURI (const isURI_type& x);

    void
    isURI (const isURI_optional& x);

    // managingAgency
    //
    typedef ::XMLSchema::ControlledVocabularyEntry managingAgency_type;
    typedef ::xsd::cxx::tree::optional< managingAgency_type > managingAgency_optional;
    typedef ::xsd::cxx::tree::traits< managingAgency_type, char > managingAgency_traits;

    const managingAgency_optional&
    managingAgency () const;

    managingAgency_optional&
    managingAgency ();

    void
    managingAgency (const managingAgency_type& x);

    void
    managingAgency (const managingAgency_optional& x);

    void
    managingAgency (::std::unique_ptr< managingAgency_type > p);

    // Constructors.
    //
    InternationalIdentifier ();

    InternationalIdentifier (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    InternationalIdentifier (const InternationalIdentifier& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual InternationalIdentifier*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InternationalIdentifier&
    operator= (const InternationalIdentifier& x);

    virtual 
    ~InternationalIdentifier ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    identifierContent_optional identifierContent_;
    isURI_optional isURI_;
    managingAgency_optional managingAgency_;
  };

  class InternationalRegistrationDataIdentifier: public ::xml_schema::type
  {
    public:
    // dataIdentifier
    //
    typedef ::xml_schema::string dataIdentifier_type;
    typedef ::xsd::cxx::tree::traits< dataIdentifier_type, char > dataIdentifier_traits;

    const dataIdentifier_type&
    dataIdentifier () const;

    dataIdentifier_type&
    dataIdentifier ();

    void
    dataIdentifier (const dataIdentifier_type& x);

    void
    dataIdentifier (::std::unique_ptr< dataIdentifier_type > p);

    // registrationAuthorityIdentifier
    //
    typedef ::xml_schema::string registrationAuthorityIdentifier_type;
    typedef ::xsd::cxx::tree::traits< registrationAuthorityIdentifier_type, char > registrationAuthorityIdentifier_traits;

    const registrationAuthorityIdentifier_type&
    registrationAuthorityIdentifier () const;

    registrationAuthorityIdentifier_type&
    registrationAuthorityIdentifier ();

    void
    registrationAuthorityIdentifier (const registrationAuthorityIdentifier_type& x);

    void
    registrationAuthorityIdentifier (::std::unique_ptr< registrationAuthorityIdentifier_type > p);

    // versionIdentifier
    //
    typedef ::xml_schema::string versionIdentifier_type;
    typedef ::xsd::cxx::tree::traits< versionIdentifier_type, char > versionIdentifier_traits;

    const versionIdentifier_type&
    versionIdentifier () const;

    versionIdentifier_type&
    versionIdentifier ();

    void
    versionIdentifier (const versionIdentifier_type& x);

    void
    versionIdentifier (::std::unique_ptr< versionIdentifier_type > p);

    // Constructors.
    //
    InternationalRegistrationDataIdentifier (const dataIdentifier_type&,
                                             const registrationAuthorityIdentifier_type&,
                                             const versionIdentifier_type&);

    InternationalRegistrationDataIdentifier (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    InternationalRegistrationDataIdentifier (const InternationalRegistrationDataIdentifier& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual InternationalRegistrationDataIdentifier*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InternationalRegistrationDataIdentifier&
    operator= (const InternationalRegistrationDataIdentifier& x);

    virtual 
    ~InternationalRegistrationDataIdentifier ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< dataIdentifier_type > dataIdentifier_;
    ::xsd::cxx::tree::one< registrationAuthorityIdentifier_type > registrationAuthorityIdentifier_;
    ::xsd::cxx::tree::one< versionIdentifier_type > versionIdentifier_;
  };

  class LabelForDisplay: public ::XMLSchema::InternationalString
  {
    public:
    // locationVariant
    //
    typedef ::XMLSchema::ControlledVocabularyEntry locationVariant_type;
    typedef ::xsd::cxx::tree::optional< locationVariant_type > locationVariant_optional;
    typedef ::xsd::cxx::tree::traits< locationVariant_type, char > locationVariant_traits;

    const locationVariant_optional&
    locationVariant () const;

    locationVariant_optional&
    locationVariant ();

    void
    locationVariant (const locationVariant_type& x);

    void
    locationVariant (const locationVariant_optional& x);

    void
    locationVariant (::std::unique_ptr< locationVariant_type > p);

    // maxLength
    //
    typedef ::xml_schema::integer maxLength_type;
    typedef ::xsd::cxx::tree::optional< maxLength_type > maxLength_optional;
    typedef ::xsd::cxx::tree::traits< maxLength_type, char > maxLength_traits;

    const maxLength_optional&
    maxLength () const;

    maxLength_optional&
    maxLength ();

    void
    maxLength (const maxLength_type& x);

    void
    maxLength (const maxLength_optional& x);

    // validDates
    //
    typedef ::XMLSchema::DateRange validDates_type;
    typedef ::xsd::cxx::tree::optional< validDates_type > validDates_optional;
    typedef ::xsd::cxx::tree::traits< validDates_type, char > validDates_traits;

    const validDates_optional&
    validDates () const;

    validDates_optional&
    validDates ();

    void
    validDates (const validDates_type& x);

    void
    validDates (const validDates_optional& x);

    void
    validDates (::std::unique_ptr< validDates_type > p);

    // Constructors.
    //
    LabelForDisplay ();

    LabelForDisplay (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    LabelForDisplay (const LabelForDisplay& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual LabelForDisplay*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LabelForDisplay&
    operator= (const LabelForDisplay& x);

    virtual 
    ~LabelForDisplay ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    locationVariant_optional locationVariant_;
    maxLength_optional maxLength_;
    validDates_optional validDates_;
  };

  class LanguageString: public ::xml_schema::type
  {
    public:
    // content
    //
    typedef ::xml_schema::string content_type;
    typedef ::xsd::cxx::tree::traits< content_type, char > content_traits;

    const content_type&
    content () const;

    content_type&
    content ();

    void
    content (const content_type& x);

    void
    content (::std::unique_ptr< content_type > p);

    // isTranslatable
    //
    typedef ::xml_schema::boolean isTranslatable_type;
    typedef ::xsd::cxx::tree::optional< isTranslatable_type > isTranslatable_optional;
    typedef ::xsd::cxx::tree::traits< isTranslatable_type, char > isTranslatable_traits;

    const isTranslatable_optional&
    isTranslatable () const;

    isTranslatable_optional&
    isTranslatable ();

    void
    isTranslatable (const isTranslatable_type& x);

    void
    isTranslatable (const isTranslatable_optional& x);

    // isTranslated
    //
    typedef ::xml_schema::boolean isTranslated_type;
    typedef ::xsd::cxx::tree::optional< isTranslated_type > isTranslated_optional;
    typedef ::xsd::cxx::tree::traits< isTranslated_type, char > isTranslated_traits;

    const isTranslated_optional&
    isTranslated () const;

    isTranslated_optional&
    isTranslated ();

    void
    isTranslated (const isTranslated_type& x);

    void
    isTranslated (const isTranslated_optional& x);

    // scope
    //
    typedef ::xml_schema::string scope_type;
    typedef ::xsd::cxx::tree::optional< scope_type > scope_optional;
    typedef ::xsd::cxx::tree::traits< scope_type, char > scope_traits;

    const scope_optional&
    scope () const;

    scope_optional&
    scope ();

    void
    scope (const scope_type& x);

    void
    scope (const scope_optional& x);

    void
    scope (::std::unique_ptr< scope_type > p);

    // structureUsed
    //
    typedef ::XMLSchema::ControlledVocabularyEntry structureUsed_type;
    typedef ::xsd::cxx::tree::optional< structureUsed_type > structureUsed_optional;
    typedef ::xsd::cxx::tree::traits< structureUsed_type, char > structureUsed_traits;

    const structureUsed_optional&
    structureUsed () const;

    structureUsed_optional&
    structureUsed ();

    void
    structureUsed (const structureUsed_type& x);

    void
    structureUsed (const structureUsed_optional& x);

    void
    structureUsed (::std::unique_ptr< structureUsed_type > p);

    // translationDate
    //
    typedef ::xml_schema::date translationDate_type;
    typedef ::xsd::cxx::tree::optional< translationDate_type > translationDate_optional;
    typedef ::xsd::cxx::tree::traits< translationDate_type, char > translationDate_traits;

    const translationDate_optional&
    translationDate () const;

    translationDate_optional&
    translationDate ();

    void
    translationDate (const translationDate_type& x);

    void
    translationDate (const translationDate_optional& x);

    void
    translationDate (::std::unique_ptr< translationDate_type > p);

    // translationSourceLanguage
    //
    typedef ::xml_schema::language translationSourceLanguage_type;
    typedef ::xsd::cxx::tree::sequence< translationSourceLanguage_type > translationSourceLanguage_sequence;
    typedef translationSourceLanguage_sequence::iterator translationSourceLanguage_iterator;
    typedef translationSourceLanguage_sequence::const_iterator translationSourceLanguage_const_iterator;
    typedef ::xsd::cxx::tree::traits< translationSourceLanguage_type, char > translationSourceLanguage_traits;

    const translationSourceLanguage_sequence&
    translationSourceLanguage () const;

    translationSourceLanguage_sequence&
    translationSourceLanguage ();

    void
    translationSourceLanguage (const translationSourceLanguage_sequence& s);

    // Constructors.
    //
    LanguageString (const content_type&);

    LanguageString (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    LanguageString (const LanguageString& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual LanguageString*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LanguageString&
    operator= (const LanguageString& x);

    virtual 
    ~LanguageString ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< content_type > content_;
    isTranslatable_optional isTranslatable_;
    isTranslated_optional isTranslated_;
    scope_optional scope_;
    structureUsed_optional structureUsed_;
    translationDate_optional translationDate_;
    translationSourceLanguage_sequence translationSourceLanguage_;
  };

  class LicenseInformation: public ::xml_schema::type
  {
    public:
    // contact
    //
    typedef ::XMLSchema::ContactInformation contact_type;
    typedef ::xsd::cxx::tree::sequence< contact_type > contact_sequence;
    typedef contact_sequence::iterator contact_iterator;
    typedef contact_sequence::const_iterator contact_const_iterator;
    typedef ::xsd::cxx::tree::traits< contact_type, char > contact_traits;

    const contact_sequence&
    contact () const;

    contact_sequence&
    contact ();

    void
    contact (const contact_sequence& s);

    // description
    //
    typedef ::XMLSchema::InternationalString description_type;
    typedef ::xsd::cxx::tree::sequence< description_type > description_sequence;
    typedef description_sequence::iterator description_iterator;
    typedef description_sequence::const_iterator description_const_iterator;
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    const description_sequence&
    description () const;

    description_sequence&
    description ();

    void
    description (const description_sequence& s);

    // licenseAgent
    //
    typedef ::XMLSchema::AgentInRole licenseAgent_type;
    typedef ::xsd::cxx::tree::sequence< licenseAgent_type > licenseAgent_sequence;
    typedef licenseAgent_sequence::iterator licenseAgent_iterator;
    typedef licenseAgent_sequence::const_iterator licenseAgent_const_iterator;
    typedef ::xsd::cxx::tree::traits< licenseAgent_type, char > licenseAgent_traits;

    const licenseAgent_sequence&
    licenseAgent () const;

    licenseAgent_sequence&
    licenseAgent ();

    void
    licenseAgent (const licenseAgent_sequence& s);

    // licenseReference
    //
    typedef ::XMLSchema::licenseReference licenseReference_type;
    typedef ::xsd::cxx::tree::sequence< licenseReference_type > licenseReference_sequence;
    typedef licenseReference_sequence::iterator licenseReference_iterator;
    typedef licenseReference_sequence::const_iterator licenseReference_const_iterator;
    typedef ::xsd::cxx::tree::traits< licenseReference_type, char > licenseReference_traits;

    const licenseReference_sequence&
    licenseReference () const;

    licenseReference_sequence&
    licenseReference ();

    void
    licenseReference (const licenseReference_sequence& s);

    // Constructors.
    //
    LicenseInformation ();

    LicenseInformation (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    LicenseInformation (const LicenseInformation& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual LicenseInformation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LicenseInformation&
    operator= (const LicenseInformation& x);

    virtual 
    ~LicenseInformation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    contact_sequence contact_;
    description_sequence description_;
    licenseAgent_sequence licenseAgent_;
    licenseReference_sequence licenseReference_;
  };

  class ModelIdentification: public ::xml_schema::type
  {
    public:
    // acronym
    //
    typedef ::xml_schema::string acronym_type;
    typedef ::xsd::cxx::tree::traits< acronym_type, char > acronym_traits;

    const acronym_type&
    acronym () const;

    acronym_type&
    acronym ();

    void
    acronym (const acronym_type& x);

    void
    acronym (::std::unique_ptr< acronym_type > p);

    // language
    //
    typedef ::xml_schema::string language_type;
    typedef ::xsd::cxx::tree::traits< language_type, char > language_traits;

    const language_type&
    language () const;

    language_type&
    language ();

    void
    language (const language_type& x);

    void
    language (::std::unique_ptr< language_type > p);

    // majorVersion
    //
    typedef ::xml_schema::integer majorVersion_type;
    typedef ::xsd::cxx::tree::traits< majorVersion_type, char > majorVersion_traits;

    const majorVersion_type&
    majorVersion () const;

    majorVersion_type&
    majorVersion ();

    void
    majorVersion (const majorVersion_type& x);

    // minorVersion
    //
    typedef ::xml_schema::integer minorVersion_type;
    typedef ::xsd::cxx::tree::traits< minorVersion_type, char > minorVersion_traits;

    const minorVersion_type&
    minorVersion () const;

    minorVersion_type&
    minorVersion ();

    void
    minorVersion (const minorVersion_type& x);

    // subtitle
    //
    typedef ::xml_schema::string subtitle_type;
    typedef ::xsd::cxx::tree::traits< subtitle_type, char > subtitle_traits;

    const subtitle_type&
    subtitle () const;

    subtitle_type&
    subtitle ();

    void
    subtitle (const subtitle_type& x);

    void
    subtitle (::std::unique_ptr< subtitle_type > p);

    // title
    //
    typedef ::xml_schema::string title_type;
    typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

    const title_type&
    title () const;

    title_type&
    title ();

    void
    title (const title_type& x);

    void
    title (::std::unique_ptr< title_type > p);

    // uri
    //
    typedef ::xml_schema::string uri_type;
    typedef ::xsd::cxx::tree::traits< uri_type, char > uri_traits;

    const uri_type&
    uri () const;

    uri_type&
    uri ();

    void
    uri (const uri_type& x);

    void
    uri (::std::unique_ptr< uri_type > p);

    // Constructors.
    //
    ModelIdentification (const acronym_type&,
                         const language_type&,
                         const majorVersion_type&,
                         const minorVersion_type&,
                         const subtitle_type&,
                         const title_type&,
                         const uri_type&);

    ModelIdentification (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ModelIdentification (const ModelIdentification& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual ModelIdentification*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ModelIdentification&
    operator= (const ModelIdentification& x);

    virtual 
    ~ModelIdentification ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< acronym_type > acronym_;
    ::xsd::cxx::tree::one< language_type > language_;
    ::xsd::cxx::tree::one< majorVersion_type > majorVersion_;
    ::xsd::cxx::tree::one< minorVersion_type > minorVersion_;
    ::xsd::cxx::tree::one< subtitle_type > subtitle_;
    ::xsd::cxx::tree::one< title_type > title_;
    ::xsd::cxx::tree::one< uri_type > uri_;
  };

  class NonDdiIdentifier: public ::xml_schema::type
  {
    public:
    // managingAgency
    //
    typedef ::xml_schema::string managingAgency_type;
    typedef ::xsd::cxx::tree::optional< managingAgency_type > managingAgency_optional;
    typedef ::xsd::cxx::tree::traits< managingAgency_type, char > managingAgency_traits;

    const managingAgency_optional&
    managingAgency () const;

    managingAgency_optional&
    managingAgency ();

    void
    managingAgency (const managingAgency_type& x);

    void
    managingAgency (const managingAgency_optional& x);

    void
    managingAgency (::std::unique_ptr< managingAgency_type > p);

    // type
    //
    typedef ::xml_schema::string type_type;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_type&
    type () const;

    type_type&
    type ();

    void
    type (const type_type& x);

    void
    type (::std::unique_ptr< type_type > p);

    // value
    //
    typedef ::xml_schema::string value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    void
    value (::std::unique_ptr< value_type > p);

    // version
    //
    typedef ::xml_schema::string version_type;
    typedef ::xsd::cxx::tree::optional< version_type > version_optional;
    typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

    const version_optional&
    version () const;

    version_optional&
    version ();

    void
    version (const version_type& x);

    void
    version (const version_optional& x);

    void
    version (::std::unique_ptr< version_type > p);

    // Constructors.
    //
    NonDdiIdentifier (const type_type&,
                      const value_type&);

    NonDdiIdentifier (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    NonDdiIdentifier (const NonDdiIdentifier& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual NonDdiIdentifier*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NonDdiIdentifier&
    operator= (const NonDdiIdentifier& x);

    virtual 
    ~NonDdiIdentifier ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    managingAgency_optional managingAgency_;
    ::xsd::cxx::tree::one< type_type > type_;
    ::xsd::cxx::tree::one< value_type > value_;
    version_optional version_;
  };

  class NonIsoDate: public ::xml_schema::type
  {
    public:
    // calendar
    //
    typedef ::XMLSchema::ControlledVocabularyEntry calendar_type;
    typedef ::xsd::cxx::tree::optional< calendar_type > calendar_optional;
    typedef ::xsd::cxx::tree::traits< calendar_type, char > calendar_traits;

    const calendar_optional&
    calendar () const;

    calendar_optional&
    calendar ();

    void
    calendar (const calendar_type& x);

    void
    calendar (const calendar_optional& x);

    void
    calendar (::std::unique_ptr< calendar_type > p);

    // dateContent
    //
    typedef ::xml_schema::string dateContent_type;
    typedef ::xsd::cxx::tree::traits< dateContent_type, char > dateContent_traits;

    const dateContent_type&
    dateContent () const;

    dateContent_type&
    dateContent ();

    void
    dateContent (const dateContent_type& x);

    void
    dateContent (::std::unique_ptr< dateContent_type > p);

    // nonIsoDateFormat
    //
    typedef ::XMLSchema::ControlledVocabularyEntry nonIsoDateFormat_type;
    typedef ::xsd::cxx::tree::optional< nonIsoDateFormat_type > nonIsoDateFormat_optional;
    typedef ::xsd::cxx::tree::traits< nonIsoDateFormat_type, char > nonIsoDateFormat_traits;

    const nonIsoDateFormat_optional&
    nonIsoDateFormat () const;

    nonIsoDateFormat_optional&
    nonIsoDateFormat ();

    void
    nonIsoDateFormat (const nonIsoDateFormat_type& x);

    void
    nonIsoDateFormat (const nonIsoDateFormat_optional& x);

    void
    nonIsoDateFormat (::std::unique_ptr< nonIsoDateFormat_type > p);

    // Constructors.
    //
    NonIsoDate (const dateContent_type&);

    NonIsoDate (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    NonIsoDate (const NonIsoDate& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual NonIsoDate*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    NonIsoDate&
    operator= (const NonIsoDate& x);

    virtual 
    ~NonIsoDate ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    calendar_optional calendar_;
    ::xsd::cxx::tree::one< dateContent_type > dateContent_;
    nonIsoDateFormat_optional nonIsoDateFormat_;
  };

  class Selector: public ::xml_schema::type
  {
    public:
    // Constructors.
    //
    Selector ();

    Selector (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Selector (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Selector (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Selector (const Selector& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual Selector*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Selector&
    operator= (const Selector&) = default;
#endif

    virtual 
    ~Selector ();
  };

  class ObjectAttributeSelector: public ::XMLSchema::Selector
  {
    public:
    // refinedBy
    //
    typedef ::XMLSchema::ObjectAttributeSelector refinedBy_type;
    typedef ::xsd::cxx::tree::optional< refinedBy_type > refinedBy_optional;
    typedef ::xsd::cxx::tree::traits< refinedBy_type, char > refinedBy_traits;

    const refinedBy_optional&
    refinedBy () const;

    refinedBy_optional&
    refinedBy ();

    void
    refinedBy (const refinedBy_type& x);

    void
    refinedBy (const refinedBy_optional& x);

    void
    refinedBy (::std::unique_ptr< refinedBy_type > p);

    // refinedByOrderNumber
    //
    typedef ::xml_schema::integer refinedByOrderNumber_type;
    typedef ::xsd::cxx::tree::optional< refinedByOrderNumber_type > refinedByOrderNumber_optional;
    typedef ::xsd::cxx::tree::traits< refinedByOrderNumber_type, char > refinedByOrderNumber_traits;

    const refinedByOrderNumber_optional&
    refinedByOrderNumber () const;

    refinedByOrderNumber_optional&
    refinedByOrderNumber ();

    void
    refinedByOrderNumber (const refinedByOrderNumber_type& x);

    void
    refinedByOrderNumber (const refinedByOrderNumber_optional& x);

    // value
    //
    typedef ::xml_schema::string value_type;
    typedef ::xsd::cxx::tree::optional< value_type > value_optional;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_optional&
    value () const;

    value_optional&
    value ();

    void
    value (const value_type& x);

    void
    value (const value_optional& x);

    void
    value (::std::unique_ptr< value_type > p);

    // Constructors.
    //
    ObjectAttributeSelector ();

    ObjectAttributeSelector (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ObjectAttributeSelector (const ObjectAttributeSelector& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual ObjectAttributeSelector*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectAttributeSelector&
    operator= (const ObjectAttributeSelector& x);

    virtual 
    ~ObjectAttributeSelector ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    refinedBy_optional refinedBy_;
    refinedByOrderNumber_optional refinedByOrderNumber_;
    value_optional value_;
  };

  class ObjectName: public ::xml_schema::type
  {
    public:
    // context
    //
    typedef ::XMLSchema::ControlledVocabularyEntry context_type;
    typedef ::xsd::cxx::tree::optional< context_type > context_optional;
    typedef ::xsd::cxx::tree::traits< context_type, char > context_traits;

    const context_optional&
    context () const;

    context_optional&
    context ();

    void
    context (const context_type& x);

    void
    context (const context_optional& x);

    void
    context (::std::unique_ptr< context_type > p);

    // name
    //
    typedef ::xml_schema::string name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::unique_ptr< name_type > p);

    // Constructors.
    //
    ObjectName ();

    ObjectName (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    ObjectName (const ObjectName& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual ObjectName*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ObjectName&
    operator= (const ObjectName& x);

    virtual 
    ~ObjectName ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    context_optional context_;
    name_optional name_;
  };

  class OrganizationName: public ::XMLSchema::ObjectName
  {
    public:
    // abbreviation
    //
    typedef ::XMLSchema::InternationalString abbreviation_type;
    typedef ::xsd::cxx::tree::optional< abbreviation_type > abbreviation_optional;
    typedef ::xsd::cxx::tree::traits< abbreviation_type, char > abbreviation_traits;

    const abbreviation_optional&
    abbreviation () const;

    abbreviation_optional&
    abbreviation ();

    void
    abbreviation (const abbreviation_type& x);

    void
    abbreviation (const abbreviation_optional& x);

    void
    abbreviation (::std::unique_ptr< abbreviation_type > p);

    // effectiveDates
    //
    typedef ::XMLSchema::DateRange effectiveDates_type;
    typedef ::xsd::cxx::tree::optional< effectiveDates_type > effectiveDates_optional;
    typedef ::xsd::cxx::tree::traits< effectiveDates_type, char > effectiveDates_traits;

    const effectiveDates_optional&
    effectiveDates () const;

    effectiveDates_optional&
    effectiveDates ();

    void
    effectiveDates (const effectiveDates_type& x);

    void
    effectiveDates (const effectiveDates_optional& x);

    void
    effectiveDates (::std::unique_ptr< effectiveDates_type > p);

    // isFormal
    //
    typedef ::xml_schema::boolean isFormal_type;
    typedef ::xsd::cxx::tree::optional< isFormal_type > isFormal_optional;
    typedef ::xsd::cxx::tree::traits< isFormal_type, char > isFormal_traits;

    const isFormal_optional&
    isFormal () const;

    isFormal_optional&
    isFormal ();

    void
    isFormal (const isFormal_type& x);

    void
    isFormal (const isFormal_optional& x);

    // typeOfOrganizationName
    //
    typedef ::XMLSchema::ControlledVocabularyEntry typeOfOrganizationName_type;
    typedef ::xsd::cxx::tree::optional< typeOfOrganizationName_type > typeOfOrganizationName_optional;
    typedef ::xsd::cxx::tree::traits< typeOfOrganizationName_type, char > typeOfOrganizationName_traits;

    const typeOfOrganizationName_optional&
    typeOfOrganizationName () const;

    typeOfOrganizationName_optional&
    typeOfOrganizationName ();

    void
    typeOfOrganizationName (const typeOfOrganizationName_type& x);

    void
    typeOfOrganizationName (const typeOfOrganizationName_optional& x);

    void
    typeOfOrganizationName (::std::unique_ptr< typeOfOrganizationName_type > p);

    // Constructors.
    //
    OrganizationName ();

    OrganizationName (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    OrganizationName (const OrganizationName& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual OrganizationName*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OrganizationName&
    operator= (const OrganizationName& x);

    virtual 
    ~OrganizationName ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    abbreviation_optional abbreviation_;
    effectiveDates_optional effectiveDates_;
    isFormal_optional isFormal_;
    typeOfOrganizationName_optional typeOfOrganizationName_;
  };

  class PairedControlledVocabularyEntry: public ::xml_schema::type
  {
    public:
    // extent
    //
    typedef ::XMLSchema::ControlledVocabularyEntry extent_type;
    typedef ::xsd::cxx::tree::optional< extent_type > extent_optional;
    typedef ::xsd::cxx::tree::traits< extent_type, char > extent_traits;

    const extent_optional&
    extent () const;

    extent_optional&
    extent ();

    void
    extent (const extent_type& x);

    void
    extent (const extent_optional& x);

    void
    extent (::std::unique_ptr< extent_type > p);

    // term
    //
    typedef ::XMLSchema::ControlledVocabularyEntry term_type;
    typedef ::xsd::cxx::tree::traits< term_type, char > term_traits;

    const term_type&
    term () const;

    term_type&
    term ();

    void
    term (const term_type& x);

    void
    term (::std::unique_ptr< term_type > p);

    // Constructors.
    //
    PairedControlledVocabularyEntry (const term_type&);

    PairedControlledVocabularyEntry (::std::unique_ptr< term_type >);

    PairedControlledVocabularyEntry (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    PairedControlledVocabularyEntry (const PairedControlledVocabularyEntry& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual PairedControlledVocabularyEntry*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PairedControlledVocabularyEntry&
    operator= (const PairedControlledVocabularyEntry& x);

    virtual 
    ~PairedControlledVocabularyEntry ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    extent_optional extent_;
    ::xsd::cxx::tree::one< term_type > term_;
  };

  class PrivateImage: public ::xml_schema::type
  {
    public:
    // effectiveDates
    //
    typedef ::XMLSchema::DateRange effectiveDates_type;
    typedef ::xsd::cxx::tree::optional< effectiveDates_type > effectiveDates_optional;
    typedef ::xsd::cxx::tree::traits< effectiveDates_type, char > effectiveDates_traits;

    const effectiveDates_optional&
    effectiveDates () const;

    effectiveDates_optional&
    effectiveDates ();

    void
    effectiveDates (const effectiveDates_type& x);

    void
    effectiveDates (const effectiveDates_optional& x);

    void
    effectiveDates (::std::unique_ptr< effectiveDates_type > p);

    // privacy
    //
    typedef ::XMLSchema::ControlledVocabularyEntry privacy_type;
    typedef ::xsd::cxx::tree::optional< privacy_type > privacy_optional;
    typedef ::xsd::cxx::tree::traits< privacy_type, char > privacy_traits;

    const privacy_optional&
    privacy () const;

    privacy_optional&
    privacy ();

    void
    privacy (const privacy_type& x);

    void
    privacy (const privacy_optional& x);

    void
    privacy (::std::unique_ptr< privacy_type > p);

    // Constructors.
    //
    PrivateImage ();

    PrivateImage (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    PrivateImage (const PrivateImage& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual PrivateImage*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PrivateImage&
    operator= (const PrivateImage& x);

    virtual 
    ~PrivateImage ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    effectiveDates_optional effectiveDates_;
    privacy_optional privacy_;
  };

  class ProvenanceInformation: public ::xml_schema::type
  {
    public:
    // funding
    //
    typedef ::XMLSchema::FundingInformation funding_type;
    typedef ::xsd::cxx::tree::sequence< funding_type > funding_sequence;
    typedef funding_sequence::iterator funding_iterator;
    typedef funding_sequence::const_iterator funding_const_iterator;
    typedef ::xsd::cxx::tree::traits< funding_type, char > funding_traits;

    const funding_sequence&
    funding () const;

    funding_sequence&
    funding ();

    void
    funding (const funding_sequence& s);

    // provenanceStatement
    //
    typedef ::XMLSchema::InternationalString provenanceStatement_type;
    typedef ::xsd::cxx::tree::sequence< provenanceStatement_type > provenanceStatement_sequence;
    typedef provenanceStatement_sequence::iterator provenanceStatement_iterator;
    typedef provenanceStatement_sequence::const_iterator provenanceStatement_const_iterator;
    typedef ::xsd::cxx::tree::traits< provenanceStatement_type, char > provenanceStatement_traits;

    const provenanceStatement_sequence&
    provenanceStatement () const;

    provenanceStatement_sequence&
    provenanceStatement ();

    void
    provenanceStatement (const provenanceStatement_sequence& s);

    // recordCreationDate
    //
    typedef ::xml_schema::date recordCreationDate_type;
    typedef ::xsd::cxx::tree::optional< recordCreationDate_type > recordCreationDate_optional;
    typedef ::xsd::cxx::tree::traits< recordCreationDate_type, char > recordCreationDate_traits;

    const recordCreationDate_optional&
    recordCreationDate () const;

    recordCreationDate_optional&
    recordCreationDate ();

    void
    recordCreationDate (const recordCreationDate_type& x);

    void
    recordCreationDate (const recordCreationDate_optional& x);

    void
    recordCreationDate (::std::unique_ptr< recordCreationDate_type > p);

    // recordLastRevisionDate
    //
    typedef ::xml_schema::date recordLastRevisionDate_type;
    typedef ::xsd::cxx::tree::optional< recordLastRevisionDate_type > recordLastRevisionDate_optional;
    typedef ::xsd::cxx::tree::traits< recordLastRevisionDate_type, char > recordLastRevisionDate_traits;

    const recordLastRevisionDate_optional&
    recordLastRevisionDate () const;

    recordLastRevisionDate_optional&
    recordLastRevisionDate ();

    void
    recordLastRevisionDate (const recordLastRevisionDate_type& x);

    void
    recordLastRevisionDate (const recordLastRevisionDate_optional& x);

    void
    recordLastRevisionDate (::std::unique_ptr< recordLastRevisionDate_type > p);

    // Constructors.
    //
    ProvenanceInformation ();

    ProvenanceInformation (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    ProvenanceInformation (const ProvenanceInformation& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual ProvenanceInformation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ProvenanceInformation&
    operator= (const ProvenanceInformation& x);

    virtual 
    ~ProvenanceInformation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    funding_sequence funding_;
    provenanceStatement_sequence provenanceStatement_;
    recordCreationDate_optional recordCreationDate_;
    recordLastRevisionDate_optional recordLastRevisionDate_;
  };

  class RationaleDefinition: public ::xml_schema::type
  {
    public:
    // rationaleCode
    //
    typedef ::XMLSchema::ControlledVocabularyEntry rationaleCode_type;
    typedef ::xsd::cxx::tree::optional< rationaleCode_type > rationaleCode_optional;
    typedef ::xsd::cxx::tree::traits< rationaleCode_type, char > rationaleCode_traits;

    const rationaleCode_optional&
    rationaleCode () const;

    rationaleCode_optional&
    rationaleCode ();

    void
    rationaleCode (const rationaleCode_type& x);

    void
    rationaleCode (const rationaleCode_optional& x);

    void
    rationaleCode (::std::unique_ptr< rationaleCode_type > p);

    // rationaleDescription
    //
    typedef ::XMLSchema::InternationalString rationaleDescription_type;
    typedef ::xsd::cxx::tree::optional< rationaleDescription_type > rationaleDescription_optional;
    typedef ::xsd::cxx::tree::traits< rationaleDescription_type, char > rationaleDescription_traits;

    const rationaleDescription_optional&
    rationaleDescription () const;

    rationaleDescription_optional&
    rationaleDescription ();

    void
    rationaleDescription (const rationaleDescription_type& x);

    void
    rationaleDescription (const rationaleDescription_optional& x);

    void
    rationaleDescription (::std::unique_ptr< rationaleDescription_type > p);

    // Constructors.
    //
    RationaleDefinition ();

    RationaleDefinition (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    RationaleDefinition (const RationaleDefinition& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual RationaleDefinition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RationaleDefinition&
    operator= (const RationaleDefinition& x);

    virtual 
    ~RationaleDefinition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    rationaleCode_optional rationaleCode_;
    rationaleDescription_optional rationaleDescription_;
  };

  class Reference: public ::xml_schema::type
  {
    public:
    // ddiReference
    //
    typedef ::XMLSchema::InternationalRegistrationDataIdentifier ddiReference_type;
    typedef ::xsd::cxx::tree::optional< ddiReference_type > ddiReference_optional;
    typedef ::xsd::cxx::tree::traits< ddiReference_type, char > ddiReference_traits;

    const ddiReference_optional&
    ddiReference () const;

    ddiReference_optional&
    ddiReference ();

    void
    ddiReference (const ddiReference_type& x);

    void
    ddiReference (const ddiReference_optional& x);

    void
    ddiReference (::std::unique_ptr< ddiReference_type > p);

    // deepLink
    //
    typedef ::XMLSchema::Selector deepLink_type;
    typedef ::xsd::cxx::tree::optional< deepLink_type > deepLink_optional;
    typedef ::xsd::cxx::tree::traits< deepLink_type, char > deepLink_traits;

    const deepLink_optional&
    deepLink () const;

    deepLink_optional&
    deepLink ();

    void
    deepLink (const deepLink_type& x);

    void
    deepLink (const deepLink_optional& x);

    void
    deepLink (::std::unique_ptr< deepLink_type > p);

    // description
    //
    typedef ::xml_schema::string description_type;
    typedef ::xsd::cxx::tree::optional< description_type > description_optional;
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    const description_optional&
    description () const;

    description_optional&
    description ();

    void
    description (const description_type& x);

    void
    description (const description_optional& x);

    void
    description (::std::unique_ptr< description_type > p);

    // location
    //
    typedef ::XMLSchema::InternationalString location_type;
    typedef ::xsd::cxx::tree::optional< location_type > location_optional;
    typedef ::xsd::cxx::tree::traits< location_type, char > location_traits;

    const location_optional&
    location () const;

    location_optional&
    location ();

    void
    location (const location_type& x);

    void
    location (const location_optional& x);

    void
    location (::std::unique_ptr< location_type > p);

    // nonDdiReference
    //
    typedef ::XMLSchema::NonDdiIdentifier nonDdiReference_type;
    typedef ::xsd::cxx::tree::sequence< nonDdiReference_type > nonDdiReference_sequence;
    typedef nonDdiReference_sequence::iterator nonDdiReference_iterator;
    typedef nonDdiReference_sequence::const_iterator nonDdiReference_const_iterator;
    typedef ::xsd::cxx::tree::traits< nonDdiReference_type, char > nonDdiReference_traits;

    const nonDdiReference_sequence&
    nonDdiReference () const;

    nonDdiReference_sequence&
    nonDdiReference ();

    void
    nonDdiReference (const nonDdiReference_sequence& s);

    // semantic
    //
    typedef ::XMLSchema::ControlledVocabularyEntry semantic_type;
    typedef ::xsd::cxx::tree::optional< semantic_type > semantic_optional;
    typedef ::xsd::cxx::tree::traits< semantic_type, char > semantic_traits;

    const semantic_optional&
    semantic () const;

    semantic_optional&
    semantic ();

    void
    semantic (const semantic_type& x);

    void
    semantic (const semantic_optional& x);

    void
    semantic (::std::unique_ptr< semantic_type > p);

    // uri
    //
    typedef ::xml_schema::uri uri_type;
    typedef ::xsd::cxx::tree::optional< uri_type > uri_optional;
    typedef ::xsd::cxx::tree::traits< uri_type, char > uri_traits;

    const uri_optional&
    uri () const;

    uri_optional&
    uri ();

    void
    uri (const uri_type& x);

    void
    uri (const uri_optional& x);

    void
    uri (::std::unique_ptr< uri_type > p);

    // validType
    //
    typedef ::xml_schema::string validType_type;
    typedef ::xsd::cxx::tree::sequence< validType_type > validType_sequence;
    typedef validType_sequence::iterator validType_iterator;
    typedef validType_sequence::const_iterator validType_const_iterator;
    typedef ::xsd::cxx::tree::traits< validType_type, char > validType_traits;

    const validType_sequence&
    validType () const;

    validType_sequence&
    validType ();

    void
    validType (const validType_sequence& s);

    // isAssociationReference
    //
    typedef ::xml_schema::boolean isAssociationReference_type;
    typedef ::xsd::cxx::tree::optional< isAssociationReference_type > isAssociationReference_optional;
    typedef ::xsd::cxx::tree::traits< isAssociationReference_type, char > isAssociationReference_traits;

    const isAssociationReference_optional&
    isAssociationReference () const;

    isAssociationReference_optional&
    isAssociationReference ();

    void
    isAssociationReference (const isAssociationReference_type& x);

    void
    isAssociationReference (const isAssociationReference_optional& x);

    // Constructors.
    //
    Reference ();

    Reference (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    Reference (const Reference& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual Reference*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Reference&
    operator= (const Reference& x);

    virtual 
    ~Reference ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ddiReference_optional ddiReference_;
    deepLink_optional deepLink_;
    description_optional description_;
    location_optional location_;
    nonDdiReference_sequence nonDdiReference_;
    semantic_optional semantic_;
    uri_optional uri_;
    validType_sequence validType_;
    isAssociationReference_optional isAssociationReference_;
  };

  class SpatialCoordinate: public ::xml_schema::type
  {
    public:
    // content
    //
    typedef ::xml_schema::string content_type;
    typedef ::xsd::cxx::tree::optional< content_type > content_optional;
    typedef ::xsd::cxx::tree::traits< content_type, char > content_traits;

    const content_optional&
    content () const;

    content_optional&
    content ();

    void
    content (const content_type& x);

    void
    content (const content_optional& x);

    void
    content (::std::unique_ptr< content_type > p);

    // coordinateType
    //
    typedef ::XMLSchema::PointFormat coordinateType_type;
    typedef ::xsd::cxx::tree::optional< coordinateType_type > coordinateType_optional;
    typedef ::xsd::cxx::tree::traits< coordinateType_type, char > coordinateType_traits;

    const coordinateType_optional&
    coordinateType () const;

    coordinateType_optional&
    coordinateType ();

    void
    coordinateType (const coordinateType_type& x);

    void
    coordinateType (const coordinateType_optional& x);

    void
    coordinateType (::std::unique_ptr< coordinateType_type > p);

    // Constructors.
    //
    SpatialCoordinate ();

    SpatialCoordinate (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    SpatialCoordinate (const SpatialCoordinate& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual SpatialCoordinate*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SpatialCoordinate&
    operator= (const SpatialCoordinate& x);

    virtual 
    ~SpatialCoordinate ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_optional content_;
    coordinateType_optional coordinateType_;
  };

  class SpatialPoint: public ::xml_schema::type
  {
    public:
    // xCoordinate
    //
    typedef ::XMLSchema::SpatialCoordinate xCoordinate_type;
    typedef ::xsd::cxx::tree::optional< xCoordinate_type > xCoordinate_optional;
    typedef ::xsd::cxx::tree::traits< xCoordinate_type, char > xCoordinate_traits;

    const xCoordinate_optional&
    xCoordinate () const;

    xCoordinate_optional&
    xCoordinate ();

    void
    xCoordinate (const xCoordinate_type& x);

    void
    xCoordinate (const xCoordinate_optional& x);

    void
    xCoordinate (::std::unique_ptr< xCoordinate_type > p);

    // yCoordinate
    //
    typedef ::XMLSchema::SpatialCoordinate yCoordinate_type;
    typedef ::xsd::cxx::tree::optional< yCoordinate_type > yCoordinate_optional;
    typedef ::xsd::cxx::tree::traits< yCoordinate_type, char > yCoordinate_traits;

    const yCoordinate_optional&
    yCoordinate () const;

    yCoordinate_optional&
    yCoordinate ();

    void
    yCoordinate (const yCoordinate_type& x);

    void
    yCoordinate (const yCoordinate_optional& x);

    void
    yCoordinate (::std::unique_ptr< yCoordinate_type > p);

    // Constructors.
    //
    SpatialPoint ();

    SpatialPoint (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    SpatialPoint (const SpatialPoint& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual SpatialPoint*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SpatialPoint&
    operator= (const SpatialPoint& x);

    virtual 
    ~SpatialPoint ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    xCoordinate_optional xCoordinate_;
    yCoordinate_optional yCoordinate_;
  };

  class Statistic: public ::xml_schema::type
  {
    public:
    // computationBase
    //
    typedef ::XMLSchema::ComputationBaseList computationBase_type;
    typedef ::xsd::cxx::tree::optional< computationBase_type > computationBase_optional;
    typedef ::xsd::cxx::tree::traits< computationBase_type, char > computationBase_traits;

    const computationBase_optional&
    computationBase () const;

    computationBase_optional&
    computationBase ();

    void
    computationBase (const computationBase_type& x);

    void
    computationBase (const computationBase_optional& x);

    void
    computationBase (::std::unique_ptr< computationBase_type > p);

    // content
    //
    typedef ::xml_schema::double_ content_type;
    typedef ::xsd::cxx::tree::optional< content_type > content_optional;
    typedef ::xsd::cxx::tree::traits< content_type, char, ::xsd::cxx::tree::schema_type::double_ > content_traits;

    const content_optional&
    content () const;

    content_optional&
    content ();

    void
    content (const content_type& x);

    void
    content (const content_optional& x);

    // isWeighted
    //
    typedef ::xml_schema::boolean isWeighted_type;
    typedef ::xsd::cxx::tree::optional< isWeighted_type > isWeighted_optional;
    typedef ::xsd::cxx::tree::traits< isWeighted_type, char > isWeighted_traits;

    const isWeighted_optional&
    isWeighted () const;

    isWeighted_optional&
    isWeighted ();

    void
    isWeighted (const isWeighted_type& x);

    void
    isWeighted (const isWeighted_optional& x);

    // typeOfNumericValue
    //
    typedef ::xml_schema::string typeOfNumericValue_type;
    typedef ::xsd::cxx::tree::optional< typeOfNumericValue_type > typeOfNumericValue_optional;
    typedef ::xsd::cxx::tree::traits< typeOfNumericValue_type, char > typeOfNumericValue_traits;

    const typeOfNumericValue_optional&
    typeOfNumericValue () const;

    typeOfNumericValue_optional&
    typeOfNumericValue ();

    void
    typeOfNumericValue (const typeOfNumericValue_type& x);

    void
    typeOfNumericValue (const typeOfNumericValue_optional& x);

    void
    typeOfNumericValue (::std::unique_ptr< typeOfNumericValue_type > p);

    // Constructors.
    //
    Statistic ();

    Statistic (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    Statistic (const Statistic& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual Statistic*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Statistic&
    operator= (const Statistic& x);

    virtual 
    ~Statistic ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    computationBase_optional computationBase_;
    content_optional content_;
    isWeighted_optional isWeighted_;
    typeOfNumericValue_optional typeOfNumericValue_;
  };

  class StructureSpecification: public ::xml_schema::type
  {
    public:
    // reflexive
    //
    typedef ::XMLSchema::MemberRelationshipScope reflexive_type;
    typedef ::xsd::cxx::tree::optional< reflexive_type > reflexive_optional;
    typedef ::xsd::cxx::tree::traits< reflexive_type, char > reflexive_traits;

    const reflexive_optional&
    reflexive () const;

    reflexive_optional&
    reflexive ();

    void
    reflexive (const reflexive_type& x);

    void
    reflexive (const reflexive_optional& x);

    void
    reflexive (::std::unique_ptr< reflexive_type > p);

    // symmetric
    //
    typedef ::XMLSchema::MemberRelationshipScope symmetric_type;
    typedef ::xsd::cxx::tree::optional< symmetric_type > symmetric_optional;
    typedef ::xsd::cxx::tree::traits< symmetric_type, char > symmetric_traits;

    const symmetric_optional&
    symmetric () const;

    symmetric_optional&
    symmetric ();

    void
    symmetric (const symmetric_type& x);

    void
    symmetric (const symmetric_optional& x);

    void
    symmetric (::std::unique_ptr< symmetric_type > p);

    // transitive
    //
    typedef ::XMLSchema::MemberRelationshipScope transitive_type;
    typedef ::xsd::cxx::tree::optional< transitive_type > transitive_optional;
    typedef ::xsd::cxx::tree::traits< transitive_type, char > transitive_traits;

    const transitive_optional&
    transitive () const;

    transitive_optional&
    transitive ();

    void
    transitive (const transitive_type& x);

    void
    transitive (const transitive_optional& x);

    void
    transitive (::std::unique_ptr< transitive_type > p);

    // Constructors.
    //
    StructureSpecification ();

    StructureSpecification (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    StructureSpecification (const StructureSpecification& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual StructureSpecification*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    StructureSpecification&
    operator= (const StructureSpecification& x);

    virtual 
    ~StructureSpecification ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    reflexive_optional reflexive_;
    symmetric_optional symmetric_;
    transitive_optional transitive_;
  };

  class Telephone: public ::xml_schema::type
  {
    public:
    // effectiveDates
    //
    typedef ::XMLSchema::DateRange effectiveDates_type;
    typedef ::xsd::cxx::tree::optional< effectiveDates_type > effectiveDates_optional;
    typedef ::xsd::cxx::tree::traits< effectiveDates_type, char > effectiveDates_traits;

    const effectiveDates_optional&
    effectiveDates () const;

    effectiveDates_optional&
    effectiveDates ();

    void
    effectiveDates (const effectiveDates_type& x);

    void
    effectiveDates (const effectiveDates_optional& x);

    void
    effectiveDates (::std::unique_ptr< effectiveDates_type > p);

    // isPreferred
    //
    typedef ::xml_schema::boolean isPreferred_type;
    typedef ::xsd::cxx::tree::optional< isPreferred_type > isPreferred_optional;
    typedef ::xsd::cxx::tree::traits< isPreferred_type, char > isPreferred_traits;

    const isPreferred_optional&
    isPreferred () const;

    isPreferred_optional&
    isPreferred ();

    void
    isPreferred (const isPreferred_type& x);

    void
    isPreferred (const isPreferred_optional& x);

    // privacy
    //
    typedef ::XMLSchema::ControlledVocabularyEntry privacy_type;
    typedef ::xsd::cxx::tree::optional< privacy_type > privacy_optional;
    typedef ::xsd::cxx::tree::traits< privacy_type, char > privacy_traits;

    const privacy_optional&
    privacy () const;

    privacy_optional&
    privacy ();

    void
    privacy (const privacy_type& x);

    void
    privacy (const privacy_optional& x);

    void
    privacy (::std::unique_ptr< privacy_type > p);

    // telephoneNumber
    //
    typedef ::xml_schema::string telephoneNumber_type;
    typedef ::xsd::cxx::tree::optional< telephoneNumber_type > telephoneNumber_optional;
    typedef ::xsd::cxx::tree::traits< telephoneNumber_type, char > telephoneNumber_traits;

    const telephoneNumber_optional&
    telephoneNumber () const;

    telephoneNumber_optional&
    telephoneNumber ();

    void
    telephoneNumber (const telephoneNumber_type& x);

    void
    telephoneNumber (const telephoneNumber_optional& x);

    void
    telephoneNumber (::std::unique_ptr< telephoneNumber_type > p);

    // typeOfTelephone
    //
    typedef ::XMLSchema::ControlledVocabularyEntry typeOfTelephone_type;
    typedef ::xsd::cxx::tree::optional< typeOfTelephone_type > typeOfTelephone_optional;
    typedef ::xsd::cxx::tree::traits< typeOfTelephone_type, char > typeOfTelephone_traits;

    const typeOfTelephone_optional&
    typeOfTelephone () const;

    typeOfTelephone_optional&
    typeOfTelephone ();

    void
    typeOfTelephone (const typeOfTelephone_type& x);

    void
    typeOfTelephone (const typeOfTelephone_optional& x);

    void
    typeOfTelephone (::std::unique_ptr< typeOfTelephone_type > p);

    // Constructors.
    //
    Telephone ();

    Telephone (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    Telephone (const Telephone& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual Telephone*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Telephone&
    operator= (const Telephone& x);

    virtual 
    ~Telephone ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    effectiveDates_optional effectiveDates_;
    isPreferred_optional isPreferred_;
    privacy_optional privacy_;
    telephoneNumber_optional telephoneNumber_;
    typeOfTelephone_optional typeOfTelephone_;
  };

  class TextPositionSelector: public ::XMLSchema::Selector
  {
    public:
    // end
    //
    typedef ::xml_schema::integer end_type;
    typedef ::xsd::cxx::tree::traits< end_type, char > end_traits;

    const end_type&
    end () const;

    end_type&
    end ();

    void
    end (const end_type& x);

    // start
    //
    typedef ::xml_schema::integer start_type;
    typedef ::xsd::cxx::tree::traits< start_type, char > start_traits;

    const start_type&
    start () const;

    start_type&
    start ();

    void
    start (const start_type& x);

    // Constructors.
    //
    TextPositionSelector (const end_type&,
                          const start_type&);

    TextPositionSelector (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    TextPositionSelector (const TextPositionSelector& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual TextPositionSelector*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TextPositionSelector&
    operator= (const TextPositionSelector& x);

    virtual 
    ~TextPositionSelector ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< end_type > end_;
    ::xsd::cxx::tree::one< start_type > start_;
  };

  class TimeRole: public ::XMLSchema::SpecializationRole
  {
    public:
    // time
    //
    typedef ::XMLSchema::ControlledVocabularyEntry time_type;
    typedef ::xsd::cxx::tree::optional< time_type > time_optional;
    typedef ::xsd::cxx::tree::traits< time_type, char > time_traits;

    const time_optional&
    time () const;

    time_optional&
    time ();

    void
    time (const time_type& x);

    void
    time (const time_optional& x);

    void
    time (::std::unique_ptr< time_type > p);

    // Constructors.
    //
    TimeRole ();

    TimeRole (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    TimeRole (const TimeRole& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual TimeRole*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TimeRole&
    operator= (const TimeRole& x);

    virtual 
    ~TimeRole ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    time_optional time_;
  };

  class TypedString: public ::xml_schema::type
  {
    public:
    // content
    //
    typedef ::xml_schema::string content_type;
    typedef ::xsd::cxx::tree::traits< content_type, char > content_traits;

    const content_type&
    content () const;

    content_type&
    content ();

    void
    content (const content_type& x);

    void
    content (::std::unique_ptr< content_type > p);

    // typeOfContent
    //
    typedef ::XMLSchema::ControlledVocabularyEntry typeOfContent_type;
    typedef ::xsd::cxx::tree::optional< typeOfContent_type > typeOfContent_optional;
    typedef ::xsd::cxx::tree::traits< typeOfContent_type, char > typeOfContent_traits;

    const typeOfContent_optional&
    typeOfContent () const;

    typeOfContent_optional&
    typeOfContent ();

    void
    typeOfContent (const typeOfContent_type& x);

    void
    typeOfContent (const typeOfContent_optional& x);

    void
    typeOfContent (::std::unique_ptr< typeOfContent_type > p);

    // Constructors.
    //
    TypedString (const content_type&);

    TypedString (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    TypedString (const TypedString& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual TypedString*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TypedString&
    operator= (const TypedString& x);

    virtual 
    ~TypedString ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< content_type > content_;
    typeOfContent_optional typeOfContent_;
  };

  class WebLink: public ::xml_schema::type
  {
    public:
    // effectiveDates
    //
    typedef ::XMLSchema::DateRange effectiveDates_type;
    typedef ::xsd::cxx::tree::optional< effectiveDates_type > effectiveDates_optional;
    typedef ::xsd::cxx::tree::traits< effectiveDates_type, char > effectiveDates_traits;

    const effectiveDates_optional&
    effectiveDates () const;

    effectiveDates_optional&
    effectiveDates ();

    void
    effectiveDates (const effectiveDates_type& x);

    void
    effectiveDates (const effectiveDates_optional& x);

    void
    effectiveDates (::std::unique_ptr< effectiveDates_type > p);

    // isPreferred
    //
    typedef ::xml_schema::boolean isPreferred_type;
    typedef ::xsd::cxx::tree::optional< isPreferred_type > isPreferred_optional;
    typedef ::xsd::cxx::tree::traits< isPreferred_type, char > isPreferred_traits;

    const isPreferred_optional&
    isPreferred () const;

    isPreferred_optional&
    isPreferred ();

    void
    isPreferred (const isPreferred_type& x);

    void
    isPreferred (const isPreferred_optional& x);

    // privacy
    //
    typedef ::XMLSchema::ControlledVocabularyEntry privacy_type;
    typedef ::xsd::cxx::tree::optional< privacy_type > privacy_optional;
    typedef ::xsd::cxx::tree::traits< privacy_type, char > privacy_traits;

    const privacy_optional&
    privacy () const;

    privacy_optional&
    privacy ();

    void
    privacy (const privacy_type& x);

    void
    privacy (const privacy_optional& x);

    void
    privacy (::std::unique_ptr< privacy_type > p);

    // typeOfWebsite
    //
    typedef ::XMLSchema::ControlledVocabularyEntry typeOfWebsite_type;
    typedef ::xsd::cxx::tree::optional< typeOfWebsite_type > typeOfWebsite_optional;
    typedef ::xsd::cxx::tree::traits< typeOfWebsite_type, char > typeOfWebsite_traits;

    const typeOfWebsite_optional&
    typeOfWebsite () const;

    typeOfWebsite_optional&
    typeOfWebsite ();

    void
    typeOfWebsite (const typeOfWebsite_type& x);

    void
    typeOfWebsite (const typeOfWebsite_optional& x);

    void
    typeOfWebsite (::std::unique_ptr< typeOfWebsite_type > p);

    // uri
    //
    typedef ::xml_schema::uri uri_type;
    typedef ::xsd::cxx::tree::optional< uri_type > uri_optional;
    typedef ::xsd::cxx::tree::traits< uri_type, char > uri_traits;

    const uri_optional&
    uri () const;

    uri_optional&
    uri ();

    void
    uri (const uri_type& x);

    void
    uri (const uri_optional& x);

    void
    uri (::std::unique_ptr< uri_type > p);

    // Constructors.
    //
    WebLink ();

    WebLink (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    WebLink (const WebLink& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual WebLink*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    WebLink&
    operator= (const WebLink& x);

    virtual 
    ~WebLink ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    effectiveDates_optional effectiveDates_;
    isPreferred_optional isPreferred_;
    privacy_optional privacy_;
    typeOfWebsite_optional typeOfWebsite_;
    uri_optional uri_;
  };

  class entityProduced: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    entityProduced ();

    entityProduced (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    entityProduced (const entityProduced& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual entityProduced*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    entityProduced&
    operator= (const entityProduced&) = default;
#endif

    virtual 
    ~entityProduced ();
  };

  class entityUsed: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    entityUsed ();

    entityUsed (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    entityUsed (const entityUsed& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual entityUsed*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    entityUsed&
    operator= (const entityUsed&) = default;
#endif

    virtual 
    ~entityUsed ();
  };

  class standardModelMapping: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    standardModelMapping ();

    standardModelMapping (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    standardModelMapping (const standardModelMapping& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual standardModelMapping*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    standardModelMapping&
    operator= (const standardModelMapping&) = default;
#endif

    virtual 
    ~standardModelMapping ();
  };

  class Activity_hasInternal_ControlLogic: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Activity_hasInternal_ControlLogic ();

    Activity_hasInternal_ControlLogic (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    Activity_hasInternal_ControlLogic (const Activity_hasInternal_ControlLogic& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual Activity_hasInternal_ControlLogic*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Activity_hasInternal_ControlLogic&
    operator= (const Activity_hasInternal_ControlLogic&) = default;
#endif

    virtual 
    ~Activity_hasInternal_ControlLogic ();
  };

  class Activity_hasSubActivity_Activity: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Activity_hasSubActivity_Activity ();

    Activity_hasSubActivity_Activity (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    Activity_hasSubActivity_Activity (const Activity_hasSubActivity_Activity& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual Activity_hasSubActivity_Activity*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Activity_hasSubActivity_Activity&
    operator= (const Activity_hasSubActivity_Activity&) = default;
#endif

    virtual 
    ~Activity_hasSubActivity_Activity ();
  };

  class Activity_has_Step: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Activity_has_Step ();

    Activity_has_Step (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    Activity_has_Step (const Activity_has_Step& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual Activity_has_Step*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Activity_has_Step&
    operator= (const Activity_has_Step&) = default;
#endif

    virtual 
    ~Activity_has_Step ();
  };

  class AgentListing_isDefinedBy_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    AgentListing_isDefinedBy_Concept ();

    AgentListing_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    AgentListing_isDefinedBy_Concept (const AgentListing_isDefinedBy_Concept& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual AgentListing_isDefinedBy_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    AgentListing_isDefinedBy_Concept&
    operator= (const AgentListing_isDefinedBy_Concept&) = default;
#endif

    virtual 
    ~AgentListing_isDefinedBy_Concept ();
  };

  class AgentListing_isMaintainedBy_Agent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    AgentListing_isMaintainedBy_Agent ();

    AgentListing_isMaintainedBy_Agent (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    AgentListing_isMaintainedBy_Agent (const AgentListing_isMaintainedBy_Agent& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual AgentListing_isMaintainedBy_Agent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    AgentListing_isMaintainedBy_Agent&
    operator= (const AgentListing_isMaintainedBy_Agent&) = default;
#endif

    virtual 
    ~AgentListing_isMaintainedBy_Agent ();
  };

  class AgentListing_has_AgentPosition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    AgentListing_has_AgentPosition ();

    AgentListing_has_AgentPosition (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    AgentListing_has_AgentPosition (const AgentListing_has_AgentPosition& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual AgentListing_has_AgentPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    AgentListing_has_AgentPosition&
    operator= (const AgentListing_has_AgentPosition&) = default;
#endif

    virtual 
    ~AgentListing_has_AgentPosition ();
  };

  class AgentListing_has_Agent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    AgentListing_has_Agent ();

    AgentListing_has_Agent (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    AgentListing_has_Agent (const AgentListing_has_Agent& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual AgentListing_has_Agent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    AgentListing_has_Agent&
    operator= (const AgentListing_has_Agent&) = default;
#endif

    virtual 
    ~AgentListing_has_Agent ();
  };

  class AgentPosition_indexes_Agent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    AgentPosition_indexes_Agent ();

    AgentPosition_indexes_Agent (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    AgentPosition_indexes_Agent (const AgentPosition_indexes_Agent& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual AgentPosition_indexes_Agent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    AgentPosition_indexes_Agent&
    operator= (const AgentPosition_indexes_Agent&) = default;
#endif

    virtual 
    ~AgentPosition_indexes_Agent ();
  };

  class AgentRelationship_hasSource_Agent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    AgentRelationship_hasSource_Agent ();

    AgentRelationship_hasSource_Agent (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    AgentRelationship_hasSource_Agent (const AgentRelationship_hasSource_Agent& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual AgentRelationship_hasSource_Agent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    AgentRelationship_hasSource_Agent&
    operator= (const AgentRelationship_hasSource_Agent&) = default;
#endif

    virtual 
    ~AgentRelationship_hasSource_Agent ();
  };

  class AgentRelationship_hasTarget_Agent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    AgentRelationship_hasTarget_Agent ();

    AgentRelationship_hasTarget_Agent (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    AgentRelationship_hasTarget_Agent (const AgentRelationship_hasTarget_Agent& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual AgentRelationship_hasTarget_Agent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    AgentRelationship_hasTarget_Agent&
    operator= (const AgentRelationship_hasTarget_Agent&) = default;
#endif

    virtual 
    ~AgentRelationship_hasTarget_Agent ();
  };

  class AgentStructure_structures_AgentListing: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    AgentStructure_structures_AgentListing ();

    AgentStructure_structures_AgentListing (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    AgentStructure_structures_AgentListing (const AgentStructure_structures_AgentListing& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual AgentStructure_structures_AgentListing*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    AgentStructure_structures_AgentListing&
    operator= (const AgentStructure_structures_AgentListing&) = default;
#endif

    virtual 
    ~AgentStructure_structures_AgentListing ();
  };

  class AgentStructure_has_AgentRelationship: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    AgentStructure_has_AgentRelationship ();

    AgentStructure_has_AgentRelationship (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    AgentStructure_has_AgentRelationship (const AgentStructure_has_AgentRelationship& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual AgentStructure_has_AgentRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    AgentStructure_has_AgentRelationship&
    operator= (const AgentStructure_has_AgentRelationship&) = default;
#endif

    virtual 
    ~AgentStructure_has_AgentRelationship ();
  };

  class AttributeComponent_qualifies_DataStructureComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    AttributeComponent_qualifies_DataStructureComponent ();

    AttributeComponent_qualifies_DataStructureComponent (const ::xercesc::DOMElement& e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    AttributeComponent_qualifies_DataStructureComponent (const AttributeComponent_qualifies_DataStructureComponent& x,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    virtual AttributeComponent_qualifies_DataStructureComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    AttributeComponent_qualifies_DataStructureComponent&
    operator= (const AttributeComponent_qualifies_DataStructureComponent&) = default;
#endif

    virtual 
    ~AttributeComponent_qualifies_DataStructureComponent ();
  };

  class AuthorizationSource_has_Agent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    AuthorizationSource_has_Agent ();

    AuthorizationSource_has_Agent (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    AuthorizationSource_has_Agent (const AuthorizationSource_has_Agent& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual AuthorizationSource_has_Agent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    AuthorizationSource_has_Agent&
    operator= (const AuthorizationSource_has_Agent&) = default;
#endif

    virtual 
    ~AuthorizationSource_has_Agent ();
  };

  class CategoryPosition_indexes_Category: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CategoryPosition_indexes_Category ();

    CategoryPosition_indexes_Category (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    CategoryPosition_indexes_Category (const CategoryPosition_indexes_Category& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual CategoryPosition_indexes_Category*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CategoryPosition_indexes_Category&
    operator= (const CategoryPosition_indexes_Category&) = default;
#endif

    virtual 
    ~CategoryPosition_indexes_Category ();
  };

  class CategoryRelationStructure_structures_CategorySet: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CategoryRelationStructure_structures_CategorySet ();

    CategoryRelationStructure_structures_CategorySet (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    CategoryRelationStructure_structures_CategorySet (const CategoryRelationStructure_structures_CategorySet& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    virtual CategoryRelationStructure_structures_CategorySet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CategoryRelationStructure_structures_CategorySet&
    operator= (const CategoryRelationStructure_structures_CategorySet&) = default;
#endif

    virtual 
    ~CategoryRelationStructure_structures_CategorySet ();
  };

  class CategoryRelationStructure_has_CategoryRelationship: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CategoryRelationStructure_has_CategoryRelationship ();

    CategoryRelationStructure_has_CategoryRelationship (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

    CategoryRelationStructure_has_CategoryRelationship (const CategoryRelationStructure_has_CategoryRelationship& x,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

    virtual CategoryRelationStructure_has_CategoryRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CategoryRelationStructure_has_CategoryRelationship&
    operator= (const CategoryRelationStructure_has_CategoryRelationship&) = default;
#endif

    virtual 
    ~CategoryRelationStructure_has_CategoryRelationship ();
  };

  class CategoryRelationship_hasSource_Category: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CategoryRelationship_hasSource_Category ();

    CategoryRelationship_hasSource_Category (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    CategoryRelationship_hasSource_Category (const CategoryRelationship_hasSource_Category& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual CategoryRelationship_hasSource_Category*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CategoryRelationship_hasSource_Category&
    operator= (const CategoryRelationship_hasSource_Category&) = default;
#endif

    virtual 
    ~CategoryRelationship_hasSource_Category ();
  };

  class CategoryRelationship_hasTarget_Category: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CategoryRelationship_hasTarget_Category ();

    CategoryRelationship_hasTarget_Category (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    CategoryRelationship_hasTarget_Category (const CategoryRelationship_hasTarget_Category& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual CategoryRelationship_hasTarget_Category*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CategoryRelationship_hasTarget_Category&
    operator= (const CategoryRelationship_hasTarget_Category&) = default;
#endif

    virtual 
    ~CategoryRelationship_hasTarget_Category ();
  };

  class CategorySet_has_Category: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CategorySet_has_Category ();

    CategorySet_has_Category (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    CategorySet_has_Category (const CategorySet_has_Category& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual CategorySet_has_Category*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CategorySet_has_Category&
    operator= (const CategorySet_has_Category&) = default;
#endif

    virtual 
    ~CategorySet_has_Category ();
  };

  class CategorySet_has_CategoryPosition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CategorySet_has_CategoryPosition ();

    CategorySet_has_CategoryPosition (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    CategorySet_has_CategoryPosition (const CategorySet_has_CategoryPosition& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual CategorySet_has_CategoryPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CategorySet_has_CategoryPosition&
    operator= (const CategorySet_has_CategoryPosition&) = default;
#endif

    virtual 
    ~CategorySet_has_CategoryPosition ();
  };

  class CategoryStatistic_appliesTo_InstanceVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CategoryStatistic_appliesTo_InstanceVariable ();

    CategoryStatistic_appliesTo_InstanceVariable (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    CategoryStatistic_appliesTo_InstanceVariable (const CategoryStatistic_appliesTo_InstanceVariable& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual CategoryStatistic_appliesTo_InstanceVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CategoryStatistic_appliesTo_InstanceVariable&
    operator= (const CategoryStatistic_appliesTo_InstanceVariable&) = default;
#endif

    virtual 
    ~CategoryStatistic_appliesTo_InstanceVariable ();
  };

  class CategoryStatistic_for_Category: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CategoryStatistic_for_Category ();

    CategoryStatistic_for_Category (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    CategoryStatistic_for_Category (const CategoryStatistic_for_Category& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual CategoryStatistic_for_Category*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CategoryStatistic_for_Category&
    operator= (const CategoryStatistic_for_Category&) = default;
#endif

    virtual 
    ~CategoryStatistic_for_Category ();
  };

  class ClassificationFamily_uses_ClassificationIndex: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationFamily_uses_ClassificationIndex ();

    ClassificationFamily_uses_ClassificationIndex (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    ClassificationFamily_uses_ClassificationIndex (const ClassificationFamily_uses_ClassificationIndex& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    virtual ClassificationFamily_uses_ClassificationIndex*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationFamily_uses_ClassificationIndex&
    operator= (const ClassificationFamily_uses_ClassificationIndex&) = default;
#endif

    virtual 
    ~ClassificationFamily_uses_ClassificationIndex ();
  };

  class ClassificationFamily_isDefinedBy_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationFamily_isDefinedBy_Concept ();

    ClassificationFamily_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ClassificationFamily_isDefinedBy_Concept (const ClassificationFamily_isDefinedBy_Concept& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual ClassificationFamily_isDefinedBy_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationFamily_isDefinedBy_Concept&
    operator= (const ClassificationFamily_isDefinedBy_Concept&) = default;
#endif

    virtual 
    ~ClassificationFamily_isDefinedBy_Concept ();
  };

  class ClassificationFamily_groups_ClassificationSeries: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationFamily_groups_ClassificationSeries ();

    ClassificationFamily_groups_ClassificationSeries (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    ClassificationFamily_groups_ClassificationSeries (const ClassificationFamily_groups_ClassificationSeries& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    virtual ClassificationFamily_groups_ClassificationSeries*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationFamily_groups_ClassificationSeries&
    operator= (const ClassificationFamily_groups_ClassificationSeries&) = default;
#endif

    virtual 
    ~ClassificationFamily_groups_ClassificationSeries ();
  };

  class ClassificationIndex_isMaintainedBy_Agent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationIndex_isMaintainedBy_Agent ();

    ClassificationIndex_isMaintainedBy_Agent (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ClassificationIndex_isMaintainedBy_Agent (const ClassificationIndex_isMaintainedBy_Agent& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual ClassificationIndex_isMaintainedBy_Agent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationIndex_isMaintainedBy_Agent&
    operator= (const ClassificationIndex_isMaintainedBy_Agent&) = default;
#endif

    virtual 
    ~ClassificationIndex_isMaintainedBy_Agent ();
  };

  class ClassificationIndex_hasContact_Agent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationIndex_hasContact_Agent ();

    ClassificationIndex_hasContact_Agent (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ClassificationIndex_hasContact_Agent (const ClassificationIndex_hasContact_Agent& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual ClassificationIndex_hasContact_Agent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationIndex_hasContact_Agent&
    operator= (const ClassificationIndex_hasContact_Agent&) = default;
#endif

    virtual 
    ~ClassificationIndex_hasContact_Agent ();
  };

  class ClassificationIndex_isDefinedBy_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationIndex_isDefinedBy_Concept ();

    ClassificationIndex_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    ClassificationIndex_isDefinedBy_Concept (const ClassificationIndex_isDefinedBy_Concept& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual ClassificationIndex_isDefinedBy_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationIndex_isDefinedBy_Concept&
    operator= (const ClassificationIndex_isDefinedBy_Concept&) = default;
#endif

    virtual 
    ~ClassificationIndex_isDefinedBy_Concept ();
  };

  class ClassificationIndex_has_ClassificationIndexEntryPosition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationIndex_has_ClassificationIndexEntryPosition ();

    ClassificationIndex_has_ClassificationIndexEntryPosition (const ::xercesc::DOMElement& e,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    ClassificationIndex_has_ClassificationIndexEntryPosition (const ClassificationIndex_has_ClassificationIndexEntryPosition& x,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    virtual ClassificationIndex_has_ClassificationIndexEntryPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationIndex_has_ClassificationIndexEntryPosition&
    operator= (const ClassificationIndex_has_ClassificationIndexEntryPosition&) = default;
#endif

    virtual 
    ~ClassificationIndex_has_ClassificationIndexEntryPosition ();
  };

  class ClassificationIndex_has_ClassificationIndexEntry: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationIndex_has_ClassificationIndexEntry ();

    ClassificationIndex_has_ClassificationIndexEntry (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    ClassificationIndex_has_ClassificationIndexEntry (const ClassificationIndex_has_ClassificationIndexEntry& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    virtual ClassificationIndex_has_ClassificationIndexEntry*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationIndex_has_ClassificationIndexEntry&
    operator= (const ClassificationIndex_has_ClassificationIndexEntry&) = default;
#endif

    virtual 
    ~ClassificationIndex_has_ClassificationIndexEntry ();
  };

  class ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry ();

    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry (const ::xercesc::DOMElement& e,
                                                                       ::xml_schema::flags f = 0,
                                                                       ::xml_schema::container* c = 0);

    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry (const ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry& x,
                                                                       ::xml_schema::flags f = 0,
                                                                       ::xml_schema::container* c = 0);

    virtual ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry&
    operator= (const ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry&) = default;
#endif

    virtual 
    ~ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry ();
  };

  class ClassificationItem_excludes_ClassificationItem: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationItem_excludes_ClassificationItem ();

    ClassificationItem_excludes_ClassificationItem (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    ClassificationItem_excludes_ClassificationItem (const ClassificationItem_excludes_ClassificationItem& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    virtual ClassificationItem_excludes_ClassificationItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationItem_excludes_ClassificationItem&
    operator= (const ClassificationItem_excludes_ClassificationItem&) = default;
#endif

    virtual 
    ~ClassificationItem_excludes_ClassificationItem ();
  };

  class ClassificationItem_denotes_Category: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationItem_denotes_Category ();

    ClassificationItem_denotes_Category (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    ClassificationItem_denotes_Category (const ClassificationItem_denotes_Category& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual ClassificationItem_denotes_Category*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationItem_denotes_Category&
    operator= (const ClassificationItem_denotes_Category&) = default;
#endif

    virtual 
    ~ClassificationItem_denotes_Category ();
  };

  class ClassificationItem_uses_Notation: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationItem_uses_Notation ();

    ClassificationItem_uses_Notation (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    ClassificationItem_uses_Notation (const ClassificationItem_uses_Notation& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual ClassificationItem_uses_Notation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationItem_uses_Notation&
    operator= (const ClassificationItem_uses_Notation&) = default;
#endif

    virtual 
    ~ClassificationItem_uses_Notation ();
  };

  class ClassificationItem_hasRulingBy_AuthorizationSource: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationItem_hasRulingBy_AuthorizationSource ();

    ClassificationItem_hasRulingBy_AuthorizationSource (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

    ClassificationItem_hasRulingBy_AuthorizationSource (const ClassificationItem_hasRulingBy_AuthorizationSource& x,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

    virtual ClassificationItem_hasRulingBy_AuthorizationSource*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationItem_hasRulingBy_AuthorizationSource&
    operator= (const ClassificationItem_hasRulingBy_AuthorizationSource&) = default;
#endif

    virtual 
    ~ClassificationItem_hasRulingBy_AuthorizationSource ();
  };

  class ClassificationItemPosition_indexes_ClassificationItem: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationItemPosition_indexes_ClassificationItem ();

    ClassificationItemPosition_indexes_ClassificationItem (const ::xercesc::DOMElement& e,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    ClassificationItemPosition_indexes_ClassificationItem (const ClassificationItemPosition_indexes_ClassificationItem& x,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    virtual ClassificationItemPosition_indexes_ClassificationItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationItemPosition_indexes_ClassificationItem&
    operator= (const ClassificationItemPosition_indexes_ClassificationItem&) = default;
#endif

    virtual 
    ~ClassificationItemPosition_indexes_ClassificationItem ();
  };

  class ClassificationItemRelationship_hasSource_ClassificationItem: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationItemRelationship_hasSource_ClassificationItem ();

    ClassificationItemRelationship_hasSource_ClassificationItem (const ::xercesc::DOMElement& e,
                                                                 ::xml_schema::flags f = 0,
                                                                 ::xml_schema::container* c = 0);

    ClassificationItemRelationship_hasSource_ClassificationItem (const ClassificationItemRelationship_hasSource_ClassificationItem& x,
                                                                 ::xml_schema::flags f = 0,
                                                                 ::xml_schema::container* c = 0);

    virtual ClassificationItemRelationship_hasSource_ClassificationItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationItemRelationship_hasSource_ClassificationItem&
    operator= (const ClassificationItemRelationship_hasSource_ClassificationItem&) = default;
#endif

    virtual 
    ~ClassificationItemRelationship_hasSource_ClassificationItem ();
  };

  class ClassificationItemRelationship_hasTarget_ClassificationItem: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationItemRelationship_hasTarget_ClassificationItem ();

    ClassificationItemRelationship_hasTarget_ClassificationItem (const ::xercesc::DOMElement& e,
                                                                 ::xml_schema::flags f = 0,
                                                                 ::xml_schema::container* c = 0);

    ClassificationItemRelationship_hasTarget_ClassificationItem (const ClassificationItemRelationship_hasTarget_ClassificationItem& x,
                                                                 ::xml_schema::flags f = 0,
                                                                 ::xml_schema::container* c = 0);

    virtual ClassificationItemRelationship_hasTarget_ClassificationItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationItemRelationship_hasTarget_ClassificationItem&
    operator= (const ClassificationItemRelationship_hasTarget_ClassificationItem&) = default;
#endif

    virtual 
    ~ClassificationItemRelationship_hasTarget_ClassificationItem ();
  };

  class ClassificationItemStructure_structures_StatisticalClassification: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationItemStructure_structures_StatisticalClassification ();

    ClassificationItemStructure_structures_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                                      ::xml_schema::flags f = 0,
                                                                      ::xml_schema::container* c = 0);

    ClassificationItemStructure_structures_StatisticalClassification (const ClassificationItemStructure_structures_StatisticalClassification& x,
                                                                      ::xml_schema::flags f = 0,
                                                                      ::xml_schema::container* c = 0);

    virtual ClassificationItemStructure_structures_StatisticalClassification*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationItemStructure_structures_StatisticalClassification&
    operator= (const ClassificationItemStructure_structures_StatisticalClassification&) = default;
#endif

    virtual 
    ~ClassificationItemStructure_structures_StatisticalClassification ();
  };

  class ClassificationItemStructure_has_ClassificationItemRelationship: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationItemStructure_has_ClassificationItemRelationship ();

    ClassificationItemStructure_has_ClassificationItemRelationship (const ::xercesc::DOMElement& e,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    ClassificationItemStructure_has_ClassificationItemRelationship (const ClassificationItemStructure_has_ClassificationItemRelationship& x,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    virtual ClassificationItemStructure_has_ClassificationItemRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationItemStructure_has_ClassificationItemRelationship&
    operator= (const ClassificationItemStructure_has_ClassificationItemRelationship&) = default;
#endif

    virtual 
    ~ClassificationItemStructure_has_ClassificationItemRelationship ();
  };

  class ClassificationPosition_indexes_StatisticalClassification: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationPosition_indexes_StatisticalClassification ();

    ClassificationPosition_indexes_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    ClassificationPosition_indexes_StatisticalClassification (const ClassificationPosition_indexes_StatisticalClassification& x,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    virtual ClassificationPosition_indexes_StatisticalClassification*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationPosition_indexes_StatisticalClassification&
    operator= (const ClassificationPosition_indexes_StatisticalClassification&) = default;
#endif

    virtual 
    ~ClassificationPosition_indexes_StatisticalClassification ();
  };

  class ClassificationSeries_isOwnedBy_Agent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationSeries_isOwnedBy_Agent ();

    ClassificationSeries_isOwnedBy_Agent (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ClassificationSeries_isOwnedBy_Agent (const ClassificationSeries_isOwnedBy_Agent& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual ClassificationSeries_isOwnedBy_Agent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationSeries_isOwnedBy_Agent&
    operator= (const ClassificationSeries_isOwnedBy_Agent&) = default;
#endif

    virtual 
    ~ClassificationSeries_isOwnedBy_Agent ();
  };

  class ClassificationSeries_isDefinedBy_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationSeries_isDefinedBy_Concept ();

    ClassificationSeries_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ClassificationSeries_isDefinedBy_Concept (const ClassificationSeries_isDefinedBy_Concept& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual ClassificationSeries_isDefinedBy_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationSeries_isDefinedBy_Concept&
    operator= (const ClassificationSeries_isDefinedBy_Concept&) = default;
#endif

    virtual 
    ~ClassificationSeries_isDefinedBy_Concept ();
  };

  class ClassificationSeries_has_StatisticalClassification: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationSeries_has_StatisticalClassification ();

    ClassificationSeries_has_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

    ClassificationSeries_has_StatisticalClassification (const ClassificationSeries_has_StatisticalClassification& x,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

    virtual ClassificationSeries_has_StatisticalClassification*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationSeries_has_StatisticalClassification&
    operator= (const ClassificationSeries_has_StatisticalClassification&) = default;
#endif

    virtual 
    ~ClassificationSeries_has_StatisticalClassification ();
  };

  class ClassificationSeries_has_ClassificationPosition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationSeries_has_ClassificationPosition ();

    ClassificationSeries_has_ClassificationPosition (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    ClassificationSeries_has_ClassificationPosition (const ClassificationSeries_has_ClassificationPosition& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    virtual ClassificationSeries_has_ClassificationPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationSeries_has_ClassificationPosition&
    operator= (const ClassificationSeries_has_ClassificationPosition&) = default;
#endif

    virtual 
    ~ClassificationSeries_has_ClassificationPosition ();
  };

  class ClassificationSeriesStructure_structures_ClassificationSeries: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationSeriesStructure_structures_ClassificationSeries ();

    ClassificationSeriesStructure_structures_ClassificationSeries (const ::xercesc::DOMElement& e,
                                                                   ::xml_schema::flags f = 0,
                                                                   ::xml_schema::container* c = 0);

    ClassificationSeriesStructure_structures_ClassificationSeries (const ClassificationSeriesStructure_structures_ClassificationSeries& x,
                                                                   ::xml_schema::flags f = 0,
                                                                   ::xml_schema::container* c = 0);

    virtual ClassificationSeriesStructure_structures_ClassificationSeries*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationSeriesStructure_structures_ClassificationSeries&
    operator= (const ClassificationSeriesStructure_structures_ClassificationSeries&) = default;
#endif

    virtual 
    ~ClassificationSeriesStructure_structures_ClassificationSeries ();
  };

  class ClassificationSeriesStructure_has_StatisticalClassificationRelationship: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ClassificationSeriesStructure_has_StatisticalClassificationRelationship ();

    ClassificationSeriesStructure_has_StatisticalClassificationRelationship (const ::xercesc::DOMElement& e,
                                                                             ::xml_schema::flags f = 0,
                                                                             ::xml_schema::container* c = 0);

    ClassificationSeriesStructure_has_StatisticalClassificationRelationship (const ClassificationSeriesStructure_has_StatisticalClassificationRelationship& x,
                                                                             ::xml_schema::flags f = 0,
                                                                             ::xml_schema::container* c = 0);

    virtual ClassificationSeriesStructure_has_StatisticalClassificationRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ClassificationSeriesStructure_has_StatisticalClassificationRelationship&
    operator= (const ClassificationSeriesStructure_has_StatisticalClassificationRelationship&) = default;
#endif

    virtual 
    ~ClassificationSeriesStructure_has_StatisticalClassificationRelationship ();
  };

  class Code_denotes_Category: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Code_denotes_Category ();

    Code_denotes_Category (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    Code_denotes_Category (const Code_denotes_Category& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual Code_denotes_Category*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Code_denotes_Category&
    operator= (const Code_denotes_Category&) = default;
#endif

    virtual 
    ~Code_denotes_Category ();
  };

  class Code_uses_Notation: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Code_uses_Notation ();

    Code_uses_Notation (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    Code_uses_Notation (const Code_uses_Notation& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual Code_uses_Notation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Code_uses_Notation&
    operator= (const Code_uses_Notation&) = default;
#endif

    virtual 
    ~Code_uses_Notation ();
  };

  class CodeList_has_CodePosition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CodeList_has_CodePosition ();

    CodeList_has_CodePosition (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    CodeList_has_CodePosition (const CodeList_has_CodePosition& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual CodeList_has_CodePosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CodeList_has_CodePosition&
    operator= (const CodeList_has_CodePosition&) = default;
#endif

    virtual 
    ~CodeList_has_CodePosition ();
  };

  class CodeList_has_Code: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CodeList_has_Code ();

    CodeList_has_Code (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    CodeList_has_Code (const CodeList_has_Code& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual CodeList_has_Code*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CodeList_has_Code&
    operator= (const CodeList_has_Code&) = default;
#endif

    virtual 
    ~CodeList_has_Code ();
  };

  class CodeListStructure_structures_CodeList: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CodeListStructure_structures_CodeList ();

    CodeListStructure_structures_CodeList (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    CodeListStructure_structures_CodeList (const CodeListStructure_structures_CodeList& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual CodeListStructure_structures_CodeList*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CodeListStructure_structures_CodeList&
    operator= (const CodeListStructure_structures_CodeList&) = default;
#endif

    virtual 
    ~CodeListStructure_structures_CodeList ();
  };

  class CodeListStructure_has_CodeRelationship: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CodeListStructure_has_CodeRelationship ();

    CodeListStructure_has_CodeRelationship (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    CodeListStructure_has_CodeRelationship (const CodeListStructure_has_CodeRelationship& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual CodeListStructure_has_CodeRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CodeListStructure_has_CodeRelationship&
    operator= (const CodeListStructure_has_CodeRelationship&) = default;
#endif

    virtual 
    ~CodeListStructure_has_CodeRelationship ();
  };

  class CodePosition_indexes_Code: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CodePosition_indexes_Code ();

    CodePosition_indexes_Code (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    CodePosition_indexes_Code (const CodePosition_indexes_Code& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual CodePosition_indexes_Code*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CodePosition_indexes_Code&
    operator= (const CodePosition_indexes_Code&) = default;
#endif

    virtual 
    ~CodePosition_indexes_Code ();
  };

  class CodeRelationship_hasTarget_Code: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CodeRelationship_hasTarget_Code ();

    CodeRelationship_hasTarget_Code (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    CodeRelationship_hasTarget_Code (const CodeRelationship_hasTarget_Code& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual CodeRelationship_hasTarget_Code*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CodeRelationship_hasTarget_Code&
    operator= (const CodeRelationship_hasTarget_Code&) = default;
#endif

    virtual 
    ~CodeRelationship_hasTarget_Code ();
  };

  class CodeRelationship_hasSource_Code: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CodeRelationship_hasSource_Code ();

    CodeRelationship_hasSource_Code (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    CodeRelationship_hasSource_Code (const CodeRelationship_hasSource_Code& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual CodeRelationship_hasSource_Code*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CodeRelationship_hasSource_Code&
    operator= (const CodeRelationship_hasSource_Code&) = default;
#endif

    virtual 
    ~CodeRelationship_hasSource_Code ();
  };

  class ComponentPosition_indexes_DataStructureComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ComponentPosition_indexes_DataStructureComponent ();

    ComponentPosition_indexes_DataStructureComponent (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    ComponentPosition_indexes_DataStructureComponent (const ComponentPosition_indexes_DataStructureComponent& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    virtual ComponentPosition_indexes_DataStructureComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ComponentPosition_indexes_DataStructureComponent&
    operator= (const ComponentPosition_indexes_DataStructureComponent&) = default;
#endif

    virtual 
    ~ComponentPosition_indexes_DataStructureComponent ();
  };

  class externalDefinition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    externalDefinition ();

    externalDefinition (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    externalDefinition (const externalDefinition& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual externalDefinition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    externalDefinition&
    operator= (const externalDefinition&) = default;
#endif

    virtual 
    ~externalDefinition ();
  };

  class Concept_uses_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Concept_uses_Concept ();

    Concept_uses_Concept (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    Concept_uses_Concept (const Concept_uses_Concept& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual Concept_uses_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Concept_uses_Concept&
    operator= (const Concept_uses_Concept&) = default;
#endif

    virtual 
    ~Concept_uses_Concept ();
  };

  class ConceptMap_hasSource_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptMap_hasSource_Concept ();

    ConceptMap_hasSource_Concept (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ConceptMap_hasSource_Concept (const ConceptMap_hasSource_Concept& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ConceptMap_hasSource_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptMap_hasSource_Concept&
    operator= (const ConceptMap_hasSource_Concept&) = default;
#endif

    virtual 
    ~ConceptMap_hasSource_Concept ();
  };

  class ConceptMap_hasTarget_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptMap_hasTarget_Concept ();

    ConceptMap_hasTarget_Concept (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    ConceptMap_hasTarget_Concept (const ConceptMap_hasTarget_Concept& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual ConceptMap_hasTarget_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptMap_hasTarget_Concept&
    operator= (const ConceptMap_hasTarget_Concept&) = default;
#endif

    virtual 
    ~ConceptMap_hasTarget_Concept ();
  };

  class ConceptRelationship_hasSource_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptRelationship_hasSource_Concept ();

    ConceptRelationship_hasSource_Concept (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ConceptRelationship_hasSource_Concept (const ConceptRelationship_hasSource_Concept& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual ConceptRelationship_hasSource_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptRelationship_hasSource_Concept&
    operator= (const ConceptRelationship_hasSource_Concept&) = default;
#endif

    virtual 
    ~ConceptRelationship_hasSource_Concept ();
  };

  class ConceptRelationship_hasTarget_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptRelationship_hasTarget_Concept ();

    ConceptRelationship_hasTarget_Concept (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    ConceptRelationship_hasTarget_Concept (const ConceptRelationship_hasTarget_Concept& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual ConceptRelationship_hasTarget_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptRelationship_hasTarget_Concept&
    operator= (const ConceptRelationship_hasTarget_Concept&) = default;
#endif

    virtual 
    ~ConceptRelationship_hasTarget_Concept ();
  };

  class ConceptStructure_structures_ConceptSystem: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptStructure_structures_ConceptSystem ();

    ConceptStructure_structures_ConceptSystem (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    ConceptStructure_structures_ConceptSystem (const ConceptStructure_structures_ConceptSystem& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual ConceptStructure_structures_ConceptSystem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptStructure_structures_ConceptSystem&
    operator= (const ConceptStructure_structures_ConceptSystem&) = default;
#endif

    virtual 
    ~ConceptStructure_structures_ConceptSystem ();
  };

  class ConceptStructure_has_ConceptRelationship: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptStructure_has_ConceptRelationship ();

    ConceptStructure_has_ConceptRelationship (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ConceptStructure_has_ConceptRelationship (const ConceptStructure_has_ConceptRelationship& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual ConceptStructure_has_ConceptRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptStructure_has_ConceptRelationship&
    operator= (const ConceptStructure_has_ConceptRelationship&) = default;
#endif

    virtual 
    ~ConceptStructure_has_ConceptRelationship ();
  };

  class ConceptSystem_isDefinedBy_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptSystem_isDefinedBy_Concept ();

    ConceptSystem_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    ConceptSystem_isDefinedBy_Concept (const ConceptSystem_isDefinedBy_Concept& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual ConceptSystem_isDefinedBy_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptSystem_isDefinedBy_Concept&
    operator= (const ConceptSystem_isDefinedBy_Concept&) = default;
#endif

    virtual 
    ~ConceptSystem_isDefinedBy_Concept ();
  };

  class ConceptSystem_has_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptSystem_has_Concept ();

    ConceptSystem_has_Concept (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    ConceptSystem_has_Concept (const ConceptSystem_has_Concept& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual ConceptSystem_has_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptSystem_has_Concept&
    operator= (const ConceptSystem_has_Concept&) = default;
#endif

    virtual 
    ~ConceptSystem_has_Concept ();
  };

  class ConceptSystemCorrespondence_maps_ConceptSystem: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptSystemCorrespondence_maps_ConceptSystem ();

    ConceptSystemCorrespondence_maps_ConceptSystem (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    ConceptSystemCorrespondence_maps_ConceptSystem (const ConceptSystemCorrespondence_maps_ConceptSystem& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    virtual ConceptSystemCorrespondence_maps_ConceptSystem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptSystemCorrespondence_maps_ConceptSystem&
    operator= (const ConceptSystemCorrespondence_maps_ConceptSystem&) = default;
#endif

    virtual 
    ~ConceptSystemCorrespondence_maps_ConceptSystem ();
  };

  class ConceptSystemCorrespondence_has_ConceptMap: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptSystemCorrespondence_has_ConceptMap ();

    ConceptSystemCorrespondence_has_ConceptMap (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ConceptSystemCorrespondence_has_ConceptMap (const ConceptSystemCorrespondence_has_ConceptMap& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual ConceptSystemCorrespondence_has_ConceptMap*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptSystemCorrespondence_has_ConceptMap&
    operator= (const ConceptSystemCorrespondence_has_ConceptMap&) = default;
#endif

    virtual 
    ~ConceptSystemCorrespondence_has_ConceptMap ();
  };

  class ConceptualDomain_isDescribedBy_ValueAndConceptDescription: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptualDomain_isDescribedBy_ValueAndConceptDescription ();

    ConceptualDomain_isDescribedBy_ValueAndConceptDescription (const ::xercesc::DOMElement& e,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

    ConceptualDomain_isDescribedBy_ValueAndConceptDescription (const ConceptualDomain_isDescribedBy_ValueAndConceptDescription& x,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

    virtual ConceptualDomain_isDescribedBy_ValueAndConceptDescription*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptualDomain_isDescribedBy_ValueAndConceptDescription&
    operator= (const ConceptualDomain_isDescribedBy_ValueAndConceptDescription&) = default;
#endif

    virtual 
    ~ConceptualDomain_isDescribedBy_ValueAndConceptDescription ();
  };

  class ConceptualDomain_takesConceptsFrom_ConceptSystem: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptualDomain_takesConceptsFrom_ConceptSystem ();

    ConceptualDomain_takesConceptsFrom_ConceptSystem (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    ConceptualDomain_takesConceptsFrom_ConceptSystem (const ConceptualDomain_takesConceptsFrom_ConceptSystem& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    virtual ConceptualDomain_takesConceptsFrom_ConceptSystem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptualDomain_takesConceptsFrom_ConceptSystem&
    operator= (const ConceptualDomain_takesConceptsFrom_ConceptSystem&) = default;
#endif

    virtual 
    ~ConceptualDomain_takesConceptsFrom_ConceptSystem ();
  };

  class ConceptualValue_hasConceptFrom_ConceptualDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptualValue_hasConceptFrom_ConceptualDomain ();

    ConceptualValue_hasConceptFrom_ConceptualDomain (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    ConceptualValue_hasConceptFrom_ConceptualDomain (const ConceptualValue_hasConceptFrom_ConceptualDomain& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    virtual ConceptualValue_hasConceptFrom_ConceptualDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptualValue_hasConceptFrom_ConceptualDomain&
    operator= (const ConceptualValue_hasConceptFrom_ConceptualDomain&) = default;
#endif

    virtual 
    ~ConceptualValue_hasConceptFrom_ConceptualDomain ();
  };

  class ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain ();

    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain (const ::xercesc::DOMElement& e,
                                                                           ::xml_schema::flags f = 0,
                                                                           ::xml_schema::container* c = 0);

    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain (const ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain& x,
                                                                           ::xml_schema::flags f = 0,
                                                                           ::xml_schema::container* c = 0);

    virtual ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain&
    operator= (const ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain&) = default;
#endif

    virtual 
    ~ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain ();
  };

  class ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain ();

    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain (const ::xercesc::DOMElement& e,
                                                                                 ::xml_schema::flags f = 0,
                                                                                 ::xml_schema::container* c = 0);

    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain (const ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain& x,
                                                                                 ::xml_schema::flags f = 0,
                                                                                 ::xml_schema::container* c = 0);

    virtual ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain&
    operator= (const ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain&) = default;
#endif

    virtual 
    ~ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain ();
  };

  class ConceptualVariable_measures_UnitType: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ConceptualVariable_measures_UnitType ();

    ConceptualVariable_measures_UnitType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ConceptualVariable_measures_UnitType (const ConceptualVariable_measures_UnitType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual ConceptualVariable_measures_UnitType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ConceptualVariable_measures_UnitType&
    operator= (const ConceptualVariable_measures_UnitType&) = default;
#endif

    virtual 
    ~ConceptualVariable_measures_UnitType ();
  };

  class ControlLogic_informs_ProcessingAgent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ControlLogic_informs_ProcessingAgent ();

    ControlLogic_informs_ProcessingAgent (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    ControlLogic_informs_ProcessingAgent (const ControlLogic_informs_ProcessingAgent& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual ControlLogic_informs_ProcessingAgent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ControlLogic_informs_ProcessingAgent&
    operator= (const ControlLogic_informs_ProcessingAgent&) = default;
#endif

    virtual 
    ~ControlLogic_informs_ProcessingAgent ();
  };

  class ControlLogic_invokes_Activity: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ControlLogic_invokes_Activity ();

    ControlLogic_invokes_Activity (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    ControlLogic_invokes_Activity (const ControlLogic_invokes_Activity& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual ControlLogic_invokes_Activity*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ControlLogic_invokes_Activity&
    operator= (const ControlLogic_invokes_Activity&) = default;
#endif

    virtual 
    ~ControlLogic_invokes_Activity ();
  };

  class ControlLogic_hasSubControlLogic_ControlLogic: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ControlLogic_hasSubControlLogic_ControlLogic ();

    ControlLogic_hasSubControlLogic_ControlLogic (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    ControlLogic_hasSubControlLogic_ControlLogic (const ControlLogic_hasSubControlLogic_ControlLogic& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual ControlLogic_hasSubControlLogic_ControlLogic*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ControlLogic_hasSubControlLogic_ControlLogic&
    operator= (const ControlLogic_hasSubControlLogic_ControlLogic&) = default;
#endif

    virtual 
    ~ControlLogic_hasSubControlLogic_ControlLogic ();
  };

  class ControlLogic_has_InformationFlowDefinition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ControlLogic_has_InformationFlowDefinition ();

    ControlLogic_has_InformationFlowDefinition (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    ControlLogic_has_InformationFlowDefinition (const ControlLogic_has_InformationFlowDefinition& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual ControlLogic_has_InformationFlowDefinition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ControlLogic_has_InformationFlowDefinition&
    operator= (const ControlLogic_has_InformationFlowDefinition&) = default;
#endif

    virtual 
    ~ControlLogic_has_InformationFlowDefinition ();
  };

  class CorrespondenceTable_hasSource_Level: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CorrespondenceTable_hasSource_Level ();

    CorrespondenceTable_hasSource_Level (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    CorrespondenceTable_hasSource_Level (const CorrespondenceTable_hasSource_Level& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual CorrespondenceTable_hasSource_Level*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CorrespondenceTable_hasSource_Level&
    operator= (const CorrespondenceTable_hasSource_Level&) = default;
#endif

    virtual 
    ~CorrespondenceTable_hasSource_Level ();
  };

  class CorrespondenceTable_hasTarget_Level: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CorrespondenceTable_hasTarget_Level ();

    CorrespondenceTable_hasTarget_Level (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    CorrespondenceTable_hasTarget_Level (const CorrespondenceTable_hasTarget_Level& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual CorrespondenceTable_hasTarget_Level*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CorrespondenceTable_hasTarget_Level&
    operator= (const CorrespondenceTable_hasTarget_Level&) = default;
#endif

    virtual 
    ~CorrespondenceTable_hasTarget_Level ();
  };

  class CorrespondenceTable_isOwnedBy_Agent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CorrespondenceTable_isOwnedBy_Agent ();

    CorrespondenceTable_isOwnedBy_Agent (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    CorrespondenceTable_isOwnedBy_Agent (const CorrespondenceTable_isOwnedBy_Agent& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual CorrespondenceTable_isOwnedBy_Agent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CorrespondenceTable_isOwnedBy_Agent&
    operator= (const CorrespondenceTable_isOwnedBy_Agent&) = default;
#endif

    virtual 
    ~CorrespondenceTable_isOwnedBy_Agent ();
  };

  class CorrespondenceTable_mapsTo_StatisticalClassification: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CorrespondenceTable_mapsTo_StatisticalClassification ();

    CorrespondenceTable_mapsTo_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    CorrespondenceTable_mapsTo_StatisticalClassification (const CorrespondenceTable_mapsTo_StatisticalClassification& x,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    virtual CorrespondenceTable_mapsTo_StatisticalClassification*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CorrespondenceTable_mapsTo_StatisticalClassification&
    operator= (const CorrespondenceTable_mapsTo_StatisticalClassification&) = default;
#endif

    virtual 
    ~CorrespondenceTable_mapsTo_StatisticalClassification ();
  };

  class CorrespondenceTable_hasContact_Agent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CorrespondenceTable_hasContact_Agent ();

    CorrespondenceTable_hasContact_Agent (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    CorrespondenceTable_hasContact_Agent (const CorrespondenceTable_hasContact_Agent& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual CorrespondenceTable_hasContact_Agent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CorrespondenceTable_hasContact_Agent&
    operator= (const CorrespondenceTable_hasContact_Agent&) = default;
#endif

    virtual 
    ~CorrespondenceTable_hasContact_Agent ();
  };

  class CorrespondenceTable_isMaintainedBy_Agent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CorrespondenceTable_isMaintainedBy_Agent ();

    CorrespondenceTable_isMaintainedBy_Agent (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    CorrespondenceTable_isMaintainedBy_Agent (const CorrespondenceTable_isMaintainedBy_Agent& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual CorrespondenceTable_isMaintainedBy_Agent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CorrespondenceTable_isMaintainedBy_Agent&
    operator= (const CorrespondenceTable_isMaintainedBy_Agent&) = default;
#endif

    virtual 
    ~CorrespondenceTable_isMaintainedBy_Agent ();
  };

  class CorrespondenceTable_has_ConceptMap: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    CorrespondenceTable_has_ConceptMap ();

    CorrespondenceTable_has_ConceptMap (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    CorrespondenceTable_has_ConceptMap (const CorrespondenceTable_has_ConceptMap& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual CorrespondenceTable_has_ConceptMap*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    CorrespondenceTable_has_ConceptMap&
    operator= (const CorrespondenceTable_has_ConceptMap&) = default;
#endif

    virtual 
    ~CorrespondenceTable_has_ConceptMap ();
  };

  class DataPoint_correspondsTo_DataStructureComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataPoint_correspondsTo_DataStructureComponent ();

    DataPoint_correspondsTo_DataStructureComponent (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    DataPoint_correspondsTo_DataStructureComponent (const DataPoint_correspondsTo_DataStructureComponent& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    virtual DataPoint_correspondsTo_DataStructureComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataPoint_correspondsTo_DataStructureComponent&
    operator= (const DataPoint_correspondsTo_DataStructureComponent&) = default;
#endif

    virtual 
    ~DataPoint_correspondsTo_DataStructureComponent ();
  };

  class DataPoint_isDescribedBy_InstanceVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataPoint_isDescribedBy_InstanceVariable ();

    DataPoint_isDescribedBy_InstanceVariable (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    DataPoint_isDescribedBy_InstanceVariable (const DataPoint_isDescribedBy_InstanceVariable& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual DataPoint_isDescribedBy_InstanceVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataPoint_isDescribedBy_InstanceVariable&
    operator= (const DataPoint_isDescribedBy_InstanceVariable&) = default;
#endif

    virtual 
    ~DataPoint_isDescribedBy_InstanceVariable ();
  };

  class DataPointPosition_indexes_DataPoint: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataPointPosition_indexes_DataPoint ();

    DataPointPosition_indexes_DataPoint (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    DataPointPosition_indexes_DataPoint (const DataPointPosition_indexes_DataPoint& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual DataPointPosition_indexes_DataPoint*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataPointPosition_indexes_DataPoint&
    operator= (const DataPointPosition_indexes_DataPoint&) = default;
#endif

    virtual 
    ~DataPointPosition_indexes_DataPoint ();
  };

  class DataPointRelationship_hasTarget_DataPoint: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataPointRelationship_hasTarget_DataPoint ();

    DataPointRelationship_hasTarget_DataPoint (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    DataPointRelationship_hasTarget_DataPoint (const DataPointRelationship_hasTarget_DataPoint& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual DataPointRelationship_hasTarget_DataPoint*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataPointRelationship_hasTarget_DataPoint&
    operator= (const DataPointRelationship_hasTarget_DataPoint&) = default;
#endif

    virtual 
    ~DataPointRelationship_hasTarget_DataPoint ();
  };

  class DataPointRelationship_hasSource_DataPoint: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataPointRelationship_hasSource_DataPoint ();

    DataPointRelationship_hasSource_DataPoint (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    DataPointRelationship_hasSource_DataPoint (const DataPointRelationship_hasSource_DataPoint& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual DataPointRelationship_hasSource_DataPoint*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataPointRelationship_hasSource_DataPoint&
    operator= (const DataPointRelationship_hasSource_DataPoint&) = default;
#endif

    virtual 
    ~DataPointRelationship_hasSource_DataPoint ();
  };

  class DataSet_isStructuredBy_DataStructure: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataSet_isStructuredBy_DataStructure ();

    DataSet_isStructuredBy_DataStructure (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    DataSet_isStructuredBy_DataStructure (const DataSet_isStructuredBy_DataStructure& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual DataSet_isStructuredBy_DataStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataSet_isStructuredBy_DataStructure&
    operator= (const DataSet_isStructuredBy_DataStructure&) = default;
#endif

    virtual 
    ~DataSet_isStructuredBy_DataStructure ();
  };

  class DataSet_has_DataPoint: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataSet_has_DataPoint ();

    DataSet_has_DataPoint (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    DataSet_has_DataPoint (const DataSet_has_DataPoint& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual DataSet_has_DataPoint*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataSet_has_DataPoint&
    operator= (const DataSet_has_DataPoint&) = default;
#endif

    virtual 
    ~DataSet_has_DataPoint ();
  };

  class DataSet_has_Key: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataSet_has_Key ();

    DataSet_has_Key (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    DataSet_has_Key (const DataSet_has_Key& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual DataSet_has_Key*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataSet_has_Key&
    operator= (const DataSet_has_Key&) = default;
#endif

    virtual 
    ~DataSet_has_Key ();
  };

  class DataStore_isDefinedBy_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataStore_isDefinedBy_Concept ();

    DataStore_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    DataStore_isDefinedBy_Concept (const DataStore_isDefinedBy_Concept& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual DataStore_isDefinedBy_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataStore_isDefinedBy_Concept&
    operator= (const DataStore_isDefinedBy_Concept&) = default;
#endif

    virtual 
    ~DataStore_isDefinedBy_Concept ();
  };

  class DataStore_has_LogicalRecordPosition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataStore_has_LogicalRecordPosition ();

    DataStore_has_LogicalRecordPosition (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    DataStore_has_LogicalRecordPosition (const DataStore_has_LogicalRecordPosition& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual DataStore_has_LogicalRecordPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataStore_has_LogicalRecordPosition&
    operator= (const DataStore_has_LogicalRecordPosition&) = default;
#endif

    virtual 
    ~DataStore_has_LogicalRecordPosition ();
  };

  class DataStore_has_LogicalRecord: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataStore_has_LogicalRecord ();

    DataStore_has_LogicalRecord (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    DataStore_has_LogicalRecord (const DataStore_has_LogicalRecord& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual DataStore_has_LogicalRecord*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataStore_has_LogicalRecord&
    operator= (const DataStore_has_LogicalRecord&) = default;
#endif

    virtual 
    ~DataStore_has_LogicalRecord ();
  };

  class DataStore_has_RecordRelation: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataStore_has_RecordRelation ();

    DataStore_has_RecordRelation (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    DataStore_has_RecordRelation (const DataStore_has_RecordRelation& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual DataStore_has_RecordRelation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataStore_has_RecordRelation&
    operator= (const DataStore_has_RecordRelation&) = default;
#endif

    virtual 
    ~DataStore_has_RecordRelation ();
  };

  class DataStructure_has_ForeignKey: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataStructure_has_ForeignKey ();

    DataStructure_has_ForeignKey (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    DataStructure_has_ForeignKey (const DataStructure_has_ForeignKey& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual DataStructure_has_ForeignKey*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataStructure_has_ForeignKey&
    operator= (const DataStructure_has_ForeignKey&) = default;
#endif

    virtual 
    ~DataStructure_has_ForeignKey ();
  };

  class DataStructure_has_DataStructureComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataStructure_has_DataStructureComponent ();

    DataStructure_has_DataStructureComponent (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    DataStructure_has_DataStructureComponent (const DataStructure_has_DataStructureComponent& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual DataStructure_has_DataStructureComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataStructure_has_DataStructureComponent&
    operator= (const DataStructure_has_DataStructureComponent&) = default;
#endif

    virtual 
    ~DataStructure_has_DataStructureComponent ();
  };

  class DataStructure_has_ComponentPosition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataStructure_has_ComponentPosition ();

    DataStructure_has_ComponentPosition (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    DataStructure_has_ComponentPosition (const DataStructure_has_ComponentPosition& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual DataStructure_has_ComponentPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataStructure_has_ComponentPosition&
    operator= (const DataStructure_has_ComponentPosition&) = default;
#endif

    virtual 
    ~DataStructure_has_ComponentPosition ();
  };

  class DataStructure_has_PrimaryKey: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataStructure_has_PrimaryKey ();

    DataStructure_has_PrimaryKey (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    DataStructure_has_PrimaryKey (const DataStructure_has_PrimaryKey& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual DataStructure_has_PrimaryKey*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataStructure_has_PrimaryKey&
    operator= (const DataStructure_has_PrimaryKey&) = default;
#endif

    virtual 
    ~DataStructure_has_PrimaryKey ();
  };

  class DataStructureComponent_isDefinedBy_RepresentedVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DataStructureComponent_isDefinedBy_RepresentedVariable ();

    DataStructureComponent_isDefinedBy_RepresentedVariable (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

    DataStructureComponent_isDefinedBy_RepresentedVariable (const DataStructureComponent_isDefinedBy_RepresentedVariable& x,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

    virtual DataStructureComponent_isDefinedBy_RepresentedVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DataStructureComponent_isDefinedBy_RepresentedVariable&
    operator= (const DataStructureComponent_isDefinedBy_RepresentedVariable&) = default;
#endif

    virtual 
    ~DataStructureComponent_isDefinedBy_RepresentedVariable ();
  };

  class Datum_uses_Notation: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Datum_uses_Notation ();

    Datum_uses_Notation (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    Datum_uses_Notation (const Datum_uses_Notation& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual Datum_uses_Notation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Datum_uses_Notation&
    operator= (const Datum_uses_Notation&) = default;
#endif

    virtual 
    ~Datum_uses_Notation ();
  };

  class Datum_denotes_ConceptualValue: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Datum_denotes_ConceptualValue ();

    Datum_denotes_ConceptualValue (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    Datum_denotes_ConceptualValue (const Datum_denotes_ConceptualValue& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual Datum_denotes_ConceptualValue*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Datum_denotes_ConceptualValue&
    operator= (const Datum_denotes_ConceptualValue&) = default;
#endif

    virtual 
    ~Datum_denotes_ConceptualValue ();
  };

  class Datum_uses_InstanceValue: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Datum_uses_InstanceValue ();

    Datum_uses_InstanceValue (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    Datum_uses_InstanceValue (const Datum_uses_InstanceValue& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual Datum_uses_InstanceValue*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Datum_uses_InstanceValue&
    operator= (const Datum_uses_InstanceValue&) = default;
#endif

    virtual 
    ~Datum_uses_InstanceValue ();
  };

  class Datum_isBoundedBy_InstanceVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Datum_isBoundedBy_InstanceVariable ();

    Datum_isBoundedBy_InstanceVariable (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    Datum_isBoundedBy_InstanceVariable (const Datum_isBoundedBy_InstanceVariable& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual Datum_isBoundedBy_InstanceVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Datum_isBoundedBy_InstanceVariable&
    operator= (const Datum_isBoundedBy_InstanceVariable&) = default;
#endif

    virtual 
    ~Datum_isBoundedBy_InstanceVariable ();
  };

  class Descriptor_refersTo_ReferenceValue: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Descriptor_refersTo_ReferenceValue ();

    Descriptor_refersTo_ReferenceValue (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    Descriptor_refersTo_ReferenceValue (const Descriptor_refersTo_ReferenceValue& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual Descriptor_refersTo_ReferenceValue*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Descriptor_refersTo_ReferenceValue&
    operator= (const Descriptor_refersTo_ReferenceValue&) = default;
#endif

    virtual 
    ~Descriptor_refersTo_ReferenceValue ();
  };

  class Descriptor_identifies_ReferenceVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Descriptor_identifies_ReferenceVariable ();

    Descriptor_identifies_ReferenceVariable (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    Descriptor_identifies_ReferenceVariable (const Descriptor_identifies_ReferenceVariable& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual Descriptor_identifies_ReferenceVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Descriptor_identifies_ReferenceVariable&
    operator= (const Descriptor_identifies_ReferenceVariable&) = default;
#endif

    virtual 
    ~Descriptor_identifies_ReferenceVariable ();
  };

  class Descriptor_hasValueFrom_DescriptorValueDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Descriptor_hasValueFrom_DescriptorValueDomain ();

    Descriptor_hasValueFrom_DescriptorValueDomain (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    Descriptor_hasValueFrom_DescriptorValueDomain (const Descriptor_hasValueFrom_DescriptorValueDomain& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    virtual Descriptor_hasValueFrom_DescriptorValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Descriptor_hasValueFrom_DescriptorValueDomain&
    operator= (const Descriptor_hasValueFrom_DescriptorValueDomain&) = default;
#endif

    virtual 
    ~Descriptor_hasValueFrom_DescriptorValueDomain ();
  };

  class DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain ();

    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain (const ::xercesc::DOMElement& e,
                                                                         ::xml_schema::flags f = 0,
                                                                         ::xml_schema::container* c = 0);

    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain (const DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain& x,
                                                                         ::xml_schema::flags f = 0,
                                                                         ::xml_schema::container* c = 0);

    virtual DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain&
    operator= (const DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain&) = default;
#endif

    virtual 
    ~DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain ();
  };

  class DimensionComponent_isStructuredBy_ValueDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DimensionComponent_isStructuredBy_ValueDomain ();

    DimensionComponent_isStructuredBy_ValueDomain (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    DimensionComponent_isStructuredBy_ValueDomain (const DimensionComponent_isStructuredBy_ValueDomain& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

    virtual DimensionComponent_isStructuredBy_ValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DimensionComponent_isStructuredBy_ValueDomain&
    operator= (const DimensionComponent_isStructuredBy_ValueDomain&) = default;
#endif

    virtual 
    ~DimensionComponent_isStructuredBy_ValueDomain ();
  };

  class DimensionGroup_has_DimensionComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DimensionGroup_has_DimensionComponent ();

    DimensionGroup_has_DimensionComponent (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    DimensionGroup_has_DimensionComponent (const DimensionGroup_has_DimensionComponent& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual DimensionGroup_has_DimensionComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DimensionGroup_has_DimensionComponent&
    operator= (const DimensionGroup_has_DimensionComponent&) = default;
#endif

    virtual 
    ~DimensionGroup_has_DimensionComponent ();
  };

  class DimensionalDataSet_represents_ScopedMeasure: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DimensionalDataSet_represents_ScopedMeasure ();

    DimensionalDataSet_represents_ScopedMeasure (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    DimensionalDataSet_represents_ScopedMeasure (const DimensionalDataSet_represents_ScopedMeasure& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual DimensionalDataSet_represents_ScopedMeasure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DimensionalDataSet_represents_ScopedMeasure&
    operator= (const DimensionalDataSet_represents_ScopedMeasure&) = default;
#endif

    virtual 
    ~DimensionalDataSet_represents_ScopedMeasure ();
  };

  class DimensionalDataStructure_uses_DimensionGroup: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DimensionalDataStructure_uses_DimensionGroup ();

    DimensionalDataStructure_uses_DimensionGroup (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    DimensionalDataStructure_uses_DimensionGroup (const DimensionalDataStructure_uses_DimensionGroup& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual DimensionalDataStructure_uses_DimensionGroup*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DimensionalDataStructure_uses_DimensionGroup&
    operator= (const DimensionalDataStructure_uses_DimensionGroup&) = default;
#endif

    virtual 
    ~DimensionalDataStructure_uses_DimensionGroup ();
  };

  class DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember ();

    DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember (const ::xercesc::DOMElement& e,
                                                                         ::xml_schema::flags f = 0,
                                                                         ::xml_schema::container* c = 0);

    DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember (const DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember& x,
                                                                         ::xml_schema::flags f = 0,
                                                                         ::xml_schema::container* c = 0);

    virtual DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember&
    operator= (const DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember&) = default;
#endif

    virtual 
    ~DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember ();
  };

  class DimensionalKeyMember_hasValueFrom_CodeList: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    DimensionalKeyMember_hasValueFrom_CodeList ();

    DimensionalKeyMember_hasValueFrom_CodeList (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    DimensionalKeyMember_hasValueFrom_CodeList (const DimensionalKeyMember_hasValueFrom_CodeList& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual DimensionalKeyMember_hasValueFrom_CodeList*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    DimensionalKeyMember_hasValueFrom_CodeList&
    operator= (const DimensionalKeyMember_hasValueFrom_CodeList&) = default;
#endif

    virtual 
    ~DimensionalKeyMember_hasValueFrom_CodeList ();
  };

  class EnumerationDomain_uses_LevelStructure: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    EnumerationDomain_uses_LevelStructure ();

    EnumerationDomain_uses_LevelStructure (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    EnumerationDomain_uses_LevelStructure (const EnumerationDomain_uses_LevelStructure& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual EnumerationDomain_uses_LevelStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    EnumerationDomain_uses_LevelStructure&
    operator= (const EnumerationDomain_uses_LevelStructure&) = default;
#endif

    virtual 
    ~EnumerationDomain_uses_LevelStructure ();
  };

  class EnumerationDomain_references_CategorySet: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    EnumerationDomain_references_CategorySet ();

    EnumerationDomain_references_CategorySet (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    EnumerationDomain_references_CategorySet (const EnumerationDomain_references_CategorySet& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual EnumerationDomain_references_CategorySet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    EnumerationDomain_references_CategorySet&
    operator= (const EnumerationDomain_references_CategorySet&) = default;
#endif

    virtual 
    ~EnumerationDomain_references_CategorySet ();
  };

  class EnumerationDomain_isDefinedBy_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    EnumerationDomain_isDefinedBy_Concept ();

    EnumerationDomain_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    EnumerationDomain_isDefinedBy_Concept (const EnumerationDomain_isDefinedBy_Concept& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual EnumerationDomain_isDefinedBy_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    EnumerationDomain_isDefinedBy_Concept&
    operator= (const EnumerationDomain_isDefinedBy_Concept&) = default;
#endif

    virtual 
    ~EnumerationDomain_isDefinedBy_Concept ();
  };

  class ForeignKey_isComposedOf_ForeignKeyComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ForeignKey_isComposedOf_ForeignKeyComponent ();

    ForeignKey_isComposedOf_ForeignKeyComponent (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    ForeignKey_isComposedOf_ForeignKeyComponent (const ForeignKey_isComposedOf_ForeignKeyComponent& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual ForeignKey_isComposedOf_ForeignKeyComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ForeignKey_isComposedOf_ForeignKeyComponent&
    operator= (const ForeignKey_isComposedOf_ForeignKeyComponent&) = default;
#endif

    virtual 
    ~ForeignKey_isComposedOf_ForeignKeyComponent ();
  };

  class ForeignKeyComponent_references_PrimaryKeyComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ForeignKeyComponent_references_PrimaryKeyComponent ();

    ForeignKeyComponent_references_PrimaryKeyComponent (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

    ForeignKeyComponent_references_PrimaryKeyComponent (const ForeignKeyComponent_references_PrimaryKeyComponent& x,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

    virtual ForeignKeyComponent_references_PrimaryKeyComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ForeignKeyComponent_references_PrimaryKeyComponent&
    operator= (const ForeignKeyComponent_references_PrimaryKeyComponent&) = default;
#endif

    virtual 
    ~ForeignKeyComponent_references_PrimaryKeyComponent ();
  };

  class ForeignKeyComponent_correspondsTo_DataStructureComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ForeignKeyComponent_correspondsTo_DataStructureComponent ();

    ForeignKeyComponent_correspondsTo_DataStructureComponent (const ::xercesc::DOMElement& e,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    ForeignKeyComponent_correspondsTo_DataStructureComponent (const ForeignKeyComponent_correspondsTo_DataStructureComponent& x,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    virtual ForeignKeyComponent_correspondsTo_DataStructureComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ForeignKeyComponent_correspondsTo_DataStructureComponent&
    operator= (const ForeignKeyComponent_correspondsTo_DataStructureComponent&) = default;
#endif

    virtual 
    ~ForeignKeyComponent_correspondsTo_DataStructureComponent ();
  };

  class InformationFlowDefinition_from_Parameter: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    InformationFlowDefinition_from_Parameter ();

    InformationFlowDefinition_from_Parameter (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    InformationFlowDefinition_from_Parameter (const InformationFlowDefinition_from_Parameter& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual InformationFlowDefinition_from_Parameter*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    InformationFlowDefinition_from_Parameter&
    operator= (const InformationFlowDefinition_from_Parameter&) = default;
#endif

    virtual 
    ~InformationFlowDefinition_from_Parameter ();
  };

  class InformationFlowDefinition_to_Parameter: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    InformationFlowDefinition_to_Parameter ();

    InformationFlowDefinition_to_Parameter (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    InformationFlowDefinition_to_Parameter (const InformationFlowDefinition_to_Parameter& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual InformationFlowDefinition_to_Parameter*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    InformationFlowDefinition_to_Parameter&
    operator= (const InformationFlowDefinition_to_Parameter&) = default;
#endif

    virtual 
    ~InformationFlowDefinition_to_Parameter ();
  };

  class InstanceKey_has_InstanceValue: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    InstanceKey_has_InstanceValue ();

    InstanceKey_has_InstanceValue (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    InstanceKey_has_InstanceValue (const InstanceKey_has_InstanceValue& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual InstanceKey_has_InstanceValue*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    InstanceKey_has_InstanceValue&
    operator= (const InstanceKey_has_InstanceValue&) = default;
#endif

    virtual 
    ~InstanceKey_has_InstanceValue ();
  };

  class InstanceKey_refersTo_ReferenceValue: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    InstanceKey_refersTo_ReferenceValue ();

    InstanceKey_refersTo_ReferenceValue (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    InstanceKey_refersTo_ReferenceValue (const InstanceKey_refersTo_ReferenceValue& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual InstanceKey_refersTo_ReferenceValue*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    InstanceKey_refersTo_ReferenceValue&
    operator= (const InstanceKey_refersTo_ReferenceValue&) = default;
#endif

    virtual 
    ~InstanceKey_refersTo_ReferenceValue ();
  };

  class InstanceValue_hasValueFrom_ValueDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    InstanceValue_hasValueFrom_ValueDomain ();

    InstanceValue_hasValueFrom_ValueDomain (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    InstanceValue_hasValueFrom_ValueDomain (const InstanceValue_hasValueFrom_ValueDomain& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual InstanceValue_hasValueFrom_ValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    InstanceValue_hasValueFrom_ValueDomain&
    operator= (const InstanceValue_hasValueFrom_ValueDomain&) = default;
#endif

    virtual 
    ~InstanceValue_hasValueFrom_ValueDomain ();
  };

  class InstanceValue_isStoredIn_DataPoint: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    InstanceValue_isStoredIn_DataPoint ();

    InstanceValue_isStoredIn_DataPoint (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    InstanceValue_isStoredIn_DataPoint (const InstanceValue_isStoredIn_DataPoint& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual InstanceValue_isStoredIn_DataPoint*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    InstanceValue_isStoredIn_DataPoint&
    operator= (const InstanceValue_isStoredIn_DataPoint&) = default;
#endif

    virtual 
    ~InstanceValue_isStoredIn_DataPoint ();
  };

  class InstanceValue_represents_ConceptualValue: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    InstanceValue_represents_ConceptualValue ();

    InstanceValue_represents_ConceptualValue (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    InstanceValue_represents_ConceptualValue (const InstanceValue_represents_ConceptualValue& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual InstanceValue_represents_ConceptualValue*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    InstanceValue_represents_ConceptualValue&
    operator= (const InstanceValue_represents_ConceptualValue&) = default;
#endif

    virtual 
    ~InstanceValue_represents_ConceptualValue ();
  };

  class source: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    source ();

    source (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    source (const source& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual source*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    source&
    operator= (const source&) = default;
#endif

    virtual 
    ~source ();
  };

  class InstanceVariableMap_hasTarget_InstanceVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    InstanceVariableMap_hasTarget_InstanceVariable ();

    InstanceVariableMap_hasTarget_InstanceVariable (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    InstanceVariableMap_hasTarget_InstanceVariable (const InstanceVariableMap_hasTarget_InstanceVariable& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    virtual InstanceVariableMap_hasTarget_InstanceVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    InstanceVariableMap_hasTarget_InstanceVariable&
    operator= (const InstanceVariableMap_hasTarget_InstanceVariable&) = default;
#endif

    virtual 
    ~InstanceVariableMap_hasTarget_InstanceVariable ();
  };

  class InstanceVariableMap_hasSource_InstanceVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    InstanceVariableMap_hasSource_InstanceVariable ();

    InstanceVariableMap_hasSource_InstanceVariable (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    InstanceVariableMap_hasSource_InstanceVariable (const InstanceVariableMap_hasSource_InstanceVariable& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    virtual InstanceVariableMap_hasSource_InstanceVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    InstanceVariableMap_hasSource_InstanceVariable&
    operator= (const InstanceVariableMap_hasSource_InstanceVariable&) = default;
#endif

    virtual 
    ~InstanceVariableMap_hasSource_InstanceVariable ();
  };

  class Key_correspondsTo_Unit: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Key_correspondsTo_Unit ();

    Key_correspondsTo_Unit (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    Key_correspondsTo_Unit (const Key_correspondsTo_Unit& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual Key_correspondsTo_Unit*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Key_correspondsTo_Unit&
    operator= (const Key_correspondsTo_Unit&) = default;
#endif

    virtual 
    ~Key_correspondsTo_Unit ();
  };

  class Key_represents_KeyDefinition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Key_represents_KeyDefinition ();

    Key_represents_KeyDefinition (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    Key_represents_KeyDefinition (const Key_represents_KeyDefinition& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual Key_represents_KeyDefinition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Key_represents_KeyDefinition&
    operator= (const Key_represents_KeyDefinition&) = default;
#endif

    virtual 
    ~Key_represents_KeyDefinition ();
  };

  class Key_identifies_DataPoint: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Key_identifies_DataPoint ();

    Key_identifies_DataPoint (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    Key_identifies_DataPoint (const Key_identifies_DataPoint& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual Key_identifies_DataPoint*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Key_identifies_DataPoint&
    operator= (const Key_identifies_DataPoint&) = default;
#endif

    virtual 
    ~Key_identifies_DataPoint ();
  };

  class Key_correspondsTo_Universe: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Key_correspondsTo_Universe ();

    Key_correspondsTo_Universe (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    Key_correspondsTo_Universe (const Key_correspondsTo_Universe& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual Key_correspondsTo_Universe*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Key_correspondsTo_Universe&
    operator= (const Key_correspondsTo_Universe&) = default;
#endif

    virtual 
    ~Key_correspondsTo_Universe ();
  };

  class Key_has_KeyMember: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Key_has_KeyMember ();

    Key_has_KeyMember (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    Key_has_KeyMember (const Key_has_KeyMember& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual Key_has_KeyMember*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Key_has_KeyMember&
    operator= (const Key_has_KeyMember&) = default;
#endif

    virtual 
    ~Key_has_KeyMember ();
  };

  class KeyDefinition_correspondsTo_Universe: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    KeyDefinition_correspondsTo_Universe ();

    KeyDefinition_correspondsTo_Universe (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    KeyDefinition_correspondsTo_Universe (const KeyDefinition_correspondsTo_Universe& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual KeyDefinition_correspondsTo_Universe*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    KeyDefinition_correspondsTo_Universe&
    operator= (const KeyDefinition_correspondsTo_Universe&) = default;
#endif

    virtual 
    ~KeyDefinition_correspondsTo_Universe ();
  };

  class KeyDefinition_correspondsTo_Unit: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    KeyDefinition_correspondsTo_Unit ();

    KeyDefinition_correspondsTo_Unit (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    KeyDefinition_correspondsTo_Unit (const KeyDefinition_correspondsTo_Unit& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual KeyDefinition_correspondsTo_Unit*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    KeyDefinition_correspondsTo_Unit&
    operator= (const KeyDefinition_correspondsTo_Unit&) = default;
#endif

    virtual 
    ~KeyDefinition_correspondsTo_Unit ();
  };

  class KeyDefinition_has_KeyDefinitionMember: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    KeyDefinition_has_KeyDefinitionMember ();

    KeyDefinition_has_KeyDefinitionMember (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    KeyDefinition_has_KeyDefinitionMember (const KeyDefinition_has_KeyDefinitionMember& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual KeyDefinition_has_KeyDefinitionMember*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    KeyDefinition_has_KeyDefinitionMember&
    operator= (const KeyDefinition_has_KeyDefinitionMember&) = default;
#endif

    virtual 
    ~KeyDefinition_has_KeyDefinitionMember ();
  };

  class KeyMember_isBasedOn_DataStructureComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    KeyMember_isBasedOn_DataStructureComponent ();

    KeyMember_isBasedOn_DataStructureComponent (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    KeyMember_isBasedOn_DataStructureComponent (const KeyMember_isBasedOn_DataStructureComponent& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual KeyMember_isBasedOn_DataStructureComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    KeyMember_isBasedOn_DataStructureComponent&
    operator= (const KeyMember_isBasedOn_DataStructureComponent&) = default;
#endif

    virtual 
    ~KeyMember_isBasedOn_DataStructureComponent ();
  };

  class Level_isDefinedBy_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Level_isDefinedBy_Concept ();

    Level_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    Level_isDefinedBy_Concept (const Level_isDefinedBy_Concept& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual Level_isDefinedBy_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Level_isDefinedBy_Concept&
    operator= (const Level_isDefinedBy_Concept&) = default;
#endif

    virtual 
    ~Level_isDefinedBy_Concept ();
  };

  class Level_groups_ClassificationItem: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Level_groups_ClassificationItem ();

    Level_groups_ClassificationItem (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    Level_groups_ClassificationItem (const Level_groups_ClassificationItem& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual Level_groups_ClassificationItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Level_groups_ClassificationItem&
    operator= (const Level_groups_ClassificationItem&) = default;
#endif

    virtual 
    ~Level_groups_ClassificationItem ();
  };

  class LevelStructure_has_Level: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    LevelStructure_has_Level ();

    LevelStructure_has_Level (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    LevelStructure_has_Level (const LevelStructure_has_Level& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual LevelStructure_has_Level*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    LevelStructure_has_Level&
    operator= (const LevelStructure_has_Level&) = default;
#endif

    virtual 
    ~LevelStructure_has_Level ();
  };

  class LogicalRecord_organizes_DataSet: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    LogicalRecord_organizes_DataSet ();

    LogicalRecord_organizes_DataSet (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    LogicalRecord_organizes_DataSet (const LogicalRecord_organizes_DataSet& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual LogicalRecord_organizes_DataSet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    LogicalRecord_organizes_DataSet&
    operator= (const LogicalRecord_organizes_DataSet&) = default;
#endif

    virtual 
    ~LogicalRecord_organizes_DataSet ();
  };

  class LogicalRecord_isDefinedBy_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    LogicalRecord_isDefinedBy_Concept ();

    LogicalRecord_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    LogicalRecord_isDefinedBy_Concept (const LogicalRecord_isDefinedBy_Concept& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual LogicalRecord_isDefinedBy_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    LogicalRecord_isDefinedBy_Concept&
    operator= (const LogicalRecord_isDefinedBy_Concept&) = default;
#endif

    virtual 
    ~LogicalRecord_isDefinedBy_Concept ();
  };

  class LogicalRecord_has_InstanceVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    LogicalRecord_has_InstanceVariable ();

    LogicalRecord_has_InstanceVariable (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    LogicalRecord_has_InstanceVariable (const LogicalRecord_has_InstanceVariable& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

    virtual LogicalRecord_has_InstanceVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    LogicalRecord_has_InstanceVariable&
    operator= (const LogicalRecord_has_InstanceVariable&) = default;
#endif

    virtual 
    ~LogicalRecord_has_InstanceVariable ();
  };

  class LogicalRecordPosition_indexes_LogicalRecord: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    LogicalRecordPosition_indexes_LogicalRecord ();

    LogicalRecordPosition_indexes_LogicalRecord (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    LogicalRecordPosition_indexes_LogicalRecord (const LogicalRecordPosition_indexes_LogicalRecord& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual LogicalRecordPosition_indexes_LogicalRecord*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    LogicalRecordPosition_indexes_LogicalRecord&
    operator= (const LogicalRecordPosition_indexes_LogicalRecord&) = default;
#endif

    virtual 
    ~LogicalRecordPosition_indexes_LogicalRecord ();
  };

  class LogicalRecordRelationStructure_structures_DataStore: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    LogicalRecordRelationStructure_structures_DataStore ();

    LogicalRecordRelationStructure_structures_DataStore (const ::xercesc::DOMElement& e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    LogicalRecordRelationStructure_structures_DataStore (const LogicalRecordRelationStructure_structures_DataStore& x,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    virtual LogicalRecordRelationStructure_structures_DataStore*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    LogicalRecordRelationStructure_structures_DataStore&
    operator= (const LogicalRecordRelationStructure_structures_DataStore&) = default;
#endif

    virtual 
    ~LogicalRecordRelationStructure_structures_DataStore ();
  };

  class LogicalRecordRelationStructure_has_LogicalRecordRelationship: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    LogicalRecordRelationStructure_has_LogicalRecordRelationship ();

    LogicalRecordRelationStructure_has_LogicalRecordRelationship (const ::xercesc::DOMElement& e,
                                                                  ::xml_schema::flags f = 0,
                                                                  ::xml_schema::container* c = 0);

    LogicalRecordRelationStructure_has_LogicalRecordRelationship (const LogicalRecordRelationStructure_has_LogicalRecordRelationship& x,
                                                                  ::xml_schema::flags f = 0,
                                                                  ::xml_schema::container* c = 0);

    virtual LogicalRecordRelationStructure_has_LogicalRecordRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    LogicalRecordRelationStructure_has_LogicalRecordRelationship&
    operator= (const LogicalRecordRelationStructure_has_LogicalRecordRelationship&) = default;
#endif

    virtual 
    ~LogicalRecordRelationStructure_has_LogicalRecordRelationship ();
  };

  class LogicalRecordRelationship_hasTarget_LogicalRecord: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    LogicalRecordRelationship_hasTarget_LogicalRecord ();

    LogicalRecordRelationship_hasTarget_LogicalRecord (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

    LogicalRecordRelationship_hasTarget_LogicalRecord (const LogicalRecordRelationship_hasTarget_LogicalRecord& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

    virtual LogicalRecordRelationship_hasTarget_LogicalRecord*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    LogicalRecordRelationship_hasTarget_LogicalRecord&
    operator= (const LogicalRecordRelationship_hasTarget_LogicalRecord&) = default;
#endif

    virtual 
    ~LogicalRecordRelationship_hasTarget_LogicalRecord ();
  };

  class LogicalRecordRelationship_hasSource_LogicalRecord: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    LogicalRecordRelationship_hasSource_LogicalRecord ();

    LogicalRecordRelationship_hasSource_LogicalRecord (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

    LogicalRecordRelationship_hasSource_LogicalRecord (const LogicalRecordRelationship_hasSource_LogicalRecord& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

    virtual LogicalRecordRelationship_hasSource_LogicalRecord*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    LogicalRecordRelationship_hasSource_LogicalRecord&
    operator= (const LogicalRecordRelationship_hasSource_LogicalRecord&) = default;
#endif

    virtual 
    ~LogicalRecordRelationship_hasSource_LogicalRecord ();
  };

  class MainKeyMember_hasValueFrom_SubstantiveValueDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    MainKeyMember_hasValueFrom_SubstantiveValueDomain ();

    MainKeyMember_hasValueFrom_SubstantiveValueDomain (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

    MainKeyMember_hasValueFrom_SubstantiveValueDomain (const MainKeyMember_hasValueFrom_SubstantiveValueDomain& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

    virtual MainKeyMember_hasValueFrom_SubstantiveValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    MainKeyMember_hasValueFrom_SubstantiveValueDomain&
    operator= (const MainKeyMember_hasValueFrom_SubstantiveValueDomain&) = default;
#endif

    virtual 
    ~MainKeyMember_hasValueFrom_SubstantiveValueDomain ();
  };

  class Notation_represents_Category: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Notation_represents_Category ();

    Notation_represents_Category (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    Notation_represents_Category (const Notation_represents_Category& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual Notation_represents_Category*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Notation_represents_Category&
    operator= (const Notation_represents_Category&) = default;
#endif

    virtual 
    ~Notation_represents_Category ();
  };

  class entityBound: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    entityBound ();

    entityBound (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    entityBound (const entityBound& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual entityBound*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    entityBound&
    operator= (const entityBound&) = default;
#endif

    virtual 
    ~entityBound ();
  };

  class PhysicalDataSet_isDefinedBy_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalDataSet_isDefinedBy_Concept ();

    PhysicalDataSet_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    PhysicalDataSet_isDefinedBy_Concept (const PhysicalDataSet_isDefinedBy_Concept& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual PhysicalDataSet_isDefinedBy_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalDataSet_isDefinedBy_Concept&
    operator= (const PhysicalDataSet_isDefinedBy_Concept&) = default;
#endif

    virtual 
    ~PhysicalDataSet_isDefinedBy_Concept ();
  };

  class PhysicalDataSet_formats_DataStore: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalDataSet_formats_DataStore ();

    PhysicalDataSet_formats_DataStore (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    PhysicalDataSet_formats_DataStore (const PhysicalDataSet_formats_DataStore& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual PhysicalDataSet_formats_DataStore*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalDataSet_formats_DataStore&
    operator= (const PhysicalDataSet_formats_DataStore&) = default;
#endif

    virtual 
    ~PhysicalDataSet_formats_DataStore ();
  };

  class PhysicalDataSet_has_InstanceVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalDataSet_has_InstanceVariable ();

    PhysicalDataSet_has_InstanceVariable (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    PhysicalDataSet_has_InstanceVariable (const PhysicalDataSet_has_InstanceVariable& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

    virtual PhysicalDataSet_has_InstanceVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalDataSet_has_InstanceVariable&
    operator= (const PhysicalDataSet_has_InstanceVariable&) = default;
#endif

    virtual 
    ~PhysicalDataSet_has_InstanceVariable ();
  };

  class PhysicalDataSet_has_PhysicalRecordSegment: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalDataSet_has_PhysicalRecordSegment ();

    PhysicalDataSet_has_PhysicalRecordSegment (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    PhysicalDataSet_has_PhysicalRecordSegment (const PhysicalDataSet_has_PhysicalRecordSegment& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual PhysicalDataSet_has_PhysicalRecordSegment*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalDataSet_has_PhysicalRecordSegment&
    operator= (const PhysicalDataSet_has_PhysicalRecordSegment&) = default;
#endif

    virtual 
    ~PhysicalDataSet_has_PhysicalRecordSegment ();
  };

  class PhysicalDataSet_has_PhysicalRecordSegmentPosition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalDataSet_has_PhysicalRecordSegmentPosition ();

    PhysicalDataSet_has_PhysicalRecordSegmentPosition (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

    PhysicalDataSet_has_PhysicalRecordSegmentPosition (const PhysicalDataSet_has_PhysicalRecordSegmentPosition& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

    virtual PhysicalDataSet_has_PhysicalRecordSegmentPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalDataSet_has_PhysicalRecordSegmentPosition&
    operator= (const PhysicalDataSet_has_PhysicalRecordSegmentPosition&) = default;
#endif

    virtual 
    ~PhysicalDataSet_has_PhysicalRecordSegmentPosition ();
  };

  class PhysicalDataSetStructure_structures_PhysicalDataSet: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalDataSetStructure_structures_PhysicalDataSet ();

    PhysicalDataSetStructure_structures_PhysicalDataSet (const ::xercesc::DOMElement& e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    PhysicalDataSetStructure_structures_PhysicalDataSet (const PhysicalDataSetStructure_structures_PhysicalDataSet& x,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    virtual PhysicalDataSetStructure_structures_PhysicalDataSet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalDataSetStructure_structures_PhysicalDataSet&
    operator= (const PhysicalDataSetStructure_structures_PhysicalDataSet&) = default;
#endif

    virtual 
    ~PhysicalDataSetStructure_structures_PhysicalDataSet ();
  };

  class PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship ();

    PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship (const ::xercesc::DOMElement& e,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship (const PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship& x,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    virtual PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship&
    operator= (const PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship&) = default;
#endif

    virtual 
    ~PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship ();
  };

  class PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout ();

    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout (const ::xercesc::DOMElement& e,
                                                                      ::xml_schema::flags f = 0,
                                                                      ::xml_schema::container* c = 0);

    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout (const PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout& x,
                                                                      ::xml_schema::flags f = 0,
                                                                      ::xml_schema::container* c = 0);

    virtual PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout&
    operator= (const PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout&) = default;
#endif

    virtual 
    ~PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout ();
  };

  class PhysicalLayoutRelationStructure_has_ValueMappingRelationship: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalLayoutRelationStructure_has_ValueMappingRelationship ();

    PhysicalLayoutRelationStructure_has_ValueMappingRelationship (const ::xercesc::DOMElement& e,
                                                                  ::xml_schema::flags f = 0,
                                                                  ::xml_schema::container* c = 0);

    PhysicalLayoutRelationStructure_has_ValueMappingRelationship (const PhysicalLayoutRelationStructure_has_ValueMappingRelationship& x,
                                                                  ::xml_schema::flags f = 0,
                                                                  ::xml_schema::container* c = 0);

    virtual PhysicalLayoutRelationStructure_has_ValueMappingRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalLayoutRelationStructure_has_ValueMappingRelationship&
    operator= (const PhysicalLayoutRelationStructure_has_ValueMappingRelationship&) = default;
#endif

    virtual 
    ~PhysicalLayoutRelationStructure_has_ValueMappingRelationship ();
  };

  class PhysicalRecordSegment_represents_Population: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalRecordSegment_represents_Population ();

    PhysicalRecordSegment_represents_Population (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    PhysicalRecordSegment_represents_Population (const PhysicalRecordSegment_represents_Population& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegment_represents_Population*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalRecordSegment_represents_Population&
    operator= (const PhysicalRecordSegment_represents_Population&) = default;
#endif

    virtual 
    ~PhysicalRecordSegment_represents_Population ();
  };

  class PhysicalRecordSegment_isDefinedBy_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalRecordSegment_isDefinedBy_Concept ();

    PhysicalRecordSegment_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    PhysicalRecordSegment_isDefinedBy_Concept (const PhysicalRecordSegment_isDefinedBy_Concept& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegment_isDefinedBy_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalRecordSegment_isDefinedBy_Concept&
    operator= (const PhysicalRecordSegment_isDefinedBy_Concept&) = default;
#endif

    virtual 
    ~PhysicalRecordSegment_isDefinedBy_Concept ();
  };

  class PhysicalRecordSegment_has_PhysicalSegmentLayout: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalRecordSegment_has_PhysicalSegmentLayout ();

    PhysicalRecordSegment_has_PhysicalSegmentLayout (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    PhysicalRecordSegment_has_PhysicalSegmentLayout (const PhysicalRecordSegment_has_PhysicalSegmentLayout& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegment_has_PhysicalSegmentLayout*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalRecordSegment_has_PhysicalSegmentLayout&
    operator= (const PhysicalRecordSegment_has_PhysicalSegmentLayout&) = default;
#endif

    virtual 
    ~PhysicalRecordSegment_has_PhysicalSegmentLayout ();
  };

  class PhysicalRecordSegment_mapsTo_LogicalRecord: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalRecordSegment_mapsTo_LogicalRecord ();

    PhysicalRecordSegment_mapsTo_LogicalRecord (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    PhysicalRecordSegment_mapsTo_LogicalRecord (const PhysicalRecordSegment_mapsTo_LogicalRecord& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegment_mapsTo_LogicalRecord*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalRecordSegment_mapsTo_LogicalRecord&
    operator= (const PhysicalRecordSegment_mapsTo_LogicalRecord&) = default;
#endif

    virtual 
    ~PhysicalRecordSegment_mapsTo_LogicalRecord ();
  };

  class PhysicalRecordSegment_has_DataPointPosition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalRecordSegment_has_DataPointPosition ();

    PhysicalRecordSegment_has_DataPointPosition (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    PhysicalRecordSegment_has_DataPointPosition (const PhysicalRecordSegment_has_DataPointPosition& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegment_has_DataPointPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalRecordSegment_has_DataPointPosition&
    operator= (const PhysicalRecordSegment_has_DataPointPosition&) = default;
#endif

    virtual 
    ~PhysicalRecordSegment_has_DataPointPosition ();
  };

  class PhysicalRecordSegment_has_DataPoint: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalRecordSegment_has_DataPoint ();

    PhysicalRecordSegment_has_DataPoint (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    PhysicalRecordSegment_has_DataPoint (const PhysicalRecordSegment_has_DataPoint& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegment_has_DataPoint*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalRecordSegment_has_DataPoint&
    operator= (const PhysicalRecordSegment_has_DataPoint&) = default;
#endif

    virtual 
    ~PhysicalRecordSegment_has_DataPoint ();
  };

  class PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment ();

    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment (const ::xercesc::DOMElement& e,
                                                                 ::xml_schema::flags f = 0,
                                                                 ::xml_schema::container* c = 0);

    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment (const PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment& x,
                                                                 ::xml_schema::flags f = 0,
                                                                 ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment&
    operator= (const PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment&) = default;
#endif

    virtual 
    ~PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment ();
  };

  class PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment ();

    PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment (const ::xercesc::DOMElement& e,
                                                                       ::xml_schema::flags f = 0,
                                                                       ::xml_schema::container* c = 0);

    PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment (const PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment& x,
                                                                       ::xml_schema::flags f = 0,
                                                                       ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment&
    operator= (const PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment&) = default;
#endif

    virtual 
    ~PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment ();
  };

  class PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment ();

    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment (const ::xercesc::DOMElement& e,
                                                                       ::xml_schema::flags f = 0,
                                                                       ::xml_schema::container* c = 0);

    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment (const PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment& x,
                                                                       ::xml_schema::flags f = 0,
                                                                       ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment&
    operator= (const PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment&) = default;
#endif

    virtual 
    ~PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment ();
  };

  class PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment ();

    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment (const ::xercesc::DOMElement& e,
                                                                     ::xml_schema::flags f = 0,
                                                                     ::xml_schema::container* c = 0);

    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment (const PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment& x,
                                                                     ::xml_schema::flags f = 0,
                                                                     ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment&
    operator= (const PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment&) = default;
#endif

    virtual 
    ~PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment ();
  };

  class PhysicalRecordSegmentStructure_has_DataPointRelationship: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalRecordSegmentStructure_has_DataPointRelationship ();

    PhysicalRecordSegmentStructure_has_DataPointRelationship (const ::xercesc::DOMElement& e,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    PhysicalRecordSegmentStructure_has_DataPointRelationship (const PhysicalRecordSegmentStructure_has_DataPointRelationship& x,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    virtual PhysicalRecordSegmentStructure_has_DataPointRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalRecordSegmentStructure_has_DataPointRelationship&
    operator= (const PhysicalRecordSegmentStructure_has_DataPointRelationship&) = default;
#endif

    virtual 
    ~PhysicalRecordSegmentStructure_has_DataPointRelationship ();
  };

  class PhysicalSegmentLayout_isDefinedBy_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalSegmentLayout_isDefinedBy_Concept ();

    PhysicalSegmentLayout_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    PhysicalSegmentLayout_isDefinedBy_Concept (const PhysicalSegmentLayout_isDefinedBy_Concept& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual PhysicalSegmentLayout_isDefinedBy_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalSegmentLayout_isDefinedBy_Concept&
    operator= (const PhysicalSegmentLayout_isDefinedBy_Concept&) = default;
#endif

    virtual 
    ~PhysicalSegmentLayout_isDefinedBy_Concept ();
  };

  class PhysicalSegmentLayout_formats_LogicalRecord: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalSegmentLayout_formats_LogicalRecord ();

    PhysicalSegmentLayout_formats_LogicalRecord (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    PhysicalSegmentLayout_formats_LogicalRecord (const PhysicalSegmentLayout_formats_LogicalRecord& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual PhysicalSegmentLayout_formats_LogicalRecord*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalSegmentLayout_formats_LogicalRecord&
    operator= (const PhysicalSegmentLayout_formats_LogicalRecord&) = default;
#endif

    virtual 
    ~PhysicalSegmentLayout_formats_LogicalRecord ();
  };

  class PhysicalSegmentLayout_has_ValueMapping: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalSegmentLayout_has_ValueMapping ();

    PhysicalSegmentLayout_has_ValueMapping (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    PhysicalSegmentLayout_has_ValueMapping (const PhysicalSegmentLayout_has_ValueMapping& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual PhysicalSegmentLayout_has_ValueMapping*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalSegmentLayout_has_ValueMapping&
    operator= (const PhysicalSegmentLayout_has_ValueMapping&) = default;
#endif

    virtual 
    ~PhysicalSegmentLayout_has_ValueMapping ();
  };

  class PhysicalSegmentLayout_has_ValueMappingPosition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PhysicalSegmentLayout_has_ValueMappingPosition ();

    PhysicalSegmentLayout_has_ValueMappingPosition (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    PhysicalSegmentLayout_has_ValueMappingPosition (const PhysicalSegmentLayout_has_ValueMappingPosition& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

    virtual PhysicalSegmentLayout_has_ValueMappingPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PhysicalSegmentLayout_has_ValueMappingPosition&
    operator= (const PhysicalSegmentLayout_has_ValueMappingPosition&) = default;
#endif

    virtual 
    ~PhysicalSegmentLayout_has_ValueMappingPosition ();
  };

  class Population_isComposedOf_Unit: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Population_isComposedOf_Unit ();

    Population_isComposedOf_Unit (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    Population_isComposedOf_Unit (const Population_isComposedOf_Unit& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual Population_isComposedOf_Unit*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Population_isComposedOf_Unit&
    operator= (const Population_isComposedOf_Unit&) = default;
#endif

    virtual 
    ~Population_isComposedOf_Unit ();
  };

  class PrimaryKey_isComposedOf_PrimaryKeyComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PrimaryKey_isComposedOf_PrimaryKeyComponent ();

    PrimaryKey_isComposedOf_PrimaryKeyComponent (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    PrimaryKey_isComposedOf_PrimaryKeyComponent (const PrimaryKey_isComposedOf_PrimaryKeyComponent& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual PrimaryKey_isComposedOf_PrimaryKeyComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PrimaryKey_isComposedOf_PrimaryKeyComponent&
    operator= (const PrimaryKey_isComposedOf_PrimaryKeyComponent&) = default;
#endif

    virtual 
    ~PrimaryKey_isComposedOf_PrimaryKeyComponent ();
  };

  class PrimaryKeyComponent_correspondsTo_DataStructureComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    PrimaryKeyComponent_correspondsTo_DataStructureComponent ();

    PrimaryKeyComponent_correspondsTo_DataStructureComponent (const ::xercesc::DOMElement& e,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    PrimaryKeyComponent_correspondsTo_DataStructureComponent (const PrimaryKeyComponent_correspondsTo_DataStructureComponent& x,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    virtual PrimaryKeyComponent_correspondsTo_DataStructureComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    PrimaryKeyComponent_correspondsTo_DataStructureComponent&
    operator= (const PrimaryKeyComponent_correspondsTo_DataStructureComponent&) = default;
#endif

    virtual 
    ~PrimaryKeyComponent_correspondsTo_DataStructureComponent ();
  };

  class ProcessingAgent_performs_Activity: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ProcessingAgent_performs_Activity ();

    ProcessingAgent_performs_Activity (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    ProcessingAgent_performs_Activity (const ProcessingAgent_performs_Activity& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual ProcessingAgent_performs_Activity*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ProcessingAgent_performs_Activity&
    operator= (const ProcessingAgent_performs_Activity&) = default;
#endif

    virtual 
    ~ProcessingAgent_performs_Activity ();
  };

  class ProcessingAgent_operatesOn_ProductionEnvironment: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ProcessingAgent_operatesOn_ProductionEnvironment ();

    ProcessingAgent_operatesOn_ProductionEnvironment (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    ProcessingAgent_operatesOn_ProductionEnvironment (const ProcessingAgent_operatesOn_ProductionEnvironment& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    virtual ProcessingAgent_operatesOn_ProductionEnvironment*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ProcessingAgent_operatesOn_ProductionEnvironment&
    operator= (const ProcessingAgent_operatesOn_ProductionEnvironment&) = default;
#endif

    virtual 
    ~ProcessingAgent_operatesOn_ProductionEnvironment ();
  };

  class QualifiedMeasure_refines_MeasureComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    QualifiedMeasure_refines_MeasureComponent ();

    QualifiedMeasure_refines_MeasureComponent (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    QualifiedMeasure_refines_MeasureComponent (const QualifiedMeasure_refines_MeasureComponent& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual QualifiedMeasure_refines_MeasureComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    QualifiedMeasure_refines_MeasureComponent&
    operator= (const QualifiedMeasure_refines_MeasureComponent&) = default;
#endif

    virtual 
    ~QualifiedMeasure_refines_MeasureComponent ();
  };

  class RecordRelation_maps_LogicalRecord: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    RecordRelation_maps_LogicalRecord ();

    RecordRelation_maps_LogicalRecord (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    RecordRelation_maps_LogicalRecord (const RecordRelation_maps_LogicalRecord& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual RecordRelation_maps_LogicalRecord*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    RecordRelation_maps_LogicalRecord&
    operator= (const RecordRelation_maps_LogicalRecord&) = default;
#endif

    virtual 
    ~RecordRelation_maps_LogicalRecord ();
  };

  class RecordRelation_has_InstanceVariableMap: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    RecordRelation_has_InstanceVariableMap ();

    RecordRelation_has_InstanceVariableMap (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    RecordRelation_has_InstanceVariableMap (const RecordRelation_has_InstanceVariableMap& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual RecordRelation_has_InstanceVariableMap*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    RecordRelation_has_InstanceVariableMap&
    operator= (const RecordRelation_has_InstanceVariableMap&) = default;
#endif

    virtual 
    ~RecordRelation_has_InstanceVariableMap ();
  };

  class ReferenceValue_correspondsTo_VariableValueComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ReferenceValue_correspondsTo_VariableValueComponent ();

    ReferenceValue_correspondsTo_VariableValueComponent (const ::xercesc::DOMElement& e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    ReferenceValue_correspondsTo_VariableValueComponent (const ReferenceValue_correspondsTo_VariableValueComponent& x,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

    virtual ReferenceValue_correspondsTo_VariableValueComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ReferenceValue_correspondsTo_VariableValueComponent&
    operator= (const ReferenceValue_correspondsTo_VariableValueComponent&) = default;
#endif

    virtual 
    ~ReferenceValue_correspondsTo_VariableValueComponent ();
  };

  class ReferenceValue_hasValueFrom_ReferenceValueDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ReferenceValue_hasValueFrom_ReferenceValueDomain ();

    ReferenceValue_hasValueFrom_ReferenceValueDomain (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    ReferenceValue_hasValueFrom_ReferenceValueDomain (const ReferenceValue_hasValueFrom_ReferenceValueDomain& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    virtual ReferenceValue_hasValueFrom_ReferenceValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ReferenceValue_hasValueFrom_ReferenceValueDomain&
    operator= (const ReferenceValue_hasValueFrom_ReferenceValueDomain&) = default;
#endif

    virtual 
    ~ReferenceValue_hasValueFrom_ReferenceValueDomain ();
  };

  class ReferenceVariable_takesValuesFrom_ReferenceValueDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ReferenceVariable_takesValuesFrom_ReferenceValueDomain ();

    ReferenceVariable_takesValuesFrom_ReferenceValueDomain (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

    ReferenceVariable_takesValuesFrom_ReferenceValueDomain (const ReferenceVariable_takesValuesFrom_ReferenceValueDomain& x,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

    virtual ReferenceVariable_takesValuesFrom_ReferenceValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ReferenceVariable_takesValuesFrom_ReferenceValueDomain&
    operator= (const ReferenceVariable_takesValuesFrom_ReferenceValueDomain&) = default;
#endif

    virtual 
    ~ReferenceVariable_takesValuesFrom_ReferenceValueDomain ();
  };

  class RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain ();

    RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain (const ::xercesc::DOMElement& e,
                                                                     ::xml_schema::flags f = 0,
                                                                     ::xml_schema::container* c = 0);

    RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain (const RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain& x,
                                                                     ::xml_schema::flags f = 0,
                                                                     ::xml_schema::container* c = 0);

    virtual RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain&
    operator= (const RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain&) = default;
#endif

    virtual 
    ~RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain ();
  };

  class RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain ();

    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain (const ::xercesc::DOMElement& e,
                                                                           ::xml_schema::flags f = 0,
                                                                           ::xml_schema::container* c = 0);

    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain (const RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain& x,
                                                                           ::xml_schema::flags f = 0,
                                                                           ::xml_schema::container* c = 0);

    virtual RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain&
    operator= (const RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain&) = default;
#endif

    virtual 
    ~RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain ();
  };

  class RevisableDatum_correspondsTo_Revision: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    RevisableDatum_correspondsTo_Revision ();

    RevisableDatum_correspondsTo_Revision (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    RevisableDatum_correspondsTo_Revision (const RevisableDatum_correspondsTo_Revision& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

    virtual RevisableDatum_correspondsTo_Revision*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    RevisableDatum_correspondsTo_Revision&
    operator= (const RevisableDatum_correspondsTo_Revision&) = default;
#endif

    virtual 
    ~RevisableDatum_correspondsTo_Revision ();
  };

  class Rule_hasPrecondition_ConditionalControlLogic: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Rule_hasPrecondition_ConditionalControlLogic ();

    Rule_hasPrecondition_ConditionalControlLogic (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    Rule_hasPrecondition_ConditionalControlLogic (const Rule_hasPrecondition_ConditionalControlLogic& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual Rule_hasPrecondition_ConditionalControlLogic*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Rule_hasPrecondition_ConditionalControlLogic&
    operator= (const Rule_hasPrecondition_ConditionalControlLogic&) = default;
#endif

    virtual 
    ~Rule_hasPrecondition_ConditionalControlLogic ();
  };

  class RuleBasedScheduling_has_RuleSet: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    RuleBasedScheduling_has_RuleSet ();

    RuleBasedScheduling_has_RuleSet (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    RuleBasedScheduling_has_RuleSet (const RuleBasedScheduling_has_RuleSet& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual RuleBasedScheduling_has_RuleSet*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    RuleBasedScheduling_has_RuleSet&
    operator= (const RuleBasedScheduling_has_RuleSet&) = default;
#endif

    virtual 
    ~RuleBasedScheduling_has_RuleSet ();
  };

  class RuleBasedScheduling_has_Curator: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    RuleBasedScheduling_has_Curator ();

    RuleBasedScheduling_has_Curator (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    RuleBasedScheduling_has_Curator (const RuleBasedScheduling_has_Curator& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    virtual RuleBasedScheduling_has_Curator*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    RuleBasedScheduling_has_Curator&
    operator= (const RuleBasedScheduling_has_Curator&) = default;
#endif

    virtual 
    ~RuleBasedScheduling_has_Curator ();
  };

  class RuleSet_has_Rule: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    RuleSet_has_Rule ();

    RuleSet_has_Rule (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    RuleSet_has_Rule (const RuleSet_has_Rule& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual RuleSet_has_Rule*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    RuleSet_has_Rule&
    operator= (const RuleSet_has_Rule&) = default;
#endif

    virtual 
    ~RuleSet_has_Rule ();
  };

  class ScopedMeasure_circumscribes_DimensionalKeyDefinition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ScopedMeasure_circumscribes_DimensionalKeyDefinition ();

    ScopedMeasure_circumscribes_DimensionalKeyDefinition (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    ScopedMeasure_circumscribes_DimensionalKeyDefinition (const ScopedMeasure_circumscribes_DimensionalKeyDefinition& x,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

    virtual ScopedMeasure_circumscribes_DimensionalKeyDefinition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ScopedMeasure_circumscribes_DimensionalKeyDefinition&
    operator= (const ScopedMeasure_circumscribes_DimensionalKeyDefinition&) = default;
#endif

    virtual 
    ~ScopedMeasure_circumscribes_DimensionalKeyDefinition ();
  };

  class ScopedMeasure_restricts_QualifiedMeasure: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ScopedMeasure_restricts_QualifiedMeasure ();

    ScopedMeasure_restricts_QualifiedMeasure (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    ScopedMeasure_restricts_QualifiedMeasure (const ScopedMeasure_restricts_QualifiedMeasure& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

    virtual ScopedMeasure_restricts_QualifiedMeasure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ScopedMeasure_restricts_QualifiedMeasure&
    operator= (const ScopedMeasure_restricts_QualifiedMeasure&) = default;
#endif

    virtual 
    ~ScopedMeasure_restricts_QualifiedMeasure ();
  };

  class ScopedMeasure_generates_RevisableDatum: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ScopedMeasure_generates_RevisableDatum ();

    ScopedMeasure_generates_RevisableDatum (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    ScopedMeasure_generates_RevisableDatum (const ScopedMeasure_generates_RevisableDatum& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual ScopedMeasure_generates_RevisableDatum*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ScopedMeasure_generates_RevisableDatum&
    operator= (const ScopedMeasure_generates_RevisableDatum&) = default;
#endif

    virtual 
    ~ScopedMeasure_generates_RevisableDatum ();
  };

  class SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain ();

    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain (const ::xercesc::DOMElement& e,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain (const SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain& x,
                                                                    ::xml_schema::flags f = 0,
                                                                    ::xml_schema::container* c = 0);

    virtual SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain&
    operator= (const SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain&) = default;
#endif

    virtual 
    ~SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain ();
  };

  class SentinelValueDomain_takesValuesFrom_EnumerationDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    SentinelValueDomain_takesValuesFrom_EnumerationDomain ();

    SentinelValueDomain_takesValuesFrom_EnumerationDomain (const ::xercesc::DOMElement& e,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    SentinelValueDomain_takesValuesFrom_EnumerationDomain (const SentinelValueDomain_takesValuesFrom_EnumerationDomain& x,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    virtual SentinelValueDomain_takesValuesFrom_EnumerationDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    SentinelValueDomain_takesValuesFrom_EnumerationDomain&
    operator= (const SentinelValueDomain_takesValuesFrom_EnumerationDomain&) = default;
#endif

    virtual 
    ~SentinelValueDomain_takesValuesFrom_EnumerationDomain ();
  };

  class SentinelValueDomain_isDescribedBy_ValueAndConceptDescription: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription ();

    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription (const ::xercesc::DOMElement& e,
                                                                  ::xml_schema::flags f = 0,
                                                                  ::xml_schema::container* c = 0);

    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription (const SentinelValueDomain_isDescribedBy_ValueAndConceptDescription& x,
                                                                  ::xml_schema::flags f = 0,
                                                                  ::xml_schema::container* c = 0);

    virtual SentinelValueDomain_isDescribedBy_ValueAndConceptDescription*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription&
    operator= (const SentinelValueDomain_isDescribedBy_ValueAndConceptDescription&) = default;
#endif

    virtual 
    ~SentinelValueDomain_isDescribedBy_ValueAndConceptDescription ();
  };

  class Sequence_has_SequencePosition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Sequence_has_SequencePosition ();

    Sequence_has_SequencePosition (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    Sequence_has_SequencePosition (const Sequence_has_SequencePosition& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual Sequence_has_SequencePosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Sequence_has_SequencePosition&
    operator= (const Sequence_has_SequencePosition&) = default;
#endif

    virtual 
    ~Sequence_has_SequencePosition ();
  };

  class StatisticalClassification_isMaintainedBy_Organization: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    StatisticalClassification_isMaintainedBy_Organization ();

    StatisticalClassification_isMaintainedBy_Organization (const ::xercesc::DOMElement& e,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    StatisticalClassification_isMaintainedBy_Organization (const StatisticalClassification_isMaintainedBy_Organization& x,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

    virtual StatisticalClassification_isMaintainedBy_Organization*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    StatisticalClassification_isMaintainedBy_Organization&
    operator= (const StatisticalClassification_isMaintainedBy_Organization&) = default;
#endif

    virtual 
    ~StatisticalClassification_isMaintainedBy_Organization ();
  };

  class StatisticalClassification_isIndexedBy_ClassificationIndex: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    StatisticalClassification_isIndexedBy_ClassificationIndex ();

    StatisticalClassification_isIndexedBy_ClassificationIndex (const ::xercesc::DOMElement& e,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

    StatisticalClassification_isIndexedBy_ClassificationIndex (const StatisticalClassification_isIndexedBy_ClassificationIndex& x,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

    virtual StatisticalClassification_isIndexedBy_ClassificationIndex*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    StatisticalClassification_isIndexedBy_ClassificationIndex&
    operator= (const StatisticalClassification_isIndexedBy_ClassificationIndex&) = default;
#endif

    virtual 
    ~StatisticalClassification_isIndexedBy_ClassificationIndex ();
  };

  class StatisticalClassification_isVariantOf_StatisticalClassification: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    StatisticalClassification_isVariantOf_StatisticalClassification ();

    StatisticalClassification_isVariantOf_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                                     ::xml_schema::flags f = 0,
                                                                     ::xml_schema::container* c = 0);

    StatisticalClassification_isVariantOf_StatisticalClassification (const StatisticalClassification_isVariantOf_StatisticalClassification& x,
                                                                     ::xml_schema::flags f = 0,
                                                                     ::xml_schema::container* c = 0);

    virtual StatisticalClassification_isVariantOf_StatisticalClassification*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    StatisticalClassification_isVariantOf_StatisticalClassification&
    operator= (const StatisticalClassification_isVariantOf_StatisticalClassification&) = default;
#endif

    virtual 
    ~StatisticalClassification_isVariantOf_StatisticalClassification ();
  };

  class StatisticalClassification_isSuccessorOf_StatisticalClassification: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    StatisticalClassification_isSuccessorOf_StatisticalClassification ();

    StatisticalClassification_isSuccessorOf_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                                       ::xml_schema::flags f = 0,
                                                                       ::xml_schema::container* c = 0);

    StatisticalClassification_isSuccessorOf_StatisticalClassification (const StatisticalClassification_isSuccessorOf_StatisticalClassification& x,
                                                                       ::xml_schema::flags f = 0,
                                                                       ::xml_schema::container* c = 0);

    virtual StatisticalClassification_isSuccessorOf_StatisticalClassification*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    StatisticalClassification_isSuccessorOf_StatisticalClassification&
    operator= (const StatisticalClassification_isSuccessorOf_StatisticalClassification&) = default;
#endif

    virtual 
    ~StatisticalClassification_isSuccessorOf_StatisticalClassification ();
  };

  class StatisticalClassification_isPredecessorOf_StatisticalClassification: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    StatisticalClassification_isPredecessorOf_StatisticalClassification ();

    StatisticalClassification_isPredecessorOf_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                                         ::xml_schema::flags f = 0,
                                                                         ::xml_schema::container* c = 0);

    StatisticalClassification_isPredecessorOf_StatisticalClassification (const StatisticalClassification_isPredecessorOf_StatisticalClassification& x,
                                                                         ::xml_schema::flags f = 0,
                                                                         ::xml_schema::container* c = 0);

    virtual StatisticalClassification_isPredecessorOf_StatisticalClassification*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    StatisticalClassification_isPredecessorOf_StatisticalClassification&
    operator= (const StatisticalClassification_isPredecessorOf_StatisticalClassification&) = default;
#endif

    virtual 
    ~StatisticalClassification_isPredecessorOf_StatisticalClassification ();
  };

  class StatisticalClassification_has_ClassificationItemPosition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    StatisticalClassification_has_ClassificationItemPosition ();

    StatisticalClassification_has_ClassificationItemPosition (const ::xercesc::DOMElement& e,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    StatisticalClassification_has_ClassificationItemPosition (const StatisticalClassification_has_ClassificationItemPosition& x,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    virtual StatisticalClassification_has_ClassificationItemPosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    StatisticalClassification_has_ClassificationItemPosition&
    operator= (const StatisticalClassification_has_ClassificationItemPosition&) = default;
#endif

    virtual 
    ~StatisticalClassification_has_ClassificationItemPosition ();
  };

  class StatisticalClassification_has_ClassificationItem: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    StatisticalClassification_has_ClassificationItem ();

    StatisticalClassification_has_ClassificationItem (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    StatisticalClassification_has_ClassificationItem (const StatisticalClassification_has_ClassificationItem& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

    virtual StatisticalClassification_has_ClassificationItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    StatisticalClassification_has_ClassificationItem&
    operator= (const StatisticalClassification_has_ClassificationItem&) = default;
#endif

    virtual 
    ~StatisticalClassification_has_ClassificationItem ();
  };

  class StatisticalClassification_has_LevelStructure: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    StatisticalClassification_has_LevelStructure ();

    StatisticalClassification_has_LevelStructure (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    StatisticalClassification_has_LevelStructure (const StatisticalClassification_has_LevelStructure& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

    virtual StatisticalClassification_has_LevelStructure*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    StatisticalClassification_has_LevelStructure&
    operator= (const StatisticalClassification_has_LevelStructure&) = default;
#endif

    virtual 
    ~StatisticalClassification_has_LevelStructure ();
  };

  class StatisticalClassificationRelationship_hasTarget_StatisticalClassification: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    StatisticalClassificationRelationship_hasTarget_StatisticalClassification ();

    StatisticalClassificationRelationship_hasTarget_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                                               ::xml_schema::flags f = 0,
                                                                               ::xml_schema::container* c = 0);

    StatisticalClassificationRelationship_hasTarget_StatisticalClassification (const StatisticalClassificationRelationship_hasTarget_StatisticalClassification& x,
                                                                               ::xml_schema::flags f = 0,
                                                                               ::xml_schema::container* c = 0);

    virtual StatisticalClassificationRelationship_hasTarget_StatisticalClassification*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    StatisticalClassificationRelationship_hasTarget_StatisticalClassification&
    operator= (const StatisticalClassificationRelationship_hasTarget_StatisticalClassification&) = default;
#endif

    virtual 
    ~StatisticalClassificationRelationship_hasTarget_StatisticalClassification ();
  };

  class StatisticalClassificationRelationship_hasSource_StatisticalClassification: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    StatisticalClassificationRelationship_hasSource_StatisticalClassification ();

    StatisticalClassificationRelationship_hasSource_StatisticalClassification (const ::xercesc::DOMElement& e,
                                                                               ::xml_schema::flags f = 0,
                                                                               ::xml_schema::container* c = 0);

    StatisticalClassificationRelationship_hasSource_StatisticalClassification (const StatisticalClassificationRelationship_hasSource_StatisticalClassification& x,
                                                                               ::xml_schema::flags f = 0,
                                                                               ::xml_schema::container* c = 0);

    virtual StatisticalClassificationRelationship_hasSource_StatisticalClassification*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    StatisticalClassificationRelationship_hasSource_StatisticalClassification&
    operator= (const StatisticalClassificationRelationship_hasSource_StatisticalClassification&) = default;
#endif

    virtual 
    ~StatisticalClassificationRelationship_hasSource_StatisticalClassification ();
  };

  class Step_produces_Parameter: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Step_produces_Parameter ();

    Step_produces_Parameter (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    Step_produces_Parameter (const Step_produces_Parameter& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual Step_produces_Parameter*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Step_produces_Parameter&
    operator= (const Step_produces_Parameter&) = default;
#endif

    virtual 
    ~Step_produces_Parameter ();
  };

  class Step_receives_Parameter: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Step_receives_Parameter ();

    Step_receives_Parameter (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    Step_receives_Parameter (const Step_receives_Parameter& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual Step_receives_Parameter*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Step_receives_Parameter&
    operator= (const Step_receives_Parameter&) = default;
#endif

    virtual 
    ~Step_receives_Parameter ();
  };

  class Step_hasSubStep_Step: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Step_hasSubStep_Step ();

    Step_hasSubStep_Step (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    Step_hasSubStep_Step (const Step_hasSubStep_Step& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual Step_hasSubStep_Step*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Step_hasSubStep_Step&
    operator= (const Step_hasSubStep_Step&) = default;
#endif

    virtual 
    ~Step_hasSubStep_Step ();
  };

  class SubstantiveValueDomain_takesValuesFrom_EnumerationDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain ();

    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain (const ::xercesc::DOMElement& e,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain (const SubstantiveValueDomain_takesValuesFrom_EnumerationDomain& x,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

    virtual SubstantiveValueDomain_takesValuesFrom_EnumerationDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    SubstantiveValueDomain_takesValuesFrom_EnumerationDomain&
    operator= (const SubstantiveValueDomain_takesValuesFrom_EnumerationDomain&) = default;
#endif

    virtual 
    ~SubstantiveValueDomain_takesValuesFrom_EnumerationDomain ();
  };

  class SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription ();

    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription (const ::xercesc::DOMElement& e,
                                                                     ::xml_schema::flags f = 0,
                                                                     ::xml_schema::container* c = 0);

    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription (const SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription& x,
                                                                     ::xml_schema::flags f = 0,
                                                                     ::xml_schema::container* c = 0);

    virtual SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription&
    operator= (const SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription&) = default;
#endif

    virtual 
    ~SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription ();
  };

  class SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain ();

    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain (const ::xercesc::DOMElement& e,
                                                                          ::xml_schema::flags f = 0,
                                                                          ::xml_schema::container* c = 0);

    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain (const SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain& x,
                                                                          ::xml_schema::flags f = 0,
                                                                          ::xml_schema::container* c = 0);

    virtual SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain&
    operator= (const SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain&) = default;
#endif

    virtual 
    ~SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain ();
  };

  class Unit_has_UnitType: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    Unit_has_UnitType ();

    Unit_has_UnitType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    Unit_has_UnitType (const Unit_has_UnitType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual Unit_has_UnitType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    Unit_has_UnitType&
    operator= (const Unit_has_UnitType&) = default;
#endif

    virtual 
    ~Unit_has_UnitType ();
  };

  class ValueMapping_formats_DataPoint: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ValueMapping_formats_DataPoint ();

    ValueMapping_formats_DataPoint (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    ValueMapping_formats_DataPoint (const ValueMapping_formats_DataPoint& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual ValueMapping_formats_DataPoint*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ValueMapping_formats_DataPoint&
    operator= (const ValueMapping_formats_DataPoint&) = default;
#endif

    virtual 
    ~ValueMapping_formats_DataPoint ();
  };

  class ValueMapping_uses_PhysicalSegmentLocation: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ValueMapping_uses_PhysicalSegmentLocation ();

    ValueMapping_uses_PhysicalSegmentLocation (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    ValueMapping_uses_PhysicalSegmentLocation (const ValueMapping_uses_PhysicalSegmentLocation& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual ValueMapping_uses_PhysicalSegmentLocation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ValueMapping_uses_PhysicalSegmentLocation&
    operator= (const ValueMapping_uses_PhysicalSegmentLocation&) = default;
#endif

    virtual 
    ~ValueMapping_uses_PhysicalSegmentLocation ();
  };

  class ValueMappingPosition_indexes_ValueMapping: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ValueMappingPosition_indexes_ValueMapping ();

    ValueMappingPosition_indexes_ValueMapping (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    ValueMappingPosition_indexes_ValueMapping (const ValueMappingPosition_indexes_ValueMapping& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual ValueMappingPosition_indexes_ValueMapping*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ValueMappingPosition_indexes_ValueMapping&
    operator= (const ValueMappingPosition_indexes_ValueMapping&) = default;
#endif

    virtual 
    ~ValueMappingPosition_indexes_ValueMapping ();
  };

  class ValueMappingRelationship_hasTarget_ValueMapping: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ValueMappingRelationship_hasTarget_ValueMapping ();

    ValueMappingRelationship_hasTarget_ValueMapping (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    ValueMappingRelationship_hasTarget_ValueMapping (const ValueMappingRelationship_hasTarget_ValueMapping& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    virtual ValueMappingRelationship_hasTarget_ValueMapping*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ValueMappingRelationship_hasTarget_ValueMapping&
    operator= (const ValueMappingRelationship_hasTarget_ValueMapping&) = default;
#endif

    virtual 
    ~ValueMappingRelationship_hasTarget_ValueMapping ();
  };

  class ValueMappingRelationship_hasSource_ValueMapping: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    ValueMappingRelationship_hasSource_ValueMapping ();

    ValueMappingRelationship_hasSource_ValueMapping (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    ValueMappingRelationship_hasSource_ValueMapping (const ValueMappingRelationship_hasSource_ValueMapping& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    virtual ValueMappingRelationship_hasSource_ValueMapping*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    ValueMappingRelationship_hasSource_ValueMapping&
    operator= (const ValueMappingRelationship_hasSource_ValueMapping&) = default;
#endif

    virtual 
    ~ValueMappingRelationship_hasSource_ValueMapping ();
  };

  class VariableCollection_isDefinedBy_Concept: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    VariableCollection_isDefinedBy_Concept ();

    VariableCollection_isDefinedBy_Concept (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    VariableCollection_isDefinedBy_Concept (const VariableCollection_isDefinedBy_Concept& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

    virtual VariableCollection_isDefinedBy_Concept*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    VariableCollection_isDefinedBy_Concept&
    operator= (const VariableCollection_isDefinedBy_Concept&) = default;
#endif

    virtual 
    ~VariableCollection_isDefinedBy_Concept ();
  };

  class VariableCollection_has_ConceptualVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    VariableCollection_has_ConceptualVariable ();

    VariableCollection_has_ConceptualVariable (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    VariableCollection_has_ConceptualVariable (const VariableCollection_has_ConceptualVariable& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

    virtual VariableCollection_has_ConceptualVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    VariableCollection_has_ConceptualVariable&
    operator= (const VariableCollection_has_ConceptualVariable&) = default;
#endif

    virtual 
    ~VariableCollection_has_ConceptualVariable ();
  };

  class VariableCollection_has_VariablePosition: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    VariableCollection_has_VariablePosition ();

    VariableCollection_has_VariablePosition (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    VariableCollection_has_VariablePosition (const VariableCollection_has_VariablePosition& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

    virtual VariableCollection_has_VariablePosition*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    VariableCollection_has_VariablePosition&
    operator= (const VariableCollection_has_VariablePosition&) = default;
#endif

    virtual 
    ~VariableCollection_has_VariablePosition ();
  };

  class VariableDescriptorComponent_isDefinedBy_DescriptorVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    VariableDescriptorComponent_isDefinedBy_DescriptorVariable ();

    VariableDescriptorComponent_isDefinedBy_DescriptorVariable (const ::xercesc::DOMElement& e,
                                                                ::xml_schema::flags f = 0,
                                                                ::xml_schema::container* c = 0);

    VariableDescriptorComponent_isDefinedBy_DescriptorVariable (const VariableDescriptorComponent_isDefinedBy_DescriptorVariable& x,
                                                                ::xml_schema::flags f = 0,
                                                                ::xml_schema::container* c = 0);

    virtual VariableDescriptorComponent_isDefinedBy_DescriptorVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    VariableDescriptorComponent_isDefinedBy_DescriptorVariable&
    operator= (const VariableDescriptorComponent_isDefinedBy_DescriptorVariable&) = default;
#endif

    virtual 
    ~VariableDescriptorComponent_isDefinedBy_DescriptorVariable ();
  };

  class VariableDescriptorComponent_refersTo_VariableValueComponent: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    VariableDescriptorComponent_refersTo_VariableValueComponent ();

    VariableDescriptorComponent_refersTo_VariableValueComponent (const ::xercesc::DOMElement& e,
                                                                 ::xml_schema::flags f = 0,
                                                                 ::xml_schema::container* c = 0);

    VariableDescriptorComponent_refersTo_VariableValueComponent (const VariableDescriptorComponent_refersTo_VariableValueComponent& x,
                                                                 ::xml_schema::flags f = 0,
                                                                 ::xml_schema::container* c = 0);

    virtual VariableDescriptorComponent_refersTo_VariableValueComponent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    VariableDescriptorComponent_refersTo_VariableValueComponent&
    operator= (const VariableDescriptorComponent_refersTo_VariableValueComponent&) = default;
#endif

    virtual 
    ~VariableDescriptorComponent_refersTo_VariableValueComponent ();
  };

  class VariablePosition_indexes_ConceptualVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    VariablePosition_indexes_ConceptualVariable ();

    VariablePosition_indexes_ConceptualVariable (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    VariablePosition_indexes_ConceptualVariable (const VariablePosition_indexes_ConceptualVariable& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

    virtual VariablePosition_indexes_ConceptualVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    VariablePosition_indexes_ConceptualVariable&
    operator= (const VariablePosition_indexes_ConceptualVariable&) = default;
#endif

    virtual 
    ~VariablePosition_indexes_ConceptualVariable ();
  };

  class VariableRelationship_hasTarget_ConceptualVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    VariableRelationship_hasTarget_ConceptualVariable ();

    VariableRelationship_hasTarget_ConceptualVariable (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

    VariableRelationship_hasTarget_ConceptualVariable (const VariableRelationship_hasTarget_ConceptualVariable& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

    virtual VariableRelationship_hasTarget_ConceptualVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    VariableRelationship_hasTarget_ConceptualVariable&
    operator= (const VariableRelationship_hasTarget_ConceptualVariable&) = default;
#endif

    virtual 
    ~VariableRelationship_hasTarget_ConceptualVariable ();
  };

  class VariableRelationship_hasSource_ConceptualVariable: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    VariableRelationship_hasSource_ConceptualVariable ();

    VariableRelationship_hasSource_ConceptualVariable (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

    VariableRelationship_hasSource_ConceptualVariable (const VariableRelationship_hasSource_ConceptualVariable& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

    virtual VariableRelationship_hasSource_ConceptualVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    VariableRelationship_hasSource_ConceptualVariable&
    operator= (const VariableRelationship_hasSource_ConceptualVariable&) = default;
#endif

    virtual 
    ~VariableRelationship_hasSource_ConceptualVariable ();
  };

  class VariableStructure_structures_VariableCollection: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    VariableStructure_structures_VariableCollection ();

    VariableStructure_structures_VariableCollection (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    VariableStructure_structures_VariableCollection (const VariableStructure_structures_VariableCollection& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

    virtual VariableStructure_structures_VariableCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    VariableStructure_structures_VariableCollection&
    operator= (const VariableStructure_structures_VariableCollection&) = default;
#endif

    virtual 
    ~VariableStructure_structures_VariableCollection ();
  };

  class VariableStructure_has_VariableRelationship: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    VariableStructure_has_VariableRelationship ();

    VariableStructure_has_VariableRelationship (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    VariableStructure_has_VariableRelationship (const VariableStructure_has_VariableRelationship& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

    virtual VariableStructure_has_VariableRelationship*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    VariableStructure_has_VariableRelationship&
    operator= (const VariableStructure_has_VariableRelationship&) = default;
#endif

    virtual 
    ~VariableStructure_has_VariableRelationship ();
  };

  class reference: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    reference ();

    reference (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    reference (const reference& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual reference*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    reference&
    operator= (const reference&) = default;
#endif

    virtual 
    ~reference ();
  };

  class relatedResource: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    relatedResource ();

    relatedResource (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    relatedResource (const relatedResource& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual relatedResource*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    relatedResource&
    operator= (const relatedResource&) = default;
#endif

    virtual 
    ~relatedResource ();
  };

  class entryReference: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    entryReference ();

    entryReference (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    entryReference (const entryReference& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual entryReference*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    entryReference&
    operator= (const entryReference&) = default;
#endif

    virtual 
    ~entryReference ();
  };

  class vocabulary: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    vocabulary ();

    vocabulary (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    vocabulary (const vocabulary& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual vocabulary*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    vocabulary&
    operator= (const vocabulary&) = default;
#endif

    virtual 
    ~vocabulary ();
  };

  class licenseReference: public ::XMLSchema::Reference
  {
    public:
    // Constructors.
    //
    licenseReference ();

    licenseReference (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    licenseReference (const licenseReference& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual licenseReference*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
    licenseReference&
    operator= (const licenseReference&) = default;
#endif

    virtual 
    ~licenseReference ();
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace XMLSchema
{
  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (const ::std::string& uri,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (const ::std::string& uri,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (const ::std::string& uri,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::std::istream& is,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::std::istream& is,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::std::istream& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::std::istream& is,
                 const ::std::string& id,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::xercesc::InputSource& is,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::xercesc::InputSource& is,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::xercesc::InputSource& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::XMLSchema::DDICDIModels >
  DDICDIModels_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX______MODEL_BASED_XSD_VARIANTS_DDI_CDI_42_NO_XSD_TYPE_IN_NAME_HXX
