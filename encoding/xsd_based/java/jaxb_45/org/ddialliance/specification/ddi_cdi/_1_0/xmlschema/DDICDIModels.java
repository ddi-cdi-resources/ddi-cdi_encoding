//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.3 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package org.ddialliance.specification.ddi_cdi._1_0.xmlschema;

import java.util.ArrayList;
import java.util.List;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlElements;
import jakarta.xml.bind.annotation.XmlType;


/**
 * DDI-CDI Specification
 *             =====================
 *             
 *             The DDI-Cross Domain Integration (DDI-CDI) specification provides a
 *             model for working with a wide variety of research data across many
 *             scientific and policy domains. It provides a level of detail which
 *             supports machine-actionable processing of data, both within and between
 *             systems, and is designed to be easily aligned with other standards.
 *             
 *             It focuses on the key elements of the data management challenges facing
 *             research today: an exact understanding of data in a wide variety of
 *             formats, coming from many different sources. Two elements are critical
 *             for dealing with these challenges: a flexible means of describing data
 *             that can reveal the connections between the same data existing in
 *             different formats, and a means of describing the provenance of the data
 *             at a detailed (but comprehensible) level: the processes which produced
 *             it must be transparent.
 *             
 *             DDI-CDI covers these areas in a fashion intended to make it optimally
 *             useful to modern systems, which often employ a variety of models, and
 *             comply with a range of related specifications for both functions related
 *             to data description and process/provenance. The model is designed to be
 *             easy to fit into such systems, by aligning with relevant external
 *             standards, and to be align-able with them into the future.
 *             
 *             The core model field-level documentation is available in the section
 *             :ref:`DDICDIModels::DDICDILibrary`.
 *             
 *             The corresponding Git repository can be found at
 *             https://bitbucket.org/ddi-alliance/ddi-cdi/.
 *             
 *             Further information on DDI-CDI is available at the
 *             related DDI Alliance web page https://ddialliance.org/Specification/DDI-CDI/.
 *             
 *             Purpose
 *             -------
 *             
 *             The DDI-CDI specification describes a model and supporting elements for
 *             implementing it in the areas of data description and process/provenance.
 *             It is not intended to supplant existing specifications for these
 *             purposes, but to fill in the information which such specifications often
 *             do not capture. For data, this is the description of a single bit of
 *             information – a datum – which can be used to play different roles in
 *             different data structures and formats. For provenance and process, this
 *             is the packaging of specific machine-level processes, which may be
 *             described in many different ways, into a structure which relates them to
 *             the business processes described at a level understandable to human
 *             users.
 *             
 *             In order to serve this purpose, the DDI-CDI specification uses a Unified
 *             Modeling Language (UML) formalization so that it can be mapped against
 *             other models within systems more easily. Several different syntax
 *             expressions of the model are made available to support implementation.
 *             
 *             Several important features of the specification can be highlighted, to
 *             show how it serves this purpose:
 *             
 *             -  Domain-independence
 *             
 *             -  Datum-Oriented Data Description
 *             
 *             -  Provenance and Process Description
 *             
 *             -  Foundational Metadata
 *             
 *             -  Interoperability, Sustainability, and Alignment with Other Standards
 *             
 *             Each of these will be addressed in more detail, and an outline of the
 *             specification documents is presented.
 *             
 *             Key Features of the Specification
 *             ---------------------------------
 *             
 *             **Domain Independence**
 *             
 *             DDI-CDI is designed to be used with research data from any domain. In
 *             order to do this, it is fundamentally based on the structure and other
 *             generic aspects of the things it describes. It does not attempt to be a
 *             domain model of semantics, nor a model specific to the life-cycle of a
 *             particular domain of science or research. (Historically, DDI has focused
 *             on the Social, behavioral, and Economic [SBE] sciences and some types of
 *             health research – to see how DDI-CDI relates to other DDI
 *             specifications, see below.)
 *             
 *             DDI-CDI is intended to be complimentary to (and used in combination
 *             with) other standards and models which focus more on domain-specific
 *             aspects (such as semantics and life-cycle models). Such generic elements
 *             such as classifications and variables are given a detailed formal
 *             treatment but are agnostic as to the domain. It is left to the user to
 *             employ whatever domain semantics are demanded by the data with which
 *             they are working.
 *             
 *             This feature of the specification makes it well-suited to combining data
 *             coming from more than one domain or system, to allow a description that
 *             supports systems which perform data integration, harmonization, and
 *             similar functions. Cross-domain data sharing is becoming increasingly
 *             common, and DDI-CDI is intended to provide support for this type of
 *             application.
 *             
 *             **Datum-Oriented Data Description**
 *             
 *             DDI-CDI embraces a form of data description which is based on its atomic
 *             components: individual datums. Any given datum can play different roles
 *             in different formatting of the same data set, depending on how it is
 *             processed and transformed. In order to retain the continuity of a given
 *             datum across different formats and throughout a series of processes,
 *             DDI-CDI allows it to be described playing different roles in different
 *             structures.
 *             
 *             DDI-CDI provides four basic types of structural description for data
 *             sets: wide data, long data, dimensional data, and key-value data. These
 *             four types (and their sub-types) provide coverage for many common data
 *             formats today. While not comprehensive, they cover the majority of cases
 *             that the developers of this specification have seen. These include many
 *             of the newer forms of data such as streaming data, "big" data,
 *             registers, and instrument data. The underlying approach is one which
 *             could – and may be – expanded in future. By assigning appropriate roles
 *             to the variables which contain the datums across each of these different
 *             formats, however, it is possible to understand how data passes from one
 *             form to another.
 *             
 *             **Provenance and Process Description**
 *             
 *             If we are to fully understand data, we also need to know how it has been
 *             processed and transformed. Given our ability to describe how a different
 *             datum can be used in different data sets, it becomes desirable to
 *             understand also how those data sets relate to one another in terms of
 *             the processes which use them. This can be understood as an important
 *             aspect of data provenance.
 *             
 *             There are many different ways of describing process and provenance.
 *             Popular models include the Business Process Modelling and Notation
 *             (BPMN) standard and the PROV Ontology (from W3C). There are a multitude
 *             of syntaxes for driving data transformation, cleaning, and analysis in
 *             packages such as R, SAS, Stata, MATLab, SPSS, Python, and so on. There
 *             are also some emerging standard models for specifically describing such
 *             processes (e.g., Structured Data Transformation Language
 *             [SDTL], https://ddialliance.org/products/sdtl/1.0, Validation and
 *             Transformation Language [VTL], https://sdmx.org/?page_id=5096).
 *             
 *             DDI-CDI attempts to do something which complements the use of such
 *             models, by connecting specific processes interpretable by machines at
 *             the lowest level (described in a package-specific syntax or language)
 *             with the higher-level flows which combine these into human-readable
 *             documentation of business processes. Both traditional linear
 *             (deterministic) processing and the newer declarative (non-deterministic)
 *             processing approaches are supported.
 *             
 *             **Foundational Metadata**
 *             
 *             In order to formally describe data at a detailed level, there are many
 *             component elements which themselves must be modelled. Concepts used for
 *             statistical data but also widely applicable – including categories and
 *             variables – are a core part of this, but the range is broad. These
 *             components are included in DDI-CDI as "foundational metadata."
 *             
 *             Terminology for such constructs varies widely across domains. DDI-CDI
 *             has attempted to provide common terms for these components, and to adopt
 *             common models from other standards where it seemed useful.
 *             
 *             One area which deserves particular attention is the "variable cascade" –
 *             a model for how data are described at different points in their
 *             creation, processing, and use, which is designed to optimize reuse.
 *             While many different models have a "variable" of some form, the one
 *             presented in DDI-CDI reflects the experience of working with this
 *             important construct in many of the specifications and standards which
 *             have preceded it. It is a nuanced view of how variables relate and are
 *             understood across different systems, and – although not simple – it is a
 *             powerful model which helps solve some of the commonly encountered
 *             problems in data description and management.
 *             
 *             **Interoperability, Sustainability, and Alignment with Other Standards**
 *             
 *             DDI-CDI is fundamentally a model which is intended to be implemented
 *             across a wide variety of technology platforms, and in combination with
 *             many other standards, models, and specifications. To support this use,
 *             it is formalized using a limited subset of the Unified Modelling
 *             Language (UML) class diagram part. The model is provided in the form of
 *             Canonical XMI (restricted XML Metadata Interchange) – an interchange
 *             format for UML models supporting the import into many different
 *             modelling and development tools. Further, a syntax representation is
 *             provided in XML Schema, so that direct implementation of the model is
 *             possible if needed.
 *             
 *             The platform-independence of the model makes it more easily applicable
 *             across a broad range of applications and helps ensure that it will be
 *             sustainable even as the technology landscape evolves.
 *             
 *             DDI-CDI builds on many other standard models and is aligned with them
 *             where appropriate. This is shown in the model itself, where
 *             formalizations from other models and specifications are refined,
 *             extended, or directly used. The specification includes a description of
 *             what these other standards and models are, and how they are used in DDI-CDI.
 *             
 *             Credits
 *             -------
 *             
 *             Members of the Cross Domain Integration (CDI) Working Group shepherded the standard into its final form and produced the final documentation. Listed in alphabetical order they are: 
 *             
 *             -  Arofan Gregory (chair)
 *             -  Dan Gillman
 *             -  Flavio Rizzolo
 *             -  Hilde Orten
 *             -  Jay Greenfield
 *             -  Joachim Wackerow
 *             -  Larry Hoyle
 *             -  Oliver Hopt
 *             -  Wendy Lee Thomas (Technical Committee contact)
 *             
 *             Over 100 people have contributed to the development of the Data Documentation Initiative Cross Domain Integration (DDI-CDI) specification. A more complete description of their contribution to the work can be found at https://bitbucket.org/ddi-alliance/ddi-cdi/src/master/CREDITS.md.
 * 
 * <p>Java class for DDICDIModels complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>{@code
 * <complexType name="DDICDIModels">
 *   <complexContent>
 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       <sequence>
 *         <group ref="{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}AllElementsDerivedFromClasses"/>
 *         <element ref="{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}Wrapper" maxOccurs="unbounded" minOccurs="0"/>
 *       </sequence>
 *     </restriction>
 *   </complexContent>
 * </complexType>
 * }</pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "DDICDIModels", propOrder = {
    "activityOrAgentOrAgentListing",
    "wrapper"
})
public class DDICDIModels {

    @XmlElements({
        @XmlElement(name = "Activity", type = Activity.class),
        @XmlElement(name = "Agent", type = Agent.class),
        @XmlElement(name = "AgentListing", type = AgentListing.class),
        @XmlElement(name = "AgentPosition", type = AgentPosition.class),
        @XmlElement(name = "AgentRelationship", type = AgentRelationship.class),
        @XmlElement(name = "AgentStructure", type = AgentStructure.class),
        @XmlElement(name = "AllenIntervalAlgebra", type = AllenIntervalAlgebra.class),
        @XmlElement(name = "AttributeComponent", type = AttributeComponent.class),
        @XmlElement(name = "AuthorizationSource", type = AuthorizationSource.class),
        @XmlElement(name = "Category", type = Category.class),
        @XmlElement(name = "CategoryPosition", type = CategoryPosition.class),
        @XmlElement(name = "CategoryRelationStructure", type = CategoryRelationStructure.class),
        @XmlElement(name = "CategoryRelationship", type = CategoryRelationship.class),
        @XmlElement(name = "CategorySet", type = CategorySet.class),
        @XmlElement(name = "CategoryStatistic", type = CategoryStatistic.class),
        @XmlElement(name = "ClassificationFamily", type = ClassificationFamily.class),
        @XmlElement(name = "ClassificationIndex", type = ClassificationIndex.class),
        @XmlElement(name = "ClassificationIndexEntry", type = ClassificationIndexEntry.class),
        @XmlElement(name = "ClassificationIndexEntryPosition", type = ClassificationIndexEntryPosition.class),
        @XmlElement(name = "ClassificationItem", type = ClassificationItem.class),
        @XmlElement(name = "ClassificationItemPosition", type = ClassificationItemPosition.class),
        @XmlElement(name = "ClassificationItemRelationship", type = ClassificationItemRelationship.class),
        @XmlElement(name = "ClassificationItemStructure", type = ClassificationItemStructure.class),
        @XmlElement(name = "ClassificationPosition", type = ClassificationPosition.class),
        @XmlElement(name = "ClassificationSeries", type = ClassificationSeries.class),
        @XmlElement(name = "ClassificationSeriesStructure", type = ClassificationSeriesStructure.class),
        @XmlElement(name = "Code", type = Code.class),
        @XmlElement(name = "CodeList", type = CodeList.class),
        @XmlElement(name = "CodeListStructure", type = CodeListStructure.class),
        @XmlElement(name = "CodePosition", type = CodePosition.class),
        @XmlElement(name = "CodeRelationship", type = CodeRelationship.class),
        @XmlElement(name = "ComponentPosition", type = ComponentPosition.class),
        @XmlElement(name = "Concept", type = Concept.class),
        @XmlElement(name = "ConceptMap", type = ConceptMap.class),
        @XmlElement(name = "ConceptRelationship", type = ConceptRelationship.class),
        @XmlElement(name = "ConceptStructure", type = ConceptStructure.class),
        @XmlElement(name = "ConceptSystem", type = ConceptSystem.class),
        @XmlElement(name = "ConceptSystemCorrespondence", type = ConceptSystemCorrespondence.class),
        @XmlElement(name = "ConceptualDomain", type = ConceptualDomain.class),
        @XmlElement(name = "ConceptualValue", type = ConceptualValue.class),
        @XmlElement(name = "ConceptualVariable", type = ConceptualVariable.class),
        @XmlElement(name = "ConditionalControlLogic", type = ConditionalControlLogic.class),
        @XmlElement(name = "ContextualComponent", type = ContextualComponent.class),
        @XmlElement(name = "ControlLogic", type = ControlLogic.class),
        @XmlElement(name = "CorrespondenceTable", type = CorrespondenceTable.class),
        @XmlElement(name = "Curator", type = Curator.class),
        @XmlElement(name = "DataPoint", type = DataPoint.class),
        @XmlElement(name = "DataPointPosition", type = DataPointPosition.class),
        @XmlElement(name = "DataPointRelationship", type = DataPointRelationship.class),
        @XmlElement(name = "DataSet", type = DataSet.class),
        @XmlElement(name = "DataStore", type = DataStore.class),
        @XmlElement(name = "DataStructure", type = DataStructure.class),
        @XmlElement(name = "DataStructureComponent", type = DataStructureComponent.class),
        @XmlElement(name = "Datum", type = Datum.class),
        @XmlElement(name = "Descriptor", type = Descriptor.class),
        @XmlElement(name = "DescriptorValueDomain", type = DescriptorValueDomain.class),
        @XmlElement(name = "DescriptorVariable", type = DescriptorVariable.class),
        @XmlElement(name = "DeterministicImperative", type = DeterministicImperative.class),
        @XmlElement(name = "DimensionComponent", type = DimensionComponent.class),
        @XmlElement(name = "DimensionGroup", type = DimensionGroup.class),
        @XmlElement(name = "DimensionalDataSet", type = DimensionalDataSet.class),
        @XmlElement(name = "DimensionalDataStructure", type = DimensionalDataStructure.class),
        @XmlElement(name = "DimensionalKey", type = DimensionalKey.class),
        @XmlElement(name = "DimensionalKeyDefinition", type = DimensionalKeyDefinition.class),
        @XmlElement(name = "DimensionalKeyDefinitionMember", type = DimensionalKeyDefinitionMember.class),
        @XmlElement(name = "DimensionalKeyMember", type = DimensionalKeyMember.class),
        @XmlElement(name = "EnumerationDomain", type = EnumerationDomain.class),
        @XmlElement(name = "ForeignKey", type = ForeignKey.class),
        @XmlElement(name = "ForeignKeyComponent", type = ForeignKeyComponent.class),
        @XmlElement(name = "IdentifierComponent", type = IdentifierComponent.class),
        @XmlElement(name = "Individual", type = Individual.class),
        @XmlElement(name = "InformationFlowDefinition", type = InformationFlowDefinition.class),
        @XmlElement(name = "InstanceKey", type = InstanceKey.class),
        @XmlElement(name = "InstanceValue", type = InstanceValue.class),
        @XmlElement(name = "InstanceVariable", type = InstanceVariable.class),
        @XmlElement(name = "InstanceVariableMap", type = InstanceVariableMap.class),
        @XmlElement(name = "Key", type = Key.class),
        @XmlElement(name = "KeyDefinition", type = KeyDefinition.class),
        @XmlElement(name = "KeyDefinitionMember", type = KeyDefinitionMember.class),
        @XmlElement(name = "KeyMember", type = KeyMember.class),
        @XmlElement(name = "KeyValueDataStore", type = KeyValueDataStore.class),
        @XmlElement(name = "KeyValueStructure", type = KeyValueStructure.class),
        @XmlElement(name = "Level", type = Level.class),
        @XmlElement(name = "LevelStructure", type = LevelStructure.class),
        @XmlElement(name = "LogicalRecord", type = LogicalRecord.class),
        @XmlElement(name = "LogicalRecordPosition", type = LogicalRecordPosition.class),
        @XmlElement(name = "LogicalRecordRelationStructure", type = LogicalRecordRelationStructure.class),
        @XmlElement(name = "LogicalRecordRelationship", type = LogicalRecordRelationship.class),
        @XmlElement(name = "LongDataSet", type = LongDataSet.class),
        @XmlElement(name = "LongDataStructure", type = LongDataStructure.class),
        @XmlElement(name = "LongKey", type = LongKey.class),
        @XmlElement(name = "LongMainKeyMember", type = LongMainKeyMember.class),
        @XmlElement(name = "Machine", type = Machine.class),
        @XmlElement(name = "MainKeyMember", type = MainKeyMember.class),
        @XmlElement(name = "MeasureComponent", type = MeasureComponent.class),
        @XmlElement(name = "NonDeterministicDeclarative", type = NonDeterministicDeclarative.class),
        @XmlElement(name = "Notation", type = Notation.class),
        @XmlElement(name = "Organization", type = Organization.class),
        @XmlElement(name = "Parameter", type = Parameter.class),
        @XmlElement(name = "PhysicalDataSet", type = PhysicalDataSet.class),
        @XmlElement(name = "PhysicalDataSetStructure", type = PhysicalDataSetStructure.class),
        @XmlElement(name = "PhysicalLayoutRelationStructure", type = PhysicalLayoutRelationStructure.class),
        @XmlElement(name = "PhysicalRecordSegment", type = PhysicalRecordSegment.class),
        @XmlElement(name = "PhysicalRecordSegmentPosition", type = PhysicalRecordSegmentPosition.class),
        @XmlElement(name = "PhysicalRecordSegmentRelationship", type = PhysicalRecordSegmentRelationship.class),
        @XmlElement(name = "PhysicalRecordSegmentStructure", type = PhysicalRecordSegmentStructure.class),
        @XmlElement(name = "PhysicalSegmentLayout", type = PhysicalSegmentLayout.class),
        @XmlElement(name = "PhysicalSegmentLocation", type = PhysicalSegmentLocation.class),
        @XmlElement(name = "Population", type = Population.class),
        @XmlElement(name = "PrimaryKey", type = PrimaryKey.class),
        @XmlElement(name = "PrimaryKeyComponent", type = PrimaryKeyComponent.class),
        @XmlElement(name = "ProcessingAgent", type = ProcessingAgent.class),
        @XmlElement(name = "ProductionEnvironment", type = ProductionEnvironment.class),
        @XmlElement(name = "QualifiedMeasure", type = QualifiedMeasure.class),
        @XmlElement(name = "RecordRelation", type = RecordRelation.class),
        @XmlElement(name = "ReferenceValue", type = ReferenceValue.class),
        @XmlElement(name = "ReferenceValueDomain", type = ReferenceValueDomain.class),
        @XmlElement(name = "ReferenceVariable", type = ReferenceVariable.class),
        @XmlElement(name = "RepresentedVariable", type = RepresentedVariable.class),
        @XmlElement(name = "RevisableDatum", type = RevisableDatum.class),
        @XmlElement(name = "Revision", type = Revision.class),
        @XmlElement(name = "Rule", type = Rule.class),
        @XmlElement(name = "RuleBasedScheduling", type = RuleBasedScheduling.class),
        @XmlElement(name = "RuleSet", type = RuleSet.class),
        @XmlElement(name = "ScopedMeasure", type = ScopedMeasure.class),
        @XmlElement(name = "SegmentByText", type = SegmentByText.class),
        @XmlElement(name = "SentinelConceptualDomain", type = SentinelConceptualDomain.class),
        @XmlElement(name = "SentinelValueDomain", type = SentinelValueDomain.class),
        @XmlElement(name = "Sequence", type = Sequence.class),
        @XmlElement(name = "SequencePosition", type = SequencePosition.class),
        @XmlElement(name = "Service", type = Service.class),
        @XmlElement(name = "StatisticalClassification", type = StatisticalClassification.class),
        @XmlElement(name = "StatisticalClassificationRelationship", type = StatisticalClassificationRelationship.class),
        @XmlElement(name = "Step", type = Step.class),
        @XmlElement(name = "SubstantiveConceptualDomain", type = SubstantiveConceptualDomain.class),
        @XmlElement(name = "SubstantiveValueDomain", type = SubstantiveValueDomain.class),
        @XmlElement(name = "SyntheticIdComponent", type = SyntheticIdComponent.class),
        @XmlElement(name = "TemporalConstraints", type = TemporalConstraints.class),
        @XmlElement(name = "TemporalControlConstruct", type = TemporalControlConstruct.class),
        @XmlElement(name = "Unit", type = Unit.class),
        @XmlElement(name = "UnitSegmentLayout", type = UnitSegmentLayout.class),
        @XmlElement(name = "UnitType", type = UnitType.class),
        @XmlElement(name = "Universe", type = Universe.class),
        @XmlElement(name = "ValueAndConceptDescription", type = ValueAndConceptDescription.class),
        @XmlElement(name = "ValueDomain", type = ValueDomain.class),
        @XmlElement(name = "ValueMapping", type = ValueMapping.class),
        @XmlElement(name = "ValueMappingPosition", type = ValueMappingPosition.class),
        @XmlElement(name = "ValueMappingRelationship", type = ValueMappingRelationship.class),
        @XmlElement(name = "VariableCollection", type = VariableCollection.class),
        @XmlElement(name = "VariableDescriptorComponent", type = VariableDescriptorComponent.class),
        @XmlElement(name = "VariablePosition", type = VariablePosition.class),
        @XmlElement(name = "VariableRelationship", type = VariableRelationship.class),
        @XmlElement(name = "VariableStructure", type = VariableStructure.class),
        @XmlElement(name = "VariableValueComponent", type = VariableValueComponent.class),
        @XmlElement(name = "WideDataSet", type = WideDataSet.class),
        @XmlElement(name = "WideDataStructure", type = WideDataStructure.class),
        @XmlElement(name = "WideKey", type = WideKey.class),
        @XmlElement(name = "WideKeyMember", type = WideKeyMember.class)
    })
    protected List<Object> activityOrAgentOrAgentListing;
    @XmlElement(name = "Wrapper")
    protected List<Wrapper> wrapper;

    /**
     * Gets the value of the activityOrAgentOrAgentListing property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a {@code set} method for the activityOrAgentOrAgentListing property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getActivityOrAgentOrAgentListing().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Activity }
     * {@link Agent }
     * {@link AgentListing }
     * {@link AgentPosition }
     * {@link AgentRelationship }
     * {@link AgentStructure }
     * {@link AllenIntervalAlgebra }
     * {@link AttributeComponent }
     * {@link AuthorizationSource }
     * {@link Category }
     * {@link CategoryPosition }
     * {@link CategoryRelationStructure }
     * {@link CategoryRelationship }
     * {@link CategorySet }
     * {@link CategoryStatistic }
     * {@link ClassificationFamily }
     * {@link ClassificationIndex }
     * {@link ClassificationIndexEntry }
     * {@link ClassificationIndexEntryPosition }
     * {@link ClassificationItem }
     * {@link ClassificationItemPosition }
     * {@link ClassificationItemRelationship }
     * {@link ClassificationItemStructure }
     * {@link ClassificationPosition }
     * {@link ClassificationSeries }
     * {@link ClassificationSeriesStructure }
     * {@link Code }
     * {@link CodeList }
     * {@link CodeListStructure }
     * {@link CodePosition }
     * {@link CodeRelationship }
     * {@link ComponentPosition }
     * {@link Concept }
     * {@link ConceptMap }
     * {@link ConceptRelationship }
     * {@link ConceptStructure }
     * {@link ConceptSystem }
     * {@link ConceptSystemCorrespondence }
     * {@link ConceptualDomain }
     * {@link ConceptualValue }
     * {@link ConceptualVariable }
     * {@link ConditionalControlLogic }
     * {@link ContextualComponent }
     * {@link ControlLogic }
     * {@link CorrespondenceTable }
     * {@link Curator }
     * {@link DataPoint }
     * {@link DataPointPosition }
     * {@link DataPointRelationship }
     * {@link DataSet }
     * {@link DataStore }
     * {@link DataStructure }
     * {@link DataStructureComponent }
     * {@link Datum }
     * {@link Descriptor }
     * {@link DescriptorValueDomain }
     * {@link DescriptorVariable }
     * {@link DeterministicImperative }
     * {@link DimensionComponent }
     * {@link DimensionGroup }
     * {@link DimensionalDataSet }
     * {@link DimensionalDataStructure }
     * {@link DimensionalKey }
     * {@link DimensionalKeyDefinition }
     * {@link DimensionalKeyDefinitionMember }
     * {@link DimensionalKeyMember }
     * {@link EnumerationDomain }
     * {@link ForeignKey }
     * {@link ForeignKeyComponent }
     * {@link IdentifierComponent }
     * {@link Individual }
     * {@link InformationFlowDefinition }
     * {@link InstanceKey }
     * {@link InstanceValue }
     * {@link InstanceVariable }
     * {@link InstanceVariableMap }
     * {@link Key }
     * {@link KeyDefinition }
     * {@link KeyDefinitionMember }
     * {@link KeyMember }
     * {@link KeyValueDataStore }
     * {@link KeyValueStructure }
     * {@link Level }
     * {@link LevelStructure }
     * {@link LogicalRecord }
     * {@link LogicalRecordPosition }
     * {@link LogicalRecordRelationStructure }
     * {@link LogicalRecordRelationship }
     * {@link LongDataSet }
     * {@link LongDataStructure }
     * {@link LongKey }
     * {@link LongMainKeyMember }
     * {@link Machine }
     * {@link MainKeyMember }
     * {@link MeasureComponent }
     * {@link NonDeterministicDeclarative }
     * {@link Notation }
     * {@link Organization }
     * {@link Parameter }
     * {@link PhysicalDataSet }
     * {@link PhysicalDataSetStructure }
     * {@link PhysicalLayoutRelationStructure }
     * {@link PhysicalRecordSegment }
     * {@link PhysicalRecordSegmentPosition }
     * {@link PhysicalRecordSegmentRelationship }
     * {@link PhysicalRecordSegmentStructure }
     * {@link PhysicalSegmentLayout }
     * {@link PhysicalSegmentLocation }
     * {@link Population }
     * {@link PrimaryKey }
     * {@link PrimaryKeyComponent }
     * {@link ProcessingAgent }
     * {@link ProductionEnvironment }
     * {@link QualifiedMeasure }
     * {@link RecordRelation }
     * {@link ReferenceValue }
     * {@link ReferenceValueDomain }
     * {@link ReferenceVariable }
     * {@link RepresentedVariable }
     * {@link RevisableDatum }
     * {@link Revision }
     * {@link Rule }
     * {@link RuleBasedScheduling }
     * {@link RuleSet }
     * {@link ScopedMeasure }
     * {@link SegmentByText }
     * {@link SentinelConceptualDomain }
     * {@link SentinelValueDomain }
     * {@link Sequence }
     * {@link SequencePosition }
     * {@link Service }
     * {@link StatisticalClassification }
     * {@link StatisticalClassificationRelationship }
     * {@link Step }
     * {@link SubstantiveConceptualDomain }
     * {@link SubstantiveValueDomain }
     * {@link SyntheticIdComponent }
     * {@link TemporalConstraints }
     * {@link TemporalControlConstruct }
     * {@link Unit }
     * {@link UnitSegmentLayout }
     * {@link UnitType }
     * {@link Universe }
     * {@link ValueAndConceptDescription }
     * {@link ValueDomain }
     * {@link ValueMapping }
     * {@link ValueMappingPosition }
     * {@link ValueMappingRelationship }
     * {@link VariableCollection }
     * {@link VariableDescriptorComponent }
     * {@link VariablePosition }
     * {@link VariableRelationship }
     * {@link VariableStructure }
     * {@link VariableValueComponent }
     * {@link WideDataSet }
     * {@link WideDataStructure }
     * {@link WideKey }
     * {@link WideKeyMember }
     * 
     * 
     * @return
     *     The value of the activityOrAgentOrAgentListing property.
     */
    public List<Object> getActivityOrAgentOrAgentListing() {
        if (activityOrAgentOrAgentListing == null) {
            activityOrAgentOrAgentListing = new ArrayList<>();
        }
        return this.activityOrAgentOrAgentListing;
    }

    /**
     * Gets the value of the wrapper property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a {@code set} method for the wrapper property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getWrapper().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Wrapper }
     * 
     * 
     * @return
     *     The value of the wrapper property.
     */
    public List<Wrapper> getWrapper() {
        if (wrapper == null) {
            wrapper = new ArrayList<>();
        }
        return this.wrapper;
    }

}
