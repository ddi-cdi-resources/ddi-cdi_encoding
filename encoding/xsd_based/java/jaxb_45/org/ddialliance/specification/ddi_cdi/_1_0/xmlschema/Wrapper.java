//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.3 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package org.ddialliance.specification.ddi_cdi._1_0.xmlschema;

import java.util.ArrayList;
import java.util.List;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlElements;
import jakarta.xml.bind.annotation.XmlType;


/**
 * Definition
 *             ==========
 *             Information structured according to the DDI-CDI model for a specific purpose or purposes within a system or community.
 * 
 * <p>Java class for Wrapper complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>{@code
 * <complexType name="Wrapper">
 *   <complexContent>
 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       <sequence>
 *         <element name="identifier" type="{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}Identifier" minOccurs="0"/>
 *         <element name="supportingInformation" type="{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}Reference" maxOccurs="unbounded" minOccurs="0"/>
 *         <group ref="{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}AllElementsDerivedFromClasses"/>
 *       </sequence>
 *     </restriction>
 *   </complexContent>
 * </complexType>
 * }</pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Wrapper", propOrder = {
    "identifier",
    "supportingInformation",
    "activityOrAgentOrAgentListing"
})
public class Wrapper {

    protected Identifier identifier;
    protected List<Reference> supportingInformation;
    @XmlElements({
        @XmlElement(name = "Activity", type = Activity.class),
        @XmlElement(name = "Agent", type = Agent.class),
        @XmlElement(name = "AgentListing", type = AgentListing.class),
        @XmlElement(name = "AgentPosition", type = AgentPosition.class),
        @XmlElement(name = "AgentRelationship", type = AgentRelationship.class),
        @XmlElement(name = "AgentStructure", type = AgentStructure.class),
        @XmlElement(name = "AllenIntervalAlgebra", type = AllenIntervalAlgebra.class),
        @XmlElement(name = "AttributeComponent", type = AttributeComponent.class),
        @XmlElement(name = "AuthorizationSource", type = AuthorizationSource.class),
        @XmlElement(name = "Category", type = Category.class),
        @XmlElement(name = "CategoryPosition", type = CategoryPosition.class),
        @XmlElement(name = "CategoryRelationStructure", type = CategoryRelationStructure.class),
        @XmlElement(name = "CategoryRelationship", type = CategoryRelationship.class),
        @XmlElement(name = "CategorySet", type = CategorySet.class),
        @XmlElement(name = "CategoryStatistic", type = CategoryStatistic.class),
        @XmlElement(name = "ClassificationFamily", type = ClassificationFamily.class),
        @XmlElement(name = "ClassificationIndex", type = ClassificationIndex.class),
        @XmlElement(name = "ClassificationIndexEntry", type = ClassificationIndexEntry.class),
        @XmlElement(name = "ClassificationIndexEntryPosition", type = ClassificationIndexEntryPosition.class),
        @XmlElement(name = "ClassificationItem", type = ClassificationItem.class),
        @XmlElement(name = "ClassificationItemPosition", type = ClassificationItemPosition.class),
        @XmlElement(name = "ClassificationItemRelationship", type = ClassificationItemRelationship.class),
        @XmlElement(name = "ClassificationItemStructure", type = ClassificationItemStructure.class),
        @XmlElement(name = "ClassificationPosition", type = ClassificationPosition.class),
        @XmlElement(name = "ClassificationSeries", type = ClassificationSeries.class),
        @XmlElement(name = "ClassificationSeriesStructure", type = ClassificationSeriesStructure.class),
        @XmlElement(name = "Code", type = Code.class),
        @XmlElement(name = "CodeList", type = CodeList.class),
        @XmlElement(name = "CodeListStructure", type = CodeListStructure.class),
        @XmlElement(name = "CodePosition", type = CodePosition.class),
        @XmlElement(name = "CodeRelationship", type = CodeRelationship.class),
        @XmlElement(name = "ComponentPosition", type = ComponentPosition.class),
        @XmlElement(name = "Concept", type = Concept.class),
        @XmlElement(name = "ConceptMap", type = ConceptMap.class),
        @XmlElement(name = "ConceptRelationship", type = ConceptRelationship.class),
        @XmlElement(name = "ConceptStructure", type = ConceptStructure.class),
        @XmlElement(name = "ConceptSystem", type = ConceptSystem.class),
        @XmlElement(name = "ConceptSystemCorrespondence", type = ConceptSystemCorrespondence.class),
        @XmlElement(name = "ConceptualDomain", type = ConceptualDomain.class),
        @XmlElement(name = "ConceptualValue", type = ConceptualValue.class),
        @XmlElement(name = "ConceptualVariable", type = ConceptualVariable.class),
        @XmlElement(name = "ConditionalControlLogic", type = ConditionalControlLogic.class),
        @XmlElement(name = "ContextualComponent", type = ContextualComponent.class),
        @XmlElement(name = "ControlLogic", type = ControlLogic.class),
        @XmlElement(name = "CorrespondenceTable", type = CorrespondenceTable.class),
        @XmlElement(name = "Curator", type = Curator.class),
        @XmlElement(name = "DataPoint", type = DataPoint.class),
        @XmlElement(name = "DataPointPosition", type = DataPointPosition.class),
        @XmlElement(name = "DataPointRelationship", type = DataPointRelationship.class),
        @XmlElement(name = "DataSet", type = DataSet.class),
        @XmlElement(name = "DataStore", type = DataStore.class),
        @XmlElement(name = "DataStructure", type = DataStructure.class),
        @XmlElement(name = "DataStructureComponent", type = DataStructureComponent.class),
        @XmlElement(name = "Datum", type = Datum.class),
        @XmlElement(name = "Descriptor", type = Descriptor.class),
        @XmlElement(name = "DescriptorValueDomain", type = DescriptorValueDomain.class),
        @XmlElement(name = "DescriptorVariable", type = DescriptorVariable.class),
        @XmlElement(name = "DeterministicImperative", type = DeterministicImperative.class),
        @XmlElement(name = "DimensionComponent", type = DimensionComponent.class),
        @XmlElement(name = "DimensionGroup", type = DimensionGroup.class),
        @XmlElement(name = "DimensionalDataSet", type = DimensionalDataSet.class),
        @XmlElement(name = "DimensionalDataStructure", type = DimensionalDataStructure.class),
        @XmlElement(name = "DimensionalKey", type = DimensionalKey.class),
        @XmlElement(name = "DimensionalKeyDefinition", type = DimensionalKeyDefinition.class),
        @XmlElement(name = "DimensionalKeyDefinitionMember", type = DimensionalKeyDefinitionMember.class),
        @XmlElement(name = "DimensionalKeyMember", type = DimensionalKeyMember.class),
        @XmlElement(name = "EnumerationDomain", type = EnumerationDomain.class),
        @XmlElement(name = "ForeignKey", type = ForeignKey.class),
        @XmlElement(name = "ForeignKeyComponent", type = ForeignKeyComponent.class),
        @XmlElement(name = "IdentifierComponent", type = IdentifierComponent.class),
        @XmlElement(name = "Individual", type = Individual.class),
        @XmlElement(name = "InformationFlowDefinition", type = InformationFlowDefinition.class),
        @XmlElement(name = "InstanceKey", type = InstanceKey.class),
        @XmlElement(name = "InstanceValue", type = InstanceValue.class),
        @XmlElement(name = "InstanceVariable", type = InstanceVariable.class),
        @XmlElement(name = "InstanceVariableMap", type = InstanceVariableMap.class),
        @XmlElement(name = "Key", type = Key.class),
        @XmlElement(name = "KeyDefinition", type = KeyDefinition.class),
        @XmlElement(name = "KeyDefinitionMember", type = KeyDefinitionMember.class),
        @XmlElement(name = "KeyMember", type = KeyMember.class),
        @XmlElement(name = "KeyValueDataStore", type = KeyValueDataStore.class),
        @XmlElement(name = "KeyValueStructure", type = KeyValueStructure.class),
        @XmlElement(name = "Level", type = Level.class),
        @XmlElement(name = "LevelStructure", type = LevelStructure.class),
        @XmlElement(name = "LogicalRecord", type = LogicalRecord.class),
        @XmlElement(name = "LogicalRecordPosition", type = LogicalRecordPosition.class),
        @XmlElement(name = "LogicalRecordRelationStructure", type = LogicalRecordRelationStructure.class),
        @XmlElement(name = "LogicalRecordRelationship", type = LogicalRecordRelationship.class),
        @XmlElement(name = "LongDataSet", type = LongDataSet.class),
        @XmlElement(name = "LongDataStructure", type = LongDataStructure.class),
        @XmlElement(name = "LongKey", type = LongKey.class),
        @XmlElement(name = "LongMainKeyMember", type = LongMainKeyMember.class),
        @XmlElement(name = "Machine", type = Machine.class),
        @XmlElement(name = "MainKeyMember", type = MainKeyMember.class),
        @XmlElement(name = "MeasureComponent", type = MeasureComponent.class),
        @XmlElement(name = "NonDeterministicDeclarative", type = NonDeterministicDeclarative.class),
        @XmlElement(name = "Notation", type = Notation.class),
        @XmlElement(name = "Organization", type = Organization.class),
        @XmlElement(name = "Parameter", type = Parameter.class),
        @XmlElement(name = "PhysicalDataSet", type = PhysicalDataSet.class),
        @XmlElement(name = "PhysicalDataSetStructure", type = PhysicalDataSetStructure.class),
        @XmlElement(name = "PhysicalLayoutRelationStructure", type = PhysicalLayoutRelationStructure.class),
        @XmlElement(name = "PhysicalRecordSegment", type = PhysicalRecordSegment.class),
        @XmlElement(name = "PhysicalRecordSegmentPosition", type = PhysicalRecordSegmentPosition.class),
        @XmlElement(name = "PhysicalRecordSegmentRelationship", type = PhysicalRecordSegmentRelationship.class),
        @XmlElement(name = "PhysicalRecordSegmentStructure", type = PhysicalRecordSegmentStructure.class),
        @XmlElement(name = "PhysicalSegmentLayout", type = PhysicalSegmentLayout.class),
        @XmlElement(name = "PhysicalSegmentLocation", type = PhysicalSegmentLocation.class),
        @XmlElement(name = "Population", type = Population.class),
        @XmlElement(name = "PrimaryKey", type = PrimaryKey.class),
        @XmlElement(name = "PrimaryKeyComponent", type = PrimaryKeyComponent.class),
        @XmlElement(name = "ProcessingAgent", type = ProcessingAgent.class),
        @XmlElement(name = "ProductionEnvironment", type = ProductionEnvironment.class),
        @XmlElement(name = "QualifiedMeasure", type = QualifiedMeasure.class),
        @XmlElement(name = "RecordRelation", type = RecordRelation.class),
        @XmlElement(name = "ReferenceValue", type = ReferenceValue.class),
        @XmlElement(name = "ReferenceValueDomain", type = ReferenceValueDomain.class),
        @XmlElement(name = "ReferenceVariable", type = ReferenceVariable.class),
        @XmlElement(name = "RepresentedVariable", type = RepresentedVariable.class),
        @XmlElement(name = "RevisableDatum", type = RevisableDatum.class),
        @XmlElement(name = "Revision", type = Revision.class),
        @XmlElement(name = "Rule", type = Rule.class),
        @XmlElement(name = "RuleBasedScheduling", type = RuleBasedScheduling.class),
        @XmlElement(name = "RuleSet", type = RuleSet.class),
        @XmlElement(name = "ScopedMeasure", type = ScopedMeasure.class),
        @XmlElement(name = "SegmentByText", type = SegmentByText.class),
        @XmlElement(name = "SentinelConceptualDomain", type = SentinelConceptualDomain.class),
        @XmlElement(name = "SentinelValueDomain", type = SentinelValueDomain.class),
        @XmlElement(name = "Sequence", type = Sequence.class),
        @XmlElement(name = "SequencePosition", type = SequencePosition.class),
        @XmlElement(name = "Service", type = Service.class),
        @XmlElement(name = "StatisticalClassification", type = StatisticalClassification.class),
        @XmlElement(name = "StatisticalClassificationRelationship", type = StatisticalClassificationRelationship.class),
        @XmlElement(name = "Step", type = Step.class),
        @XmlElement(name = "SubstantiveConceptualDomain", type = SubstantiveConceptualDomain.class),
        @XmlElement(name = "SubstantiveValueDomain", type = SubstantiveValueDomain.class),
        @XmlElement(name = "SyntheticIdComponent", type = SyntheticIdComponent.class),
        @XmlElement(name = "TemporalConstraints", type = TemporalConstraints.class),
        @XmlElement(name = "TemporalControlConstruct", type = TemporalControlConstruct.class),
        @XmlElement(name = "Unit", type = Unit.class),
        @XmlElement(name = "UnitSegmentLayout", type = UnitSegmentLayout.class),
        @XmlElement(name = "UnitType", type = UnitType.class),
        @XmlElement(name = "Universe", type = Universe.class),
        @XmlElement(name = "ValueAndConceptDescription", type = ValueAndConceptDescription.class),
        @XmlElement(name = "ValueDomain", type = ValueDomain.class),
        @XmlElement(name = "ValueMapping", type = ValueMapping.class),
        @XmlElement(name = "ValueMappingPosition", type = ValueMappingPosition.class),
        @XmlElement(name = "ValueMappingRelationship", type = ValueMappingRelationship.class),
        @XmlElement(name = "VariableCollection", type = VariableCollection.class),
        @XmlElement(name = "VariableDescriptorComponent", type = VariableDescriptorComponent.class),
        @XmlElement(name = "VariablePosition", type = VariablePosition.class),
        @XmlElement(name = "VariableRelationship", type = VariableRelationship.class),
        @XmlElement(name = "VariableStructure", type = VariableStructure.class),
        @XmlElement(name = "VariableValueComponent", type = VariableValueComponent.class),
        @XmlElement(name = "WideDataSet", type = WideDataSet.class),
        @XmlElement(name = "WideDataStructure", type = WideDataStructure.class),
        @XmlElement(name = "WideKey", type = WideKey.class),
        @XmlElement(name = "WideKeyMember", type = WideKeyMember.class)
    })
    protected List<Object> activityOrAgentOrAgentListing;

    /**
     * Gets the value of the identifier property.
     * 
     * @return
     *     possible object is
     *     {@link Identifier }
     *     
     */
    public Identifier getIdentifier() {
        return identifier;
    }

    /**
     * Sets the value of the identifier property.
     * 
     * @param value
     *     allowed object is
     *     {@link Identifier }
     *     
     */
    public void setIdentifier(Identifier value) {
        this.identifier = value;
    }

    /**
     * Gets the value of the supportingInformation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a {@code set} method for the supportingInformation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSupportingInformation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Reference }
     * 
     * 
     * @return
     *     The value of the supportingInformation property.
     */
    public List<Reference> getSupportingInformation() {
        if (supportingInformation == null) {
            supportingInformation = new ArrayList<>();
        }
        return this.supportingInformation;
    }

    /**
     * Gets the value of the activityOrAgentOrAgentListing property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a {@code set} method for the activityOrAgentOrAgentListing property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getActivityOrAgentOrAgentListing().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Activity }
     * {@link Agent }
     * {@link AgentListing }
     * {@link AgentPosition }
     * {@link AgentRelationship }
     * {@link AgentStructure }
     * {@link AllenIntervalAlgebra }
     * {@link AttributeComponent }
     * {@link AuthorizationSource }
     * {@link Category }
     * {@link CategoryPosition }
     * {@link CategoryRelationStructure }
     * {@link CategoryRelationship }
     * {@link CategorySet }
     * {@link CategoryStatistic }
     * {@link ClassificationFamily }
     * {@link ClassificationIndex }
     * {@link ClassificationIndexEntry }
     * {@link ClassificationIndexEntryPosition }
     * {@link ClassificationItem }
     * {@link ClassificationItemPosition }
     * {@link ClassificationItemRelationship }
     * {@link ClassificationItemStructure }
     * {@link ClassificationPosition }
     * {@link ClassificationSeries }
     * {@link ClassificationSeriesStructure }
     * {@link Code }
     * {@link CodeList }
     * {@link CodeListStructure }
     * {@link CodePosition }
     * {@link CodeRelationship }
     * {@link ComponentPosition }
     * {@link Concept }
     * {@link ConceptMap }
     * {@link ConceptRelationship }
     * {@link ConceptStructure }
     * {@link ConceptSystem }
     * {@link ConceptSystemCorrespondence }
     * {@link ConceptualDomain }
     * {@link ConceptualValue }
     * {@link ConceptualVariable }
     * {@link ConditionalControlLogic }
     * {@link ContextualComponent }
     * {@link ControlLogic }
     * {@link CorrespondenceTable }
     * {@link Curator }
     * {@link DataPoint }
     * {@link DataPointPosition }
     * {@link DataPointRelationship }
     * {@link DataSet }
     * {@link DataStore }
     * {@link DataStructure }
     * {@link DataStructureComponent }
     * {@link Datum }
     * {@link Descriptor }
     * {@link DescriptorValueDomain }
     * {@link DescriptorVariable }
     * {@link DeterministicImperative }
     * {@link DimensionComponent }
     * {@link DimensionGroup }
     * {@link DimensionalDataSet }
     * {@link DimensionalDataStructure }
     * {@link DimensionalKey }
     * {@link DimensionalKeyDefinition }
     * {@link DimensionalKeyDefinitionMember }
     * {@link DimensionalKeyMember }
     * {@link EnumerationDomain }
     * {@link ForeignKey }
     * {@link ForeignKeyComponent }
     * {@link IdentifierComponent }
     * {@link Individual }
     * {@link InformationFlowDefinition }
     * {@link InstanceKey }
     * {@link InstanceValue }
     * {@link InstanceVariable }
     * {@link InstanceVariableMap }
     * {@link Key }
     * {@link KeyDefinition }
     * {@link KeyDefinitionMember }
     * {@link KeyMember }
     * {@link KeyValueDataStore }
     * {@link KeyValueStructure }
     * {@link Level }
     * {@link LevelStructure }
     * {@link LogicalRecord }
     * {@link LogicalRecordPosition }
     * {@link LogicalRecordRelationStructure }
     * {@link LogicalRecordRelationship }
     * {@link LongDataSet }
     * {@link LongDataStructure }
     * {@link LongKey }
     * {@link LongMainKeyMember }
     * {@link Machine }
     * {@link MainKeyMember }
     * {@link MeasureComponent }
     * {@link NonDeterministicDeclarative }
     * {@link Notation }
     * {@link Organization }
     * {@link Parameter }
     * {@link PhysicalDataSet }
     * {@link PhysicalDataSetStructure }
     * {@link PhysicalLayoutRelationStructure }
     * {@link PhysicalRecordSegment }
     * {@link PhysicalRecordSegmentPosition }
     * {@link PhysicalRecordSegmentRelationship }
     * {@link PhysicalRecordSegmentStructure }
     * {@link PhysicalSegmentLayout }
     * {@link PhysicalSegmentLocation }
     * {@link Population }
     * {@link PrimaryKey }
     * {@link PrimaryKeyComponent }
     * {@link ProcessingAgent }
     * {@link ProductionEnvironment }
     * {@link QualifiedMeasure }
     * {@link RecordRelation }
     * {@link ReferenceValue }
     * {@link ReferenceValueDomain }
     * {@link ReferenceVariable }
     * {@link RepresentedVariable }
     * {@link RevisableDatum }
     * {@link Revision }
     * {@link Rule }
     * {@link RuleBasedScheduling }
     * {@link RuleSet }
     * {@link ScopedMeasure }
     * {@link SegmentByText }
     * {@link SentinelConceptualDomain }
     * {@link SentinelValueDomain }
     * {@link Sequence }
     * {@link SequencePosition }
     * {@link Service }
     * {@link StatisticalClassification }
     * {@link StatisticalClassificationRelationship }
     * {@link Step }
     * {@link SubstantiveConceptualDomain }
     * {@link SubstantiveValueDomain }
     * {@link SyntheticIdComponent }
     * {@link TemporalConstraints }
     * {@link TemporalControlConstruct }
     * {@link Unit }
     * {@link UnitSegmentLayout }
     * {@link UnitType }
     * {@link Universe }
     * {@link ValueAndConceptDescription }
     * {@link ValueDomain }
     * {@link ValueMapping }
     * {@link ValueMappingPosition }
     * {@link ValueMappingRelationship }
     * {@link VariableCollection }
     * {@link VariableDescriptorComponent }
     * {@link VariablePosition }
     * {@link VariableRelationship }
     * {@link VariableStructure }
     * {@link VariableValueComponent }
     * {@link WideDataSet }
     * {@link WideDataStructure }
     * {@link WideKey }
     * {@link WideKeyMember }
     * 
     * 
     * @return
     *     The value of the activityOrAgentOrAgentListing property.
     */
    public List<Object> getActivityOrAgentOrAgentListing() {
        if (activityOrAgentOrAgentListing == null) {
            activityOrAgentOrAgentListing = new ArrayList<>();
        }
        return this.activityOrAgentOrAgentListing;
    }

}
