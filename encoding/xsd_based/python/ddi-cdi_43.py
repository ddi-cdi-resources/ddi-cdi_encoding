#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sat Nov 18 20:20:51 2023 by generateDS.py version 2.43.3.
# Python 3.10.2 (tags/v3.10.2:a58ebcc, Jan 17 2022, 14:12:15) [MSC v.1929 64 bit (AMD64)]
#
# Command line options:
#   ('--export', 'etree')
#   ('--no-warnings', '')
#   ('-o', 'ddi-cdi_43.py')
#
# Command line arguments:
#   ddi-cdi_43_noXsdTypeInName_complete.xsd
#
# Command line:
#   C:\Users\Joachim Wackerow\AppData\Roaming\Python\Python310\Scripts\generateDS.py --export="etree" --no-warnings -o "ddi-cdi_43.py" ddi-cdi_43_noXsdTypeInName_complete.xsd
#
# Current working directory (os.getcwd()):
#   python
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            value = ('%.15f' % float(input_data)).rstrip('0')
            if value.endswith('.'):
                value += '0'
            return value
    
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            input_data = input_data.strip()
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    s1 = s1.replace('\n', '&#10;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Start enum classes
#
class CategoryRelationCode(str, Enum):
    """CategoryRelationCode -- Definition
    ============
    Indicates the type of relationship, nominal, ordinal, interval, ratio, or continuous. Use where appropriate for the representation type.
    
    """
    CONTINUOUS='Continuous' # May be used to identify both interval and ratio classification levels, when more precise information is not available.
    INTERVAL='Interval' # The categories in the domain are in rank order and have a consistent interval between each category so that differences between arbitrary pairs of measurements can be meaningfully compared.
    NOMINAL='Nominal' # A relationship of less than, or greater than, cannot be established among the included categories. This type of relationship is also called categorical or discrete.
    ORDINAL='Ordinal' # The categories in the domain have a rank order.
    RATIO='Ratio' # The categories have all the features of interval measurement and also have meaningful ratios between arbitrary pairs of numbers.


class ComparisonOperator(str, Enum):
    """ComparisonOperator -- Definition
    ============
    Defines the relationship between values in key/value pair.
    
    """
    EQUAL='Equal' # The value the key's in the source and target must be equal.
    GREATER_THAN='GreaterThan' # The value the key in the source must be greater than the key in the target.
    GREATER_THAN_OR_EQUAL_TO='GreaterThanOrEqualTo' # The value the key in the source must be greater than or equal to the key in the target.
    LESS_THAN='LessThan' # The value the key in the source must be less than the key in the target.
    LESS_THAN_OR_EQUAL_TO='LessThanOrEqualTo' # The value the key in the source must be less than or equal to the key in the target.
    NOT_EQUAL='NotEqual' # The value the key's in the source and target must be unequal.


class ComputationBaseList(str, Enum):
    """ComputationBaseList -- Definition
    ============
    Defines the cases included in determining the statistic.
    
    """
    MISSING_ONLY='MissingOnly' # Only missing (invalid) cases included in the calculation.
    TOTAL='Total' # All cases, both valid and missing (invalid).
    VALID_ONLY='ValidOnly' # Only valid values, missing (invalid) are not included in the calculation.


class ControlConstruct(str, Enum):
    """ControlConstruct -- Definition
    ============
    Type of control construct used by the conditional control logic related to an activity.
    
    """
    ELSE='Else' # Describes an Else type of control construct.
    IF_THEN='IfThen' # Describes an IfThen type of control construct. If the stated condition is met, the Then clause is triggered.
    LOOP='Loop' # Describes a Loop type of control construct (loops until a limiting condition is met).
    REPEAT_UNTIL='RepeatUntil' # Describes an RepeatUntil type of control construct (to be repeated until a specified condition is met).
    REPEAT_WHILE='RepeatWhile' # Describes a RepeatWhile type of control construct (to be repeated while a specified condition is met).


class MatchingCriterion(str, Enum):
    """MatchingCriterion -- Definition
    ============
    Supports mapping comparative relationships by type of match. Not used for causative, sequential, temporal or special relations.
    
    """
    CLOSE_MATCH='CloseMatch' # The identified objects (source and target) are not exact but are similar. Equivalent to SKOS closeMatch - see the W3C Recommendation "SKOS Simple Knowledge Organization System Reference" - 10. Mapping Properties (https://www.w3.org/TR/skos-reference/#L4186).
    DISJOINT='Disjoint' # The identified objects are do not have a close or exact match. Equivalent to disjoint objects in SKOS - see the W3C Recommendation "SKOS Simple Knowledge Organization System Reference" (https://www.w3.org/TR/skos-reference/#L4186).
    EXACT_MATCH='ExactMatch' # The identified objects (source and target) are identical. Equivalent to SKOS exactMatch - see the W3C Recommendation "SKOS Simple Knowledge Organization System Reference" - 10. Mapping Properties (https://www.w3.org/TR/skos-reference/#L4186).


class MemberRelationshipScope(str, Enum):
    """MemberRelationshipScope -- Definition
    ============
    A vocabulary for the specification of how much of a collection is referenced. All, some or none of the collection may be indicated.
    
    """
    ALL='All' # Every member of the collection is indicated.
    NONE='None' # This indicates that no member of the collection is indicated, e.g. None of the relationships are symmetric.
    SOME='Some' # Some, but not necessarily all of the members of the collection are indicated.


class PointFormat(str, Enum):
    """PointFormat -- Definition
    ============
    Provides an enumerated list of valid point format types for capturing a coordinate point.
    
    """
    DECIMAL_DEGREE='DecimalDegree' # Value is expressed as a decimal degree.
    DECIMAL_MINUTES='DecimalMinutes' # Value is expressed as decimal minutes.
    DEGREES_MINUTES_SECONDS='DegreesMinutesSeconds' # Value is expressed as degrees-minutes-seconds.
    FEET='Feet' # Value is expressed in feet.
    METERS='Meters' # Value is expressed in meters.


class SchedulingStrategy(str, Enum):
    """SchedulingStrategy -- Definition
    ============
    Enumeration that consists of forward chaining and backward chaining. Rule based scheduling is guided by its scheduling strategy.
    
    """
    BACKWARD_CHAINING='BackwardChaining' # Backward chaining is a strategy of first identifying the goal/completion date and working backward in time from there to achieve it.
    FORWARD_CHAINING='ForwardChaining' # Forward chaining is a strategy of planning to complete each step as soon as possible to reach the goal at the earliest date.


class SexSpecification(str, Enum):
    """SexSpecification -- Definition
    ============
    Sex specification is limited to the purpose of determining the proper pronoun to use in addressing the individual. This may be based on conventional usage or personal preference.
    
    """
    FEMININE='Feminine' # Use the feminine pronoun (equivalent of English she, her, her's).
    GENDER_NEUTRAL='GenderNeutral' # Use a gender neutral or non-specified pronoun. (equivalent of English they, them, theirs).
    MASCULINE='Masculine' # Use the masculine pronoun (equivalent of English he, him, his).


class StructureExtent(str, Enum):
    """StructureExtent -- Definition
    ============
    Type of relation in terms of totality with respect to an associated collection.  The totality type is given by the controlled vocabulary {total, partial}.
    Examples
    ==========
    A binary relation R on a collection C is total if all members of C are related to each other in R. The relation is partial otherwise.
    
    """
    PARTIAL='Partial' # Some members of a collection C are not related to each other.
    TOTAL='Total' # All members of a collection C are related to each other.


class TableDirectionValues(str, Enum):
    """TableDirectionValues -- Definition
    ============
    Indicates whether the tables in the group should be displayed with the first column on the right, on the left, or based on the first character in the table that has a specific direction.
    
    """
    AUTO='Auto' # Display table based on the first character in the table that has a specific direction.
    LTR='Ltr' # Display table with first column on the left.
    RTL='Rtl' # Display table with first column on the right.


class TemporalOperator(str, Enum):
    """TemporalOperator -- Definition
    ============
    Set of control flow operators where the continuation of the execution flow depends on the finalization of one or more preceding activities.
    
    """
    AND_JOIN='AndJoin' # Given three activities A, B and C, if ANDJoin(A, B) -> C, then C is executed after both A and B finish executing. ANDJoin is sometimes referred to as synchronization.
    AND_SPLIT='AndSplit' # Given three activities A, B and C, if ANDSplit(A) -> (B, C), then both B and C are executed after A finishes executing.
    XOR_JOIN='XorJoin' # Given three activities A, B and C, if XORJoin(A, B) -> C, then C is executed after either A or B finishes executing. XORJoin is sometimes referred to as simple merge.
    XOR_SPLIT='XorSplit' # Given three activities A, B and C, if XORSplit(A) -> (B, C), then either B or C is executed, not both, after A finishes executing. XORSplit is sometimes referred to as exclusive choice.


class TemporalRelation(str, Enum):
    """TemporalRelation -- Definition
    ==========
    Set of thirteen Allen's interval relations defined as Contains, Finishes, Meets, Overlaps, Precedes, Starts (and their converses), plus Equals. These are jointly exhaustive and pairwise disjoint binary relations representing temporal relationships between pairs of time intervals.
    Explanatory notes
    =================
    Here are the relations in Allen's interval algebra:
    - a precedes b (p) and b is preceded by a (P)
    - a meets b (m) and b is met by a (M)
    - a overlaps b (o) and b is overlapped by a (O)
    - a is finished by b (F) and b finishes a (f)
    - a contains B (D) and b is during a (d)
    - a starts b (s) and b is started by a (S)
    - a and b equal (e) each other
    
    """
    CONTAINS='Contains' # A contains interval relation. Representation of the contains relation in Allen's interval algebra. We say that an interval A contains another interval B if and only if A begins before B but finishes after it. More precisely, A.start < B.start < B.end < A.end. Instead of saying that A contains B we can also say that B is during A (converse). An asymmetric relationship: anti-reflexive, anti-symmetric, transitive.
    EQUALS='Equals' # An equals interval relation. Representation of the equals relation in Allen's interval algebra. We say that an interval A equals another interval B if and only if they both begin and finish at the same time. More precisely, A.start = B.start < A.end = B.end. Instead of saying that A equals B we can also say the B equals A (reflexive). An equivalence symmetric relationship: reflexive, symmetric, transitive.
    FINISHES='Finishes' # A finishes interval relation. Representation of the finishes relation in Allen's interval algebra. We say that an interval A finishes another interval B if and only if A begins after B but both finish at the same time. More precisely, B.start < A.start < B.end = A.end. Instead of saying that A finishes B we can also say that B is finished by A (converse). An asymmetric relationship: anti-reflexive, anti-symmetric, transitive.
    MEETS='Meets' # A meets interval relation. Representation of the meets relation in Allen's interval algebra. We say that an interval A meets another interval B if and only if A finishes when B begins. More precisely, A.ends = B.start. Instead of saying that A meets B we can also say that B is met by A (converse). An immediate-precedence relationship: anti-reflexive, anti-symmetric, anti-transitive.
    OVERLAPS='Overlaps' # A overlaps interval relation. Representation of the overlaps relation in Allen's interval algebra. We say that an interval A overlaps another interval B if and only if A begins before B but finishes during B. More precisely, A.start < B.start < A.end < B.end. Instead of saying that A overlaps B we can also say that B is overlapped by A (converse). An acyclic precedence relationship: anti-reflexive, anti-symmetric, neither.
    PRECEDES='Precedes' # A precedes interval relation. Representation of the precedes relation in Allen's interval algebra. We say that an interval A precedes another interval B if and only if A finishes before B begins. More precisely, A.end < B.start. Instead of saying that A precedes B we can also say that B is preceded by A (converse). An asymmetric relationship: anti-reflexive, anti-symmetric, transitive.
    STARTS='Starts' # A starts interval relation. Representation of the starts relation in Allen's interval algebra. We say that an interval A starts another interval B if and only if they both start at the same time but A finishes first. More precisely, A.start = B.start < A.end. An asymmetric relationship: anti-reflexive, anti-symmetric, transitive.


class TextDirectionValues(str, Enum):
    """TextDirectionValues -- Definition
    ============
    Indicates whether the text within cells should be displayed as left-to-right text (ltr), as right-to-left text (rtl), according to the content of the cell (auto) or in the direction inherited from the table direction annotation of the table.
    
    """
    AUTO='Auto' # Text in the cells should be according to the content of the cell (auto).
    INHERIT='Inherit' # Text in the cells should inherit its direction from the table direction annotation of the table.
    LTR='Ltr' # Text in cells should be displayed left-to-right (ltr).
    RTL='Rtl' # Text in cells should be displayed right-to-left (rtl).


class TrimValues(str, Enum):
    """TrimValues -- Definition
    ============
    Specifies which spaces to remove from a data value (start, end, both, neither).
    
    """
    BOTH='Both' # Trim whitespace characters from both the start and the end of the value.
    END='End' # Trim whitespace characters from the end of the value.
    NEITHER='Neither' # Trim whitespace characters from neither the start nor the end of the value.
    START='Start' # Trim whitespce characters from the start of the value.


class WhiteSpaceRule(str, Enum):
    """WhiteSpaceRule -- Definition
    ============
    WhiteSpace constrains the value space of types derived from string.
    
    """
    COLLAPSE='Collapse' # After the processing implied by the replace, contiguous sequences of Unicode hexadecimal #x20's are collapsed to a single #x20, and any #x20 at the start or end of the string is then removed.
    PRESERVE='Preserve' # No normalization is done, the value is not changed (this is the behavior required by XML for element content).
    REPLACE='Replace' # All occurrences of Unicode hexadecimal #x9 (tab), #xA (line feed) and #xD (carriage return) are replaced with #x20 (space).


class validTypeType(str, Enum):
    ALLEN_INTERVAL_ALGEBRA='AllenIntervalAlgebra'
    CONDITIONAL_CONTROL_LOGIC='ConditionalControlLogic'
    CONTROL_LOGIC='ControlLogic'
    DETERMINISTIC_IMPERATIVE='DeterministicImperative'
    NON_DETERMINISTIC_DECLARATIVE='NonDeterministicDeclarative'
    RULE_BASED_SCHEDULING='RuleBasedScheduling'
    SEQUENCE='Sequence'
    TEMPORAL_CONSTRAINTS='TemporalConstraints'
    TEMPORAL_CONTROL_CONSTRUCT='TemporalControlConstruct'


class validTypeType1(str, Enum):
    ACTIVITY='Activity'
    STEP='Step'


class validTypeType10(str, Enum):
    AGENT_LISTING='AgentListing'


class validTypeType100(str, Enum):
    COMPONENT_POSITION='ComponentPosition'


class validTypeType101(str, Enum):
    PRIMARY_KEY='PrimaryKey'


class validTypeType102(str, Enum):
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    INSTANCE_VARIABLE='InstanceVariable'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'


class validTypeType103(str, Enum):
    NOTATION='Notation'


class validTypeType104(str, Enum):
    CONCEPTUAL_VALUE='ConceptualValue'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'


class validTypeType105(str, Enum):
    DESCRIPTOR='Descriptor'
    DIMENSIONAL_KEY_MEMBER='DimensionalKeyMember'
    INSTANCE_VALUE='InstanceValue'
    KEY_MEMBER='KeyMember'
    LONG_MAIN_KEY_MEMBER='LongMainKeyMember'
    MAIN_KEY_MEMBER='MainKeyMember'
    REFERENCE_VALUE='ReferenceValue'
    WIDE_KEY_MEMBER='WideKeyMember'


class validTypeType106(str, Enum):
    INSTANCE_VARIABLE='InstanceVariable'


class validTypeType107(str, Enum):
    REFERENCE_VALUE='ReferenceValue'


class validTypeType108(str, Enum):
    REFERENCE_VARIABLE='ReferenceVariable'


class validTypeType109(str, Enum):
    DESCRIPTOR_VALUE_DOMAIN='DescriptorValueDomain'


class validTypeType11(str, Enum):
    AGENT_RELATIONSHIP='AgentRelationship'


class validTypeType110(str, Enum):
    DESCRIPTOR_VALUE_DOMAIN='DescriptorValueDomain'


class validTypeType111(str, Enum):
    DESCRIPTOR_VALUE_DOMAIN='DescriptorValueDomain'
    REFERENCE_VALUE_DOMAIN='ReferenceValueDomain'
    SENTINEL_VALUE_DOMAIN='SentinelValueDomain'
    SUBSTANTIVE_VALUE_DOMAIN='SubstantiveValueDomain'
    VALUE_DOMAIN='ValueDomain'


class validTypeType112(str, Enum):
    DIMENSION_COMPONENT='DimensionComponent'


class validTypeType113(str, Enum):
    SCOPED_MEASURE='ScopedMeasure'


class validTypeType114(str, Enum):
    DIMENSION_GROUP='DimensionGroup'


class validTypeType115(str, Enum):
    DIMENSIONAL_KEY_MEMBER='DimensionalKeyMember'


class validTypeType116(str, Enum):
    CODE_LIST='CodeList'


class validTypeType117(str, Enum):
    LEVEL_STRUCTURE='LevelStructure'


class validTypeType118(str, Enum):
    CATEGORY_SET='CategorySet'


class validTypeType119(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType12(str, Enum):
    ATTRIBUTE_COMPONENT='AttributeComponent'
    CONTEXTUAL_COMPONENT='ContextualComponent'
    DATA_STRUCTURE='DataStructure'
    DATA_STRUCTURE_COMPONENT='DataStructureComponent'
    DIMENSION_COMPONENT='DimensionComponent'
    DIMENSIONAL_DATA_STRUCTURE='DimensionalDataStructure'
    IDENTIFIER_COMPONENT='IdentifierComponent'
    KEY_VALUE_STRUCTURE='KeyValueStructure'
    LONG_DATA_STRUCTURE='LongDataStructure'
    MEASURE_COMPONENT='MeasureComponent'
    QUALIFIED_MEASURE='QualifiedMeasure'
    SYNTHETIC_ID_COMPONENT='SyntheticIdComponent'
    VARIABLE_DESCRIPTOR_COMPONENT='VariableDescriptorComponent'
    VARIABLE_VALUE_COMPONENT='VariableValueComponent'
    WIDE_DATA_STRUCTURE='WideDataStructure'


class validTypeType120(str, Enum):
    FOREIGN_KEY_COMPONENT='ForeignKeyComponent'


class validTypeType121(str, Enum):
    PRIMARY_KEY_COMPONENT='PrimaryKeyComponent'


class validTypeType122(str, Enum):
    ATTRIBUTE_COMPONENT='AttributeComponent'
    CONTEXTUAL_COMPONENT='ContextualComponent'
    DATA_STRUCTURE='DataStructure'
    DATA_STRUCTURE_COMPONENT='DataStructureComponent'
    DIMENSION_COMPONENT='DimensionComponent'
    DIMENSIONAL_DATA_STRUCTURE='DimensionalDataStructure'
    IDENTIFIER_COMPONENT='IdentifierComponent'
    KEY_VALUE_STRUCTURE='KeyValueStructure'
    LONG_DATA_STRUCTURE='LongDataStructure'
    MEASURE_COMPONENT='MeasureComponent'
    QUALIFIED_MEASURE='QualifiedMeasure'
    SYNTHETIC_ID_COMPONENT='SyntheticIdComponent'
    VARIABLE_DESCRIPTOR_COMPONENT='VariableDescriptorComponent'
    VARIABLE_VALUE_COMPONENT='VariableValueComponent'
    WIDE_DATA_STRUCTURE='WideDataStructure'


class validTypeType123(str, Enum):
    PARAMETER='Parameter'


class validTypeType124(str, Enum):
    PARAMETER='Parameter'


class validTypeType125(str, Enum):
    DESCRIPTOR='Descriptor'
    DIMENSIONAL_KEY_MEMBER='DimensionalKeyMember'
    INSTANCE_VALUE='InstanceValue'
    KEY_MEMBER='KeyMember'
    LONG_MAIN_KEY_MEMBER='LongMainKeyMember'
    MAIN_KEY_MEMBER='MainKeyMember'
    REFERENCE_VALUE='ReferenceValue'
    WIDE_KEY_MEMBER='WideKeyMember'


class validTypeType126(str, Enum):
    REFERENCE_VALUE='ReferenceValue'


class validTypeType127(str, Enum):
    DESCRIPTOR_VALUE_DOMAIN='DescriptorValueDomain'
    REFERENCE_VALUE_DOMAIN='ReferenceValueDomain'
    SENTINEL_VALUE_DOMAIN='SentinelValueDomain'
    SUBSTANTIVE_VALUE_DOMAIN='SubstantiveValueDomain'
    VALUE_DOMAIN='ValueDomain'


class validTypeType128(str, Enum):
    DATA_POINT='DataPoint'


class validTypeType129(str, Enum):
    CONCEPTUAL_VALUE='ConceptualValue'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'


class validTypeType13(str, Enum):
    AGENT='Agent'
    CURATOR='Curator'
    INDIVIDUAL='Individual'
    MACHINE='Machine'
    ORGANIZATION='Organization'
    PROCESSING_AGENT='ProcessingAgent'
    SERVICE='Service'


class validTypeType130(str, Enum):
    INSTANCE_VARIABLE='InstanceVariable'


class validTypeType131(str, Enum):
    INSTANCE_VARIABLE='InstanceVariable'


class validTypeType132(str, Enum):
    UNIT='Unit'


class validTypeType133(str, Enum):
    DIMENSIONAL_KEY_DEFINITION='DimensionalKeyDefinition'
    KEY_DEFINITION='KeyDefinition'


class validTypeType134(str, Enum):
    DATA_POINT='DataPoint'


class validTypeType135(str, Enum):
    POPULATION='Population'
    UNIVERSE='Universe'


class validTypeType136(str, Enum):
    DESCRIPTOR='Descriptor'
    DIMENSIONAL_KEY_MEMBER='DimensionalKeyMember'
    KEY_MEMBER='KeyMember'
    LONG_MAIN_KEY_MEMBER='LongMainKeyMember'
    MAIN_KEY_MEMBER='MainKeyMember'
    WIDE_KEY_MEMBER='WideKeyMember'


class validTypeType137(str, Enum):
    POPULATION='Population'
    UNIVERSE='Universe'


class validTypeType138(str, Enum):
    UNIT='Unit'


class validTypeType139(str, Enum):
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'


class validTypeType14(str, Enum):
    CATEGORY='Category'


class validTypeType140(str, Enum):
    ATTRIBUTE_COMPONENT='AttributeComponent'
    CONTEXTUAL_COMPONENT='ContextualComponent'
    DATA_STRUCTURE='DataStructure'
    DATA_STRUCTURE_COMPONENT='DataStructureComponent'
    DIMENSION_COMPONENT='DimensionComponent'
    DIMENSIONAL_DATA_STRUCTURE='DimensionalDataStructure'
    IDENTIFIER_COMPONENT='IdentifierComponent'
    KEY_VALUE_STRUCTURE='KeyValueStructure'
    LONG_DATA_STRUCTURE='LongDataStructure'
    MEASURE_COMPONENT='MeasureComponent'
    QUALIFIED_MEASURE='QualifiedMeasure'
    SYNTHETIC_ID_COMPONENT='SyntheticIdComponent'
    VARIABLE_DESCRIPTOR_COMPONENT='VariableDescriptorComponent'
    VARIABLE_VALUE_COMPONENT='VariableValueComponent'
    WIDE_DATA_STRUCTURE='WideDataStructure'


class validTypeType141(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType142(str, Enum):
    CLASSIFICATION_ITEM='ClassificationItem'


class validTypeType143(str, Enum):
    LEVEL='Level'


class validTypeType144(str, Enum):
    DATA_SET='DataSet'
    DIMENSIONAL_DATA_SET='DimensionalDataSet'
    KEY_VALUE_DATA_STORE='KeyValueDataStore'
    LONG_DATA_SET='LongDataSet'
    WIDE_DATA_SET='WideDataSet'


class validTypeType145(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType146(str, Enum):
    INSTANCE_VARIABLE='InstanceVariable'


class validTypeType147(str, Enum):
    LOGICAL_RECORD='LogicalRecord'


class validTypeType148(str, Enum):
    DATA_STORE='DataStore'


class validTypeType149(str, Enum):
    LOGICAL_RECORD_RELATIONSHIP='LogicalRecordRelationship'


class validTypeType15(str, Enum):
    CATEGORY_SET='CategorySet'


class validTypeType150(str, Enum):
    LOGICAL_RECORD='LogicalRecord'


class validTypeType151(str, Enum):
    LOGICAL_RECORD='LogicalRecord'


class validTypeType152(str, Enum):
    DESCRIPTOR_VALUE_DOMAIN='DescriptorValueDomain'
    SUBSTANTIVE_VALUE_DOMAIN='SubstantiveValueDomain'


class validTypeType153(str, Enum):
    CATEGORY='Category'


class validTypeType154(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType155(str, Enum):
    DATA_STORE='DataStore'


class validTypeType156(str, Enum):
    INSTANCE_VARIABLE='InstanceVariable'


class validTypeType157(str, Enum):
    PHYSICAL_RECORD_SEGMENT='PhysicalRecordSegment'


class validTypeType158(str, Enum):
    PHYSICAL_RECORD_SEGMENT_POSITION='PhysicalRecordSegmentPosition'


class validTypeType159(str, Enum):
    PHYSICAL_DATA_SET='PhysicalDataSet'


class validTypeType16(str, Enum):
    CATEGORY_RELATIONSHIP='CategoryRelationship'


class validTypeType160(str, Enum):
    PHYSICAL_RECORD_SEGMENT_RELATIONSHIP='PhysicalRecordSegmentRelationship'


class validTypeType161(str, Enum):
    PHYSICAL_SEGMENT_LAYOUT='PhysicalSegmentLayout'
    UNIT_SEGMENT_LAYOUT='UnitSegmentLayout'


class validTypeType162(str, Enum):
    VALUE_MAPPING_RELATIONSHIP='ValueMappingRelationship'


class validTypeType163(str, Enum):
    POPULATION='Population'


class validTypeType164(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType165(str, Enum):
    PHYSICAL_SEGMENT_LAYOUT='PhysicalSegmentLayout'
    UNIT_SEGMENT_LAYOUT='UnitSegmentLayout'


class validTypeType166(str, Enum):
    LOGICAL_RECORD='LogicalRecord'


class validTypeType167(str, Enum):
    DATA_POINT_POSITION='DataPointPosition'


class validTypeType168(str, Enum):
    DATA_POINT='DataPoint'


class validTypeType169(str, Enum):
    PHYSICAL_RECORD_SEGMENT='PhysicalRecordSegment'


class validTypeType17(str, Enum):
    CATEGORY='Category'


class validTypeType170(str, Enum):
    PHYSICAL_RECORD_SEGMENT='PhysicalRecordSegment'


class validTypeType171(str, Enum):
    PHYSICAL_RECORD_SEGMENT='PhysicalRecordSegment'


class validTypeType172(str, Enum):
    PHYSICAL_RECORD_SEGMENT='PhysicalRecordSegment'


class validTypeType173(str, Enum):
    DATA_POINT_RELATIONSHIP='DataPointRelationship'


class validTypeType174(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType175(str, Enum):
    LOGICAL_RECORD='LogicalRecord'


class validTypeType176(str, Enum):
    VALUE_MAPPING='ValueMapping'


class validTypeType177(str, Enum):
    VALUE_MAPPING_POSITION='ValueMappingPosition'


class validTypeType178(str, Enum):
    UNIT='Unit'


class validTypeType179(str, Enum):
    PRIMARY_KEY_COMPONENT='PrimaryKeyComponent'


class validTypeType18(str, Enum):
    CATEGORY='Category'


class validTypeType180(str, Enum):
    ATTRIBUTE_COMPONENT='AttributeComponent'
    CONTEXTUAL_COMPONENT='ContextualComponent'
    DATA_STRUCTURE='DataStructure'
    DATA_STRUCTURE_COMPONENT='DataStructureComponent'
    DIMENSION_COMPONENT='DimensionComponent'
    DIMENSIONAL_DATA_STRUCTURE='DimensionalDataStructure'
    IDENTIFIER_COMPONENT='IdentifierComponent'
    KEY_VALUE_STRUCTURE='KeyValueStructure'
    LONG_DATA_STRUCTURE='LongDataStructure'
    MEASURE_COMPONENT='MeasureComponent'
    QUALIFIED_MEASURE='QualifiedMeasure'
    SYNTHETIC_ID_COMPONENT='SyntheticIdComponent'
    VARIABLE_DESCRIPTOR_COMPONENT='VariableDescriptorComponent'
    VARIABLE_VALUE_COMPONENT='VariableValueComponent'
    WIDE_DATA_STRUCTURE='WideDataStructure'


class validTypeType181(str, Enum):
    ACTIVITY='Activity'
    STEP='Step'


class validTypeType182(str, Enum):
    PRODUCTION_ENVIRONMENT='ProductionEnvironment'


class validTypeType183(str, Enum):
    MEASURE_COMPONENT='MeasureComponent'
    QUALIFIED_MEASURE='QualifiedMeasure'


class validTypeType184(str, Enum):
    LOGICAL_RECORD='LogicalRecord'


class validTypeType185(str, Enum):
    INSTANCE_VARIABLE_MAP='InstanceVariableMap'


class validTypeType186(str, Enum):
    VARIABLE_VALUE_COMPONENT='VariableValueComponent'


class validTypeType187(str, Enum):
    REFERENCE_VALUE_DOMAIN='ReferenceValueDomain'


class validTypeType188(str, Enum):
    REFERENCE_VALUE_DOMAIN='ReferenceValueDomain'


class validTypeType189(str, Enum):
    SENTINEL_VALUE_DOMAIN='SentinelValueDomain'


class validTypeType19(str, Enum):
    CATEGORY='Category'


class validTypeType190(str, Enum):
    DESCRIPTOR_VALUE_DOMAIN='DescriptorValueDomain'
    SUBSTANTIVE_VALUE_DOMAIN='SubstantiveValueDomain'


class validTypeType191(str, Enum):
    REVISION='Revision'


class validTypeType192(str, Enum):
    CONDITIONAL_CONTROL_LOGIC='ConditionalControlLogic'


class validTypeType193(str, Enum):
    RULE_SET='RuleSet'


class validTypeType194(str, Enum):
    CURATOR='Curator'


class validTypeType195(str, Enum):
    RULE='Rule'


class validTypeType196(str, Enum):
    DIMENSIONAL_KEY_DEFINITION='DimensionalKeyDefinition'


class validTypeType197(str, Enum):
    QUALIFIED_MEASURE='QualifiedMeasure'


class validTypeType198(str, Enum):
    REVISABLE_DATUM='RevisableDatum'


class validTypeType199(str, Enum):
    SENTINEL_CONCEPTUAL_DOMAIN='SentinelConceptualDomain'


class validTypeType2(str, Enum):
    STEP='Step'


class validTypeType20(str, Enum):
    CATEGORY_POSITION='CategoryPosition'


class validTypeType200(str, Enum):
    CODE_LIST='CodeList'
    ENUMERATION_DOMAIN='EnumerationDomain'
    STATISTICAL_CLASSIFICATION='StatisticalClassification'


class validTypeType201(str, Enum):
    VALUE_AND_CONCEPT_DESCRIPTION='ValueAndConceptDescription'


class validTypeType202(str, Enum):
    SEQUENCE_POSITION='SequencePosition'


class validTypeType203(str, Enum):
    ORGANIZATION='Organization'


class validTypeType204(str, Enum):
    CLASSIFICATION_INDEX='ClassificationIndex'


class validTypeType205(str, Enum):
    STATISTICAL_CLASSIFICATION='StatisticalClassification'


class validTypeType206(str, Enum):
    STATISTICAL_CLASSIFICATION='StatisticalClassification'


class validTypeType207(str, Enum):
    STATISTICAL_CLASSIFICATION='StatisticalClassification'


class validTypeType208(str, Enum):
    CLASSIFICATION_ITEM_POSITION='ClassificationItemPosition'


class validTypeType209(str, Enum):
    CLASSIFICATION_ITEM='ClassificationItem'


class validTypeType21(str, Enum):
    INSTANCE_VARIABLE='InstanceVariable'


class validTypeType210(str, Enum):
    LEVEL_STRUCTURE='LevelStructure'


class validTypeType211(str, Enum):
    STATISTICAL_CLASSIFICATION='StatisticalClassification'


class validTypeType212(str, Enum):
    STATISTICAL_CLASSIFICATION='StatisticalClassification'


class validTypeType213(str, Enum):
    PARAMETER='Parameter'


class validTypeType214(str, Enum):
    PARAMETER='Parameter'


class validTypeType215(str, Enum):
    STEP='Step'


class validTypeType216(str, Enum):
    CODE_LIST='CodeList'
    ENUMERATION_DOMAIN='EnumerationDomain'
    STATISTICAL_CLASSIFICATION='StatisticalClassification'


class validTypeType217(str, Enum):
    VALUE_AND_CONCEPT_DESCRIPTION='ValueAndConceptDescription'


class validTypeType218(str, Enum):
    SUBSTANTIVE_CONCEPTUAL_DOMAIN='SubstantiveConceptualDomain'


class validTypeType219(str, Enum):
    POPULATION='Population'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType22(str, Enum):
    CATEGORY='Category'


class validTypeType220(str, Enum):
    DATA_POINT='DataPoint'


class validTypeType221(str, Enum):
    PHYSICAL_SEGMENT_LOCATION='PhysicalSegmentLocation'
    SEGMENT_BY_TEXT='SegmentByText'


class validTypeType222(str, Enum):
    VALUE_MAPPING='ValueMapping'


class validTypeType223(str, Enum):
    VALUE_MAPPING='ValueMapping'


class validTypeType224(str, Enum):
    VALUE_MAPPING='ValueMapping'


class validTypeType225(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType226(str, Enum):
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    INSTANCE_VARIABLE='InstanceVariable'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'


class validTypeType227(str, Enum):
    VARIABLE_POSITION='VariablePosition'


class validTypeType228(str, Enum):
    DESCRIPTOR_VARIABLE='DescriptorVariable'


class validTypeType229(str, Enum):
    VARIABLE_VALUE_COMPONENT='VariableValueComponent'


class validTypeType23(str, Enum):
    CLASSIFICATION_INDEX='ClassificationIndex'


class validTypeType230(str, Enum):
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    INSTANCE_VARIABLE='InstanceVariable'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'


class validTypeType231(str, Enum):
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    INSTANCE_VARIABLE='InstanceVariable'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'


class validTypeType232(str, Enum):
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    INSTANCE_VARIABLE='InstanceVariable'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'


class validTypeType233(str, Enum):
    VARIABLE_COLLECTION='VariableCollection'


class validTypeType234(str, Enum):
    VARIABLE_RELATIONSHIP='VariableRelationship'


class validTypeType24(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType25(str, Enum):
    CLASSIFICATION_SERIES='ClassificationSeries'


class validTypeType26(str, Enum):
    AGENT='Agent'
    CURATOR='Curator'
    INDIVIDUAL='Individual'
    MACHINE='Machine'
    ORGANIZATION='Organization'
    PROCESSING_AGENT='ProcessingAgent'
    SERVICE='Service'


class validTypeType27(str, Enum):
    AGENT='Agent'
    CURATOR='Curator'
    INDIVIDUAL='Individual'
    MACHINE='Machine'
    ORGANIZATION='Organization'
    PROCESSING_AGENT='ProcessingAgent'
    SERVICE='Service'


class validTypeType28(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType29(str, Enum):
    CLASSIFICATION_INDEX_ENTRY_POSITION='ClassificationIndexEntryPosition'


class validTypeType3(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType30(str, Enum):
    CLASSIFICATION_INDEX_ENTRY='ClassificationIndexEntry'


class validTypeType31(str, Enum):
    CLASSIFICATION_INDEX_ENTRY='ClassificationIndexEntry'


class validTypeType32(str, Enum):
    CLASSIFICATION_ITEM='ClassificationItem'


class validTypeType33(str, Enum):
    CATEGORY='Category'


class validTypeType34(str, Enum):
    NOTATION='Notation'


class validTypeType35(str, Enum):
    AUTHORIZATION_SOURCE='AuthorizationSource'


class validTypeType36(str, Enum):
    CLASSIFICATION_ITEM='ClassificationItem'


class validTypeType37(str, Enum):
    CLASSIFICATION_ITEM='ClassificationItem'


class validTypeType38(str, Enum):
    CLASSIFICATION_ITEM='ClassificationItem'


class validTypeType39(str, Enum):
    STATISTICAL_CLASSIFICATION='StatisticalClassification'


class validTypeType4(str, Enum):
    AGENT='Agent'
    CURATOR='Curator'
    INDIVIDUAL='Individual'
    MACHINE='Machine'
    ORGANIZATION='Organization'
    PROCESSING_AGENT='ProcessingAgent'
    SERVICE='Service'


class validTypeType40(str, Enum):
    CLASSIFICATION_ITEM_RELATIONSHIP='ClassificationItemRelationship'


class validTypeType41(str, Enum):
    STATISTICAL_CLASSIFICATION='StatisticalClassification'


class validTypeType42(str, Enum):
    AGENT='Agent'
    CURATOR='Curator'
    INDIVIDUAL='Individual'
    MACHINE='Machine'
    ORGANIZATION='Organization'
    PROCESSING_AGENT='ProcessingAgent'
    SERVICE='Service'


class validTypeType43(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType44(str, Enum):
    STATISTICAL_CLASSIFICATION='StatisticalClassification'


class validTypeType45(str, Enum):
    CLASSIFICATION_POSITION='ClassificationPosition'


class validTypeType46(str, Enum):
    CLASSIFICATION_SERIES='ClassificationSeries'


class validTypeType47(str, Enum):
    STATISTICAL_CLASSIFICATION_RELATIONSHIP='StatisticalClassificationRelationship'


class validTypeType48(str, Enum):
    CATEGORY='Category'


class validTypeType49(str, Enum):
    NOTATION='Notation'


class validTypeType5(str, Enum):
    AGENT_POSITION='AgentPosition'


class validTypeType50(str, Enum):
    CODE_POSITION='CodePosition'


class validTypeType51(str, Enum):
    CODE='Code'


class validTypeType52(str, Enum):
    CODE_LIST='CodeList'


class validTypeType53(str, Enum):
    CODE_RELATIONSHIP='CodeRelationship'


class validTypeType54(str, Enum):
    CODE='Code'


class validTypeType55(str, Enum):
    CODE='Code'


class validTypeType56(str, Enum):
    CODE='Code'


class validTypeType57(str, Enum):
    ATTRIBUTE_COMPONENT='AttributeComponent'
    CONTEXTUAL_COMPONENT='ContextualComponent'
    DATA_STRUCTURE='DataStructure'
    DATA_STRUCTURE_COMPONENT='DataStructureComponent'
    DIMENSION_COMPONENT='DimensionComponent'
    DIMENSIONAL_DATA_STRUCTURE='DimensionalDataStructure'
    IDENTIFIER_COMPONENT='IdentifierComponent'
    KEY_VALUE_STRUCTURE='KeyValueStructure'
    LONG_DATA_STRUCTURE='LongDataStructure'
    MEASURE_COMPONENT='MeasureComponent'
    QUALIFIED_MEASURE='QualifiedMeasure'
    SYNTHETIC_ID_COMPONENT='SyntheticIdComponent'
    VARIABLE_DESCRIPTOR_COMPONENT='VariableDescriptorComponent'
    VARIABLE_VALUE_COMPONENT='VariableValueComponent'
    WIDE_DATA_STRUCTURE='WideDataStructure'


class validTypeType58(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType59(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType6(str, Enum):
    AGENT='Agent'
    CURATOR='Curator'
    INDIVIDUAL='Individual'
    MACHINE='Machine'
    ORGANIZATION='Organization'
    PROCESSING_AGENT='ProcessingAgent'
    SERVICE='Service'


class validTypeType60(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType61(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType62(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType63(str, Enum):
    CATEGORY_SET='CategorySet'
    CONCEPT_SYSTEM='ConceptSystem'


class validTypeType64(str, Enum):
    CONCEPT_RELATIONSHIP='ConceptRelationship'


class validTypeType65(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType66(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType67(str, Enum):
    CATEGORY_SET='CategorySet'
    CONCEPT_SYSTEM='ConceptSystem'


class validTypeType68(str, Enum):
    CONCEPT_MAP='ConceptMap'


class validTypeType69(str, Enum):
    VALUE_AND_CONCEPT_DESCRIPTION='ValueAndConceptDescription'


class validTypeType7(str, Enum):
    AGENT='Agent'
    CURATOR='Curator'
    INDIVIDUAL='Individual'
    MACHINE='Machine'
    ORGANIZATION='Organization'
    PROCESSING_AGENT='ProcessingAgent'
    SERVICE='Service'


class validTypeType70(str, Enum):
    CATEGORY_SET='CategorySet'
    CONCEPT_SYSTEM='ConceptSystem'


class validTypeType71(str, Enum):
    CONCEPTUAL_DOMAIN='ConceptualDomain'
    SENTINEL_CONCEPTUAL_DOMAIN='SentinelConceptualDomain'
    SUBSTANTIVE_CONCEPTUAL_DOMAIN='SubstantiveConceptualDomain'


class validTypeType72(str, Enum):
    SENTINEL_CONCEPTUAL_DOMAIN='SentinelConceptualDomain'


class validTypeType73(str, Enum):
    SUBSTANTIVE_CONCEPTUAL_DOMAIN='SubstantiveConceptualDomain'


class validTypeType74(str, Enum):
    POPULATION='Population'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType75(str, Enum):
    CURATOR='Curator'
    PROCESSING_AGENT='ProcessingAgent'
    SERVICE='Service'


class validTypeType76(str, Enum):
    ACTIVITY='Activity'
    STEP='Step'


class validTypeType77(str, Enum):
    ALLEN_INTERVAL_ALGEBRA='AllenIntervalAlgebra'
    CONDITIONAL_CONTROL_LOGIC='ConditionalControlLogic'
    CONTROL_LOGIC='ControlLogic'
    DETERMINISTIC_IMPERATIVE='DeterministicImperative'
    NON_DETERMINISTIC_DECLARATIVE='NonDeterministicDeclarative'
    RULE_BASED_SCHEDULING='RuleBasedScheduling'
    SEQUENCE='Sequence'
    TEMPORAL_CONSTRAINTS='TemporalConstraints'
    TEMPORAL_CONTROL_CONSTRUCT='TemporalControlConstruct'


class validTypeType78(str, Enum):
    INFORMATION_FLOW_DEFINITION='InformationFlowDefinition'


class validTypeType79(str, Enum):
    LEVEL='Level'


class validTypeType8(str, Enum):
    AGENT='Agent'
    CURATOR='Curator'
    INDIVIDUAL='Individual'
    MACHINE='Machine'
    ORGANIZATION='Organization'
    PROCESSING_AGENT='ProcessingAgent'
    SERVICE='Service'


class validTypeType80(str, Enum):
    LEVEL='Level'


class validTypeType81(str, Enum):
    AGENT='Agent'
    CURATOR='Curator'
    INDIVIDUAL='Individual'
    MACHINE='Machine'
    ORGANIZATION='Organization'
    PROCESSING_AGENT='ProcessingAgent'
    SERVICE='Service'


class validTypeType82(str, Enum):
    STATISTICAL_CLASSIFICATION='StatisticalClassification'


class validTypeType83(str, Enum):
    AGENT='Agent'
    CURATOR='Curator'
    INDIVIDUAL='Individual'
    MACHINE='Machine'
    ORGANIZATION='Organization'
    PROCESSING_AGENT='ProcessingAgent'
    SERVICE='Service'


class validTypeType84(str, Enum):
    AGENT='Agent'
    CURATOR='Curator'
    INDIVIDUAL='Individual'
    MACHINE='Machine'
    ORGANIZATION='Organization'
    PROCESSING_AGENT='ProcessingAgent'
    SERVICE='Service'


class validTypeType85(str, Enum):
    CONCEPT_MAP='ConceptMap'


class validTypeType86(str, Enum):
    ATTRIBUTE_COMPONENT='AttributeComponent'
    CONTEXTUAL_COMPONENT='ContextualComponent'
    DATA_STRUCTURE='DataStructure'
    DATA_STRUCTURE_COMPONENT='DataStructureComponent'
    DIMENSION_COMPONENT='DimensionComponent'
    DIMENSIONAL_DATA_STRUCTURE='DimensionalDataStructure'
    IDENTIFIER_COMPONENT='IdentifierComponent'
    KEY_VALUE_STRUCTURE='KeyValueStructure'
    LONG_DATA_STRUCTURE='LongDataStructure'
    MEASURE_COMPONENT='MeasureComponent'
    QUALIFIED_MEASURE='QualifiedMeasure'
    SYNTHETIC_ID_COMPONENT='SyntheticIdComponent'
    VARIABLE_DESCRIPTOR_COMPONENT='VariableDescriptorComponent'
    VARIABLE_VALUE_COMPONENT='VariableValueComponent'
    WIDE_DATA_STRUCTURE='WideDataStructure'


class validTypeType87(str, Enum):
    INSTANCE_VARIABLE='InstanceVariable'


class validTypeType88(str, Enum):
    DATA_POINT='DataPoint'


class validTypeType89(str, Enum):
    DATA_POINT='DataPoint'


class validTypeType9(str, Enum):
    AGENT='Agent'
    CURATOR='Curator'
    INDIVIDUAL='Individual'
    MACHINE='Machine'
    ORGANIZATION='Organization'
    PROCESSING_AGENT='ProcessingAgent'
    SERVICE='Service'


class validTypeType90(str, Enum):
    DATA_POINT='DataPoint'


class validTypeType91(str, Enum):
    DATA_STRUCTURE='DataStructure'
    DIMENSIONAL_DATA_STRUCTURE='DimensionalDataStructure'
    KEY_VALUE_STRUCTURE='KeyValueStructure'
    LONG_DATA_STRUCTURE='LongDataStructure'
    WIDE_DATA_STRUCTURE='WideDataStructure'


class validTypeType92(str, Enum):
    DATA_POINT='DataPoint'


class validTypeType93(str, Enum):
    DIMENSIONAL_KEY='DimensionalKey'
    INSTANCE_KEY='InstanceKey'
    KEY='Key'
    LONG_KEY='LongKey'
    WIDE_KEY='WideKey'


class validTypeType94(str, Enum):
    CATEGORY='Category'
    CONCEPT='Concept'
    CONCEPTUAL_VALUE='ConceptualValue'
    CONCEPTUAL_VARIABLE='ConceptualVariable'
    DESCRIPTOR_VARIABLE='DescriptorVariable'
    DIMENSIONAL_KEY_DEFINITION_MEMBER='DimensionalKeyDefinitionMember'
    INSTANCE_VARIABLE='InstanceVariable'
    KEY_DEFINITION_MEMBER='KeyDefinitionMember'
    POPULATION='Population'
    REFERENCE_VARIABLE='ReferenceVariable'
    REPRESENTED_VARIABLE='RepresentedVariable'
    UNIT_TYPE='UnitType'
    UNIVERSE='Universe'


class validTypeType95(str, Enum):
    LOGICAL_RECORD_POSITION='LogicalRecordPosition'


class validTypeType96(str, Enum):
    LOGICAL_RECORD='LogicalRecord'


class validTypeType97(str, Enum):
    RECORD_RELATION='RecordRelation'


class validTypeType98(str, Enum):
    FOREIGN_KEY='ForeignKey'


class validTypeType99(str, Enum):
    ATTRIBUTE_COMPONENT='AttributeComponent'
    CONTEXTUAL_COMPONENT='ContextualComponent'
    DATA_STRUCTURE='DataStructure'
    DATA_STRUCTURE_COMPONENT='DataStructureComponent'
    DIMENSION_COMPONENT='DimensionComponent'
    DIMENSIONAL_DATA_STRUCTURE='DimensionalDataStructure'
    IDENTIFIER_COMPONENT='IdentifierComponent'
    KEY_VALUE_STRUCTURE='KeyValueStructure'
    LONG_DATA_STRUCTURE='LongDataStructure'
    MEASURE_COMPONENT='MeasureComponent'
    QUALIFIED_MEASURE='QualifiedMeasure'
    SYNTHETIC_ID_COMPONENT='SyntheticIdComponent'
    VARIABLE_DESCRIPTOR_COMPONENT='VariableDescriptorComponent'
    VARIABLE_VALUE_COMPONENT='VariableValueComponent'
    WIDE_DATA_STRUCTURE='WideDataStructure'


#
# Start data representation classes
#
class DDICDIModels(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Activity=None, Agent=None, AgentListing=None, AgentPosition=None, AgentRelationship=None, AgentStructure=None, AllenIntervalAlgebra=None, AttributeComponent=None, AuthorizationSource=None, Category=None, CategoryPosition=None, CategoryRelationStructure=None, CategoryRelationship=None, CategorySet=None, CategoryStatistic=None, ClassificationFamily=None, ClassificationIndex=None, ClassificationIndexEntry=None, ClassificationIndexEntryPosition=None, ClassificationItem=None, ClassificationItemPosition=None, ClassificationItemRelationship=None, ClassificationItemStructure=None, ClassificationPosition=None, ClassificationSeries=None, ClassificationSeriesStructure=None, Code=None, CodeList=None, CodeListStructure=None, CodePosition=None, CodeRelationship=None, ComponentPosition=None, Concept=None, ConceptMap=None, ConceptRelationship=None, ConceptStructure=None, ConceptSystem=None, ConceptSystemCorrespondence=None, ConceptualDomain=None, ConceptualValue=None, ConceptualVariable=None, ConditionalControlLogic=None, ContextualComponent=None, ControlLogic=None, CorrespondenceTable=None, Curator=None, DataPoint=None, DataPointPosition=None, DataPointRelationship=None, DataSet=None, DataStore=None, DataStructure=None, DataStructureComponent=None, Datum=None, Descriptor=None, DescriptorValueDomain=None, DescriptorVariable=None, DeterministicImperative=None, DimensionComponent=None, DimensionGroup=None, DimensionalDataSet=None, DimensionalDataStructure=None, DimensionalKey=None, DimensionalKeyDefinition=None, DimensionalKeyDefinitionMember=None, DimensionalKeyMember=None, EnumerationDomain=None, ForeignKey=None, ForeignKeyComponent=None, IdentifierComponent=None, Individual=None, InformationFlowDefinition=None, InstanceKey=None, InstanceValue=None, InstanceVariable=None, InstanceVariableMap=None, Key=None, KeyDefinition=None, KeyDefinitionMember=None, KeyMember=None, KeyValueDataStore=None, KeyValueStructure=None, Level=None, LevelStructure=None, LogicalRecord=None, LogicalRecordPosition=None, LogicalRecordRelationStructure=None, LogicalRecordRelationship=None, LongDataSet=None, LongDataStructure=None, LongKey=None, LongMainKeyMember=None, Machine=None, MainKeyMember=None, MeasureComponent=None, NonDeterministicDeclarative=None, Notation=None, Organization=None, Parameter=None, PhysicalDataSet=None, PhysicalDataSetStructure=None, PhysicalLayoutRelationStructure=None, PhysicalRecordSegment=None, PhysicalRecordSegmentPosition=None, PhysicalRecordSegmentRelationship=None, PhysicalRecordSegmentStructure=None, PhysicalSegmentLayout=None, PhysicalSegmentLocation=None, Population=None, PrimaryKey=None, PrimaryKeyComponent=None, ProcessingAgent=None, ProductionEnvironment=None, QualifiedMeasure=None, RecordRelation=None, ReferenceValue=None, ReferenceValueDomain=None, ReferenceVariable=None, RepresentedVariable=None, RevisableDatum=None, Revision=None, Rule=None, RuleBasedScheduling=None, RuleSet=None, ScopedMeasure=None, SegmentByText=None, SentinelConceptualDomain=None, SentinelValueDomain=None, Sequence=None, SequencePosition=None, Service=None, StatisticalClassification=None, StatisticalClassificationRelationship=None, Step=None, SubstantiveConceptualDomain=None, SubstantiveValueDomain=None, SyntheticIdComponent=None, TemporalConstraints=None, TemporalControlConstruct=None, Unit=None, UnitSegmentLayout=None, UnitType=None, Universe=None, ValueAndConceptDescription=None, ValueDomain=None, ValueMapping=None, ValueMappingPosition=None, ValueMappingRelationship=None, VariableCollection=None, VariableDescriptorComponent=None, VariablePosition=None, VariableRelationship=None, VariableStructure=None, VariableValueComponent=None, WideDataSet=None, WideDataStructure=None, WideKey=None, WideKeyMember=None, Wrapper=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Activity is None:
            self.Activity = []
        else:
            self.Activity = Activity
        self.Activity_nsprefix_ = None
        if Agent is None:
            self.Agent = []
        else:
            self.Agent = Agent
        self.Agent_nsprefix_ = None
        if AgentListing is None:
            self.AgentListing = []
        else:
            self.AgentListing = AgentListing
        self.AgentListing_nsprefix_ = None
        if AgentPosition is None:
            self.AgentPosition = []
        else:
            self.AgentPosition = AgentPosition
        self.AgentPosition_nsprefix_ = None
        if AgentRelationship is None:
            self.AgentRelationship = []
        else:
            self.AgentRelationship = AgentRelationship
        self.AgentRelationship_nsprefix_ = None
        if AgentStructure is None:
            self.AgentStructure = []
        else:
            self.AgentStructure = AgentStructure
        self.AgentStructure_nsprefix_ = None
        if AllenIntervalAlgebra is None:
            self.AllenIntervalAlgebra = []
        else:
            self.AllenIntervalAlgebra = AllenIntervalAlgebra
        self.AllenIntervalAlgebra_nsprefix_ = None
        if AttributeComponent is None:
            self.AttributeComponent = []
        else:
            self.AttributeComponent = AttributeComponent
        self.AttributeComponent_nsprefix_ = None
        if AuthorizationSource is None:
            self.AuthorizationSource = []
        else:
            self.AuthorizationSource = AuthorizationSource
        self.AuthorizationSource_nsprefix_ = None
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
        self.Category_nsprefix_ = None
        if CategoryPosition is None:
            self.CategoryPosition = []
        else:
            self.CategoryPosition = CategoryPosition
        self.CategoryPosition_nsprefix_ = None
        if CategoryRelationStructure is None:
            self.CategoryRelationStructure = []
        else:
            self.CategoryRelationStructure = CategoryRelationStructure
        self.CategoryRelationStructure_nsprefix_ = None
        if CategoryRelationship is None:
            self.CategoryRelationship = []
        else:
            self.CategoryRelationship = CategoryRelationship
        self.CategoryRelationship_nsprefix_ = None
        if CategorySet is None:
            self.CategorySet = []
        else:
            self.CategorySet = CategorySet
        self.CategorySet_nsprefix_ = None
        if CategoryStatistic is None:
            self.CategoryStatistic = []
        else:
            self.CategoryStatistic = CategoryStatistic
        self.CategoryStatistic_nsprefix_ = None
        if ClassificationFamily is None:
            self.ClassificationFamily = []
        else:
            self.ClassificationFamily = ClassificationFamily
        self.ClassificationFamily_nsprefix_ = None
        if ClassificationIndex is None:
            self.ClassificationIndex = []
        else:
            self.ClassificationIndex = ClassificationIndex
        self.ClassificationIndex_nsprefix_ = None
        if ClassificationIndexEntry is None:
            self.ClassificationIndexEntry = []
        else:
            self.ClassificationIndexEntry = ClassificationIndexEntry
        self.ClassificationIndexEntry_nsprefix_ = None
        if ClassificationIndexEntryPosition is None:
            self.ClassificationIndexEntryPosition = []
        else:
            self.ClassificationIndexEntryPosition = ClassificationIndexEntryPosition
        self.ClassificationIndexEntryPosition_nsprefix_ = None
        if ClassificationItem is None:
            self.ClassificationItem = []
        else:
            self.ClassificationItem = ClassificationItem
        self.ClassificationItem_nsprefix_ = None
        if ClassificationItemPosition is None:
            self.ClassificationItemPosition = []
        else:
            self.ClassificationItemPosition = ClassificationItemPosition
        self.ClassificationItemPosition_nsprefix_ = None
        if ClassificationItemRelationship is None:
            self.ClassificationItemRelationship = []
        else:
            self.ClassificationItemRelationship = ClassificationItemRelationship
        self.ClassificationItemRelationship_nsprefix_ = None
        if ClassificationItemStructure is None:
            self.ClassificationItemStructure = []
        else:
            self.ClassificationItemStructure = ClassificationItemStructure
        self.ClassificationItemStructure_nsprefix_ = None
        if ClassificationPosition is None:
            self.ClassificationPosition = []
        else:
            self.ClassificationPosition = ClassificationPosition
        self.ClassificationPosition_nsprefix_ = None
        if ClassificationSeries is None:
            self.ClassificationSeries = []
        else:
            self.ClassificationSeries = ClassificationSeries
        self.ClassificationSeries_nsprefix_ = None
        if ClassificationSeriesStructure is None:
            self.ClassificationSeriesStructure = []
        else:
            self.ClassificationSeriesStructure = ClassificationSeriesStructure
        self.ClassificationSeriesStructure_nsprefix_ = None
        if Code is None:
            self.Code = []
        else:
            self.Code = Code
        self.Code_nsprefix_ = None
        if CodeList is None:
            self.CodeList = []
        else:
            self.CodeList = CodeList
        self.CodeList_nsprefix_ = None
        if CodeListStructure is None:
            self.CodeListStructure = []
        else:
            self.CodeListStructure = CodeListStructure
        self.CodeListStructure_nsprefix_ = None
        if CodePosition is None:
            self.CodePosition = []
        else:
            self.CodePosition = CodePosition
        self.CodePosition_nsprefix_ = None
        if CodeRelationship is None:
            self.CodeRelationship = []
        else:
            self.CodeRelationship = CodeRelationship
        self.CodeRelationship_nsprefix_ = None
        if ComponentPosition is None:
            self.ComponentPosition = []
        else:
            self.ComponentPosition = ComponentPosition
        self.ComponentPosition_nsprefix_ = None
        if Concept is None:
            self.Concept = []
        else:
            self.Concept = Concept
        self.Concept_nsprefix_ = None
        if ConceptMap is None:
            self.ConceptMap = []
        else:
            self.ConceptMap = ConceptMap
        self.ConceptMap_nsprefix_ = None
        if ConceptRelationship is None:
            self.ConceptRelationship = []
        else:
            self.ConceptRelationship = ConceptRelationship
        self.ConceptRelationship_nsprefix_ = None
        if ConceptStructure is None:
            self.ConceptStructure = []
        else:
            self.ConceptStructure = ConceptStructure
        self.ConceptStructure_nsprefix_ = None
        if ConceptSystem is None:
            self.ConceptSystem = []
        else:
            self.ConceptSystem = ConceptSystem
        self.ConceptSystem_nsprefix_ = None
        if ConceptSystemCorrespondence is None:
            self.ConceptSystemCorrespondence = []
        else:
            self.ConceptSystemCorrespondence = ConceptSystemCorrespondence
        self.ConceptSystemCorrespondence_nsprefix_ = None
        if ConceptualDomain is None:
            self.ConceptualDomain = []
        else:
            self.ConceptualDomain = ConceptualDomain
        self.ConceptualDomain_nsprefix_ = None
        if ConceptualValue is None:
            self.ConceptualValue = []
        else:
            self.ConceptualValue = ConceptualValue
        self.ConceptualValue_nsprefix_ = None
        if ConceptualVariable is None:
            self.ConceptualVariable = []
        else:
            self.ConceptualVariable = ConceptualVariable
        self.ConceptualVariable_nsprefix_ = None
        if ConditionalControlLogic is None:
            self.ConditionalControlLogic = []
        else:
            self.ConditionalControlLogic = ConditionalControlLogic
        self.ConditionalControlLogic_nsprefix_ = None
        if ContextualComponent is None:
            self.ContextualComponent = []
        else:
            self.ContextualComponent = ContextualComponent
        self.ContextualComponent_nsprefix_ = None
        if ControlLogic is None:
            self.ControlLogic = []
        else:
            self.ControlLogic = ControlLogic
        self.ControlLogic_nsprefix_ = None
        if CorrespondenceTable is None:
            self.CorrespondenceTable = []
        else:
            self.CorrespondenceTable = CorrespondenceTable
        self.CorrespondenceTable_nsprefix_ = None
        if Curator is None:
            self.Curator = []
        else:
            self.Curator = Curator
        self.Curator_nsprefix_ = None
        if DataPoint is None:
            self.DataPoint = []
        else:
            self.DataPoint = DataPoint
        self.DataPoint_nsprefix_ = None
        if DataPointPosition is None:
            self.DataPointPosition = []
        else:
            self.DataPointPosition = DataPointPosition
        self.DataPointPosition_nsprefix_ = None
        if DataPointRelationship is None:
            self.DataPointRelationship = []
        else:
            self.DataPointRelationship = DataPointRelationship
        self.DataPointRelationship_nsprefix_ = None
        if DataSet is None:
            self.DataSet = []
        else:
            self.DataSet = DataSet
        self.DataSet_nsprefix_ = None
        if DataStore is None:
            self.DataStore = []
        else:
            self.DataStore = DataStore
        self.DataStore_nsprefix_ = None
        if DataStructure is None:
            self.DataStructure = []
        else:
            self.DataStructure = DataStructure
        self.DataStructure_nsprefix_ = None
        if DataStructureComponent is None:
            self.DataStructureComponent = []
        else:
            self.DataStructureComponent = DataStructureComponent
        self.DataStructureComponent_nsprefix_ = None
        if Datum is None:
            self.Datum = []
        else:
            self.Datum = Datum
        self.Datum_nsprefix_ = None
        if Descriptor is None:
            self.Descriptor = []
        else:
            self.Descriptor = Descriptor
        self.Descriptor_nsprefix_ = None
        if DescriptorValueDomain is None:
            self.DescriptorValueDomain = []
        else:
            self.DescriptorValueDomain = DescriptorValueDomain
        self.DescriptorValueDomain_nsprefix_ = None
        if DescriptorVariable is None:
            self.DescriptorVariable = []
        else:
            self.DescriptorVariable = DescriptorVariable
        self.DescriptorVariable_nsprefix_ = None
        if DeterministicImperative is None:
            self.DeterministicImperative = []
        else:
            self.DeterministicImperative = DeterministicImperative
        self.DeterministicImperative_nsprefix_ = None
        if DimensionComponent is None:
            self.DimensionComponent = []
        else:
            self.DimensionComponent = DimensionComponent
        self.DimensionComponent_nsprefix_ = None
        if DimensionGroup is None:
            self.DimensionGroup = []
        else:
            self.DimensionGroup = DimensionGroup
        self.DimensionGroup_nsprefix_ = None
        if DimensionalDataSet is None:
            self.DimensionalDataSet = []
        else:
            self.DimensionalDataSet = DimensionalDataSet
        self.DimensionalDataSet_nsprefix_ = None
        if DimensionalDataStructure is None:
            self.DimensionalDataStructure = []
        else:
            self.DimensionalDataStructure = DimensionalDataStructure
        self.DimensionalDataStructure_nsprefix_ = None
        if DimensionalKey is None:
            self.DimensionalKey = []
        else:
            self.DimensionalKey = DimensionalKey
        self.DimensionalKey_nsprefix_ = None
        if DimensionalKeyDefinition is None:
            self.DimensionalKeyDefinition = []
        else:
            self.DimensionalKeyDefinition = DimensionalKeyDefinition
        self.DimensionalKeyDefinition_nsprefix_ = None
        if DimensionalKeyDefinitionMember is None:
            self.DimensionalKeyDefinitionMember = []
        else:
            self.DimensionalKeyDefinitionMember = DimensionalKeyDefinitionMember
        self.DimensionalKeyDefinitionMember_nsprefix_ = None
        if DimensionalKeyMember is None:
            self.DimensionalKeyMember = []
        else:
            self.DimensionalKeyMember = DimensionalKeyMember
        self.DimensionalKeyMember_nsprefix_ = None
        if EnumerationDomain is None:
            self.EnumerationDomain = []
        else:
            self.EnumerationDomain = EnumerationDomain
        self.EnumerationDomain_nsprefix_ = None
        if ForeignKey is None:
            self.ForeignKey = []
        else:
            self.ForeignKey = ForeignKey
        self.ForeignKey_nsprefix_ = None
        if ForeignKeyComponent is None:
            self.ForeignKeyComponent = []
        else:
            self.ForeignKeyComponent = ForeignKeyComponent
        self.ForeignKeyComponent_nsprefix_ = None
        if IdentifierComponent is None:
            self.IdentifierComponent = []
        else:
            self.IdentifierComponent = IdentifierComponent
        self.IdentifierComponent_nsprefix_ = None
        if Individual is None:
            self.Individual = []
        else:
            self.Individual = Individual
        self.Individual_nsprefix_ = None
        if InformationFlowDefinition is None:
            self.InformationFlowDefinition = []
        else:
            self.InformationFlowDefinition = InformationFlowDefinition
        self.InformationFlowDefinition_nsprefix_ = None
        if InstanceKey is None:
            self.InstanceKey = []
        else:
            self.InstanceKey = InstanceKey
        self.InstanceKey_nsprefix_ = None
        if InstanceValue is None:
            self.InstanceValue = []
        else:
            self.InstanceValue = InstanceValue
        self.InstanceValue_nsprefix_ = None
        if InstanceVariable is None:
            self.InstanceVariable = []
        else:
            self.InstanceVariable = InstanceVariable
        self.InstanceVariable_nsprefix_ = None
        if InstanceVariableMap is None:
            self.InstanceVariableMap = []
        else:
            self.InstanceVariableMap = InstanceVariableMap
        self.InstanceVariableMap_nsprefix_ = None
        if Key is None:
            self.Key = []
        else:
            self.Key = Key
        self.Key_nsprefix_ = None
        if KeyDefinition is None:
            self.KeyDefinition = []
        else:
            self.KeyDefinition = KeyDefinition
        self.KeyDefinition_nsprefix_ = None
        if KeyDefinitionMember is None:
            self.KeyDefinitionMember = []
        else:
            self.KeyDefinitionMember = KeyDefinitionMember
        self.KeyDefinitionMember_nsprefix_ = None
        if KeyMember is None:
            self.KeyMember = []
        else:
            self.KeyMember = KeyMember
        self.KeyMember_nsprefix_ = None
        if KeyValueDataStore is None:
            self.KeyValueDataStore = []
        else:
            self.KeyValueDataStore = KeyValueDataStore
        self.KeyValueDataStore_nsprefix_ = None
        if KeyValueStructure is None:
            self.KeyValueStructure = []
        else:
            self.KeyValueStructure = KeyValueStructure
        self.KeyValueStructure_nsprefix_ = None
        if Level is None:
            self.Level = []
        else:
            self.Level = Level
        self.Level_nsprefix_ = None
        if LevelStructure is None:
            self.LevelStructure = []
        else:
            self.LevelStructure = LevelStructure
        self.LevelStructure_nsprefix_ = None
        if LogicalRecord is None:
            self.LogicalRecord = []
        else:
            self.LogicalRecord = LogicalRecord
        self.LogicalRecord_nsprefix_ = None
        if LogicalRecordPosition is None:
            self.LogicalRecordPosition = []
        else:
            self.LogicalRecordPosition = LogicalRecordPosition
        self.LogicalRecordPosition_nsprefix_ = None
        if LogicalRecordRelationStructure is None:
            self.LogicalRecordRelationStructure = []
        else:
            self.LogicalRecordRelationStructure = LogicalRecordRelationStructure
        self.LogicalRecordRelationStructure_nsprefix_ = None
        if LogicalRecordRelationship is None:
            self.LogicalRecordRelationship = []
        else:
            self.LogicalRecordRelationship = LogicalRecordRelationship
        self.LogicalRecordRelationship_nsprefix_ = None
        if LongDataSet is None:
            self.LongDataSet = []
        else:
            self.LongDataSet = LongDataSet
        self.LongDataSet_nsprefix_ = None
        if LongDataStructure is None:
            self.LongDataStructure = []
        else:
            self.LongDataStructure = LongDataStructure
        self.LongDataStructure_nsprefix_ = None
        if LongKey is None:
            self.LongKey = []
        else:
            self.LongKey = LongKey
        self.LongKey_nsprefix_ = None
        if LongMainKeyMember is None:
            self.LongMainKeyMember = []
        else:
            self.LongMainKeyMember = LongMainKeyMember
        self.LongMainKeyMember_nsprefix_ = None
        if Machine is None:
            self.Machine = []
        else:
            self.Machine = Machine
        self.Machine_nsprefix_ = None
        if MainKeyMember is None:
            self.MainKeyMember = []
        else:
            self.MainKeyMember = MainKeyMember
        self.MainKeyMember_nsprefix_ = None
        if MeasureComponent is None:
            self.MeasureComponent = []
        else:
            self.MeasureComponent = MeasureComponent
        self.MeasureComponent_nsprefix_ = None
        if NonDeterministicDeclarative is None:
            self.NonDeterministicDeclarative = []
        else:
            self.NonDeterministicDeclarative = NonDeterministicDeclarative
        self.NonDeterministicDeclarative_nsprefix_ = None
        if Notation is None:
            self.Notation = []
        else:
            self.Notation = Notation
        self.Notation_nsprefix_ = None
        if Organization is None:
            self.Organization = []
        else:
            self.Organization = Organization
        self.Organization_nsprefix_ = None
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        self.Parameter_nsprefix_ = None
        if PhysicalDataSet is None:
            self.PhysicalDataSet = []
        else:
            self.PhysicalDataSet = PhysicalDataSet
        self.PhysicalDataSet_nsprefix_ = None
        if PhysicalDataSetStructure is None:
            self.PhysicalDataSetStructure = []
        else:
            self.PhysicalDataSetStructure = PhysicalDataSetStructure
        self.PhysicalDataSetStructure_nsprefix_ = None
        if PhysicalLayoutRelationStructure is None:
            self.PhysicalLayoutRelationStructure = []
        else:
            self.PhysicalLayoutRelationStructure = PhysicalLayoutRelationStructure
        self.PhysicalLayoutRelationStructure_nsprefix_ = None
        if PhysicalRecordSegment is None:
            self.PhysicalRecordSegment = []
        else:
            self.PhysicalRecordSegment = PhysicalRecordSegment
        self.PhysicalRecordSegment_nsprefix_ = None
        if PhysicalRecordSegmentPosition is None:
            self.PhysicalRecordSegmentPosition = []
        else:
            self.PhysicalRecordSegmentPosition = PhysicalRecordSegmentPosition
        self.PhysicalRecordSegmentPosition_nsprefix_ = None
        if PhysicalRecordSegmentRelationship is None:
            self.PhysicalRecordSegmentRelationship = []
        else:
            self.PhysicalRecordSegmentRelationship = PhysicalRecordSegmentRelationship
        self.PhysicalRecordSegmentRelationship_nsprefix_ = None
        if PhysicalRecordSegmentStructure is None:
            self.PhysicalRecordSegmentStructure = []
        else:
            self.PhysicalRecordSegmentStructure = PhysicalRecordSegmentStructure
        self.PhysicalRecordSegmentStructure_nsprefix_ = None
        if PhysicalSegmentLayout is None:
            self.PhysicalSegmentLayout = []
        else:
            self.PhysicalSegmentLayout = PhysicalSegmentLayout
        self.PhysicalSegmentLayout_nsprefix_ = None
        if PhysicalSegmentLocation is None:
            self.PhysicalSegmentLocation = []
        else:
            self.PhysicalSegmentLocation = PhysicalSegmentLocation
        self.PhysicalSegmentLocation_nsprefix_ = None
        if Population is None:
            self.Population = []
        else:
            self.Population = Population
        self.Population_nsprefix_ = None
        if PrimaryKey is None:
            self.PrimaryKey = []
        else:
            self.PrimaryKey = PrimaryKey
        self.PrimaryKey_nsprefix_ = None
        if PrimaryKeyComponent is None:
            self.PrimaryKeyComponent = []
        else:
            self.PrimaryKeyComponent = PrimaryKeyComponent
        self.PrimaryKeyComponent_nsprefix_ = None
        if ProcessingAgent is None:
            self.ProcessingAgent = []
        else:
            self.ProcessingAgent = ProcessingAgent
        self.ProcessingAgent_nsprefix_ = None
        if ProductionEnvironment is None:
            self.ProductionEnvironment = []
        else:
            self.ProductionEnvironment = ProductionEnvironment
        self.ProductionEnvironment_nsprefix_ = None
        if QualifiedMeasure is None:
            self.QualifiedMeasure = []
        else:
            self.QualifiedMeasure = QualifiedMeasure
        self.QualifiedMeasure_nsprefix_ = None
        if RecordRelation is None:
            self.RecordRelation = []
        else:
            self.RecordRelation = RecordRelation
        self.RecordRelation_nsprefix_ = None
        if ReferenceValue is None:
            self.ReferenceValue = []
        else:
            self.ReferenceValue = ReferenceValue
        self.ReferenceValue_nsprefix_ = None
        if ReferenceValueDomain is None:
            self.ReferenceValueDomain = []
        else:
            self.ReferenceValueDomain = ReferenceValueDomain
        self.ReferenceValueDomain_nsprefix_ = None
        if ReferenceVariable is None:
            self.ReferenceVariable = []
        else:
            self.ReferenceVariable = ReferenceVariable
        self.ReferenceVariable_nsprefix_ = None
        if RepresentedVariable is None:
            self.RepresentedVariable = []
        else:
            self.RepresentedVariable = RepresentedVariable
        self.RepresentedVariable_nsprefix_ = None
        if RevisableDatum is None:
            self.RevisableDatum = []
        else:
            self.RevisableDatum = RevisableDatum
        self.RevisableDatum_nsprefix_ = None
        if Revision is None:
            self.Revision = []
        else:
            self.Revision = Revision
        self.Revision_nsprefix_ = None
        if Rule is None:
            self.Rule = []
        else:
            self.Rule = Rule
        self.Rule_nsprefix_ = None
        if RuleBasedScheduling is None:
            self.RuleBasedScheduling = []
        else:
            self.RuleBasedScheduling = RuleBasedScheduling
        self.RuleBasedScheduling_nsprefix_ = None
        if RuleSet is None:
            self.RuleSet = []
        else:
            self.RuleSet = RuleSet
        self.RuleSet_nsprefix_ = None
        if ScopedMeasure is None:
            self.ScopedMeasure = []
        else:
            self.ScopedMeasure = ScopedMeasure
        self.ScopedMeasure_nsprefix_ = None
        if SegmentByText is None:
            self.SegmentByText = []
        else:
            self.SegmentByText = SegmentByText
        self.SegmentByText_nsprefix_ = None
        if SentinelConceptualDomain is None:
            self.SentinelConceptualDomain = []
        else:
            self.SentinelConceptualDomain = SentinelConceptualDomain
        self.SentinelConceptualDomain_nsprefix_ = None
        if SentinelValueDomain is None:
            self.SentinelValueDomain = []
        else:
            self.SentinelValueDomain = SentinelValueDomain
        self.SentinelValueDomain_nsprefix_ = None
        if Sequence is None:
            self.Sequence = []
        else:
            self.Sequence = Sequence
        self.Sequence_nsprefix_ = None
        if SequencePosition is None:
            self.SequencePosition = []
        else:
            self.SequencePosition = SequencePosition
        self.SequencePosition_nsprefix_ = None
        if Service is None:
            self.Service = []
        else:
            self.Service = Service
        self.Service_nsprefix_ = None
        if StatisticalClassification is None:
            self.StatisticalClassification = []
        else:
            self.StatisticalClassification = StatisticalClassification
        self.StatisticalClassification_nsprefix_ = None
        if StatisticalClassificationRelationship is None:
            self.StatisticalClassificationRelationship = []
        else:
            self.StatisticalClassificationRelationship = StatisticalClassificationRelationship
        self.StatisticalClassificationRelationship_nsprefix_ = None
        if Step is None:
            self.Step = []
        else:
            self.Step = Step
        self.Step_nsprefix_ = None
        if SubstantiveConceptualDomain is None:
            self.SubstantiveConceptualDomain = []
        else:
            self.SubstantiveConceptualDomain = SubstantiveConceptualDomain
        self.SubstantiveConceptualDomain_nsprefix_ = None
        if SubstantiveValueDomain is None:
            self.SubstantiveValueDomain = []
        else:
            self.SubstantiveValueDomain = SubstantiveValueDomain
        self.SubstantiveValueDomain_nsprefix_ = None
        if SyntheticIdComponent is None:
            self.SyntheticIdComponent = []
        else:
            self.SyntheticIdComponent = SyntheticIdComponent
        self.SyntheticIdComponent_nsprefix_ = None
        if TemporalConstraints is None:
            self.TemporalConstraints = []
        else:
            self.TemporalConstraints = TemporalConstraints
        self.TemporalConstraints_nsprefix_ = None
        if TemporalControlConstruct is None:
            self.TemporalControlConstruct = []
        else:
            self.TemporalControlConstruct = TemporalControlConstruct
        self.TemporalControlConstruct_nsprefix_ = None
        if Unit is None:
            self.Unit = []
        else:
            self.Unit = Unit
        self.Unit_nsprefix_ = None
        if UnitSegmentLayout is None:
            self.UnitSegmentLayout = []
        else:
            self.UnitSegmentLayout = UnitSegmentLayout
        self.UnitSegmentLayout_nsprefix_ = None
        if UnitType is None:
            self.UnitType = []
        else:
            self.UnitType = UnitType
        self.UnitType_nsprefix_ = None
        if Universe is None:
            self.Universe = []
        else:
            self.Universe = Universe
        self.Universe_nsprefix_ = None
        if ValueAndConceptDescription is None:
            self.ValueAndConceptDescription = []
        else:
            self.ValueAndConceptDescription = ValueAndConceptDescription
        self.ValueAndConceptDescription_nsprefix_ = None
        if ValueDomain is None:
            self.ValueDomain = []
        else:
            self.ValueDomain = ValueDomain
        self.ValueDomain_nsprefix_ = None
        if ValueMapping is None:
            self.ValueMapping = []
        else:
            self.ValueMapping = ValueMapping
        self.ValueMapping_nsprefix_ = None
        if ValueMappingPosition is None:
            self.ValueMappingPosition = []
        else:
            self.ValueMappingPosition = ValueMappingPosition
        self.ValueMappingPosition_nsprefix_ = None
        if ValueMappingRelationship is None:
            self.ValueMappingRelationship = []
        else:
            self.ValueMappingRelationship = ValueMappingRelationship
        self.ValueMappingRelationship_nsprefix_ = None
        if VariableCollection is None:
            self.VariableCollection = []
        else:
            self.VariableCollection = VariableCollection
        self.VariableCollection_nsprefix_ = None
        if VariableDescriptorComponent is None:
            self.VariableDescriptorComponent = []
        else:
            self.VariableDescriptorComponent = VariableDescriptorComponent
        self.VariableDescriptorComponent_nsprefix_ = None
        if VariablePosition is None:
            self.VariablePosition = []
        else:
            self.VariablePosition = VariablePosition
        self.VariablePosition_nsprefix_ = None
        if VariableRelationship is None:
            self.VariableRelationship = []
        else:
            self.VariableRelationship = VariableRelationship
        self.VariableRelationship_nsprefix_ = None
        if VariableStructure is None:
            self.VariableStructure = []
        else:
            self.VariableStructure = VariableStructure
        self.VariableStructure_nsprefix_ = None
        if VariableValueComponent is None:
            self.VariableValueComponent = []
        else:
            self.VariableValueComponent = VariableValueComponent
        self.VariableValueComponent_nsprefix_ = None
        if WideDataSet is None:
            self.WideDataSet = []
        else:
            self.WideDataSet = WideDataSet
        self.WideDataSet_nsprefix_ = None
        if WideDataStructure is None:
            self.WideDataStructure = []
        else:
            self.WideDataStructure = WideDataStructure
        self.WideDataStructure_nsprefix_ = None
        if WideKey is None:
            self.WideKey = []
        else:
            self.WideKey = WideKey
        self.WideKey_nsprefix_ = None
        if WideKeyMember is None:
            self.WideKeyMember = []
        else:
            self.WideKeyMember = WideKeyMember
        self.WideKeyMember_nsprefix_ = None
        if Wrapper is None:
            self.Wrapper = []
        else:
            self.Wrapper = Wrapper
        self.Wrapper_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DDICDIModels)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DDICDIModels.subclass:
            return DDICDIModels.subclass(*args_, **kwargs_)
        else:
            return DDICDIModels(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Activity(self):
        return self.Activity
    def set_Activity(self, Activity):
        self.Activity = Activity
    def add_Activity(self, value):
        self.Activity.append(value)
    def insert_Activity_at(self, index, value):
        self.Activity.insert(index, value)
    def replace_Activity_at(self, index, value):
        self.Activity[index] = value
    def get_Agent(self):
        return self.Agent
    def set_Agent(self, Agent):
        self.Agent = Agent
    def add_Agent(self, value):
        self.Agent.append(value)
    def insert_Agent_at(self, index, value):
        self.Agent.insert(index, value)
    def replace_Agent_at(self, index, value):
        self.Agent[index] = value
    def get_AgentListing(self):
        return self.AgentListing
    def set_AgentListing(self, AgentListing):
        self.AgentListing = AgentListing
    def add_AgentListing(self, value):
        self.AgentListing.append(value)
    def insert_AgentListing_at(self, index, value):
        self.AgentListing.insert(index, value)
    def replace_AgentListing_at(self, index, value):
        self.AgentListing[index] = value
    def get_AgentPosition(self):
        return self.AgentPosition
    def set_AgentPosition(self, AgentPosition):
        self.AgentPosition = AgentPosition
    def add_AgentPosition(self, value):
        self.AgentPosition.append(value)
    def insert_AgentPosition_at(self, index, value):
        self.AgentPosition.insert(index, value)
    def replace_AgentPosition_at(self, index, value):
        self.AgentPosition[index] = value
    def get_AgentRelationship(self):
        return self.AgentRelationship
    def set_AgentRelationship(self, AgentRelationship):
        self.AgentRelationship = AgentRelationship
    def add_AgentRelationship(self, value):
        self.AgentRelationship.append(value)
    def insert_AgentRelationship_at(self, index, value):
        self.AgentRelationship.insert(index, value)
    def replace_AgentRelationship_at(self, index, value):
        self.AgentRelationship[index] = value
    def get_AgentStructure(self):
        return self.AgentStructure
    def set_AgentStructure(self, AgentStructure):
        self.AgentStructure = AgentStructure
    def add_AgentStructure(self, value):
        self.AgentStructure.append(value)
    def insert_AgentStructure_at(self, index, value):
        self.AgentStructure.insert(index, value)
    def replace_AgentStructure_at(self, index, value):
        self.AgentStructure[index] = value
    def get_AllenIntervalAlgebra(self):
        return self.AllenIntervalAlgebra
    def set_AllenIntervalAlgebra(self, AllenIntervalAlgebra):
        self.AllenIntervalAlgebra = AllenIntervalAlgebra
    def add_AllenIntervalAlgebra(self, value):
        self.AllenIntervalAlgebra.append(value)
    def insert_AllenIntervalAlgebra_at(self, index, value):
        self.AllenIntervalAlgebra.insert(index, value)
    def replace_AllenIntervalAlgebra_at(self, index, value):
        self.AllenIntervalAlgebra[index] = value
    def get_AttributeComponent(self):
        return self.AttributeComponent
    def set_AttributeComponent(self, AttributeComponent):
        self.AttributeComponent = AttributeComponent
    def add_AttributeComponent(self, value):
        self.AttributeComponent.append(value)
    def insert_AttributeComponent_at(self, index, value):
        self.AttributeComponent.insert(index, value)
    def replace_AttributeComponent_at(self, index, value):
        self.AttributeComponent[index] = value
    def get_AuthorizationSource(self):
        return self.AuthorizationSource
    def set_AuthorizationSource(self, AuthorizationSource):
        self.AuthorizationSource = AuthorizationSource
    def add_AuthorizationSource(self, value):
        self.AuthorizationSource.append(value)
    def insert_AuthorizationSource_at(self, index, value):
        self.AuthorizationSource.insert(index, value)
    def replace_AuthorizationSource_at(self, index, value):
        self.AuthorizationSource[index] = value
    def get_Category(self):
        return self.Category
    def set_Category(self, Category):
        self.Category = Category
    def add_Category(self, value):
        self.Category.append(value)
    def insert_Category_at(self, index, value):
        self.Category.insert(index, value)
    def replace_Category_at(self, index, value):
        self.Category[index] = value
    def get_CategoryPosition(self):
        return self.CategoryPosition
    def set_CategoryPosition(self, CategoryPosition):
        self.CategoryPosition = CategoryPosition
    def add_CategoryPosition(self, value):
        self.CategoryPosition.append(value)
    def insert_CategoryPosition_at(self, index, value):
        self.CategoryPosition.insert(index, value)
    def replace_CategoryPosition_at(self, index, value):
        self.CategoryPosition[index] = value
    def get_CategoryRelationStructure(self):
        return self.CategoryRelationStructure
    def set_CategoryRelationStructure(self, CategoryRelationStructure):
        self.CategoryRelationStructure = CategoryRelationStructure
    def add_CategoryRelationStructure(self, value):
        self.CategoryRelationStructure.append(value)
    def insert_CategoryRelationStructure_at(self, index, value):
        self.CategoryRelationStructure.insert(index, value)
    def replace_CategoryRelationStructure_at(self, index, value):
        self.CategoryRelationStructure[index] = value
    def get_CategoryRelationship(self):
        return self.CategoryRelationship
    def set_CategoryRelationship(self, CategoryRelationship):
        self.CategoryRelationship = CategoryRelationship
    def add_CategoryRelationship(self, value):
        self.CategoryRelationship.append(value)
    def insert_CategoryRelationship_at(self, index, value):
        self.CategoryRelationship.insert(index, value)
    def replace_CategoryRelationship_at(self, index, value):
        self.CategoryRelationship[index] = value
    def get_CategorySet(self):
        return self.CategorySet
    def set_CategorySet(self, CategorySet):
        self.CategorySet = CategorySet
    def add_CategorySet(self, value):
        self.CategorySet.append(value)
    def insert_CategorySet_at(self, index, value):
        self.CategorySet.insert(index, value)
    def replace_CategorySet_at(self, index, value):
        self.CategorySet[index] = value
    def get_CategoryStatistic(self):
        return self.CategoryStatistic
    def set_CategoryStatistic(self, CategoryStatistic):
        self.CategoryStatistic = CategoryStatistic
    def add_CategoryStatistic(self, value):
        self.CategoryStatistic.append(value)
    def insert_CategoryStatistic_at(self, index, value):
        self.CategoryStatistic.insert(index, value)
    def replace_CategoryStatistic_at(self, index, value):
        self.CategoryStatistic[index] = value
    def get_ClassificationFamily(self):
        return self.ClassificationFamily
    def set_ClassificationFamily(self, ClassificationFamily):
        self.ClassificationFamily = ClassificationFamily
    def add_ClassificationFamily(self, value):
        self.ClassificationFamily.append(value)
    def insert_ClassificationFamily_at(self, index, value):
        self.ClassificationFamily.insert(index, value)
    def replace_ClassificationFamily_at(self, index, value):
        self.ClassificationFamily[index] = value
    def get_ClassificationIndex(self):
        return self.ClassificationIndex
    def set_ClassificationIndex(self, ClassificationIndex):
        self.ClassificationIndex = ClassificationIndex
    def add_ClassificationIndex(self, value):
        self.ClassificationIndex.append(value)
    def insert_ClassificationIndex_at(self, index, value):
        self.ClassificationIndex.insert(index, value)
    def replace_ClassificationIndex_at(self, index, value):
        self.ClassificationIndex[index] = value
    def get_ClassificationIndexEntry(self):
        return self.ClassificationIndexEntry
    def set_ClassificationIndexEntry(self, ClassificationIndexEntry):
        self.ClassificationIndexEntry = ClassificationIndexEntry
    def add_ClassificationIndexEntry(self, value):
        self.ClassificationIndexEntry.append(value)
    def insert_ClassificationIndexEntry_at(self, index, value):
        self.ClassificationIndexEntry.insert(index, value)
    def replace_ClassificationIndexEntry_at(self, index, value):
        self.ClassificationIndexEntry[index] = value
    def get_ClassificationIndexEntryPosition(self):
        return self.ClassificationIndexEntryPosition
    def set_ClassificationIndexEntryPosition(self, ClassificationIndexEntryPosition):
        self.ClassificationIndexEntryPosition = ClassificationIndexEntryPosition
    def add_ClassificationIndexEntryPosition(self, value):
        self.ClassificationIndexEntryPosition.append(value)
    def insert_ClassificationIndexEntryPosition_at(self, index, value):
        self.ClassificationIndexEntryPosition.insert(index, value)
    def replace_ClassificationIndexEntryPosition_at(self, index, value):
        self.ClassificationIndexEntryPosition[index] = value
    def get_ClassificationItem(self):
        return self.ClassificationItem
    def set_ClassificationItem(self, ClassificationItem):
        self.ClassificationItem = ClassificationItem
    def add_ClassificationItem(self, value):
        self.ClassificationItem.append(value)
    def insert_ClassificationItem_at(self, index, value):
        self.ClassificationItem.insert(index, value)
    def replace_ClassificationItem_at(self, index, value):
        self.ClassificationItem[index] = value
    def get_ClassificationItemPosition(self):
        return self.ClassificationItemPosition
    def set_ClassificationItemPosition(self, ClassificationItemPosition):
        self.ClassificationItemPosition = ClassificationItemPosition
    def add_ClassificationItemPosition(self, value):
        self.ClassificationItemPosition.append(value)
    def insert_ClassificationItemPosition_at(self, index, value):
        self.ClassificationItemPosition.insert(index, value)
    def replace_ClassificationItemPosition_at(self, index, value):
        self.ClassificationItemPosition[index] = value
    def get_ClassificationItemRelationship(self):
        return self.ClassificationItemRelationship
    def set_ClassificationItemRelationship(self, ClassificationItemRelationship):
        self.ClassificationItemRelationship = ClassificationItemRelationship
    def add_ClassificationItemRelationship(self, value):
        self.ClassificationItemRelationship.append(value)
    def insert_ClassificationItemRelationship_at(self, index, value):
        self.ClassificationItemRelationship.insert(index, value)
    def replace_ClassificationItemRelationship_at(self, index, value):
        self.ClassificationItemRelationship[index] = value
    def get_ClassificationItemStructure(self):
        return self.ClassificationItemStructure
    def set_ClassificationItemStructure(self, ClassificationItemStructure):
        self.ClassificationItemStructure = ClassificationItemStructure
    def add_ClassificationItemStructure(self, value):
        self.ClassificationItemStructure.append(value)
    def insert_ClassificationItemStructure_at(self, index, value):
        self.ClassificationItemStructure.insert(index, value)
    def replace_ClassificationItemStructure_at(self, index, value):
        self.ClassificationItemStructure[index] = value
    def get_ClassificationPosition(self):
        return self.ClassificationPosition
    def set_ClassificationPosition(self, ClassificationPosition):
        self.ClassificationPosition = ClassificationPosition
    def add_ClassificationPosition(self, value):
        self.ClassificationPosition.append(value)
    def insert_ClassificationPosition_at(self, index, value):
        self.ClassificationPosition.insert(index, value)
    def replace_ClassificationPosition_at(self, index, value):
        self.ClassificationPosition[index] = value
    def get_ClassificationSeries(self):
        return self.ClassificationSeries
    def set_ClassificationSeries(self, ClassificationSeries):
        self.ClassificationSeries = ClassificationSeries
    def add_ClassificationSeries(self, value):
        self.ClassificationSeries.append(value)
    def insert_ClassificationSeries_at(self, index, value):
        self.ClassificationSeries.insert(index, value)
    def replace_ClassificationSeries_at(self, index, value):
        self.ClassificationSeries[index] = value
    def get_ClassificationSeriesStructure(self):
        return self.ClassificationSeriesStructure
    def set_ClassificationSeriesStructure(self, ClassificationSeriesStructure):
        self.ClassificationSeriesStructure = ClassificationSeriesStructure
    def add_ClassificationSeriesStructure(self, value):
        self.ClassificationSeriesStructure.append(value)
    def insert_ClassificationSeriesStructure_at(self, index, value):
        self.ClassificationSeriesStructure.insert(index, value)
    def replace_ClassificationSeriesStructure_at(self, index, value):
        self.ClassificationSeriesStructure[index] = value
    def get_Code(self):
        return self.Code
    def set_Code(self, Code):
        self.Code = Code
    def add_Code(self, value):
        self.Code.append(value)
    def insert_Code_at(self, index, value):
        self.Code.insert(index, value)
    def replace_Code_at(self, index, value):
        self.Code[index] = value
    def get_CodeList(self):
        return self.CodeList
    def set_CodeList(self, CodeList):
        self.CodeList = CodeList
    def add_CodeList(self, value):
        self.CodeList.append(value)
    def insert_CodeList_at(self, index, value):
        self.CodeList.insert(index, value)
    def replace_CodeList_at(self, index, value):
        self.CodeList[index] = value
    def get_CodeListStructure(self):
        return self.CodeListStructure
    def set_CodeListStructure(self, CodeListStructure):
        self.CodeListStructure = CodeListStructure
    def add_CodeListStructure(self, value):
        self.CodeListStructure.append(value)
    def insert_CodeListStructure_at(self, index, value):
        self.CodeListStructure.insert(index, value)
    def replace_CodeListStructure_at(self, index, value):
        self.CodeListStructure[index] = value
    def get_CodePosition(self):
        return self.CodePosition
    def set_CodePosition(self, CodePosition):
        self.CodePosition = CodePosition
    def add_CodePosition(self, value):
        self.CodePosition.append(value)
    def insert_CodePosition_at(self, index, value):
        self.CodePosition.insert(index, value)
    def replace_CodePosition_at(self, index, value):
        self.CodePosition[index] = value
    def get_CodeRelationship(self):
        return self.CodeRelationship
    def set_CodeRelationship(self, CodeRelationship):
        self.CodeRelationship = CodeRelationship
    def add_CodeRelationship(self, value):
        self.CodeRelationship.append(value)
    def insert_CodeRelationship_at(self, index, value):
        self.CodeRelationship.insert(index, value)
    def replace_CodeRelationship_at(self, index, value):
        self.CodeRelationship[index] = value
    def get_ComponentPosition(self):
        return self.ComponentPosition
    def set_ComponentPosition(self, ComponentPosition):
        self.ComponentPosition = ComponentPosition
    def add_ComponentPosition(self, value):
        self.ComponentPosition.append(value)
    def insert_ComponentPosition_at(self, index, value):
        self.ComponentPosition.insert(index, value)
    def replace_ComponentPosition_at(self, index, value):
        self.ComponentPosition[index] = value
    def get_Concept(self):
        return self.Concept
    def set_Concept(self, Concept):
        self.Concept = Concept
    def add_Concept(self, value):
        self.Concept.append(value)
    def insert_Concept_at(self, index, value):
        self.Concept.insert(index, value)
    def replace_Concept_at(self, index, value):
        self.Concept[index] = value
    def get_ConceptMap(self):
        return self.ConceptMap
    def set_ConceptMap(self, ConceptMap):
        self.ConceptMap = ConceptMap
    def add_ConceptMap(self, value):
        self.ConceptMap.append(value)
    def insert_ConceptMap_at(self, index, value):
        self.ConceptMap.insert(index, value)
    def replace_ConceptMap_at(self, index, value):
        self.ConceptMap[index] = value
    def get_ConceptRelationship(self):
        return self.ConceptRelationship
    def set_ConceptRelationship(self, ConceptRelationship):
        self.ConceptRelationship = ConceptRelationship
    def add_ConceptRelationship(self, value):
        self.ConceptRelationship.append(value)
    def insert_ConceptRelationship_at(self, index, value):
        self.ConceptRelationship.insert(index, value)
    def replace_ConceptRelationship_at(self, index, value):
        self.ConceptRelationship[index] = value
    def get_ConceptStructure(self):
        return self.ConceptStructure
    def set_ConceptStructure(self, ConceptStructure):
        self.ConceptStructure = ConceptStructure
    def add_ConceptStructure(self, value):
        self.ConceptStructure.append(value)
    def insert_ConceptStructure_at(self, index, value):
        self.ConceptStructure.insert(index, value)
    def replace_ConceptStructure_at(self, index, value):
        self.ConceptStructure[index] = value
    def get_ConceptSystem(self):
        return self.ConceptSystem
    def set_ConceptSystem(self, ConceptSystem):
        self.ConceptSystem = ConceptSystem
    def add_ConceptSystem(self, value):
        self.ConceptSystem.append(value)
    def insert_ConceptSystem_at(self, index, value):
        self.ConceptSystem.insert(index, value)
    def replace_ConceptSystem_at(self, index, value):
        self.ConceptSystem[index] = value
    def get_ConceptSystemCorrespondence(self):
        return self.ConceptSystemCorrespondence
    def set_ConceptSystemCorrespondence(self, ConceptSystemCorrespondence):
        self.ConceptSystemCorrespondence = ConceptSystemCorrespondence
    def add_ConceptSystemCorrespondence(self, value):
        self.ConceptSystemCorrespondence.append(value)
    def insert_ConceptSystemCorrespondence_at(self, index, value):
        self.ConceptSystemCorrespondence.insert(index, value)
    def replace_ConceptSystemCorrespondence_at(self, index, value):
        self.ConceptSystemCorrespondence[index] = value
    def get_ConceptualDomain(self):
        return self.ConceptualDomain
    def set_ConceptualDomain(self, ConceptualDomain):
        self.ConceptualDomain = ConceptualDomain
    def add_ConceptualDomain(self, value):
        self.ConceptualDomain.append(value)
    def insert_ConceptualDomain_at(self, index, value):
        self.ConceptualDomain.insert(index, value)
    def replace_ConceptualDomain_at(self, index, value):
        self.ConceptualDomain[index] = value
    def get_ConceptualValue(self):
        return self.ConceptualValue
    def set_ConceptualValue(self, ConceptualValue):
        self.ConceptualValue = ConceptualValue
    def add_ConceptualValue(self, value):
        self.ConceptualValue.append(value)
    def insert_ConceptualValue_at(self, index, value):
        self.ConceptualValue.insert(index, value)
    def replace_ConceptualValue_at(self, index, value):
        self.ConceptualValue[index] = value
    def get_ConceptualVariable(self):
        return self.ConceptualVariable
    def set_ConceptualVariable(self, ConceptualVariable):
        self.ConceptualVariable = ConceptualVariable
    def add_ConceptualVariable(self, value):
        self.ConceptualVariable.append(value)
    def insert_ConceptualVariable_at(self, index, value):
        self.ConceptualVariable.insert(index, value)
    def replace_ConceptualVariable_at(self, index, value):
        self.ConceptualVariable[index] = value
    def get_ConditionalControlLogic(self):
        return self.ConditionalControlLogic
    def set_ConditionalControlLogic(self, ConditionalControlLogic):
        self.ConditionalControlLogic = ConditionalControlLogic
    def add_ConditionalControlLogic(self, value):
        self.ConditionalControlLogic.append(value)
    def insert_ConditionalControlLogic_at(self, index, value):
        self.ConditionalControlLogic.insert(index, value)
    def replace_ConditionalControlLogic_at(self, index, value):
        self.ConditionalControlLogic[index] = value
    def get_ContextualComponent(self):
        return self.ContextualComponent
    def set_ContextualComponent(self, ContextualComponent):
        self.ContextualComponent = ContextualComponent
    def add_ContextualComponent(self, value):
        self.ContextualComponent.append(value)
    def insert_ContextualComponent_at(self, index, value):
        self.ContextualComponent.insert(index, value)
    def replace_ContextualComponent_at(self, index, value):
        self.ContextualComponent[index] = value
    def get_ControlLogic(self):
        return self.ControlLogic
    def set_ControlLogic(self, ControlLogic):
        self.ControlLogic = ControlLogic
    def add_ControlLogic(self, value):
        self.ControlLogic.append(value)
    def insert_ControlLogic_at(self, index, value):
        self.ControlLogic.insert(index, value)
    def replace_ControlLogic_at(self, index, value):
        self.ControlLogic[index] = value
    def get_CorrespondenceTable(self):
        return self.CorrespondenceTable
    def set_CorrespondenceTable(self, CorrespondenceTable):
        self.CorrespondenceTable = CorrespondenceTable
    def add_CorrespondenceTable(self, value):
        self.CorrespondenceTable.append(value)
    def insert_CorrespondenceTable_at(self, index, value):
        self.CorrespondenceTable.insert(index, value)
    def replace_CorrespondenceTable_at(self, index, value):
        self.CorrespondenceTable[index] = value
    def get_Curator(self):
        return self.Curator
    def set_Curator(self, Curator):
        self.Curator = Curator
    def add_Curator(self, value):
        self.Curator.append(value)
    def insert_Curator_at(self, index, value):
        self.Curator.insert(index, value)
    def replace_Curator_at(self, index, value):
        self.Curator[index] = value
    def get_DataPoint(self):
        return self.DataPoint
    def set_DataPoint(self, DataPoint):
        self.DataPoint = DataPoint
    def add_DataPoint(self, value):
        self.DataPoint.append(value)
    def insert_DataPoint_at(self, index, value):
        self.DataPoint.insert(index, value)
    def replace_DataPoint_at(self, index, value):
        self.DataPoint[index] = value
    def get_DataPointPosition(self):
        return self.DataPointPosition
    def set_DataPointPosition(self, DataPointPosition):
        self.DataPointPosition = DataPointPosition
    def add_DataPointPosition(self, value):
        self.DataPointPosition.append(value)
    def insert_DataPointPosition_at(self, index, value):
        self.DataPointPosition.insert(index, value)
    def replace_DataPointPosition_at(self, index, value):
        self.DataPointPosition[index] = value
    def get_DataPointRelationship(self):
        return self.DataPointRelationship
    def set_DataPointRelationship(self, DataPointRelationship):
        self.DataPointRelationship = DataPointRelationship
    def add_DataPointRelationship(self, value):
        self.DataPointRelationship.append(value)
    def insert_DataPointRelationship_at(self, index, value):
        self.DataPointRelationship.insert(index, value)
    def replace_DataPointRelationship_at(self, index, value):
        self.DataPointRelationship[index] = value
    def get_DataSet(self):
        return self.DataSet
    def set_DataSet(self, DataSet):
        self.DataSet = DataSet
    def add_DataSet(self, value):
        self.DataSet.append(value)
    def insert_DataSet_at(self, index, value):
        self.DataSet.insert(index, value)
    def replace_DataSet_at(self, index, value):
        self.DataSet[index] = value
    def get_DataStore(self):
        return self.DataStore
    def set_DataStore(self, DataStore):
        self.DataStore = DataStore
    def add_DataStore(self, value):
        self.DataStore.append(value)
    def insert_DataStore_at(self, index, value):
        self.DataStore.insert(index, value)
    def replace_DataStore_at(self, index, value):
        self.DataStore[index] = value
    def get_DataStructure(self):
        return self.DataStructure
    def set_DataStructure(self, DataStructure):
        self.DataStructure = DataStructure
    def add_DataStructure(self, value):
        self.DataStructure.append(value)
    def insert_DataStructure_at(self, index, value):
        self.DataStructure.insert(index, value)
    def replace_DataStructure_at(self, index, value):
        self.DataStructure[index] = value
    def get_DataStructureComponent(self):
        return self.DataStructureComponent
    def set_DataStructureComponent(self, DataStructureComponent):
        self.DataStructureComponent = DataStructureComponent
    def add_DataStructureComponent(self, value):
        self.DataStructureComponent.append(value)
    def insert_DataStructureComponent_at(self, index, value):
        self.DataStructureComponent.insert(index, value)
    def replace_DataStructureComponent_at(self, index, value):
        self.DataStructureComponent[index] = value
    def get_Datum(self):
        return self.Datum
    def set_Datum(self, Datum):
        self.Datum = Datum
    def add_Datum(self, value):
        self.Datum.append(value)
    def insert_Datum_at(self, index, value):
        self.Datum.insert(index, value)
    def replace_Datum_at(self, index, value):
        self.Datum[index] = value
    def get_Descriptor(self):
        return self.Descriptor
    def set_Descriptor(self, Descriptor):
        self.Descriptor = Descriptor
    def add_Descriptor(self, value):
        self.Descriptor.append(value)
    def insert_Descriptor_at(self, index, value):
        self.Descriptor.insert(index, value)
    def replace_Descriptor_at(self, index, value):
        self.Descriptor[index] = value
    def get_DescriptorValueDomain(self):
        return self.DescriptorValueDomain
    def set_DescriptorValueDomain(self, DescriptorValueDomain):
        self.DescriptorValueDomain = DescriptorValueDomain
    def add_DescriptorValueDomain(self, value):
        self.DescriptorValueDomain.append(value)
    def insert_DescriptorValueDomain_at(self, index, value):
        self.DescriptorValueDomain.insert(index, value)
    def replace_DescriptorValueDomain_at(self, index, value):
        self.DescriptorValueDomain[index] = value
    def get_DescriptorVariable(self):
        return self.DescriptorVariable
    def set_DescriptorVariable(self, DescriptorVariable):
        self.DescriptorVariable = DescriptorVariable
    def add_DescriptorVariable(self, value):
        self.DescriptorVariable.append(value)
    def insert_DescriptorVariable_at(self, index, value):
        self.DescriptorVariable.insert(index, value)
    def replace_DescriptorVariable_at(self, index, value):
        self.DescriptorVariable[index] = value
    def get_DeterministicImperative(self):
        return self.DeterministicImperative
    def set_DeterministicImperative(self, DeterministicImperative):
        self.DeterministicImperative = DeterministicImperative
    def add_DeterministicImperative(self, value):
        self.DeterministicImperative.append(value)
    def insert_DeterministicImperative_at(self, index, value):
        self.DeterministicImperative.insert(index, value)
    def replace_DeterministicImperative_at(self, index, value):
        self.DeterministicImperative[index] = value
    def get_DimensionComponent(self):
        return self.DimensionComponent
    def set_DimensionComponent(self, DimensionComponent):
        self.DimensionComponent = DimensionComponent
    def add_DimensionComponent(self, value):
        self.DimensionComponent.append(value)
    def insert_DimensionComponent_at(self, index, value):
        self.DimensionComponent.insert(index, value)
    def replace_DimensionComponent_at(self, index, value):
        self.DimensionComponent[index] = value
    def get_DimensionGroup(self):
        return self.DimensionGroup
    def set_DimensionGroup(self, DimensionGroup):
        self.DimensionGroup = DimensionGroup
    def add_DimensionGroup(self, value):
        self.DimensionGroup.append(value)
    def insert_DimensionGroup_at(self, index, value):
        self.DimensionGroup.insert(index, value)
    def replace_DimensionGroup_at(self, index, value):
        self.DimensionGroup[index] = value
    def get_DimensionalDataSet(self):
        return self.DimensionalDataSet
    def set_DimensionalDataSet(self, DimensionalDataSet):
        self.DimensionalDataSet = DimensionalDataSet
    def add_DimensionalDataSet(self, value):
        self.DimensionalDataSet.append(value)
    def insert_DimensionalDataSet_at(self, index, value):
        self.DimensionalDataSet.insert(index, value)
    def replace_DimensionalDataSet_at(self, index, value):
        self.DimensionalDataSet[index] = value
    def get_DimensionalDataStructure(self):
        return self.DimensionalDataStructure
    def set_DimensionalDataStructure(self, DimensionalDataStructure):
        self.DimensionalDataStructure = DimensionalDataStructure
    def add_DimensionalDataStructure(self, value):
        self.DimensionalDataStructure.append(value)
    def insert_DimensionalDataStructure_at(self, index, value):
        self.DimensionalDataStructure.insert(index, value)
    def replace_DimensionalDataStructure_at(self, index, value):
        self.DimensionalDataStructure[index] = value
    def get_DimensionalKey(self):
        return self.DimensionalKey
    def set_DimensionalKey(self, DimensionalKey):
        self.DimensionalKey = DimensionalKey
    def add_DimensionalKey(self, value):
        self.DimensionalKey.append(value)
    def insert_DimensionalKey_at(self, index, value):
        self.DimensionalKey.insert(index, value)
    def replace_DimensionalKey_at(self, index, value):
        self.DimensionalKey[index] = value
    def get_DimensionalKeyDefinition(self):
        return self.DimensionalKeyDefinition
    def set_DimensionalKeyDefinition(self, DimensionalKeyDefinition):
        self.DimensionalKeyDefinition = DimensionalKeyDefinition
    def add_DimensionalKeyDefinition(self, value):
        self.DimensionalKeyDefinition.append(value)
    def insert_DimensionalKeyDefinition_at(self, index, value):
        self.DimensionalKeyDefinition.insert(index, value)
    def replace_DimensionalKeyDefinition_at(self, index, value):
        self.DimensionalKeyDefinition[index] = value
    def get_DimensionalKeyDefinitionMember(self):
        return self.DimensionalKeyDefinitionMember
    def set_DimensionalKeyDefinitionMember(self, DimensionalKeyDefinitionMember):
        self.DimensionalKeyDefinitionMember = DimensionalKeyDefinitionMember
    def add_DimensionalKeyDefinitionMember(self, value):
        self.DimensionalKeyDefinitionMember.append(value)
    def insert_DimensionalKeyDefinitionMember_at(self, index, value):
        self.DimensionalKeyDefinitionMember.insert(index, value)
    def replace_DimensionalKeyDefinitionMember_at(self, index, value):
        self.DimensionalKeyDefinitionMember[index] = value
    def get_DimensionalKeyMember(self):
        return self.DimensionalKeyMember
    def set_DimensionalKeyMember(self, DimensionalKeyMember):
        self.DimensionalKeyMember = DimensionalKeyMember
    def add_DimensionalKeyMember(self, value):
        self.DimensionalKeyMember.append(value)
    def insert_DimensionalKeyMember_at(self, index, value):
        self.DimensionalKeyMember.insert(index, value)
    def replace_DimensionalKeyMember_at(self, index, value):
        self.DimensionalKeyMember[index] = value
    def get_EnumerationDomain(self):
        return self.EnumerationDomain
    def set_EnumerationDomain(self, EnumerationDomain):
        self.EnumerationDomain = EnumerationDomain
    def add_EnumerationDomain(self, value):
        self.EnumerationDomain.append(value)
    def insert_EnumerationDomain_at(self, index, value):
        self.EnumerationDomain.insert(index, value)
    def replace_EnumerationDomain_at(self, index, value):
        self.EnumerationDomain[index] = value
    def get_ForeignKey(self):
        return self.ForeignKey
    def set_ForeignKey(self, ForeignKey):
        self.ForeignKey = ForeignKey
    def add_ForeignKey(self, value):
        self.ForeignKey.append(value)
    def insert_ForeignKey_at(self, index, value):
        self.ForeignKey.insert(index, value)
    def replace_ForeignKey_at(self, index, value):
        self.ForeignKey[index] = value
    def get_ForeignKeyComponent(self):
        return self.ForeignKeyComponent
    def set_ForeignKeyComponent(self, ForeignKeyComponent):
        self.ForeignKeyComponent = ForeignKeyComponent
    def add_ForeignKeyComponent(self, value):
        self.ForeignKeyComponent.append(value)
    def insert_ForeignKeyComponent_at(self, index, value):
        self.ForeignKeyComponent.insert(index, value)
    def replace_ForeignKeyComponent_at(self, index, value):
        self.ForeignKeyComponent[index] = value
    def get_IdentifierComponent(self):
        return self.IdentifierComponent
    def set_IdentifierComponent(self, IdentifierComponent):
        self.IdentifierComponent = IdentifierComponent
    def add_IdentifierComponent(self, value):
        self.IdentifierComponent.append(value)
    def insert_IdentifierComponent_at(self, index, value):
        self.IdentifierComponent.insert(index, value)
    def replace_IdentifierComponent_at(self, index, value):
        self.IdentifierComponent[index] = value
    def get_Individual(self):
        return self.Individual
    def set_Individual(self, Individual):
        self.Individual = Individual
    def add_Individual(self, value):
        self.Individual.append(value)
    def insert_Individual_at(self, index, value):
        self.Individual.insert(index, value)
    def replace_Individual_at(self, index, value):
        self.Individual[index] = value
    def get_InformationFlowDefinition(self):
        return self.InformationFlowDefinition
    def set_InformationFlowDefinition(self, InformationFlowDefinition):
        self.InformationFlowDefinition = InformationFlowDefinition
    def add_InformationFlowDefinition(self, value):
        self.InformationFlowDefinition.append(value)
    def insert_InformationFlowDefinition_at(self, index, value):
        self.InformationFlowDefinition.insert(index, value)
    def replace_InformationFlowDefinition_at(self, index, value):
        self.InformationFlowDefinition[index] = value
    def get_InstanceKey(self):
        return self.InstanceKey
    def set_InstanceKey(self, InstanceKey):
        self.InstanceKey = InstanceKey
    def add_InstanceKey(self, value):
        self.InstanceKey.append(value)
    def insert_InstanceKey_at(self, index, value):
        self.InstanceKey.insert(index, value)
    def replace_InstanceKey_at(self, index, value):
        self.InstanceKey[index] = value
    def get_InstanceValue(self):
        return self.InstanceValue
    def set_InstanceValue(self, InstanceValue):
        self.InstanceValue = InstanceValue
    def add_InstanceValue(self, value):
        self.InstanceValue.append(value)
    def insert_InstanceValue_at(self, index, value):
        self.InstanceValue.insert(index, value)
    def replace_InstanceValue_at(self, index, value):
        self.InstanceValue[index] = value
    def get_InstanceVariable(self):
        return self.InstanceVariable
    def set_InstanceVariable(self, InstanceVariable):
        self.InstanceVariable = InstanceVariable
    def add_InstanceVariable(self, value):
        self.InstanceVariable.append(value)
    def insert_InstanceVariable_at(self, index, value):
        self.InstanceVariable.insert(index, value)
    def replace_InstanceVariable_at(self, index, value):
        self.InstanceVariable[index] = value
    def get_InstanceVariableMap(self):
        return self.InstanceVariableMap
    def set_InstanceVariableMap(self, InstanceVariableMap):
        self.InstanceVariableMap = InstanceVariableMap
    def add_InstanceVariableMap(self, value):
        self.InstanceVariableMap.append(value)
    def insert_InstanceVariableMap_at(self, index, value):
        self.InstanceVariableMap.insert(index, value)
    def replace_InstanceVariableMap_at(self, index, value):
        self.InstanceVariableMap[index] = value
    def get_Key(self):
        return self.Key
    def set_Key(self, Key):
        self.Key = Key
    def add_Key(self, value):
        self.Key.append(value)
    def insert_Key_at(self, index, value):
        self.Key.insert(index, value)
    def replace_Key_at(self, index, value):
        self.Key[index] = value
    def get_KeyDefinition(self):
        return self.KeyDefinition
    def set_KeyDefinition(self, KeyDefinition):
        self.KeyDefinition = KeyDefinition
    def add_KeyDefinition(self, value):
        self.KeyDefinition.append(value)
    def insert_KeyDefinition_at(self, index, value):
        self.KeyDefinition.insert(index, value)
    def replace_KeyDefinition_at(self, index, value):
        self.KeyDefinition[index] = value
    def get_KeyDefinitionMember(self):
        return self.KeyDefinitionMember
    def set_KeyDefinitionMember(self, KeyDefinitionMember):
        self.KeyDefinitionMember = KeyDefinitionMember
    def add_KeyDefinitionMember(self, value):
        self.KeyDefinitionMember.append(value)
    def insert_KeyDefinitionMember_at(self, index, value):
        self.KeyDefinitionMember.insert(index, value)
    def replace_KeyDefinitionMember_at(self, index, value):
        self.KeyDefinitionMember[index] = value
    def get_KeyMember(self):
        return self.KeyMember
    def set_KeyMember(self, KeyMember):
        self.KeyMember = KeyMember
    def add_KeyMember(self, value):
        self.KeyMember.append(value)
    def insert_KeyMember_at(self, index, value):
        self.KeyMember.insert(index, value)
    def replace_KeyMember_at(self, index, value):
        self.KeyMember[index] = value
    def get_KeyValueDataStore(self):
        return self.KeyValueDataStore
    def set_KeyValueDataStore(self, KeyValueDataStore):
        self.KeyValueDataStore = KeyValueDataStore
    def add_KeyValueDataStore(self, value):
        self.KeyValueDataStore.append(value)
    def insert_KeyValueDataStore_at(self, index, value):
        self.KeyValueDataStore.insert(index, value)
    def replace_KeyValueDataStore_at(self, index, value):
        self.KeyValueDataStore[index] = value
    def get_KeyValueStructure(self):
        return self.KeyValueStructure
    def set_KeyValueStructure(self, KeyValueStructure):
        self.KeyValueStructure = KeyValueStructure
    def add_KeyValueStructure(self, value):
        self.KeyValueStructure.append(value)
    def insert_KeyValueStructure_at(self, index, value):
        self.KeyValueStructure.insert(index, value)
    def replace_KeyValueStructure_at(self, index, value):
        self.KeyValueStructure[index] = value
    def get_Level(self):
        return self.Level
    def set_Level(self, Level):
        self.Level = Level
    def add_Level(self, value):
        self.Level.append(value)
    def insert_Level_at(self, index, value):
        self.Level.insert(index, value)
    def replace_Level_at(self, index, value):
        self.Level[index] = value
    def get_LevelStructure(self):
        return self.LevelStructure
    def set_LevelStructure(self, LevelStructure):
        self.LevelStructure = LevelStructure
    def add_LevelStructure(self, value):
        self.LevelStructure.append(value)
    def insert_LevelStructure_at(self, index, value):
        self.LevelStructure.insert(index, value)
    def replace_LevelStructure_at(self, index, value):
        self.LevelStructure[index] = value
    def get_LogicalRecord(self):
        return self.LogicalRecord
    def set_LogicalRecord(self, LogicalRecord):
        self.LogicalRecord = LogicalRecord
    def add_LogicalRecord(self, value):
        self.LogicalRecord.append(value)
    def insert_LogicalRecord_at(self, index, value):
        self.LogicalRecord.insert(index, value)
    def replace_LogicalRecord_at(self, index, value):
        self.LogicalRecord[index] = value
    def get_LogicalRecordPosition(self):
        return self.LogicalRecordPosition
    def set_LogicalRecordPosition(self, LogicalRecordPosition):
        self.LogicalRecordPosition = LogicalRecordPosition
    def add_LogicalRecordPosition(self, value):
        self.LogicalRecordPosition.append(value)
    def insert_LogicalRecordPosition_at(self, index, value):
        self.LogicalRecordPosition.insert(index, value)
    def replace_LogicalRecordPosition_at(self, index, value):
        self.LogicalRecordPosition[index] = value
    def get_LogicalRecordRelationStructure(self):
        return self.LogicalRecordRelationStructure
    def set_LogicalRecordRelationStructure(self, LogicalRecordRelationStructure):
        self.LogicalRecordRelationStructure = LogicalRecordRelationStructure
    def add_LogicalRecordRelationStructure(self, value):
        self.LogicalRecordRelationStructure.append(value)
    def insert_LogicalRecordRelationStructure_at(self, index, value):
        self.LogicalRecordRelationStructure.insert(index, value)
    def replace_LogicalRecordRelationStructure_at(self, index, value):
        self.LogicalRecordRelationStructure[index] = value
    def get_LogicalRecordRelationship(self):
        return self.LogicalRecordRelationship
    def set_LogicalRecordRelationship(self, LogicalRecordRelationship):
        self.LogicalRecordRelationship = LogicalRecordRelationship
    def add_LogicalRecordRelationship(self, value):
        self.LogicalRecordRelationship.append(value)
    def insert_LogicalRecordRelationship_at(self, index, value):
        self.LogicalRecordRelationship.insert(index, value)
    def replace_LogicalRecordRelationship_at(self, index, value):
        self.LogicalRecordRelationship[index] = value
    def get_LongDataSet(self):
        return self.LongDataSet
    def set_LongDataSet(self, LongDataSet):
        self.LongDataSet = LongDataSet
    def add_LongDataSet(self, value):
        self.LongDataSet.append(value)
    def insert_LongDataSet_at(self, index, value):
        self.LongDataSet.insert(index, value)
    def replace_LongDataSet_at(self, index, value):
        self.LongDataSet[index] = value
    def get_LongDataStructure(self):
        return self.LongDataStructure
    def set_LongDataStructure(self, LongDataStructure):
        self.LongDataStructure = LongDataStructure
    def add_LongDataStructure(self, value):
        self.LongDataStructure.append(value)
    def insert_LongDataStructure_at(self, index, value):
        self.LongDataStructure.insert(index, value)
    def replace_LongDataStructure_at(self, index, value):
        self.LongDataStructure[index] = value
    def get_LongKey(self):
        return self.LongKey
    def set_LongKey(self, LongKey):
        self.LongKey = LongKey
    def add_LongKey(self, value):
        self.LongKey.append(value)
    def insert_LongKey_at(self, index, value):
        self.LongKey.insert(index, value)
    def replace_LongKey_at(self, index, value):
        self.LongKey[index] = value
    def get_LongMainKeyMember(self):
        return self.LongMainKeyMember
    def set_LongMainKeyMember(self, LongMainKeyMember):
        self.LongMainKeyMember = LongMainKeyMember
    def add_LongMainKeyMember(self, value):
        self.LongMainKeyMember.append(value)
    def insert_LongMainKeyMember_at(self, index, value):
        self.LongMainKeyMember.insert(index, value)
    def replace_LongMainKeyMember_at(self, index, value):
        self.LongMainKeyMember[index] = value
    def get_Machine(self):
        return self.Machine
    def set_Machine(self, Machine):
        self.Machine = Machine
    def add_Machine(self, value):
        self.Machine.append(value)
    def insert_Machine_at(self, index, value):
        self.Machine.insert(index, value)
    def replace_Machine_at(self, index, value):
        self.Machine[index] = value
    def get_MainKeyMember(self):
        return self.MainKeyMember
    def set_MainKeyMember(self, MainKeyMember):
        self.MainKeyMember = MainKeyMember
    def add_MainKeyMember(self, value):
        self.MainKeyMember.append(value)
    def insert_MainKeyMember_at(self, index, value):
        self.MainKeyMember.insert(index, value)
    def replace_MainKeyMember_at(self, index, value):
        self.MainKeyMember[index] = value
    def get_MeasureComponent(self):
        return self.MeasureComponent
    def set_MeasureComponent(self, MeasureComponent):
        self.MeasureComponent = MeasureComponent
    def add_MeasureComponent(self, value):
        self.MeasureComponent.append(value)
    def insert_MeasureComponent_at(self, index, value):
        self.MeasureComponent.insert(index, value)
    def replace_MeasureComponent_at(self, index, value):
        self.MeasureComponent[index] = value
    def get_NonDeterministicDeclarative(self):
        return self.NonDeterministicDeclarative
    def set_NonDeterministicDeclarative(self, NonDeterministicDeclarative):
        self.NonDeterministicDeclarative = NonDeterministicDeclarative
    def add_NonDeterministicDeclarative(self, value):
        self.NonDeterministicDeclarative.append(value)
    def insert_NonDeterministicDeclarative_at(self, index, value):
        self.NonDeterministicDeclarative.insert(index, value)
    def replace_NonDeterministicDeclarative_at(self, index, value):
        self.NonDeterministicDeclarative[index] = value
    def get_Notation(self):
        return self.Notation
    def set_Notation(self, Notation):
        self.Notation = Notation
    def add_Notation(self, value):
        self.Notation.append(value)
    def insert_Notation_at(self, index, value):
        self.Notation.insert(index, value)
    def replace_Notation_at(self, index, value):
        self.Notation[index] = value
    def get_Organization(self):
        return self.Organization
    def set_Organization(self, Organization):
        self.Organization = Organization
    def add_Organization(self, value):
        self.Organization.append(value)
    def insert_Organization_at(self, index, value):
        self.Organization.insert(index, value)
    def replace_Organization_at(self, index, value):
        self.Organization[index] = value
    def get_Parameter(self):
        return self.Parameter
    def set_Parameter(self, Parameter):
        self.Parameter = Parameter
    def add_Parameter(self, value):
        self.Parameter.append(value)
    def insert_Parameter_at(self, index, value):
        self.Parameter.insert(index, value)
    def replace_Parameter_at(self, index, value):
        self.Parameter[index] = value
    def get_PhysicalDataSet(self):
        return self.PhysicalDataSet
    def set_PhysicalDataSet(self, PhysicalDataSet):
        self.PhysicalDataSet = PhysicalDataSet
    def add_PhysicalDataSet(self, value):
        self.PhysicalDataSet.append(value)
    def insert_PhysicalDataSet_at(self, index, value):
        self.PhysicalDataSet.insert(index, value)
    def replace_PhysicalDataSet_at(self, index, value):
        self.PhysicalDataSet[index] = value
    def get_PhysicalDataSetStructure(self):
        return self.PhysicalDataSetStructure
    def set_PhysicalDataSetStructure(self, PhysicalDataSetStructure):
        self.PhysicalDataSetStructure = PhysicalDataSetStructure
    def add_PhysicalDataSetStructure(self, value):
        self.PhysicalDataSetStructure.append(value)
    def insert_PhysicalDataSetStructure_at(self, index, value):
        self.PhysicalDataSetStructure.insert(index, value)
    def replace_PhysicalDataSetStructure_at(self, index, value):
        self.PhysicalDataSetStructure[index] = value
    def get_PhysicalLayoutRelationStructure(self):
        return self.PhysicalLayoutRelationStructure
    def set_PhysicalLayoutRelationStructure(self, PhysicalLayoutRelationStructure):
        self.PhysicalLayoutRelationStructure = PhysicalLayoutRelationStructure
    def add_PhysicalLayoutRelationStructure(self, value):
        self.PhysicalLayoutRelationStructure.append(value)
    def insert_PhysicalLayoutRelationStructure_at(self, index, value):
        self.PhysicalLayoutRelationStructure.insert(index, value)
    def replace_PhysicalLayoutRelationStructure_at(self, index, value):
        self.PhysicalLayoutRelationStructure[index] = value
    def get_PhysicalRecordSegment(self):
        return self.PhysicalRecordSegment
    def set_PhysicalRecordSegment(self, PhysicalRecordSegment):
        self.PhysicalRecordSegment = PhysicalRecordSegment
    def add_PhysicalRecordSegment(self, value):
        self.PhysicalRecordSegment.append(value)
    def insert_PhysicalRecordSegment_at(self, index, value):
        self.PhysicalRecordSegment.insert(index, value)
    def replace_PhysicalRecordSegment_at(self, index, value):
        self.PhysicalRecordSegment[index] = value
    def get_PhysicalRecordSegmentPosition(self):
        return self.PhysicalRecordSegmentPosition
    def set_PhysicalRecordSegmentPosition(self, PhysicalRecordSegmentPosition):
        self.PhysicalRecordSegmentPosition = PhysicalRecordSegmentPosition
    def add_PhysicalRecordSegmentPosition(self, value):
        self.PhysicalRecordSegmentPosition.append(value)
    def insert_PhysicalRecordSegmentPosition_at(self, index, value):
        self.PhysicalRecordSegmentPosition.insert(index, value)
    def replace_PhysicalRecordSegmentPosition_at(self, index, value):
        self.PhysicalRecordSegmentPosition[index] = value
    def get_PhysicalRecordSegmentRelationship(self):
        return self.PhysicalRecordSegmentRelationship
    def set_PhysicalRecordSegmentRelationship(self, PhysicalRecordSegmentRelationship):
        self.PhysicalRecordSegmentRelationship = PhysicalRecordSegmentRelationship
    def add_PhysicalRecordSegmentRelationship(self, value):
        self.PhysicalRecordSegmentRelationship.append(value)
    def insert_PhysicalRecordSegmentRelationship_at(self, index, value):
        self.PhysicalRecordSegmentRelationship.insert(index, value)
    def replace_PhysicalRecordSegmentRelationship_at(self, index, value):
        self.PhysicalRecordSegmentRelationship[index] = value
    def get_PhysicalRecordSegmentStructure(self):
        return self.PhysicalRecordSegmentStructure
    def set_PhysicalRecordSegmentStructure(self, PhysicalRecordSegmentStructure):
        self.PhysicalRecordSegmentStructure = PhysicalRecordSegmentStructure
    def add_PhysicalRecordSegmentStructure(self, value):
        self.PhysicalRecordSegmentStructure.append(value)
    def insert_PhysicalRecordSegmentStructure_at(self, index, value):
        self.PhysicalRecordSegmentStructure.insert(index, value)
    def replace_PhysicalRecordSegmentStructure_at(self, index, value):
        self.PhysicalRecordSegmentStructure[index] = value
    def get_PhysicalSegmentLayout(self):
        return self.PhysicalSegmentLayout
    def set_PhysicalSegmentLayout(self, PhysicalSegmentLayout):
        self.PhysicalSegmentLayout = PhysicalSegmentLayout
    def add_PhysicalSegmentLayout(self, value):
        self.PhysicalSegmentLayout.append(value)
    def insert_PhysicalSegmentLayout_at(self, index, value):
        self.PhysicalSegmentLayout.insert(index, value)
    def replace_PhysicalSegmentLayout_at(self, index, value):
        self.PhysicalSegmentLayout[index] = value
    def get_PhysicalSegmentLocation(self):
        return self.PhysicalSegmentLocation
    def set_PhysicalSegmentLocation(self, PhysicalSegmentLocation):
        self.PhysicalSegmentLocation = PhysicalSegmentLocation
    def add_PhysicalSegmentLocation(self, value):
        self.PhysicalSegmentLocation.append(value)
    def insert_PhysicalSegmentLocation_at(self, index, value):
        self.PhysicalSegmentLocation.insert(index, value)
    def replace_PhysicalSegmentLocation_at(self, index, value):
        self.PhysicalSegmentLocation[index] = value
    def get_Population(self):
        return self.Population
    def set_Population(self, Population):
        self.Population = Population
    def add_Population(self, value):
        self.Population.append(value)
    def insert_Population_at(self, index, value):
        self.Population.insert(index, value)
    def replace_Population_at(self, index, value):
        self.Population[index] = value
    def get_PrimaryKey(self):
        return self.PrimaryKey
    def set_PrimaryKey(self, PrimaryKey):
        self.PrimaryKey = PrimaryKey
    def add_PrimaryKey(self, value):
        self.PrimaryKey.append(value)
    def insert_PrimaryKey_at(self, index, value):
        self.PrimaryKey.insert(index, value)
    def replace_PrimaryKey_at(self, index, value):
        self.PrimaryKey[index] = value
    def get_PrimaryKeyComponent(self):
        return self.PrimaryKeyComponent
    def set_PrimaryKeyComponent(self, PrimaryKeyComponent):
        self.PrimaryKeyComponent = PrimaryKeyComponent
    def add_PrimaryKeyComponent(self, value):
        self.PrimaryKeyComponent.append(value)
    def insert_PrimaryKeyComponent_at(self, index, value):
        self.PrimaryKeyComponent.insert(index, value)
    def replace_PrimaryKeyComponent_at(self, index, value):
        self.PrimaryKeyComponent[index] = value
    def get_ProcessingAgent(self):
        return self.ProcessingAgent
    def set_ProcessingAgent(self, ProcessingAgent):
        self.ProcessingAgent = ProcessingAgent
    def add_ProcessingAgent(self, value):
        self.ProcessingAgent.append(value)
    def insert_ProcessingAgent_at(self, index, value):
        self.ProcessingAgent.insert(index, value)
    def replace_ProcessingAgent_at(self, index, value):
        self.ProcessingAgent[index] = value
    def get_ProductionEnvironment(self):
        return self.ProductionEnvironment
    def set_ProductionEnvironment(self, ProductionEnvironment):
        self.ProductionEnvironment = ProductionEnvironment
    def add_ProductionEnvironment(self, value):
        self.ProductionEnvironment.append(value)
    def insert_ProductionEnvironment_at(self, index, value):
        self.ProductionEnvironment.insert(index, value)
    def replace_ProductionEnvironment_at(self, index, value):
        self.ProductionEnvironment[index] = value
    def get_QualifiedMeasure(self):
        return self.QualifiedMeasure
    def set_QualifiedMeasure(self, QualifiedMeasure):
        self.QualifiedMeasure = QualifiedMeasure
    def add_QualifiedMeasure(self, value):
        self.QualifiedMeasure.append(value)
    def insert_QualifiedMeasure_at(self, index, value):
        self.QualifiedMeasure.insert(index, value)
    def replace_QualifiedMeasure_at(self, index, value):
        self.QualifiedMeasure[index] = value
    def get_RecordRelation(self):
        return self.RecordRelation
    def set_RecordRelation(self, RecordRelation):
        self.RecordRelation = RecordRelation
    def add_RecordRelation(self, value):
        self.RecordRelation.append(value)
    def insert_RecordRelation_at(self, index, value):
        self.RecordRelation.insert(index, value)
    def replace_RecordRelation_at(self, index, value):
        self.RecordRelation[index] = value
    def get_ReferenceValue(self):
        return self.ReferenceValue
    def set_ReferenceValue(self, ReferenceValue):
        self.ReferenceValue = ReferenceValue
    def add_ReferenceValue(self, value):
        self.ReferenceValue.append(value)
    def insert_ReferenceValue_at(self, index, value):
        self.ReferenceValue.insert(index, value)
    def replace_ReferenceValue_at(self, index, value):
        self.ReferenceValue[index] = value
    def get_ReferenceValueDomain(self):
        return self.ReferenceValueDomain
    def set_ReferenceValueDomain(self, ReferenceValueDomain):
        self.ReferenceValueDomain = ReferenceValueDomain
    def add_ReferenceValueDomain(self, value):
        self.ReferenceValueDomain.append(value)
    def insert_ReferenceValueDomain_at(self, index, value):
        self.ReferenceValueDomain.insert(index, value)
    def replace_ReferenceValueDomain_at(self, index, value):
        self.ReferenceValueDomain[index] = value
    def get_ReferenceVariable(self):
        return self.ReferenceVariable
    def set_ReferenceVariable(self, ReferenceVariable):
        self.ReferenceVariable = ReferenceVariable
    def add_ReferenceVariable(self, value):
        self.ReferenceVariable.append(value)
    def insert_ReferenceVariable_at(self, index, value):
        self.ReferenceVariable.insert(index, value)
    def replace_ReferenceVariable_at(self, index, value):
        self.ReferenceVariable[index] = value
    def get_RepresentedVariable(self):
        return self.RepresentedVariable
    def set_RepresentedVariable(self, RepresentedVariable):
        self.RepresentedVariable = RepresentedVariable
    def add_RepresentedVariable(self, value):
        self.RepresentedVariable.append(value)
    def insert_RepresentedVariable_at(self, index, value):
        self.RepresentedVariable.insert(index, value)
    def replace_RepresentedVariable_at(self, index, value):
        self.RepresentedVariable[index] = value
    def get_RevisableDatum(self):
        return self.RevisableDatum
    def set_RevisableDatum(self, RevisableDatum):
        self.RevisableDatum = RevisableDatum
    def add_RevisableDatum(self, value):
        self.RevisableDatum.append(value)
    def insert_RevisableDatum_at(self, index, value):
        self.RevisableDatum.insert(index, value)
    def replace_RevisableDatum_at(self, index, value):
        self.RevisableDatum[index] = value
    def get_Revision(self):
        return self.Revision
    def set_Revision(self, Revision):
        self.Revision = Revision
    def add_Revision(self, value):
        self.Revision.append(value)
    def insert_Revision_at(self, index, value):
        self.Revision.insert(index, value)
    def replace_Revision_at(self, index, value):
        self.Revision[index] = value
    def get_Rule(self):
        return self.Rule
    def set_Rule(self, Rule):
        self.Rule = Rule
    def add_Rule(self, value):
        self.Rule.append(value)
    def insert_Rule_at(self, index, value):
        self.Rule.insert(index, value)
    def replace_Rule_at(self, index, value):
        self.Rule[index] = value
    def get_RuleBasedScheduling(self):
        return self.RuleBasedScheduling
    def set_RuleBasedScheduling(self, RuleBasedScheduling):
        self.RuleBasedScheduling = RuleBasedScheduling
    def add_RuleBasedScheduling(self, value):
        self.RuleBasedScheduling.append(value)
    def insert_RuleBasedScheduling_at(self, index, value):
        self.RuleBasedScheduling.insert(index, value)
    def replace_RuleBasedScheduling_at(self, index, value):
        self.RuleBasedScheduling[index] = value
    def get_RuleSet(self):
        return self.RuleSet
    def set_RuleSet(self, RuleSet):
        self.RuleSet = RuleSet
    def add_RuleSet(self, value):
        self.RuleSet.append(value)
    def insert_RuleSet_at(self, index, value):
        self.RuleSet.insert(index, value)
    def replace_RuleSet_at(self, index, value):
        self.RuleSet[index] = value
    def get_ScopedMeasure(self):
        return self.ScopedMeasure
    def set_ScopedMeasure(self, ScopedMeasure):
        self.ScopedMeasure = ScopedMeasure
    def add_ScopedMeasure(self, value):
        self.ScopedMeasure.append(value)
    def insert_ScopedMeasure_at(self, index, value):
        self.ScopedMeasure.insert(index, value)
    def replace_ScopedMeasure_at(self, index, value):
        self.ScopedMeasure[index] = value
    def get_SegmentByText(self):
        return self.SegmentByText
    def set_SegmentByText(self, SegmentByText):
        self.SegmentByText = SegmentByText
    def add_SegmentByText(self, value):
        self.SegmentByText.append(value)
    def insert_SegmentByText_at(self, index, value):
        self.SegmentByText.insert(index, value)
    def replace_SegmentByText_at(self, index, value):
        self.SegmentByText[index] = value
    def get_SentinelConceptualDomain(self):
        return self.SentinelConceptualDomain
    def set_SentinelConceptualDomain(self, SentinelConceptualDomain):
        self.SentinelConceptualDomain = SentinelConceptualDomain
    def add_SentinelConceptualDomain(self, value):
        self.SentinelConceptualDomain.append(value)
    def insert_SentinelConceptualDomain_at(self, index, value):
        self.SentinelConceptualDomain.insert(index, value)
    def replace_SentinelConceptualDomain_at(self, index, value):
        self.SentinelConceptualDomain[index] = value
    def get_SentinelValueDomain(self):
        return self.SentinelValueDomain
    def set_SentinelValueDomain(self, SentinelValueDomain):
        self.SentinelValueDomain = SentinelValueDomain
    def add_SentinelValueDomain(self, value):
        self.SentinelValueDomain.append(value)
    def insert_SentinelValueDomain_at(self, index, value):
        self.SentinelValueDomain.insert(index, value)
    def replace_SentinelValueDomain_at(self, index, value):
        self.SentinelValueDomain[index] = value
    def get_Sequence(self):
        return self.Sequence
    def set_Sequence(self, Sequence):
        self.Sequence = Sequence
    def add_Sequence(self, value):
        self.Sequence.append(value)
    def insert_Sequence_at(self, index, value):
        self.Sequence.insert(index, value)
    def replace_Sequence_at(self, index, value):
        self.Sequence[index] = value
    def get_SequencePosition(self):
        return self.SequencePosition
    def set_SequencePosition(self, SequencePosition):
        self.SequencePosition = SequencePosition
    def add_SequencePosition(self, value):
        self.SequencePosition.append(value)
    def insert_SequencePosition_at(self, index, value):
        self.SequencePosition.insert(index, value)
    def replace_SequencePosition_at(self, index, value):
        self.SequencePosition[index] = value
    def get_Service(self):
        return self.Service
    def set_Service(self, Service):
        self.Service = Service
    def add_Service(self, value):
        self.Service.append(value)
    def insert_Service_at(self, index, value):
        self.Service.insert(index, value)
    def replace_Service_at(self, index, value):
        self.Service[index] = value
    def get_StatisticalClassification(self):
        return self.StatisticalClassification
    def set_StatisticalClassification(self, StatisticalClassification):
        self.StatisticalClassification = StatisticalClassification
    def add_StatisticalClassification(self, value):
        self.StatisticalClassification.append(value)
    def insert_StatisticalClassification_at(self, index, value):
        self.StatisticalClassification.insert(index, value)
    def replace_StatisticalClassification_at(self, index, value):
        self.StatisticalClassification[index] = value
    def get_StatisticalClassificationRelationship(self):
        return self.StatisticalClassificationRelationship
    def set_StatisticalClassificationRelationship(self, StatisticalClassificationRelationship):
        self.StatisticalClassificationRelationship = StatisticalClassificationRelationship
    def add_StatisticalClassificationRelationship(self, value):
        self.StatisticalClassificationRelationship.append(value)
    def insert_StatisticalClassificationRelationship_at(self, index, value):
        self.StatisticalClassificationRelationship.insert(index, value)
    def replace_StatisticalClassificationRelationship_at(self, index, value):
        self.StatisticalClassificationRelationship[index] = value
    def get_Step(self):
        return self.Step
    def set_Step(self, Step):
        self.Step = Step
    def add_Step(self, value):
        self.Step.append(value)
    def insert_Step_at(self, index, value):
        self.Step.insert(index, value)
    def replace_Step_at(self, index, value):
        self.Step[index] = value
    def get_SubstantiveConceptualDomain(self):
        return self.SubstantiveConceptualDomain
    def set_SubstantiveConceptualDomain(self, SubstantiveConceptualDomain):
        self.SubstantiveConceptualDomain = SubstantiveConceptualDomain
    def add_SubstantiveConceptualDomain(self, value):
        self.SubstantiveConceptualDomain.append(value)
    def insert_SubstantiveConceptualDomain_at(self, index, value):
        self.SubstantiveConceptualDomain.insert(index, value)
    def replace_SubstantiveConceptualDomain_at(self, index, value):
        self.SubstantiveConceptualDomain[index] = value
    def get_SubstantiveValueDomain(self):
        return self.SubstantiveValueDomain
    def set_SubstantiveValueDomain(self, SubstantiveValueDomain):
        self.SubstantiveValueDomain = SubstantiveValueDomain
    def add_SubstantiveValueDomain(self, value):
        self.SubstantiveValueDomain.append(value)
    def insert_SubstantiveValueDomain_at(self, index, value):
        self.SubstantiveValueDomain.insert(index, value)
    def replace_SubstantiveValueDomain_at(self, index, value):
        self.SubstantiveValueDomain[index] = value
    def get_SyntheticIdComponent(self):
        return self.SyntheticIdComponent
    def set_SyntheticIdComponent(self, SyntheticIdComponent):
        self.SyntheticIdComponent = SyntheticIdComponent
    def add_SyntheticIdComponent(self, value):
        self.SyntheticIdComponent.append(value)
    def insert_SyntheticIdComponent_at(self, index, value):
        self.SyntheticIdComponent.insert(index, value)
    def replace_SyntheticIdComponent_at(self, index, value):
        self.SyntheticIdComponent[index] = value
    def get_TemporalConstraints(self):
        return self.TemporalConstraints
    def set_TemporalConstraints(self, TemporalConstraints):
        self.TemporalConstraints = TemporalConstraints
    def add_TemporalConstraints(self, value):
        self.TemporalConstraints.append(value)
    def insert_TemporalConstraints_at(self, index, value):
        self.TemporalConstraints.insert(index, value)
    def replace_TemporalConstraints_at(self, index, value):
        self.TemporalConstraints[index] = value
    def get_TemporalControlConstruct(self):
        return self.TemporalControlConstruct
    def set_TemporalControlConstruct(self, TemporalControlConstruct):
        self.TemporalControlConstruct = TemporalControlConstruct
    def add_TemporalControlConstruct(self, value):
        self.TemporalControlConstruct.append(value)
    def insert_TemporalControlConstruct_at(self, index, value):
        self.TemporalControlConstruct.insert(index, value)
    def replace_TemporalControlConstruct_at(self, index, value):
        self.TemporalControlConstruct[index] = value
    def get_Unit(self):
        return self.Unit
    def set_Unit(self, Unit):
        self.Unit = Unit
    def add_Unit(self, value):
        self.Unit.append(value)
    def insert_Unit_at(self, index, value):
        self.Unit.insert(index, value)
    def replace_Unit_at(self, index, value):
        self.Unit[index] = value
    def get_UnitSegmentLayout(self):
        return self.UnitSegmentLayout
    def set_UnitSegmentLayout(self, UnitSegmentLayout):
        self.UnitSegmentLayout = UnitSegmentLayout
    def add_UnitSegmentLayout(self, value):
        self.UnitSegmentLayout.append(value)
    def insert_UnitSegmentLayout_at(self, index, value):
        self.UnitSegmentLayout.insert(index, value)
    def replace_UnitSegmentLayout_at(self, index, value):
        self.UnitSegmentLayout[index] = value
    def get_UnitType(self):
        return self.UnitType
    def set_UnitType(self, UnitType):
        self.UnitType = UnitType
    def add_UnitType(self, value):
        self.UnitType.append(value)
    def insert_UnitType_at(self, index, value):
        self.UnitType.insert(index, value)
    def replace_UnitType_at(self, index, value):
        self.UnitType[index] = value
    def get_Universe(self):
        return self.Universe
    def set_Universe(self, Universe):
        self.Universe = Universe
    def add_Universe(self, value):
        self.Universe.append(value)
    def insert_Universe_at(self, index, value):
        self.Universe.insert(index, value)
    def replace_Universe_at(self, index, value):
        self.Universe[index] = value
    def get_ValueAndConceptDescription(self):
        return self.ValueAndConceptDescription
    def set_ValueAndConceptDescription(self, ValueAndConceptDescription):
        self.ValueAndConceptDescription = ValueAndConceptDescription
    def add_ValueAndConceptDescription(self, value):
        self.ValueAndConceptDescription.append(value)
    def insert_ValueAndConceptDescription_at(self, index, value):
        self.ValueAndConceptDescription.insert(index, value)
    def replace_ValueAndConceptDescription_at(self, index, value):
        self.ValueAndConceptDescription[index] = value
    def get_ValueDomain(self):
        return self.ValueDomain
    def set_ValueDomain(self, ValueDomain):
        self.ValueDomain = ValueDomain
    def add_ValueDomain(self, value):
        self.ValueDomain.append(value)
    def insert_ValueDomain_at(self, index, value):
        self.ValueDomain.insert(index, value)
    def replace_ValueDomain_at(self, index, value):
        self.ValueDomain[index] = value
    def get_ValueMapping(self):
        return self.ValueMapping
    def set_ValueMapping(self, ValueMapping):
        self.ValueMapping = ValueMapping
    def add_ValueMapping(self, value):
        self.ValueMapping.append(value)
    def insert_ValueMapping_at(self, index, value):
        self.ValueMapping.insert(index, value)
    def replace_ValueMapping_at(self, index, value):
        self.ValueMapping[index] = value
    def get_ValueMappingPosition(self):
        return self.ValueMappingPosition
    def set_ValueMappingPosition(self, ValueMappingPosition):
        self.ValueMappingPosition = ValueMappingPosition
    def add_ValueMappingPosition(self, value):
        self.ValueMappingPosition.append(value)
    def insert_ValueMappingPosition_at(self, index, value):
        self.ValueMappingPosition.insert(index, value)
    def replace_ValueMappingPosition_at(self, index, value):
        self.ValueMappingPosition[index] = value
    def get_ValueMappingRelationship(self):
        return self.ValueMappingRelationship
    def set_ValueMappingRelationship(self, ValueMappingRelationship):
        self.ValueMappingRelationship = ValueMappingRelationship
    def add_ValueMappingRelationship(self, value):
        self.ValueMappingRelationship.append(value)
    def insert_ValueMappingRelationship_at(self, index, value):
        self.ValueMappingRelationship.insert(index, value)
    def replace_ValueMappingRelationship_at(self, index, value):
        self.ValueMappingRelationship[index] = value
    def get_VariableCollection(self):
        return self.VariableCollection
    def set_VariableCollection(self, VariableCollection):
        self.VariableCollection = VariableCollection
    def add_VariableCollection(self, value):
        self.VariableCollection.append(value)
    def insert_VariableCollection_at(self, index, value):
        self.VariableCollection.insert(index, value)
    def replace_VariableCollection_at(self, index, value):
        self.VariableCollection[index] = value
    def get_VariableDescriptorComponent(self):
        return self.VariableDescriptorComponent
    def set_VariableDescriptorComponent(self, VariableDescriptorComponent):
        self.VariableDescriptorComponent = VariableDescriptorComponent
    def add_VariableDescriptorComponent(self, value):
        self.VariableDescriptorComponent.append(value)
    def insert_VariableDescriptorComponent_at(self, index, value):
        self.VariableDescriptorComponent.insert(index, value)
    def replace_VariableDescriptorComponent_at(self, index, value):
        self.VariableDescriptorComponent[index] = value
    def get_VariablePosition(self):
        return self.VariablePosition
    def set_VariablePosition(self, VariablePosition):
        self.VariablePosition = VariablePosition
    def add_VariablePosition(self, value):
        self.VariablePosition.append(value)
    def insert_VariablePosition_at(self, index, value):
        self.VariablePosition.insert(index, value)
    def replace_VariablePosition_at(self, index, value):
        self.VariablePosition[index] = value
    def get_VariableRelationship(self):
        return self.VariableRelationship
    def set_VariableRelationship(self, VariableRelationship):
        self.VariableRelationship = VariableRelationship
    def add_VariableRelationship(self, value):
        self.VariableRelationship.append(value)
    def insert_VariableRelationship_at(self, index, value):
        self.VariableRelationship.insert(index, value)
    def replace_VariableRelationship_at(self, index, value):
        self.VariableRelationship[index] = value
    def get_VariableStructure(self):
        return self.VariableStructure
    def set_VariableStructure(self, VariableStructure):
        self.VariableStructure = VariableStructure
    def add_VariableStructure(self, value):
        self.VariableStructure.append(value)
    def insert_VariableStructure_at(self, index, value):
        self.VariableStructure.insert(index, value)
    def replace_VariableStructure_at(self, index, value):
        self.VariableStructure[index] = value
    def get_VariableValueComponent(self):
        return self.VariableValueComponent
    def set_VariableValueComponent(self, VariableValueComponent):
        self.VariableValueComponent = VariableValueComponent
    def add_VariableValueComponent(self, value):
        self.VariableValueComponent.append(value)
    def insert_VariableValueComponent_at(self, index, value):
        self.VariableValueComponent.insert(index, value)
    def replace_VariableValueComponent_at(self, index, value):
        self.VariableValueComponent[index] = value
    def get_WideDataSet(self):
        return self.WideDataSet
    def set_WideDataSet(self, WideDataSet):
        self.WideDataSet = WideDataSet
    def add_WideDataSet(self, value):
        self.WideDataSet.append(value)
    def insert_WideDataSet_at(self, index, value):
        self.WideDataSet.insert(index, value)
    def replace_WideDataSet_at(self, index, value):
        self.WideDataSet[index] = value
    def get_WideDataStructure(self):
        return self.WideDataStructure
    def set_WideDataStructure(self, WideDataStructure):
        self.WideDataStructure = WideDataStructure
    def add_WideDataStructure(self, value):
        self.WideDataStructure.append(value)
    def insert_WideDataStructure_at(self, index, value):
        self.WideDataStructure.insert(index, value)
    def replace_WideDataStructure_at(self, index, value):
        self.WideDataStructure[index] = value
    def get_WideKey(self):
        return self.WideKey
    def set_WideKey(self, WideKey):
        self.WideKey = WideKey
    def add_WideKey(self, value):
        self.WideKey.append(value)
    def insert_WideKey_at(self, index, value):
        self.WideKey.insert(index, value)
    def replace_WideKey_at(self, index, value):
        self.WideKey[index] = value
    def get_WideKeyMember(self):
        return self.WideKeyMember
    def set_WideKeyMember(self, WideKeyMember):
        self.WideKeyMember = WideKeyMember
    def add_WideKeyMember(self, value):
        self.WideKeyMember.append(value)
    def insert_WideKeyMember_at(self, index, value):
        self.WideKeyMember.insert(index, value)
    def replace_WideKeyMember_at(self, index, value):
        self.WideKeyMember[index] = value
    def get_Wrapper(self):
        return self.Wrapper
    def set_Wrapper(self, Wrapper):
        self.Wrapper = Wrapper
    def add_Wrapper(self, value):
        self.Wrapper.append(value)
    def insert_Wrapper_at(self, index, value):
        self.Wrapper.insert(index, value)
    def replace_Wrapper_at(self, index, value):
        self.Wrapper[index] = value
    def has__content(self):
        if (
            self.Activity or
            self.Agent or
            self.AgentListing or
            self.AgentPosition or
            self.AgentRelationship or
            self.AgentStructure or
            self.AllenIntervalAlgebra or
            self.AttributeComponent or
            self.AuthorizationSource or
            self.Category or
            self.CategoryPosition or
            self.CategoryRelationStructure or
            self.CategoryRelationship or
            self.CategorySet or
            self.CategoryStatistic or
            self.ClassificationFamily or
            self.ClassificationIndex or
            self.ClassificationIndexEntry or
            self.ClassificationIndexEntryPosition or
            self.ClassificationItem or
            self.ClassificationItemPosition or
            self.ClassificationItemRelationship or
            self.ClassificationItemStructure or
            self.ClassificationPosition or
            self.ClassificationSeries or
            self.ClassificationSeriesStructure or
            self.Code or
            self.CodeList or
            self.CodeListStructure or
            self.CodePosition or
            self.CodeRelationship or
            self.ComponentPosition or
            self.Concept or
            self.ConceptMap or
            self.ConceptRelationship or
            self.ConceptStructure or
            self.ConceptSystem or
            self.ConceptSystemCorrespondence or
            self.ConceptualDomain or
            self.ConceptualValue or
            self.ConceptualVariable or
            self.ConditionalControlLogic or
            self.ContextualComponent or
            self.ControlLogic or
            self.CorrespondenceTable or
            self.Curator or
            self.DataPoint or
            self.DataPointPosition or
            self.DataPointRelationship or
            self.DataSet or
            self.DataStore or
            self.DataStructure or
            self.DataStructureComponent or
            self.Datum or
            self.Descriptor or
            self.DescriptorValueDomain or
            self.DescriptorVariable or
            self.DeterministicImperative or
            self.DimensionComponent or
            self.DimensionGroup or
            self.DimensionalDataSet or
            self.DimensionalDataStructure or
            self.DimensionalKey or
            self.DimensionalKeyDefinition or
            self.DimensionalKeyDefinitionMember or
            self.DimensionalKeyMember or
            self.EnumerationDomain or
            self.ForeignKey or
            self.ForeignKeyComponent or
            self.IdentifierComponent or
            self.Individual or
            self.InformationFlowDefinition or
            self.InstanceKey or
            self.InstanceValue or
            self.InstanceVariable or
            self.InstanceVariableMap or
            self.Key or
            self.KeyDefinition or
            self.KeyDefinitionMember or
            self.KeyMember or
            self.KeyValueDataStore or
            self.KeyValueStructure or
            self.Level or
            self.LevelStructure or
            self.LogicalRecord or
            self.LogicalRecordPosition or
            self.LogicalRecordRelationStructure or
            self.LogicalRecordRelationship or
            self.LongDataSet or
            self.LongDataStructure or
            self.LongKey or
            self.LongMainKeyMember or
            self.Machine or
            self.MainKeyMember or
            self.MeasureComponent or
            self.NonDeterministicDeclarative or
            self.Notation or
            self.Organization or
            self.Parameter or
            self.PhysicalDataSet or
            self.PhysicalDataSetStructure or
            self.PhysicalLayoutRelationStructure or
            self.PhysicalRecordSegment or
            self.PhysicalRecordSegmentPosition or
            self.PhysicalRecordSegmentRelationship or
            self.PhysicalRecordSegmentStructure or
            self.PhysicalSegmentLayout or
            self.PhysicalSegmentLocation or
            self.Population or
            self.PrimaryKey or
            self.PrimaryKeyComponent or
            self.ProcessingAgent or
            self.ProductionEnvironment or
            self.QualifiedMeasure or
            self.RecordRelation or
            self.ReferenceValue or
            self.ReferenceValueDomain or
            self.ReferenceVariable or
            self.RepresentedVariable or
            self.RevisableDatum or
            self.Revision or
            self.Rule or
            self.RuleBasedScheduling or
            self.RuleSet or
            self.ScopedMeasure or
            self.SegmentByText or
            self.SentinelConceptualDomain or
            self.SentinelValueDomain or
            self.Sequence or
            self.SequencePosition or
            self.Service or
            self.StatisticalClassification or
            self.StatisticalClassificationRelationship or
            self.Step or
            self.SubstantiveConceptualDomain or
            self.SubstantiveValueDomain or
            self.SyntheticIdComponent or
            self.TemporalConstraints or
            self.TemporalControlConstruct or
            self.Unit or
            self.UnitSegmentLayout or
            self.UnitType or
            self.Universe or
            self.ValueAndConceptDescription or
            self.ValueDomain or
            self.ValueMapping or
            self.ValueMappingPosition or
            self.ValueMappingRelationship or
            self.VariableCollection or
            self.VariableDescriptorComponent or
            self.VariablePosition or
            self.VariableRelationship or
            self.VariableStructure or
            self.VariableValueComponent or
            self.WideDataSet or
            self.WideDataStructure or
            self.WideKey or
            self.WideKeyMember or
            self.Wrapper
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DDICDIModels', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        for Activity_ in self.Activity:
            Activity_.to_etree(element, name_='Activity', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Agent_ in self.Agent:
            Agent_.to_etree(element, name_='Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AgentListing_ in self.AgentListing:
            AgentListing_.to_etree(element, name_='AgentListing', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AgentPosition_ in self.AgentPosition:
            AgentPosition_.to_etree(element, name_='AgentPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AgentRelationship_ in self.AgentRelationship:
            AgentRelationship_.to_etree(element, name_='AgentRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AgentStructure_ in self.AgentStructure:
            AgentStructure_.to_etree(element, name_='AgentStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AllenIntervalAlgebra_ in self.AllenIntervalAlgebra:
            AllenIntervalAlgebra_.to_etree(element, name_='AllenIntervalAlgebra', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AttributeComponent_ in self.AttributeComponent:
            AttributeComponent_.to_etree(element, name_='AttributeComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AuthorizationSource_ in self.AuthorizationSource:
            AuthorizationSource_.to_etree(element, name_='AuthorizationSource', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Category_ in self.Category:
            Category_.to_etree(element, name_='Category', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategoryPosition_ in self.CategoryPosition:
            CategoryPosition_.to_etree(element, name_='CategoryPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategoryRelationStructure_ in self.CategoryRelationStructure:
            CategoryRelationStructure_.to_etree(element, name_='CategoryRelationStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategoryRelationship_ in self.CategoryRelationship:
            CategoryRelationship_.to_etree(element, name_='CategoryRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategorySet_ in self.CategorySet:
            CategorySet_.to_etree(element, name_='CategorySet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategoryStatistic_ in self.CategoryStatistic:
            CategoryStatistic_.to_etree(element, name_='CategoryStatistic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationFamily_ in self.ClassificationFamily:
            ClassificationFamily_.to_etree(element, name_='ClassificationFamily', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationIndex_ in self.ClassificationIndex:
            ClassificationIndex_.to_etree(element, name_='ClassificationIndex', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationIndexEntry_ in self.ClassificationIndexEntry:
            ClassificationIndexEntry_.to_etree(element, name_='ClassificationIndexEntry', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationIndexEntryPosition_ in self.ClassificationIndexEntryPosition:
            ClassificationIndexEntryPosition_.to_etree(element, name_='ClassificationIndexEntryPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationItem_ in self.ClassificationItem:
            ClassificationItem_.to_etree(element, name_='ClassificationItem', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationItemPosition_ in self.ClassificationItemPosition:
            ClassificationItemPosition_.to_etree(element, name_='ClassificationItemPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationItemRelationship_ in self.ClassificationItemRelationship:
            ClassificationItemRelationship_.to_etree(element, name_='ClassificationItemRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationItemStructure_ in self.ClassificationItemStructure:
            ClassificationItemStructure_.to_etree(element, name_='ClassificationItemStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationPosition_ in self.ClassificationPosition:
            ClassificationPosition_.to_etree(element, name_='ClassificationPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationSeries_ in self.ClassificationSeries:
            ClassificationSeries_.to_etree(element, name_='ClassificationSeries', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationSeriesStructure_ in self.ClassificationSeriesStructure:
            ClassificationSeriesStructure_.to_etree(element, name_='ClassificationSeriesStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Code_ in self.Code:
            Code_.to_etree(element, name_='Code', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CodeList_ in self.CodeList:
            CodeList_.to_etree(element, name_='CodeList', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CodeListStructure_ in self.CodeListStructure:
            CodeListStructure_.to_etree(element, name_='CodeListStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CodePosition_ in self.CodePosition:
            CodePosition_.to_etree(element, name_='CodePosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CodeRelationship_ in self.CodeRelationship:
            CodeRelationship_.to_etree(element, name_='CodeRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ComponentPosition_ in self.ComponentPosition:
            ComponentPosition_.to_etree(element, name_='ComponentPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Concept_ in self.Concept:
            Concept_.to_etree(element, name_='Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptMap_ in self.ConceptMap:
            ConceptMap_.to_etree(element, name_='ConceptMap', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptRelationship_ in self.ConceptRelationship:
            ConceptRelationship_.to_etree(element, name_='ConceptRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptStructure_ in self.ConceptStructure:
            ConceptStructure_.to_etree(element, name_='ConceptStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptSystem_ in self.ConceptSystem:
            ConceptSystem_.to_etree(element, name_='ConceptSystem', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptSystemCorrespondence_ in self.ConceptSystemCorrespondence:
            ConceptSystemCorrespondence_.to_etree(element, name_='ConceptSystemCorrespondence', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptualDomain_ in self.ConceptualDomain:
            ConceptualDomain_.to_etree(element, name_='ConceptualDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptualValue_ in self.ConceptualValue:
            ConceptualValue_.to_etree(element, name_='ConceptualValue', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptualVariable_ in self.ConceptualVariable:
            ConceptualVariable_.to_etree(element, name_='ConceptualVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConditionalControlLogic_ in self.ConditionalControlLogic:
            ConditionalControlLogic_.to_etree(element, name_='ConditionalControlLogic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ContextualComponent_ in self.ContextualComponent:
            ContextualComponent_.to_etree(element, name_='ContextualComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ControlLogic_ in self.ControlLogic:
            ControlLogic_.to_etree(element, name_='ControlLogic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CorrespondenceTable_ in self.CorrespondenceTable:
            CorrespondenceTable_.to_etree(element, name_='CorrespondenceTable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Curator_ in self.Curator:
            Curator_.to_etree(element, name_='Curator', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataPoint_ in self.DataPoint:
            DataPoint_.to_etree(element, name_='DataPoint', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataPointPosition_ in self.DataPointPosition:
            DataPointPosition_.to_etree(element, name_='DataPointPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataPointRelationship_ in self.DataPointRelationship:
            DataPointRelationship_.to_etree(element, name_='DataPointRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataSet_ in self.DataSet:
            DataSet_.to_etree(element, name_='DataSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataStore_ in self.DataStore:
            DataStore_.to_etree(element, name_='DataStore', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataStructure_ in self.DataStructure:
            DataStructure_.to_etree(element, name_='DataStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataStructureComponent_ in self.DataStructureComponent:
            DataStructureComponent_.to_etree(element, name_='DataStructureComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Datum_ in self.Datum:
            Datum_.to_etree(element, name_='Datum', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Descriptor_ in self.Descriptor:
            Descriptor_.to_etree(element, name_='Descriptor', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DescriptorValueDomain_ in self.DescriptorValueDomain:
            DescriptorValueDomain_.to_etree(element, name_='DescriptorValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DescriptorVariable_ in self.DescriptorVariable:
            DescriptorVariable_.to_etree(element, name_='DescriptorVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DeterministicImperative_ in self.DeterministicImperative:
            DeterministicImperative_.to_etree(element, name_='DeterministicImperative', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionComponent_ in self.DimensionComponent:
            DimensionComponent_.to_etree(element, name_='DimensionComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionGroup_ in self.DimensionGroup:
            DimensionGroup_.to_etree(element, name_='DimensionGroup', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionalDataSet_ in self.DimensionalDataSet:
            DimensionalDataSet_.to_etree(element, name_='DimensionalDataSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionalDataStructure_ in self.DimensionalDataStructure:
            DimensionalDataStructure_.to_etree(element, name_='DimensionalDataStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionalKey_ in self.DimensionalKey:
            DimensionalKey_.to_etree(element, name_='DimensionalKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionalKeyDefinition_ in self.DimensionalKeyDefinition:
            DimensionalKeyDefinition_.to_etree(element, name_='DimensionalKeyDefinition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionalKeyDefinitionMember_ in self.DimensionalKeyDefinitionMember:
            DimensionalKeyDefinitionMember_.to_etree(element, name_='DimensionalKeyDefinitionMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionalKeyMember_ in self.DimensionalKeyMember:
            DimensionalKeyMember_.to_etree(element, name_='DimensionalKeyMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for EnumerationDomain_ in self.EnumerationDomain:
            EnumerationDomain_.to_etree(element, name_='EnumerationDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ForeignKey_ in self.ForeignKey:
            ForeignKey_.to_etree(element, name_='ForeignKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ForeignKeyComponent_ in self.ForeignKeyComponent:
            ForeignKeyComponent_.to_etree(element, name_='ForeignKeyComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for IdentifierComponent_ in self.IdentifierComponent:
            IdentifierComponent_.to_etree(element, name_='IdentifierComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Individual_ in self.Individual:
            Individual_.to_etree(element, name_='Individual', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for InformationFlowDefinition_ in self.InformationFlowDefinition:
            InformationFlowDefinition_.to_etree(element, name_='InformationFlowDefinition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for InstanceKey_ in self.InstanceKey:
            InstanceKey_.to_etree(element, name_='InstanceKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for InstanceValue_ in self.InstanceValue:
            InstanceValue_.to_etree(element, name_='InstanceValue', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for InstanceVariable_ in self.InstanceVariable:
            InstanceVariable_.to_etree(element, name_='InstanceVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for InstanceVariableMap_ in self.InstanceVariableMap:
            InstanceVariableMap_.to_etree(element, name_='InstanceVariableMap', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Key_ in self.Key:
            Key_.to_etree(element, name_='Key', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for KeyDefinition_ in self.KeyDefinition:
            KeyDefinition_.to_etree(element, name_='KeyDefinition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for KeyDefinitionMember_ in self.KeyDefinitionMember:
            KeyDefinitionMember_.to_etree(element, name_='KeyDefinitionMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for KeyMember_ in self.KeyMember:
            KeyMember_.to_etree(element, name_='KeyMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for KeyValueDataStore_ in self.KeyValueDataStore:
            KeyValueDataStore_.to_etree(element, name_='KeyValueDataStore', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for KeyValueStructure_ in self.KeyValueStructure:
            KeyValueStructure_.to_etree(element, name_='KeyValueStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Level_ in self.Level:
            Level_.to_etree(element, name_='Level', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LevelStructure_ in self.LevelStructure:
            LevelStructure_.to_etree(element, name_='LevelStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecord_ in self.LogicalRecord:
            LogicalRecord_.to_etree(element, name_='LogicalRecord', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecordPosition_ in self.LogicalRecordPosition:
            LogicalRecordPosition_.to_etree(element, name_='LogicalRecordPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecordRelationStructure_ in self.LogicalRecordRelationStructure:
            LogicalRecordRelationStructure_.to_etree(element, name_='LogicalRecordRelationStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecordRelationship_ in self.LogicalRecordRelationship:
            LogicalRecordRelationship_.to_etree(element, name_='LogicalRecordRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LongDataSet_ in self.LongDataSet:
            LongDataSet_.to_etree(element, name_='LongDataSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LongDataStructure_ in self.LongDataStructure:
            LongDataStructure_.to_etree(element, name_='LongDataStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LongKey_ in self.LongKey:
            LongKey_.to_etree(element, name_='LongKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LongMainKeyMember_ in self.LongMainKeyMember:
            LongMainKeyMember_.to_etree(element, name_='LongMainKeyMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Machine_ in self.Machine:
            Machine_.to_etree(element, name_='Machine', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for MainKeyMember_ in self.MainKeyMember:
            MainKeyMember_.to_etree(element, name_='MainKeyMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for MeasureComponent_ in self.MeasureComponent:
            MeasureComponent_.to_etree(element, name_='MeasureComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for NonDeterministicDeclarative_ in self.NonDeterministicDeclarative:
            NonDeterministicDeclarative_.to_etree(element, name_='NonDeterministicDeclarative', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Notation_ in self.Notation:
            Notation_.to_etree(element, name_='Notation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Organization_ in self.Organization:
            Organization_.to_etree(element, name_='Organization', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Parameter_ in self.Parameter:
            Parameter_.to_etree(element, name_='Parameter', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalDataSet_ in self.PhysicalDataSet:
            PhysicalDataSet_.to_etree(element, name_='PhysicalDataSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalDataSetStructure_ in self.PhysicalDataSetStructure:
            PhysicalDataSetStructure_.to_etree(element, name_='PhysicalDataSetStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalLayoutRelationStructure_ in self.PhysicalLayoutRelationStructure:
            PhysicalLayoutRelationStructure_.to_etree(element, name_='PhysicalLayoutRelationStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalRecordSegment_ in self.PhysicalRecordSegment:
            PhysicalRecordSegment_.to_etree(element, name_='PhysicalRecordSegment', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalRecordSegmentPosition_ in self.PhysicalRecordSegmentPosition:
            PhysicalRecordSegmentPosition_.to_etree(element, name_='PhysicalRecordSegmentPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalRecordSegmentRelationship_ in self.PhysicalRecordSegmentRelationship:
            PhysicalRecordSegmentRelationship_.to_etree(element, name_='PhysicalRecordSegmentRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalRecordSegmentStructure_ in self.PhysicalRecordSegmentStructure:
            PhysicalRecordSegmentStructure_.to_etree(element, name_='PhysicalRecordSegmentStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalSegmentLayout_ in self.PhysicalSegmentLayout:
            PhysicalSegmentLayout_.to_etree(element, name_='PhysicalSegmentLayout', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalSegmentLocation_ in self.PhysicalSegmentLocation:
            PhysicalSegmentLocation_.to_etree(element, name_='PhysicalSegmentLocation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Population_ in self.Population:
            Population_.to_etree(element, name_='Population', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PrimaryKey_ in self.PrimaryKey:
            PrimaryKey_.to_etree(element, name_='PrimaryKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PrimaryKeyComponent_ in self.PrimaryKeyComponent:
            PrimaryKeyComponent_.to_etree(element, name_='PrimaryKeyComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ProcessingAgent_ in self.ProcessingAgent:
            ProcessingAgent_.to_etree(element, name_='ProcessingAgent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ProductionEnvironment_ in self.ProductionEnvironment:
            ProductionEnvironment_.to_etree(element, name_='ProductionEnvironment', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for QualifiedMeasure_ in self.QualifiedMeasure:
            QualifiedMeasure_.to_etree(element, name_='QualifiedMeasure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RecordRelation_ in self.RecordRelation:
            RecordRelation_.to_etree(element, name_='RecordRelation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ReferenceValue_ in self.ReferenceValue:
            ReferenceValue_.to_etree(element, name_='ReferenceValue', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ReferenceValueDomain_ in self.ReferenceValueDomain:
            ReferenceValueDomain_.to_etree(element, name_='ReferenceValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ReferenceVariable_ in self.ReferenceVariable:
            ReferenceVariable_.to_etree(element, name_='ReferenceVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RepresentedVariable_ in self.RepresentedVariable:
            RepresentedVariable_.to_etree(element, name_='RepresentedVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RevisableDatum_ in self.RevisableDatum:
            RevisableDatum_.to_etree(element, name_='RevisableDatum', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Revision_ in self.Revision:
            Revision_.to_etree(element, name_='Revision', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Rule_ in self.Rule:
            Rule_.to_etree(element, name_='Rule', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RuleBasedScheduling_ in self.RuleBasedScheduling:
            RuleBasedScheduling_.to_etree(element, name_='RuleBasedScheduling', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RuleSet_ in self.RuleSet:
            RuleSet_.to_etree(element, name_='RuleSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ScopedMeasure_ in self.ScopedMeasure:
            ScopedMeasure_.to_etree(element, name_='ScopedMeasure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SegmentByText_ in self.SegmentByText:
            SegmentByText_.to_etree(element, name_='SegmentByText', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SentinelConceptualDomain_ in self.SentinelConceptualDomain:
            SentinelConceptualDomain_.to_etree(element, name_='SentinelConceptualDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SentinelValueDomain_ in self.SentinelValueDomain:
            SentinelValueDomain_.to_etree(element, name_='SentinelValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Sequence_ in self.Sequence:
            Sequence_.to_etree(element, name_='Sequence', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SequencePosition_ in self.SequencePosition:
            SequencePosition_.to_etree(element, name_='SequencePosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Service_ in self.Service:
            Service_.to_etree(element, name_='Service', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for StatisticalClassification_ in self.StatisticalClassification:
            StatisticalClassification_.to_etree(element, name_='StatisticalClassification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for StatisticalClassificationRelationship_ in self.StatisticalClassificationRelationship:
            StatisticalClassificationRelationship_.to_etree(element, name_='StatisticalClassificationRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Step_ in self.Step:
            Step_.to_etree(element, name_='Step', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SubstantiveConceptualDomain_ in self.SubstantiveConceptualDomain:
            SubstantiveConceptualDomain_.to_etree(element, name_='SubstantiveConceptualDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SubstantiveValueDomain_ in self.SubstantiveValueDomain:
            SubstantiveValueDomain_.to_etree(element, name_='SubstantiveValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SyntheticIdComponent_ in self.SyntheticIdComponent:
            SyntheticIdComponent_.to_etree(element, name_='SyntheticIdComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for TemporalConstraints_ in self.TemporalConstraints:
            TemporalConstraints_.to_etree(element, name_='TemporalConstraints', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for TemporalControlConstruct_ in self.TemporalControlConstruct:
            TemporalControlConstruct_.to_etree(element, name_='TemporalControlConstruct', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Unit_ in self.Unit:
            Unit_.to_etree(element, name_='Unit', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for UnitSegmentLayout_ in self.UnitSegmentLayout:
            UnitSegmentLayout_.to_etree(element, name_='UnitSegmentLayout', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for UnitType_ in self.UnitType:
            UnitType_.to_etree(element, name_='UnitType', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Universe_ in self.Universe:
            Universe_.to_etree(element, name_='Universe', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ValueAndConceptDescription_ in self.ValueAndConceptDescription:
            ValueAndConceptDescription_.to_etree(element, name_='ValueAndConceptDescription', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ValueDomain_ in self.ValueDomain:
            ValueDomain_.to_etree(element, name_='ValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ValueMapping_ in self.ValueMapping:
            ValueMapping_.to_etree(element, name_='ValueMapping', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ValueMappingPosition_ in self.ValueMappingPosition:
            ValueMappingPosition_.to_etree(element, name_='ValueMappingPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ValueMappingRelationship_ in self.ValueMappingRelationship:
            ValueMappingRelationship_.to_etree(element, name_='ValueMappingRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableCollection_ in self.VariableCollection:
            VariableCollection_.to_etree(element, name_='VariableCollection', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableDescriptorComponent_ in self.VariableDescriptorComponent:
            VariableDescriptorComponent_.to_etree(element, name_='VariableDescriptorComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariablePosition_ in self.VariablePosition:
            VariablePosition_.to_etree(element, name_='VariablePosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableRelationship_ in self.VariableRelationship:
            VariableRelationship_.to_etree(element, name_='VariableRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableStructure_ in self.VariableStructure:
            VariableStructure_.to_etree(element, name_='VariableStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableValueComponent_ in self.VariableValueComponent:
            VariableValueComponent_.to_etree(element, name_='VariableValueComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for WideDataSet_ in self.WideDataSet:
            WideDataSet_.to_etree(element, name_='WideDataSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for WideDataStructure_ in self.WideDataStructure:
            WideDataStructure_.to_etree(element, name_='WideDataStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for WideKey_ in self.WideKey:
            WideKey_.to_etree(element, name_='WideKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for WideKeyMember_ in self.WideKeyMember:
            WideKeyMember_.to_etree(element, name_='WideKeyMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Wrapper_ in self.Wrapper:
            Wrapper_.to_etree(element, name_='Wrapper', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Activity':
            class_obj_ = self.get_class_obj_(child_, Activity)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Activity.append(obj_)
            obj_.original_tagname_ = 'Activity'
        elif nodeName_ == 'Agent':
            class_obj_ = self.get_class_obj_(child_, Agent)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Agent.append(obj_)
            obj_.original_tagname_ = 'Agent'
        elif nodeName_ == 'AgentListing':
            obj_ = AgentListing.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentListing.append(obj_)
            obj_.original_tagname_ = 'AgentListing'
        elif nodeName_ == 'AgentPosition':
            obj_ = AgentPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentPosition.append(obj_)
            obj_.original_tagname_ = 'AgentPosition'
        elif nodeName_ == 'AgentRelationship':
            obj_ = AgentRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentRelationship.append(obj_)
            obj_.original_tagname_ = 'AgentRelationship'
        elif nodeName_ == 'AgentStructure':
            obj_ = AgentStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentStructure.append(obj_)
            obj_.original_tagname_ = 'AgentStructure'
        elif nodeName_ == 'AllenIntervalAlgebra':
            obj_ = AllenIntervalAlgebra.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AllenIntervalAlgebra.append(obj_)
            obj_.original_tagname_ = 'AllenIntervalAlgebra'
        elif nodeName_ == 'AttributeComponent':
            obj_ = AttributeComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeComponent.append(obj_)
            obj_.original_tagname_ = 'AttributeComponent'
        elif nodeName_ == 'AuthorizationSource':
            obj_ = AuthorizationSource.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AuthorizationSource.append(obj_)
            obj_.original_tagname_ = 'AuthorizationSource'
        elif nodeName_ == 'Category':
            obj_ = Category.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Category.append(obj_)
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'CategoryPosition':
            obj_ = CategoryPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryPosition.append(obj_)
            obj_.original_tagname_ = 'CategoryPosition'
        elif nodeName_ == 'CategoryRelationStructure':
            obj_ = CategoryRelationStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryRelationStructure.append(obj_)
            obj_.original_tagname_ = 'CategoryRelationStructure'
        elif nodeName_ == 'CategoryRelationship':
            obj_ = CategoryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryRelationship.append(obj_)
            obj_.original_tagname_ = 'CategoryRelationship'
        elif nodeName_ == 'CategorySet':
            obj_ = CategorySet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategorySet.append(obj_)
            obj_.original_tagname_ = 'CategorySet'
        elif nodeName_ == 'CategoryStatistic':
            obj_ = CategoryStatistic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryStatistic.append(obj_)
            obj_.original_tagname_ = 'CategoryStatistic'
        elif nodeName_ == 'ClassificationFamily':
            obj_ = ClassificationFamily.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationFamily.append(obj_)
            obj_.original_tagname_ = 'ClassificationFamily'
        elif nodeName_ == 'ClassificationIndex':
            obj_ = ClassificationIndex.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationIndex.append(obj_)
            obj_.original_tagname_ = 'ClassificationIndex'
        elif nodeName_ == 'ClassificationIndexEntry':
            obj_ = ClassificationIndexEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationIndexEntry.append(obj_)
            obj_.original_tagname_ = 'ClassificationIndexEntry'
        elif nodeName_ == 'ClassificationIndexEntryPosition':
            obj_ = ClassificationIndexEntryPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationIndexEntryPosition.append(obj_)
            obj_.original_tagname_ = 'ClassificationIndexEntryPosition'
        elif nodeName_ == 'ClassificationItem':
            obj_ = ClassificationItem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItem.append(obj_)
            obj_.original_tagname_ = 'ClassificationItem'
        elif nodeName_ == 'ClassificationItemPosition':
            obj_ = ClassificationItemPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItemPosition.append(obj_)
            obj_.original_tagname_ = 'ClassificationItemPosition'
        elif nodeName_ == 'ClassificationItemRelationship':
            obj_ = ClassificationItemRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItemRelationship.append(obj_)
            obj_.original_tagname_ = 'ClassificationItemRelationship'
        elif nodeName_ == 'ClassificationItemStructure':
            obj_ = ClassificationItemStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItemStructure.append(obj_)
            obj_.original_tagname_ = 'ClassificationItemStructure'
        elif nodeName_ == 'ClassificationPosition':
            obj_ = ClassificationPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationPosition.append(obj_)
            obj_.original_tagname_ = 'ClassificationPosition'
        elif nodeName_ == 'ClassificationSeries':
            obj_ = ClassificationSeries.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationSeries.append(obj_)
            obj_.original_tagname_ = 'ClassificationSeries'
        elif nodeName_ == 'ClassificationSeriesStructure':
            obj_ = ClassificationSeriesStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationSeriesStructure.append(obj_)
            obj_.original_tagname_ = 'ClassificationSeriesStructure'
        elif nodeName_ == 'Code':
            obj_ = Code.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Code.append(obj_)
            obj_.original_tagname_ = 'Code'
        elif nodeName_ == 'CodeList':
            obj_ = CodeList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodeList.append(obj_)
            obj_.original_tagname_ = 'CodeList'
        elif nodeName_ == 'CodeListStructure':
            obj_ = CodeListStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodeListStructure.append(obj_)
            obj_.original_tagname_ = 'CodeListStructure'
        elif nodeName_ == 'CodePosition':
            obj_ = CodePosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodePosition.append(obj_)
            obj_.original_tagname_ = 'CodePosition'
        elif nodeName_ == 'CodeRelationship':
            obj_ = CodeRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodeRelationship.append(obj_)
            obj_.original_tagname_ = 'CodeRelationship'
        elif nodeName_ == 'ComponentPosition':
            obj_ = ComponentPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ComponentPosition.append(obj_)
            obj_.original_tagname_ = 'ComponentPosition'
        elif nodeName_ == 'Concept':
            class_obj_ = self.get_class_obj_(child_, Concept)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Concept.append(obj_)
            obj_.original_tagname_ = 'Concept'
        elif nodeName_ == 'ConceptMap':
            obj_ = ConceptMap.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptMap.append(obj_)
            obj_.original_tagname_ = 'ConceptMap'
        elif nodeName_ == 'ConceptRelationship':
            obj_ = ConceptRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptRelationship.append(obj_)
            obj_.original_tagname_ = 'ConceptRelationship'
        elif nodeName_ == 'ConceptStructure':
            obj_ = ConceptStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptStructure.append(obj_)
            obj_.original_tagname_ = 'ConceptStructure'
        elif nodeName_ == 'ConceptSystem':
            class_obj_ = self.get_class_obj_(child_, ConceptSystem)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptSystem.append(obj_)
            obj_.original_tagname_ = 'ConceptSystem'
        elif nodeName_ == 'ConceptSystemCorrespondence':
            obj_ = ConceptSystemCorrespondence.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptSystemCorrespondence.append(obj_)
            obj_.original_tagname_ = 'ConceptSystemCorrespondence'
        elif nodeName_ == 'ConceptualDomain':
            class_obj_ = self.get_class_obj_(child_, ConceptualDomain)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptualDomain.append(obj_)
            obj_.original_tagname_ = 'ConceptualDomain'
        elif nodeName_ == 'ConceptualValue':
            class_obj_ = self.get_class_obj_(child_, ConceptualValue)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptualValue.append(obj_)
            obj_.original_tagname_ = 'ConceptualValue'
        elif nodeName_ == 'ConceptualVariable':
            class_obj_ = self.get_class_obj_(child_, ConceptualVariable)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptualVariable.append(obj_)
            obj_.original_tagname_ = 'ConceptualVariable'
        elif nodeName_ == 'ConditionalControlLogic':
            obj_ = ConditionalControlLogic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConditionalControlLogic.append(obj_)
            obj_.original_tagname_ = 'ConditionalControlLogic'
        elif nodeName_ == 'ContextualComponent':
            obj_ = ContextualComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextualComponent.append(obj_)
            obj_.original_tagname_ = 'ContextualComponent'
        elif nodeName_ == 'ControlLogic':
            class_obj_ = self.get_class_obj_(child_, ControlLogic)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlLogic.append(obj_)
            obj_.original_tagname_ = 'ControlLogic'
        elif nodeName_ == 'CorrespondenceTable':
            obj_ = CorrespondenceTable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CorrespondenceTable.append(obj_)
            obj_.original_tagname_ = 'CorrespondenceTable'
        elif nodeName_ == 'Curator':
            obj_ = Curator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Curator.append(obj_)
            obj_.original_tagname_ = 'Curator'
        elif nodeName_ == 'DataPoint':
            obj_ = DataPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataPoint.append(obj_)
            obj_.original_tagname_ = 'DataPoint'
        elif nodeName_ == 'DataPointPosition':
            obj_ = DataPointPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataPointPosition.append(obj_)
            obj_.original_tagname_ = 'DataPointPosition'
        elif nodeName_ == 'DataPointRelationship':
            obj_ = DataPointRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataPointRelationship.append(obj_)
            obj_.original_tagname_ = 'DataPointRelationship'
        elif nodeName_ == 'DataSet':
            class_obj_ = self.get_class_obj_(child_, DataSet)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataSet.append(obj_)
            obj_.original_tagname_ = 'DataSet'
        elif nodeName_ == 'DataStore':
            obj_ = DataStore.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStore.append(obj_)
            obj_.original_tagname_ = 'DataStore'
        elif nodeName_ == 'DataStructure':
            class_obj_ = self.get_class_obj_(child_, DataStructure)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStructure.append(obj_)
            obj_.original_tagname_ = 'DataStructure'
        elif nodeName_ == 'DataStructureComponent':
            class_obj_ = self.get_class_obj_(child_, DataStructureComponent)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStructureComponent.append(obj_)
            obj_.original_tagname_ = 'DataStructureComponent'
        elif nodeName_ == 'Datum':
            class_obj_ = self.get_class_obj_(child_, Datum)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Datum.append(obj_)
            obj_.original_tagname_ = 'Datum'
        elif nodeName_ == 'Descriptor':
            obj_ = Descriptor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Descriptor.append(obj_)
            obj_.original_tagname_ = 'Descriptor'
        elif nodeName_ == 'DescriptorValueDomain':
            obj_ = DescriptorValueDomain.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DescriptorValueDomain.append(obj_)
            obj_.original_tagname_ = 'DescriptorValueDomain'
        elif nodeName_ == 'DescriptorVariable':
            obj_ = DescriptorVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DescriptorVariable.append(obj_)
            obj_.original_tagname_ = 'DescriptorVariable'
        elif nodeName_ == 'DeterministicImperative':
            class_obj_ = self.get_class_obj_(child_, DeterministicImperative)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DeterministicImperative.append(obj_)
            obj_.original_tagname_ = 'DeterministicImperative'
        elif nodeName_ == 'DimensionComponent':
            obj_ = DimensionComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionComponent.append(obj_)
            obj_.original_tagname_ = 'DimensionComponent'
        elif nodeName_ == 'DimensionGroup':
            obj_ = DimensionGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionGroup.append(obj_)
            obj_.original_tagname_ = 'DimensionGroup'
        elif nodeName_ == 'DimensionalDataSet':
            obj_ = DimensionalDataSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalDataSet.append(obj_)
            obj_.original_tagname_ = 'DimensionalDataSet'
        elif nodeName_ == 'DimensionalDataStructure':
            obj_ = DimensionalDataStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalDataStructure.append(obj_)
            obj_.original_tagname_ = 'DimensionalDataStructure'
        elif nodeName_ == 'DimensionalKey':
            obj_ = DimensionalKey.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalKey.append(obj_)
            obj_.original_tagname_ = 'DimensionalKey'
        elif nodeName_ == 'DimensionalKeyDefinition':
            obj_ = DimensionalKeyDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalKeyDefinition.append(obj_)
            obj_.original_tagname_ = 'DimensionalKeyDefinition'
        elif nodeName_ == 'DimensionalKeyDefinitionMember':
            obj_ = DimensionalKeyDefinitionMember.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalKeyDefinitionMember.append(obj_)
            obj_.original_tagname_ = 'DimensionalKeyDefinitionMember'
        elif nodeName_ == 'DimensionalKeyMember':
            obj_ = DimensionalKeyMember.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalKeyMember.append(obj_)
            obj_.original_tagname_ = 'DimensionalKeyMember'
        elif nodeName_ == 'EnumerationDomain':
            class_obj_ = self.get_class_obj_(child_, EnumerationDomain)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnumerationDomain.append(obj_)
            obj_.original_tagname_ = 'EnumerationDomain'
        elif nodeName_ == 'ForeignKey':
            obj_ = ForeignKey.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ForeignKey.append(obj_)
            obj_.original_tagname_ = 'ForeignKey'
        elif nodeName_ == 'ForeignKeyComponent':
            obj_ = ForeignKeyComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ForeignKeyComponent.append(obj_)
            obj_.original_tagname_ = 'ForeignKeyComponent'
        elif nodeName_ == 'IdentifierComponent':
            obj_ = IdentifierComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IdentifierComponent.append(obj_)
            obj_.original_tagname_ = 'IdentifierComponent'
        elif nodeName_ == 'Individual':
            obj_ = Individual.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Individual.append(obj_)
            obj_.original_tagname_ = 'Individual'
        elif nodeName_ == 'InformationFlowDefinition':
            obj_ = InformationFlowDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InformationFlowDefinition.append(obj_)
            obj_.original_tagname_ = 'InformationFlowDefinition'
        elif nodeName_ == 'InstanceKey':
            obj_ = InstanceKey.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceKey.append(obj_)
            obj_.original_tagname_ = 'InstanceKey'
        elif nodeName_ == 'InstanceValue':
            class_obj_ = self.get_class_obj_(child_, InstanceValue)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceValue.append(obj_)
            obj_.original_tagname_ = 'InstanceValue'
        elif nodeName_ == 'InstanceVariable':
            obj_ = InstanceVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceVariable.append(obj_)
            obj_.original_tagname_ = 'InstanceVariable'
        elif nodeName_ == 'InstanceVariableMap':
            obj_ = InstanceVariableMap.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceVariableMap.append(obj_)
            obj_.original_tagname_ = 'InstanceVariableMap'
        elif nodeName_ == 'Key':
            class_obj_ = self.get_class_obj_(child_, Key)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Key.append(obj_)
            obj_.original_tagname_ = 'Key'
        elif nodeName_ == 'KeyDefinition':
            class_obj_ = self.get_class_obj_(child_, KeyDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyDefinition.append(obj_)
            obj_.original_tagname_ = 'KeyDefinition'
        elif nodeName_ == 'KeyDefinitionMember':
            obj_ = KeyDefinitionMember.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyDefinitionMember.append(obj_)
            obj_.original_tagname_ = 'KeyDefinitionMember'
        elif nodeName_ == 'KeyMember':
            class_obj_ = self.get_class_obj_(child_, KeyMember)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyMember.append(obj_)
            obj_.original_tagname_ = 'KeyMember'
        elif nodeName_ == 'KeyValueDataStore':
            obj_ = KeyValueDataStore.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyValueDataStore.append(obj_)
            obj_.original_tagname_ = 'KeyValueDataStore'
        elif nodeName_ == 'KeyValueStructure':
            obj_ = KeyValueStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyValueStructure.append(obj_)
            obj_.original_tagname_ = 'KeyValueStructure'
        elif nodeName_ == 'Level':
            obj_ = Level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Level.append(obj_)
            obj_.original_tagname_ = 'Level'
        elif nodeName_ == 'LevelStructure':
            obj_ = LevelStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LevelStructure.append(obj_)
            obj_.original_tagname_ = 'LevelStructure'
        elif nodeName_ == 'LogicalRecord':
            obj_ = LogicalRecord.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecord.append(obj_)
            obj_.original_tagname_ = 'LogicalRecord'
        elif nodeName_ == 'LogicalRecordPosition':
            obj_ = LogicalRecordPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecordPosition.append(obj_)
            obj_.original_tagname_ = 'LogicalRecordPosition'
        elif nodeName_ == 'LogicalRecordRelationStructure':
            obj_ = LogicalRecordRelationStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecordRelationStructure.append(obj_)
            obj_.original_tagname_ = 'LogicalRecordRelationStructure'
        elif nodeName_ == 'LogicalRecordRelationship':
            obj_ = LogicalRecordRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecordRelationship.append(obj_)
            obj_.original_tagname_ = 'LogicalRecordRelationship'
        elif nodeName_ == 'LongDataSet':
            obj_ = LongDataSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LongDataSet.append(obj_)
            obj_.original_tagname_ = 'LongDataSet'
        elif nodeName_ == 'LongDataStructure':
            obj_ = LongDataStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LongDataStructure.append(obj_)
            obj_.original_tagname_ = 'LongDataStructure'
        elif nodeName_ == 'LongKey':
            obj_ = LongKey.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LongKey.append(obj_)
            obj_.original_tagname_ = 'LongKey'
        elif nodeName_ == 'LongMainKeyMember':
            obj_ = LongMainKeyMember.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LongMainKeyMember.append(obj_)
            obj_.original_tagname_ = 'LongMainKeyMember'
        elif nodeName_ == 'Machine':
            obj_ = Machine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Machine.append(obj_)
            obj_.original_tagname_ = 'Machine'
        elif nodeName_ == 'MainKeyMember':
            obj_ = MainKeyMember.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MainKeyMember.append(obj_)
            obj_.original_tagname_ = 'MainKeyMember'
        elif nodeName_ == 'MeasureComponent':
            class_obj_ = self.get_class_obj_(child_, MeasureComponent)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasureComponent.append(obj_)
            obj_.original_tagname_ = 'MeasureComponent'
        elif nodeName_ == 'NonDeterministicDeclarative':
            class_obj_ = self.get_class_obj_(child_, NonDeterministicDeclarative)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NonDeterministicDeclarative.append(obj_)
            obj_.original_tagname_ = 'NonDeterministicDeclarative'
        elif nodeName_ == 'Notation':
            obj_ = Notation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Notation.append(obj_)
            obj_.original_tagname_ = 'Notation'
        elif nodeName_ == 'Organization':
            obj_ = Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organization.append(obj_)
            obj_.original_tagname_ = 'Organization'
        elif nodeName_ == 'Parameter':
            obj_ = Parameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Parameter.append(obj_)
            obj_.original_tagname_ = 'Parameter'
        elif nodeName_ == 'PhysicalDataSet':
            obj_ = PhysicalDataSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalDataSet.append(obj_)
            obj_.original_tagname_ = 'PhysicalDataSet'
        elif nodeName_ == 'PhysicalDataSetStructure':
            obj_ = PhysicalDataSetStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalDataSetStructure.append(obj_)
            obj_.original_tagname_ = 'PhysicalDataSetStructure'
        elif nodeName_ == 'PhysicalLayoutRelationStructure':
            obj_ = PhysicalLayoutRelationStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalLayoutRelationStructure.append(obj_)
            obj_.original_tagname_ = 'PhysicalLayoutRelationStructure'
        elif nodeName_ == 'PhysicalRecordSegment':
            obj_ = PhysicalRecordSegment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegment.append(obj_)
            obj_.original_tagname_ = 'PhysicalRecordSegment'
        elif nodeName_ == 'PhysicalRecordSegmentPosition':
            obj_ = PhysicalRecordSegmentPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegmentPosition.append(obj_)
            obj_.original_tagname_ = 'PhysicalRecordSegmentPosition'
        elif nodeName_ == 'PhysicalRecordSegmentRelationship':
            obj_ = PhysicalRecordSegmentRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegmentRelationship.append(obj_)
            obj_.original_tagname_ = 'PhysicalRecordSegmentRelationship'
        elif nodeName_ == 'PhysicalRecordSegmentStructure':
            obj_ = PhysicalRecordSegmentStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegmentStructure.append(obj_)
            obj_.original_tagname_ = 'PhysicalRecordSegmentStructure'
        elif nodeName_ == 'PhysicalSegmentLayout':
            class_obj_ = self.get_class_obj_(child_, PhysicalSegmentLayout)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalSegmentLayout.append(obj_)
            obj_.original_tagname_ = 'PhysicalSegmentLayout'
        elif nodeName_ == 'PhysicalSegmentLocation':
            class_obj_ = self.get_class_obj_(child_, PhysicalSegmentLocation)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalSegmentLocation.append(obj_)
            obj_.original_tagname_ = 'PhysicalSegmentLocation'
        elif nodeName_ == 'Population':
            obj_ = Population.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Population.append(obj_)
            obj_.original_tagname_ = 'Population'
        elif nodeName_ == 'PrimaryKey':
            obj_ = PrimaryKey.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrimaryKey.append(obj_)
            obj_.original_tagname_ = 'PrimaryKey'
        elif nodeName_ == 'PrimaryKeyComponent':
            obj_ = PrimaryKeyComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrimaryKeyComponent.append(obj_)
            obj_.original_tagname_ = 'PrimaryKeyComponent'
        elif nodeName_ == 'ProcessingAgent':
            class_obj_ = self.get_class_obj_(child_, ProcessingAgent)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ProcessingAgent.append(obj_)
            obj_.original_tagname_ = 'ProcessingAgent'
        elif nodeName_ == 'ProductionEnvironment':
            obj_ = ProductionEnvironment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ProductionEnvironment.append(obj_)
            obj_.original_tagname_ = 'ProductionEnvironment'
        elif nodeName_ == 'QualifiedMeasure':
            obj_ = QualifiedMeasure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.QualifiedMeasure.append(obj_)
            obj_.original_tagname_ = 'QualifiedMeasure'
        elif nodeName_ == 'RecordRelation':
            obj_ = RecordRelation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RecordRelation.append(obj_)
            obj_.original_tagname_ = 'RecordRelation'
        elif nodeName_ == 'ReferenceValue':
            obj_ = ReferenceValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReferenceValue.append(obj_)
            obj_.original_tagname_ = 'ReferenceValue'
        elif nodeName_ == 'ReferenceValueDomain':
            obj_ = ReferenceValueDomain.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReferenceValueDomain.append(obj_)
            obj_.original_tagname_ = 'ReferenceValueDomain'
        elif nodeName_ == 'ReferenceVariable':
            obj_ = ReferenceVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReferenceVariable.append(obj_)
            obj_.original_tagname_ = 'ReferenceVariable'
        elif nodeName_ == 'RepresentedVariable':
            class_obj_ = self.get_class_obj_(child_, RepresentedVariable)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RepresentedVariable.append(obj_)
            obj_.original_tagname_ = 'RepresentedVariable'
        elif nodeName_ == 'RevisableDatum':
            obj_ = RevisableDatum.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RevisableDatum.append(obj_)
            obj_.original_tagname_ = 'RevisableDatum'
        elif nodeName_ == 'Revision':
            obj_ = Revision.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Revision.append(obj_)
            obj_.original_tagname_ = 'Revision'
        elif nodeName_ == 'Rule':
            obj_ = Rule.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Rule.append(obj_)
            obj_.original_tagname_ = 'Rule'
        elif nodeName_ == 'RuleBasedScheduling':
            obj_ = RuleBasedScheduling.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RuleBasedScheduling.append(obj_)
            obj_.original_tagname_ = 'RuleBasedScheduling'
        elif nodeName_ == 'RuleSet':
            obj_ = RuleSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RuleSet.append(obj_)
            obj_.original_tagname_ = 'RuleSet'
        elif nodeName_ == 'ScopedMeasure':
            obj_ = ScopedMeasure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ScopedMeasure.append(obj_)
            obj_.original_tagname_ = 'ScopedMeasure'
        elif nodeName_ == 'SegmentByText':
            obj_ = SegmentByText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SegmentByText.append(obj_)
            obj_.original_tagname_ = 'SegmentByText'
        elif nodeName_ == 'SentinelConceptualDomain':
            obj_ = SentinelConceptualDomain.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SentinelConceptualDomain.append(obj_)
            obj_.original_tagname_ = 'SentinelConceptualDomain'
        elif nodeName_ == 'SentinelValueDomain':
            obj_ = SentinelValueDomain.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SentinelValueDomain.append(obj_)
            obj_.original_tagname_ = 'SentinelValueDomain'
        elif nodeName_ == 'Sequence':
            obj_ = Sequence.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Sequence.append(obj_)
            obj_.original_tagname_ = 'Sequence'
        elif nodeName_ == 'SequencePosition':
            obj_ = SequencePosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SequencePosition.append(obj_)
            obj_.original_tagname_ = 'SequencePosition'
        elif nodeName_ == 'Service':
            obj_ = Service.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Service.append(obj_)
            obj_.original_tagname_ = 'Service'
        elif nodeName_ == 'StatisticalClassification':
            obj_ = StatisticalClassification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassification.append(obj_)
            obj_.original_tagname_ = 'StatisticalClassification'
        elif nodeName_ == 'StatisticalClassificationRelationship':
            obj_ = StatisticalClassificationRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassificationRelationship.append(obj_)
            obj_.original_tagname_ = 'StatisticalClassificationRelationship'
        elif nodeName_ == 'Step':
            obj_ = Step.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Step.append(obj_)
            obj_.original_tagname_ = 'Step'
        elif nodeName_ == 'SubstantiveConceptualDomain':
            obj_ = SubstantiveConceptualDomain.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SubstantiveConceptualDomain.append(obj_)
            obj_.original_tagname_ = 'SubstantiveConceptualDomain'
        elif nodeName_ == 'SubstantiveValueDomain':
            class_obj_ = self.get_class_obj_(child_, SubstantiveValueDomain)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SubstantiveValueDomain.append(obj_)
            obj_.original_tagname_ = 'SubstantiveValueDomain'
        elif nodeName_ == 'SyntheticIdComponent':
            obj_ = SyntheticIdComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SyntheticIdComponent.append(obj_)
            obj_.original_tagname_ = 'SyntheticIdComponent'
        elif nodeName_ == 'TemporalConstraints':
            class_obj_ = self.get_class_obj_(child_, TemporalConstraints)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TemporalConstraints.append(obj_)
            obj_.original_tagname_ = 'TemporalConstraints'
        elif nodeName_ == 'TemporalControlConstruct':
            obj_ = TemporalControlConstruct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TemporalControlConstruct.append(obj_)
            obj_.original_tagname_ = 'TemporalControlConstruct'
        elif nodeName_ == 'Unit':
            obj_ = Unit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Unit.append(obj_)
            obj_.original_tagname_ = 'Unit'
        elif nodeName_ == 'UnitSegmentLayout':
            obj_ = UnitSegmentLayout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UnitSegmentLayout.append(obj_)
            obj_.original_tagname_ = 'UnitSegmentLayout'
        elif nodeName_ == 'UnitType':
            class_obj_ = self.get_class_obj_(child_, UnitType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UnitType.append(obj_)
            obj_.original_tagname_ = 'UnitType'
        elif nodeName_ == 'Universe':
            class_obj_ = self.get_class_obj_(child_, Universe)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Universe.append(obj_)
            obj_.original_tagname_ = 'Universe'
        elif nodeName_ == 'ValueAndConceptDescription':
            obj_ = ValueAndConceptDescription.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueAndConceptDescription.append(obj_)
            obj_.original_tagname_ = 'ValueAndConceptDescription'
        elif nodeName_ == 'ValueDomain':
            class_obj_ = self.get_class_obj_(child_, ValueDomain)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueDomain.append(obj_)
            obj_.original_tagname_ = 'ValueDomain'
        elif nodeName_ == 'ValueMapping':
            obj_ = ValueMapping.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueMapping.append(obj_)
            obj_.original_tagname_ = 'ValueMapping'
        elif nodeName_ == 'ValueMappingPosition':
            obj_ = ValueMappingPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueMappingPosition.append(obj_)
            obj_.original_tagname_ = 'ValueMappingPosition'
        elif nodeName_ == 'ValueMappingRelationship':
            obj_ = ValueMappingRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueMappingRelationship.append(obj_)
            obj_.original_tagname_ = 'ValueMappingRelationship'
        elif nodeName_ == 'VariableCollection':
            obj_ = VariableCollection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableCollection.append(obj_)
            obj_.original_tagname_ = 'VariableCollection'
        elif nodeName_ == 'VariableDescriptorComponent':
            obj_ = VariableDescriptorComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableDescriptorComponent.append(obj_)
            obj_.original_tagname_ = 'VariableDescriptorComponent'
        elif nodeName_ == 'VariablePosition':
            obj_ = VariablePosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariablePosition.append(obj_)
            obj_.original_tagname_ = 'VariablePosition'
        elif nodeName_ == 'VariableRelationship':
            obj_ = VariableRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableRelationship.append(obj_)
            obj_.original_tagname_ = 'VariableRelationship'
        elif nodeName_ == 'VariableStructure':
            obj_ = VariableStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableStructure.append(obj_)
            obj_.original_tagname_ = 'VariableStructure'
        elif nodeName_ == 'VariableValueComponent':
            obj_ = VariableValueComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableValueComponent.append(obj_)
            obj_.original_tagname_ = 'VariableValueComponent'
        elif nodeName_ == 'WideDataSet':
            obj_ = WideDataSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WideDataSet.append(obj_)
            obj_.original_tagname_ = 'WideDataSet'
        elif nodeName_ == 'WideDataStructure':
            obj_ = WideDataStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WideDataStructure.append(obj_)
            obj_.original_tagname_ = 'WideDataStructure'
        elif nodeName_ == 'WideKey':
            obj_ = WideKey.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WideKey.append(obj_)
            obj_.original_tagname_ = 'WideKey'
        elif nodeName_ == 'WideKeyMember':
            obj_ = WideKeyMember.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WideKeyMember.append(obj_)
            obj_.original_tagname_ = 'WideKeyMember'
        elif nodeName_ == 'Wrapper':
            obj_ = Wrapper.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Wrapper.append(obj_)
            obj_.original_tagname_ = 'Wrapper'
# end class DDICDIModels


class Wrapper(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    supportingInformation -- Information structured according to a non-DDI-CDI specification which is relevant to the understanding and/or processing of the content of Wrapper.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, supportingInformation=None, Activity=None, Agent=None, AgentListing=None, AgentPosition=None, AgentRelationship=None, AgentStructure=None, AllenIntervalAlgebra=None, AttributeComponent=None, AuthorizationSource=None, Category=None, CategoryPosition=None, CategoryRelationStructure=None, CategoryRelationship=None, CategorySet=None, CategoryStatistic=None, ClassificationFamily=None, ClassificationIndex=None, ClassificationIndexEntry=None, ClassificationIndexEntryPosition=None, ClassificationItem=None, ClassificationItemPosition=None, ClassificationItemRelationship=None, ClassificationItemStructure=None, ClassificationPosition=None, ClassificationSeries=None, ClassificationSeriesStructure=None, Code=None, CodeList=None, CodeListStructure=None, CodePosition=None, CodeRelationship=None, ComponentPosition=None, Concept=None, ConceptMap=None, ConceptRelationship=None, ConceptStructure=None, ConceptSystem=None, ConceptSystemCorrespondence=None, ConceptualDomain=None, ConceptualValue=None, ConceptualVariable=None, ConditionalControlLogic=None, ContextualComponent=None, ControlLogic=None, CorrespondenceTable=None, Curator=None, DataPoint=None, DataPointPosition=None, DataPointRelationship=None, DataSet=None, DataStore=None, DataStructure=None, DataStructureComponent=None, Datum=None, Descriptor=None, DescriptorValueDomain=None, DescriptorVariable=None, DeterministicImperative=None, DimensionComponent=None, DimensionGroup=None, DimensionalDataSet=None, DimensionalDataStructure=None, DimensionalKey=None, DimensionalKeyDefinition=None, DimensionalKeyDefinitionMember=None, DimensionalKeyMember=None, EnumerationDomain=None, ForeignKey=None, ForeignKeyComponent=None, IdentifierComponent=None, Individual=None, InformationFlowDefinition=None, InstanceKey=None, InstanceValue=None, InstanceVariable=None, InstanceVariableMap=None, Key=None, KeyDefinition=None, KeyDefinitionMember=None, KeyMember=None, KeyValueDataStore=None, KeyValueStructure=None, Level=None, LevelStructure=None, LogicalRecord=None, LogicalRecordPosition=None, LogicalRecordRelationStructure=None, LogicalRecordRelationship=None, LongDataSet=None, LongDataStructure=None, LongKey=None, LongMainKeyMember=None, Machine=None, MainKeyMember=None, MeasureComponent=None, NonDeterministicDeclarative=None, Notation=None, Organization=None, Parameter=None, PhysicalDataSet=None, PhysicalDataSetStructure=None, PhysicalLayoutRelationStructure=None, PhysicalRecordSegment=None, PhysicalRecordSegmentPosition=None, PhysicalRecordSegmentRelationship=None, PhysicalRecordSegmentStructure=None, PhysicalSegmentLayout=None, PhysicalSegmentLocation=None, Population=None, PrimaryKey=None, PrimaryKeyComponent=None, ProcessingAgent=None, ProductionEnvironment=None, QualifiedMeasure=None, RecordRelation=None, ReferenceValue=None, ReferenceValueDomain=None, ReferenceVariable=None, RepresentedVariable=None, RevisableDatum=None, Revision=None, Rule=None, RuleBasedScheduling=None, RuleSet=None, ScopedMeasure=None, SegmentByText=None, SentinelConceptualDomain=None, SentinelValueDomain=None, Sequence=None, SequencePosition=None, Service=None, StatisticalClassification=None, StatisticalClassificationRelationship=None, Step=None, SubstantiveConceptualDomain=None, SubstantiveValueDomain=None, SyntheticIdComponent=None, TemporalConstraints=None, TemporalControlConstruct=None, Unit=None, UnitSegmentLayout=None, UnitType=None, Universe=None, ValueAndConceptDescription=None, ValueDomain=None, ValueMapping=None, ValueMappingPosition=None, ValueMappingRelationship=None, VariableCollection=None, VariableDescriptorComponent=None, VariablePosition=None, VariableRelationship=None, VariableStructure=None, VariableValueComponent=None, WideDataSet=None, WideDataStructure=None, WideKey=None, WideKeyMember=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if supportingInformation is None:
            self.supportingInformation = []
        else:
            self.supportingInformation = supportingInformation
        self.supportingInformation_nsprefix_ = None
        if Activity is None:
            self.Activity = []
        else:
            self.Activity = Activity
        self.Activity_nsprefix_ = None
        if Agent is None:
            self.Agent = []
        else:
            self.Agent = Agent
        self.Agent_nsprefix_ = None
        if AgentListing is None:
            self.AgentListing = []
        else:
            self.AgentListing = AgentListing
        self.AgentListing_nsprefix_ = None
        if AgentPosition is None:
            self.AgentPosition = []
        else:
            self.AgentPosition = AgentPosition
        self.AgentPosition_nsprefix_ = None
        if AgentRelationship is None:
            self.AgentRelationship = []
        else:
            self.AgentRelationship = AgentRelationship
        self.AgentRelationship_nsprefix_ = None
        if AgentStructure is None:
            self.AgentStructure = []
        else:
            self.AgentStructure = AgentStructure
        self.AgentStructure_nsprefix_ = None
        if AllenIntervalAlgebra is None:
            self.AllenIntervalAlgebra = []
        else:
            self.AllenIntervalAlgebra = AllenIntervalAlgebra
        self.AllenIntervalAlgebra_nsprefix_ = None
        if AttributeComponent is None:
            self.AttributeComponent = []
        else:
            self.AttributeComponent = AttributeComponent
        self.AttributeComponent_nsprefix_ = None
        if AuthorizationSource is None:
            self.AuthorizationSource = []
        else:
            self.AuthorizationSource = AuthorizationSource
        self.AuthorizationSource_nsprefix_ = None
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
        self.Category_nsprefix_ = None
        if CategoryPosition is None:
            self.CategoryPosition = []
        else:
            self.CategoryPosition = CategoryPosition
        self.CategoryPosition_nsprefix_ = None
        if CategoryRelationStructure is None:
            self.CategoryRelationStructure = []
        else:
            self.CategoryRelationStructure = CategoryRelationStructure
        self.CategoryRelationStructure_nsprefix_ = None
        if CategoryRelationship is None:
            self.CategoryRelationship = []
        else:
            self.CategoryRelationship = CategoryRelationship
        self.CategoryRelationship_nsprefix_ = None
        if CategorySet is None:
            self.CategorySet = []
        else:
            self.CategorySet = CategorySet
        self.CategorySet_nsprefix_ = None
        if CategoryStatistic is None:
            self.CategoryStatistic = []
        else:
            self.CategoryStatistic = CategoryStatistic
        self.CategoryStatistic_nsprefix_ = None
        if ClassificationFamily is None:
            self.ClassificationFamily = []
        else:
            self.ClassificationFamily = ClassificationFamily
        self.ClassificationFamily_nsprefix_ = None
        if ClassificationIndex is None:
            self.ClassificationIndex = []
        else:
            self.ClassificationIndex = ClassificationIndex
        self.ClassificationIndex_nsprefix_ = None
        if ClassificationIndexEntry is None:
            self.ClassificationIndexEntry = []
        else:
            self.ClassificationIndexEntry = ClassificationIndexEntry
        self.ClassificationIndexEntry_nsprefix_ = None
        if ClassificationIndexEntryPosition is None:
            self.ClassificationIndexEntryPosition = []
        else:
            self.ClassificationIndexEntryPosition = ClassificationIndexEntryPosition
        self.ClassificationIndexEntryPosition_nsprefix_ = None
        if ClassificationItem is None:
            self.ClassificationItem = []
        else:
            self.ClassificationItem = ClassificationItem
        self.ClassificationItem_nsprefix_ = None
        if ClassificationItemPosition is None:
            self.ClassificationItemPosition = []
        else:
            self.ClassificationItemPosition = ClassificationItemPosition
        self.ClassificationItemPosition_nsprefix_ = None
        if ClassificationItemRelationship is None:
            self.ClassificationItemRelationship = []
        else:
            self.ClassificationItemRelationship = ClassificationItemRelationship
        self.ClassificationItemRelationship_nsprefix_ = None
        if ClassificationItemStructure is None:
            self.ClassificationItemStructure = []
        else:
            self.ClassificationItemStructure = ClassificationItemStructure
        self.ClassificationItemStructure_nsprefix_ = None
        if ClassificationPosition is None:
            self.ClassificationPosition = []
        else:
            self.ClassificationPosition = ClassificationPosition
        self.ClassificationPosition_nsprefix_ = None
        if ClassificationSeries is None:
            self.ClassificationSeries = []
        else:
            self.ClassificationSeries = ClassificationSeries
        self.ClassificationSeries_nsprefix_ = None
        if ClassificationSeriesStructure is None:
            self.ClassificationSeriesStructure = []
        else:
            self.ClassificationSeriesStructure = ClassificationSeriesStructure
        self.ClassificationSeriesStructure_nsprefix_ = None
        if Code is None:
            self.Code = []
        else:
            self.Code = Code
        self.Code_nsprefix_ = None
        if CodeList is None:
            self.CodeList = []
        else:
            self.CodeList = CodeList
        self.CodeList_nsprefix_ = None
        if CodeListStructure is None:
            self.CodeListStructure = []
        else:
            self.CodeListStructure = CodeListStructure
        self.CodeListStructure_nsprefix_ = None
        if CodePosition is None:
            self.CodePosition = []
        else:
            self.CodePosition = CodePosition
        self.CodePosition_nsprefix_ = None
        if CodeRelationship is None:
            self.CodeRelationship = []
        else:
            self.CodeRelationship = CodeRelationship
        self.CodeRelationship_nsprefix_ = None
        if ComponentPosition is None:
            self.ComponentPosition = []
        else:
            self.ComponentPosition = ComponentPosition
        self.ComponentPosition_nsprefix_ = None
        if Concept is None:
            self.Concept = []
        else:
            self.Concept = Concept
        self.Concept_nsprefix_ = None
        if ConceptMap is None:
            self.ConceptMap = []
        else:
            self.ConceptMap = ConceptMap
        self.ConceptMap_nsprefix_ = None
        if ConceptRelationship is None:
            self.ConceptRelationship = []
        else:
            self.ConceptRelationship = ConceptRelationship
        self.ConceptRelationship_nsprefix_ = None
        if ConceptStructure is None:
            self.ConceptStructure = []
        else:
            self.ConceptStructure = ConceptStructure
        self.ConceptStructure_nsprefix_ = None
        if ConceptSystem is None:
            self.ConceptSystem = []
        else:
            self.ConceptSystem = ConceptSystem
        self.ConceptSystem_nsprefix_ = None
        if ConceptSystemCorrespondence is None:
            self.ConceptSystemCorrespondence = []
        else:
            self.ConceptSystemCorrespondence = ConceptSystemCorrespondence
        self.ConceptSystemCorrespondence_nsprefix_ = None
        if ConceptualDomain is None:
            self.ConceptualDomain = []
        else:
            self.ConceptualDomain = ConceptualDomain
        self.ConceptualDomain_nsprefix_ = None
        if ConceptualValue is None:
            self.ConceptualValue = []
        else:
            self.ConceptualValue = ConceptualValue
        self.ConceptualValue_nsprefix_ = None
        if ConceptualVariable is None:
            self.ConceptualVariable = []
        else:
            self.ConceptualVariable = ConceptualVariable
        self.ConceptualVariable_nsprefix_ = None
        if ConditionalControlLogic is None:
            self.ConditionalControlLogic = []
        else:
            self.ConditionalControlLogic = ConditionalControlLogic
        self.ConditionalControlLogic_nsprefix_ = None
        if ContextualComponent is None:
            self.ContextualComponent = []
        else:
            self.ContextualComponent = ContextualComponent
        self.ContextualComponent_nsprefix_ = None
        if ControlLogic is None:
            self.ControlLogic = []
        else:
            self.ControlLogic = ControlLogic
        self.ControlLogic_nsprefix_ = None
        if CorrespondenceTable is None:
            self.CorrespondenceTable = []
        else:
            self.CorrespondenceTable = CorrespondenceTable
        self.CorrespondenceTable_nsprefix_ = None
        if Curator is None:
            self.Curator = []
        else:
            self.Curator = Curator
        self.Curator_nsprefix_ = None
        if DataPoint is None:
            self.DataPoint = []
        else:
            self.DataPoint = DataPoint
        self.DataPoint_nsprefix_ = None
        if DataPointPosition is None:
            self.DataPointPosition = []
        else:
            self.DataPointPosition = DataPointPosition
        self.DataPointPosition_nsprefix_ = None
        if DataPointRelationship is None:
            self.DataPointRelationship = []
        else:
            self.DataPointRelationship = DataPointRelationship
        self.DataPointRelationship_nsprefix_ = None
        if DataSet is None:
            self.DataSet = []
        else:
            self.DataSet = DataSet
        self.DataSet_nsprefix_ = None
        if DataStore is None:
            self.DataStore = []
        else:
            self.DataStore = DataStore
        self.DataStore_nsprefix_ = None
        if DataStructure is None:
            self.DataStructure = []
        else:
            self.DataStructure = DataStructure
        self.DataStructure_nsprefix_ = None
        if DataStructureComponent is None:
            self.DataStructureComponent = []
        else:
            self.DataStructureComponent = DataStructureComponent
        self.DataStructureComponent_nsprefix_ = None
        if Datum is None:
            self.Datum = []
        else:
            self.Datum = Datum
        self.Datum_nsprefix_ = None
        if Descriptor is None:
            self.Descriptor = []
        else:
            self.Descriptor = Descriptor
        self.Descriptor_nsprefix_ = None
        if DescriptorValueDomain is None:
            self.DescriptorValueDomain = []
        else:
            self.DescriptorValueDomain = DescriptorValueDomain
        self.DescriptorValueDomain_nsprefix_ = None
        if DescriptorVariable is None:
            self.DescriptorVariable = []
        else:
            self.DescriptorVariable = DescriptorVariable
        self.DescriptorVariable_nsprefix_ = None
        if DeterministicImperative is None:
            self.DeterministicImperative = []
        else:
            self.DeterministicImperative = DeterministicImperative
        self.DeterministicImperative_nsprefix_ = None
        if DimensionComponent is None:
            self.DimensionComponent = []
        else:
            self.DimensionComponent = DimensionComponent
        self.DimensionComponent_nsprefix_ = None
        if DimensionGroup is None:
            self.DimensionGroup = []
        else:
            self.DimensionGroup = DimensionGroup
        self.DimensionGroup_nsprefix_ = None
        if DimensionalDataSet is None:
            self.DimensionalDataSet = []
        else:
            self.DimensionalDataSet = DimensionalDataSet
        self.DimensionalDataSet_nsprefix_ = None
        if DimensionalDataStructure is None:
            self.DimensionalDataStructure = []
        else:
            self.DimensionalDataStructure = DimensionalDataStructure
        self.DimensionalDataStructure_nsprefix_ = None
        if DimensionalKey is None:
            self.DimensionalKey = []
        else:
            self.DimensionalKey = DimensionalKey
        self.DimensionalKey_nsprefix_ = None
        if DimensionalKeyDefinition is None:
            self.DimensionalKeyDefinition = []
        else:
            self.DimensionalKeyDefinition = DimensionalKeyDefinition
        self.DimensionalKeyDefinition_nsprefix_ = None
        if DimensionalKeyDefinitionMember is None:
            self.DimensionalKeyDefinitionMember = []
        else:
            self.DimensionalKeyDefinitionMember = DimensionalKeyDefinitionMember
        self.DimensionalKeyDefinitionMember_nsprefix_ = None
        if DimensionalKeyMember is None:
            self.DimensionalKeyMember = []
        else:
            self.DimensionalKeyMember = DimensionalKeyMember
        self.DimensionalKeyMember_nsprefix_ = None
        if EnumerationDomain is None:
            self.EnumerationDomain = []
        else:
            self.EnumerationDomain = EnumerationDomain
        self.EnumerationDomain_nsprefix_ = None
        if ForeignKey is None:
            self.ForeignKey = []
        else:
            self.ForeignKey = ForeignKey
        self.ForeignKey_nsprefix_ = None
        if ForeignKeyComponent is None:
            self.ForeignKeyComponent = []
        else:
            self.ForeignKeyComponent = ForeignKeyComponent
        self.ForeignKeyComponent_nsprefix_ = None
        if IdentifierComponent is None:
            self.IdentifierComponent = []
        else:
            self.IdentifierComponent = IdentifierComponent
        self.IdentifierComponent_nsprefix_ = None
        if Individual is None:
            self.Individual = []
        else:
            self.Individual = Individual
        self.Individual_nsprefix_ = None
        if InformationFlowDefinition is None:
            self.InformationFlowDefinition = []
        else:
            self.InformationFlowDefinition = InformationFlowDefinition
        self.InformationFlowDefinition_nsprefix_ = None
        if InstanceKey is None:
            self.InstanceKey = []
        else:
            self.InstanceKey = InstanceKey
        self.InstanceKey_nsprefix_ = None
        if InstanceValue is None:
            self.InstanceValue = []
        else:
            self.InstanceValue = InstanceValue
        self.InstanceValue_nsprefix_ = None
        if InstanceVariable is None:
            self.InstanceVariable = []
        else:
            self.InstanceVariable = InstanceVariable
        self.InstanceVariable_nsprefix_ = None
        if InstanceVariableMap is None:
            self.InstanceVariableMap = []
        else:
            self.InstanceVariableMap = InstanceVariableMap
        self.InstanceVariableMap_nsprefix_ = None
        if Key is None:
            self.Key = []
        else:
            self.Key = Key
        self.Key_nsprefix_ = None
        if KeyDefinition is None:
            self.KeyDefinition = []
        else:
            self.KeyDefinition = KeyDefinition
        self.KeyDefinition_nsprefix_ = None
        if KeyDefinitionMember is None:
            self.KeyDefinitionMember = []
        else:
            self.KeyDefinitionMember = KeyDefinitionMember
        self.KeyDefinitionMember_nsprefix_ = None
        if KeyMember is None:
            self.KeyMember = []
        else:
            self.KeyMember = KeyMember
        self.KeyMember_nsprefix_ = None
        if KeyValueDataStore is None:
            self.KeyValueDataStore = []
        else:
            self.KeyValueDataStore = KeyValueDataStore
        self.KeyValueDataStore_nsprefix_ = None
        if KeyValueStructure is None:
            self.KeyValueStructure = []
        else:
            self.KeyValueStructure = KeyValueStructure
        self.KeyValueStructure_nsprefix_ = None
        if Level is None:
            self.Level = []
        else:
            self.Level = Level
        self.Level_nsprefix_ = None
        if LevelStructure is None:
            self.LevelStructure = []
        else:
            self.LevelStructure = LevelStructure
        self.LevelStructure_nsprefix_ = None
        if LogicalRecord is None:
            self.LogicalRecord = []
        else:
            self.LogicalRecord = LogicalRecord
        self.LogicalRecord_nsprefix_ = None
        if LogicalRecordPosition is None:
            self.LogicalRecordPosition = []
        else:
            self.LogicalRecordPosition = LogicalRecordPosition
        self.LogicalRecordPosition_nsprefix_ = None
        if LogicalRecordRelationStructure is None:
            self.LogicalRecordRelationStructure = []
        else:
            self.LogicalRecordRelationStructure = LogicalRecordRelationStructure
        self.LogicalRecordRelationStructure_nsprefix_ = None
        if LogicalRecordRelationship is None:
            self.LogicalRecordRelationship = []
        else:
            self.LogicalRecordRelationship = LogicalRecordRelationship
        self.LogicalRecordRelationship_nsprefix_ = None
        if LongDataSet is None:
            self.LongDataSet = []
        else:
            self.LongDataSet = LongDataSet
        self.LongDataSet_nsprefix_ = None
        if LongDataStructure is None:
            self.LongDataStructure = []
        else:
            self.LongDataStructure = LongDataStructure
        self.LongDataStructure_nsprefix_ = None
        if LongKey is None:
            self.LongKey = []
        else:
            self.LongKey = LongKey
        self.LongKey_nsprefix_ = None
        if LongMainKeyMember is None:
            self.LongMainKeyMember = []
        else:
            self.LongMainKeyMember = LongMainKeyMember
        self.LongMainKeyMember_nsprefix_ = None
        if Machine is None:
            self.Machine = []
        else:
            self.Machine = Machine
        self.Machine_nsprefix_ = None
        if MainKeyMember is None:
            self.MainKeyMember = []
        else:
            self.MainKeyMember = MainKeyMember
        self.MainKeyMember_nsprefix_ = None
        if MeasureComponent is None:
            self.MeasureComponent = []
        else:
            self.MeasureComponent = MeasureComponent
        self.MeasureComponent_nsprefix_ = None
        if NonDeterministicDeclarative is None:
            self.NonDeterministicDeclarative = []
        else:
            self.NonDeterministicDeclarative = NonDeterministicDeclarative
        self.NonDeterministicDeclarative_nsprefix_ = None
        if Notation is None:
            self.Notation = []
        else:
            self.Notation = Notation
        self.Notation_nsprefix_ = None
        if Organization is None:
            self.Organization = []
        else:
            self.Organization = Organization
        self.Organization_nsprefix_ = None
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        self.Parameter_nsprefix_ = None
        if PhysicalDataSet is None:
            self.PhysicalDataSet = []
        else:
            self.PhysicalDataSet = PhysicalDataSet
        self.PhysicalDataSet_nsprefix_ = None
        if PhysicalDataSetStructure is None:
            self.PhysicalDataSetStructure = []
        else:
            self.PhysicalDataSetStructure = PhysicalDataSetStructure
        self.PhysicalDataSetStructure_nsprefix_ = None
        if PhysicalLayoutRelationStructure is None:
            self.PhysicalLayoutRelationStructure = []
        else:
            self.PhysicalLayoutRelationStructure = PhysicalLayoutRelationStructure
        self.PhysicalLayoutRelationStructure_nsprefix_ = None
        if PhysicalRecordSegment is None:
            self.PhysicalRecordSegment = []
        else:
            self.PhysicalRecordSegment = PhysicalRecordSegment
        self.PhysicalRecordSegment_nsprefix_ = None
        if PhysicalRecordSegmentPosition is None:
            self.PhysicalRecordSegmentPosition = []
        else:
            self.PhysicalRecordSegmentPosition = PhysicalRecordSegmentPosition
        self.PhysicalRecordSegmentPosition_nsprefix_ = None
        if PhysicalRecordSegmentRelationship is None:
            self.PhysicalRecordSegmentRelationship = []
        else:
            self.PhysicalRecordSegmentRelationship = PhysicalRecordSegmentRelationship
        self.PhysicalRecordSegmentRelationship_nsprefix_ = None
        if PhysicalRecordSegmentStructure is None:
            self.PhysicalRecordSegmentStructure = []
        else:
            self.PhysicalRecordSegmentStructure = PhysicalRecordSegmentStructure
        self.PhysicalRecordSegmentStructure_nsprefix_ = None
        if PhysicalSegmentLayout is None:
            self.PhysicalSegmentLayout = []
        else:
            self.PhysicalSegmentLayout = PhysicalSegmentLayout
        self.PhysicalSegmentLayout_nsprefix_ = None
        if PhysicalSegmentLocation is None:
            self.PhysicalSegmentLocation = []
        else:
            self.PhysicalSegmentLocation = PhysicalSegmentLocation
        self.PhysicalSegmentLocation_nsprefix_ = None
        if Population is None:
            self.Population = []
        else:
            self.Population = Population
        self.Population_nsprefix_ = None
        if PrimaryKey is None:
            self.PrimaryKey = []
        else:
            self.PrimaryKey = PrimaryKey
        self.PrimaryKey_nsprefix_ = None
        if PrimaryKeyComponent is None:
            self.PrimaryKeyComponent = []
        else:
            self.PrimaryKeyComponent = PrimaryKeyComponent
        self.PrimaryKeyComponent_nsprefix_ = None
        if ProcessingAgent is None:
            self.ProcessingAgent = []
        else:
            self.ProcessingAgent = ProcessingAgent
        self.ProcessingAgent_nsprefix_ = None
        if ProductionEnvironment is None:
            self.ProductionEnvironment = []
        else:
            self.ProductionEnvironment = ProductionEnvironment
        self.ProductionEnvironment_nsprefix_ = None
        if QualifiedMeasure is None:
            self.QualifiedMeasure = []
        else:
            self.QualifiedMeasure = QualifiedMeasure
        self.QualifiedMeasure_nsprefix_ = None
        if RecordRelation is None:
            self.RecordRelation = []
        else:
            self.RecordRelation = RecordRelation
        self.RecordRelation_nsprefix_ = None
        if ReferenceValue is None:
            self.ReferenceValue = []
        else:
            self.ReferenceValue = ReferenceValue
        self.ReferenceValue_nsprefix_ = None
        if ReferenceValueDomain is None:
            self.ReferenceValueDomain = []
        else:
            self.ReferenceValueDomain = ReferenceValueDomain
        self.ReferenceValueDomain_nsprefix_ = None
        if ReferenceVariable is None:
            self.ReferenceVariable = []
        else:
            self.ReferenceVariable = ReferenceVariable
        self.ReferenceVariable_nsprefix_ = None
        if RepresentedVariable is None:
            self.RepresentedVariable = []
        else:
            self.RepresentedVariable = RepresentedVariable
        self.RepresentedVariable_nsprefix_ = None
        if RevisableDatum is None:
            self.RevisableDatum = []
        else:
            self.RevisableDatum = RevisableDatum
        self.RevisableDatum_nsprefix_ = None
        if Revision is None:
            self.Revision = []
        else:
            self.Revision = Revision
        self.Revision_nsprefix_ = None
        if Rule is None:
            self.Rule = []
        else:
            self.Rule = Rule
        self.Rule_nsprefix_ = None
        if RuleBasedScheduling is None:
            self.RuleBasedScheduling = []
        else:
            self.RuleBasedScheduling = RuleBasedScheduling
        self.RuleBasedScheduling_nsprefix_ = None
        if RuleSet is None:
            self.RuleSet = []
        else:
            self.RuleSet = RuleSet
        self.RuleSet_nsprefix_ = None
        if ScopedMeasure is None:
            self.ScopedMeasure = []
        else:
            self.ScopedMeasure = ScopedMeasure
        self.ScopedMeasure_nsprefix_ = None
        if SegmentByText is None:
            self.SegmentByText = []
        else:
            self.SegmentByText = SegmentByText
        self.SegmentByText_nsprefix_ = None
        if SentinelConceptualDomain is None:
            self.SentinelConceptualDomain = []
        else:
            self.SentinelConceptualDomain = SentinelConceptualDomain
        self.SentinelConceptualDomain_nsprefix_ = None
        if SentinelValueDomain is None:
            self.SentinelValueDomain = []
        else:
            self.SentinelValueDomain = SentinelValueDomain
        self.SentinelValueDomain_nsprefix_ = None
        if Sequence is None:
            self.Sequence = []
        else:
            self.Sequence = Sequence
        self.Sequence_nsprefix_ = None
        if SequencePosition is None:
            self.SequencePosition = []
        else:
            self.SequencePosition = SequencePosition
        self.SequencePosition_nsprefix_ = None
        if Service is None:
            self.Service = []
        else:
            self.Service = Service
        self.Service_nsprefix_ = None
        if StatisticalClassification is None:
            self.StatisticalClassification = []
        else:
            self.StatisticalClassification = StatisticalClassification
        self.StatisticalClassification_nsprefix_ = None
        if StatisticalClassificationRelationship is None:
            self.StatisticalClassificationRelationship = []
        else:
            self.StatisticalClassificationRelationship = StatisticalClassificationRelationship
        self.StatisticalClassificationRelationship_nsprefix_ = None
        if Step is None:
            self.Step = []
        else:
            self.Step = Step
        self.Step_nsprefix_ = None
        if SubstantiveConceptualDomain is None:
            self.SubstantiveConceptualDomain = []
        else:
            self.SubstantiveConceptualDomain = SubstantiveConceptualDomain
        self.SubstantiveConceptualDomain_nsprefix_ = None
        if SubstantiveValueDomain is None:
            self.SubstantiveValueDomain = []
        else:
            self.SubstantiveValueDomain = SubstantiveValueDomain
        self.SubstantiveValueDomain_nsprefix_ = None
        if SyntheticIdComponent is None:
            self.SyntheticIdComponent = []
        else:
            self.SyntheticIdComponent = SyntheticIdComponent
        self.SyntheticIdComponent_nsprefix_ = None
        if TemporalConstraints is None:
            self.TemporalConstraints = []
        else:
            self.TemporalConstraints = TemporalConstraints
        self.TemporalConstraints_nsprefix_ = None
        if TemporalControlConstruct is None:
            self.TemporalControlConstruct = []
        else:
            self.TemporalControlConstruct = TemporalControlConstruct
        self.TemporalControlConstruct_nsprefix_ = None
        if Unit is None:
            self.Unit = []
        else:
            self.Unit = Unit
        self.Unit_nsprefix_ = None
        if UnitSegmentLayout is None:
            self.UnitSegmentLayout = []
        else:
            self.UnitSegmentLayout = UnitSegmentLayout
        self.UnitSegmentLayout_nsprefix_ = None
        if UnitType is None:
            self.UnitType = []
        else:
            self.UnitType = UnitType
        self.UnitType_nsprefix_ = None
        if Universe is None:
            self.Universe = []
        else:
            self.Universe = Universe
        self.Universe_nsprefix_ = None
        if ValueAndConceptDescription is None:
            self.ValueAndConceptDescription = []
        else:
            self.ValueAndConceptDescription = ValueAndConceptDescription
        self.ValueAndConceptDescription_nsprefix_ = None
        if ValueDomain is None:
            self.ValueDomain = []
        else:
            self.ValueDomain = ValueDomain
        self.ValueDomain_nsprefix_ = None
        if ValueMapping is None:
            self.ValueMapping = []
        else:
            self.ValueMapping = ValueMapping
        self.ValueMapping_nsprefix_ = None
        if ValueMappingPosition is None:
            self.ValueMappingPosition = []
        else:
            self.ValueMappingPosition = ValueMappingPosition
        self.ValueMappingPosition_nsprefix_ = None
        if ValueMappingRelationship is None:
            self.ValueMappingRelationship = []
        else:
            self.ValueMappingRelationship = ValueMappingRelationship
        self.ValueMappingRelationship_nsprefix_ = None
        if VariableCollection is None:
            self.VariableCollection = []
        else:
            self.VariableCollection = VariableCollection
        self.VariableCollection_nsprefix_ = None
        if VariableDescriptorComponent is None:
            self.VariableDescriptorComponent = []
        else:
            self.VariableDescriptorComponent = VariableDescriptorComponent
        self.VariableDescriptorComponent_nsprefix_ = None
        if VariablePosition is None:
            self.VariablePosition = []
        else:
            self.VariablePosition = VariablePosition
        self.VariablePosition_nsprefix_ = None
        if VariableRelationship is None:
            self.VariableRelationship = []
        else:
            self.VariableRelationship = VariableRelationship
        self.VariableRelationship_nsprefix_ = None
        if VariableStructure is None:
            self.VariableStructure = []
        else:
            self.VariableStructure = VariableStructure
        self.VariableStructure_nsprefix_ = None
        if VariableValueComponent is None:
            self.VariableValueComponent = []
        else:
            self.VariableValueComponent = VariableValueComponent
        self.VariableValueComponent_nsprefix_ = None
        if WideDataSet is None:
            self.WideDataSet = []
        else:
            self.WideDataSet = WideDataSet
        self.WideDataSet_nsprefix_ = None
        if WideDataStructure is None:
            self.WideDataStructure = []
        else:
            self.WideDataStructure = WideDataStructure
        self.WideDataStructure_nsprefix_ = None
        if WideKey is None:
            self.WideKey = []
        else:
            self.WideKey = WideKey
        self.WideKey_nsprefix_ = None
        if WideKeyMember is None:
            self.WideKeyMember = []
        else:
            self.WideKeyMember = WideKeyMember
        self.WideKeyMember_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Wrapper)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Wrapper.subclass:
            return Wrapper.subclass(*args_, **kwargs_)
        else:
            return Wrapper(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_supportingInformation(self):
        return self.supportingInformation
    def set_supportingInformation(self, supportingInformation):
        self.supportingInformation = supportingInformation
    def add_supportingInformation(self, value):
        self.supportingInformation.append(value)
    def insert_supportingInformation_at(self, index, value):
        self.supportingInformation.insert(index, value)
    def replace_supportingInformation_at(self, index, value):
        self.supportingInformation[index] = value
    def get_Activity(self):
        return self.Activity
    def set_Activity(self, Activity):
        self.Activity = Activity
    def add_Activity(self, value):
        self.Activity.append(value)
    def insert_Activity_at(self, index, value):
        self.Activity.insert(index, value)
    def replace_Activity_at(self, index, value):
        self.Activity[index] = value
    def get_Agent(self):
        return self.Agent
    def set_Agent(self, Agent):
        self.Agent = Agent
    def add_Agent(self, value):
        self.Agent.append(value)
    def insert_Agent_at(self, index, value):
        self.Agent.insert(index, value)
    def replace_Agent_at(self, index, value):
        self.Agent[index] = value
    def get_AgentListing(self):
        return self.AgentListing
    def set_AgentListing(self, AgentListing):
        self.AgentListing = AgentListing
    def add_AgentListing(self, value):
        self.AgentListing.append(value)
    def insert_AgentListing_at(self, index, value):
        self.AgentListing.insert(index, value)
    def replace_AgentListing_at(self, index, value):
        self.AgentListing[index] = value
    def get_AgentPosition(self):
        return self.AgentPosition
    def set_AgentPosition(self, AgentPosition):
        self.AgentPosition = AgentPosition
    def add_AgentPosition(self, value):
        self.AgentPosition.append(value)
    def insert_AgentPosition_at(self, index, value):
        self.AgentPosition.insert(index, value)
    def replace_AgentPosition_at(self, index, value):
        self.AgentPosition[index] = value
    def get_AgentRelationship(self):
        return self.AgentRelationship
    def set_AgentRelationship(self, AgentRelationship):
        self.AgentRelationship = AgentRelationship
    def add_AgentRelationship(self, value):
        self.AgentRelationship.append(value)
    def insert_AgentRelationship_at(self, index, value):
        self.AgentRelationship.insert(index, value)
    def replace_AgentRelationship_at(self, index, value):
        self.AgentRelationship[index] = value
    def get_AgentStructure(self):
        return self.AgentStructure
    def set_AgentStructure(self, AgentStructure):
        self.AgentStructure = AgentStructure
    def add_AgentStructure(self, value):
        self.AgentStructure.append(value)
    def insert_AgentStructure_at(self, index, value):
        self.AgentStructure.insert(index, value)
    def replace_AgentStructure_at(self, index, value):
        self.AgentStructure[index] = value
    def get_AllenIntervalAlgebra(self):
        return self.AllenIntervalAlgebra
    def set_AllenIntervalAlgebra(self, AllenIntervalAlgebra):
        self.AllenIntervalAlgebra = AllenIntervalAlgebra
    def add_AllenIntervalAlgebra(self, value):
        self.AllenIntervalAlgebra.append(value)
    def insert_AllenIntervalAlgebra_at(self, index, value):
        self.AllenIntervalAlgebra.insert(index, value)
    def replace_AllenIntervalAlgebra_at(self, index, value):
        self.AllenIntervalAlgebra[index] = value
    def get_AttributeComponent(self):
        return self.AttributeComponent
    def set_AttributeComponent(self, AttributeComponent):
        self.AttributeComponent = AttributeComponent
    def add_AttributeComponent(self, value):
        self.AttributeComponent.append(value)
    def insert_AttributeComponent_at(self, index, value):
        self.AttributeComponent.insert(index, value)
    def replace_AttributeComponent_at(self, index, value):
        self.AttributeComponent[index] = value
    def get_AuthorizationSource(self):
        return self.AuthorizationSource
    def set_AuthorizationSource(self, AuthorizationSource):
        self.AuthorizationSource = AuthorizationSource
    def add_AuthorizationSource(self, value):
        self.AuthorizationSource.append(value)
    def insert_AuthorizationSource_at(self, index, value):
        self.AuthorizationSource.insert(index, value)
    def replace_AuthorizationSource_at(self, index, value):
        self.AuthorizationSource[index] = value
    def get_Category(self):
        return self.Category
    def set_Category(self, Category):
        self.Category = Category
    def add_Category(self, value):
        self.Category.append(value)
    def insert_Category_at(self, index, value):
        self.Category.insert(index, value)
    def replace_Category_at(self, index, value):
        self.Category[index] = value
    def get_CategoryPosition(self):
        return self.CategoryPosition
    def set_CategoryPosition(self, CategoryPosition):
        self.CategoryPosition = CategoryPosition
    def add_CategoryPosition(self, value):
        self.CategoryPosition.append(value)
    def insert_CategoryPosition_at(self, index, value):
        self.CategoryPosition.insert(index, value)
    def replace_CategoryPosition_at(self, index, value):
        self.CategoryPosition[index] = value
    def get_CategoryRelationStructure(self):
        return self.CategoryRelationStructure
    def set_CategoryRelationStructure(self, CategoryRelationStructure):
        self.CategoryRelationStructure = CategoryRelationStructure
    def add_CategoryRelationStructure(self, value):
        self.CategoryRelationStructure.append(value)
    def insert_CategoryRelationStructure_at(self, index, value):
        self.CategoryRelationStructure.insert(index, value)
    def replace_CategoryRelationStructure_at(self, index, value):
        self.CategoryRelationStructure[index] = value
    def get_CategoryRelationship(self):
        return self.CategoryRelationship
    def set_CategoryRelationship(self, CategoryRelationship):
        self.CategoryRelationship = CategoryRelationship
    def add_CategoryRelationship(self, value):
        self.CategoryRelationship.append(value)
    def insert_CategoryRelationship_at(self, index, value):
        self.CategoryRelationship.insert(index, value)
    def replace_CategoryRelationship_at(self, index, value):
        self.CategoryRelationship[index] = value
    def get_CategorySet(self):
        return self.CategorySet
    def set_CategorySet(self, CategorySet):
        self.CategorySet = CategorySet
    def add_CategorySet(self, value):
        self.CategorySet.append(value)
    def insert_CategorySet_at(self, index, value):
        self.CategorySet.insert(index, value)
    def replace_CategorySet_at(self, index, value):
        self.CategorySet[index] = value
    def get_CategoryStatistic(self):
        return self.CategoryStatistic
    def set_CategoryStatistic(self, CategoryStatistic):
        self.CategoryStatistic = CategoryStatistic
    def add_CategoryStatistic(self, value):
        self.CategoryStatistic.append(value)
    def insert_CategoryStatistic_at(self, index, value):
        self.CategoryStatistic.insert(index, value)
    def replace_CategoryStatistic_at(self, index, value):
        self.CategoryStatistic[index] = value
    def get_ClassificationFamily(self):
        return self.ClassificationFamily
    def set_ClassificationFamily(self, ClassificationFamily):
        self.ClassificationFamily = ClassificationFamily
    def add_ClassificationFamily(self, value):
        self.ClassificationFamily.append(value)
    def insert_ClassificationFamily_at(self, index, value):
        self.ClassificationFamily.insert(index, value)
    def replace_ClassificationFamily_at(self, index, value):
        self.ClassificationFamily[index] = value
    def get_ClassificationIndex(self):
        return self.ClassificationIndex
    def set_ClassificationIndex(self, ClassificationIndex):
        self.ClassificationIndex = ClassificationIndex
    def add_ClassificationIndex(self, value):
        self.ClassificationIndex.append(value)
    def insert_ClassificationIndex_at(self, index, value):
        self.ClassificationIndex.insert(index, value)
    def replace_ClassificationIndex_at(self, index, value):
        self.ClassificationIndex[index] = value
    def get_ClassificationIndexEntry(self):
        return self.ClassificationIndexEntry
    def set_ClassificationIndexEntry(self, ClassificationIndexEntry):
        self.ClassificationIndexEntry = ClassificationIndexEntry
    def add_ClassificationIndexEntry(self, value):
        self.ClassificationIndexEntry.append(value)
    def insert_ClassificationIndexEntry_at(self, index, value):
        self.ClassificationIndexEntry.insert(index, value)
    def replace_ClassificationIndexEntry_at(self, index, value):
        self.ClassificationIndexEntry[index] = value
    def get_ClassificationIndexEntryPosition(self):
        return self.ClassificationIndexEntryPosition
    def set_ClassificationIndexEntryPosition(self, ClassificationIndexEntryPosition):
        self.ClassificationIndexEntryPosition = ClassificationIndexEntryPosition
    def add_ClassificationIndexEntryPosition(self, value):
        self.ClassificationIndexEntryPosition.append(value)
    def insert_ClassificationIndexEntryPosition_at(self, index, value):
        self.ClassificationIndexEntryPosition.insert(index, value)
    def replace_ClassificationIndexEntryPosition_at(self, index, value):
        self.ClassificationIndexEntryPosition[index] = value
    def get_ClassificationItem(self):
        return self.ClassificationItem
    def set_ClassificationItem(self, ClassificationItem):
        self.ClassificationItem = ClassificationItem
    def add_ClassificationItem(self, value):
        self.ClassificationItem.append(value)
    def insert_ClassificationItem_at(self, index, value):
        self.ClassificationItem.insert(index, value)
    def replace_ClassificationItem_at(self, index, value):
        self.ClassificationItem[index] = value
    def get_ClassificationItemPosition(self):
        return self.ClassificationItemPosition
    def set_ClassificationItemPosition(self, ClassificationItemPosition):
        self.ClassificationItemPosition = ClassificationItemPosition
    def add_ClassificationItemPosition(self, value):
        self.ClassificationItemPosition.append(value)
    def insert_ClassificationItemPosition_at(self, index, value):
        self.ClassificationItemPosition.insert(index, value)
    def replace_ClassificationItemPosition_at(self, index, value):
        self.ClassificationItemPosition[index] = value
    def get_ClassificationItemRelationship(self):
        return self.ClassificationItemRelationship
    def set_ClassificationItemRelationship(self, ClassificationItemRelationship):
        self.ClassificationItemRelationship = ClassificationItemRelationship
    def add_ClassificationItemRelationship(self, value):
        self.ClassificationItemRelationship.append(value)
    def insert_ClassificationItemRelationship_at(self, index, value):
        self.ClassificationItemRelationship.insert(index, value)
    def replace_ClassificationItemRelationship_at(self, index, value):
        self.ClassificationItemRelationship[index] = value
    def get_ClassificationItemStructure(self):
        return self.ClassificationItemStructure
    def set_ClassificationItemStructure(self, ClassificationItemStructure):
        self.ClassificationItemStructure = ClassificationItemStructure
    def add_ClassificationItemStructure(self, value):
        self.ClassificationItemStructure.append(value)
    def insert_ClassificationItemStructure_at(self, index, value):
        self.ClassificationItemStructure.insert(index, value)
    def replace_ClassificationItemStructure_at(self, index, value):
        self.ClassificationItemStructure[index] = value
    def get_ClassificationPosition(self):
        return self.ClassificationPosition
    def set_ClassificationPosition(self, ClassificationPosition):
        self.ClassificationPosition = ClassificationPosition
    def add_ClassificationPosition(self, value):
        self.ClassificationPosition.append(value)
    def insert_ClassificationPosition_at(self, index, value):
        self.ClassificationPosition.insert(index, value)
    def replace_ClassificationPosition_at(self, index, value):
        self.ClassificationPosition[index] = value
    def get_ClassificationSeries(self):
        return self.ClassificationSeries
    def set_ClassificationSeries(self, ClassificationSeries):
        self.ClassificationSeries = ClassificationSeries
    def add_ClassificationSeries(self, value):
        self.ClassificationSeries.append(value)
    def insert_ClassificationSeries_at(self, index, value):
        self.ClassificationSeries.insert(index, value)
    def replace_ClassificationSeries_at(self, index, value):
        self.ClassificationSeries[index] = value
    def get_ClassificationSeriesStructure(self):
        return self.ClassificationSeriesStructure
    def set_ClassificationSeriesStructure(self, ClassificationSeriesStructure):
        self.ClassificationSeriesStructure = ClassificationSeriesStructure
    def add_ClassificationSeriesStructure(self, value):
        self.ClassificationSeriesStructure.append(value)
    def insert_ClassificationSeriesStructure_at(self, index, value):
        self.ClassificationSeriesStructure.insert(index, value)
    def replace_ClassificationSeriesStructure_at(self, index, value):
        self.ClassificationSeriesStructure[index] = value
    def get_Code(self):
        return self.Code
    def set_Code(self, Code):
        self.Code = Code
    def add_Code(self, value):
        self.Code.append(value)
    def insert_Code_at(self, index, value):
        self.Code.insert(index, value)
    def replace_Code_at(self, index, value):
        self.Code[index] = value
    def get_CodeList(self):
        return self.CodeList
    def set_CodeList(self, CodeList):
        self.CodeList = CodeList
    def add_CodeList(self, value):
        self.CodeList.append(value)
    def insert_CodeList_at(self, index, value):
        self.CodeList.insert(index, value)
    def replace_CodeList_at(self, index, value):
        self.CodeList[index] = value
    def get_CodeListStructure(self):
        return self.CodeListStructure
    def set_CodeListStructure(self, CodeListStructure):
        self.CodeListStructure = CodeListStructure
    def add_CodeListStructure(self, value):
        self.CodeListStructure.append(value)
    def insert_CodeListStructure_at(self, index, value):
        self.CodeListStructure.insert(index, value)
    def replace_CodeListStructure_at(self, index, value):
        self.CodeListStructure[index] = value
    def get_CodePosition(self):
        return self.CodePosition
    def set_CodePosition(self, CodePosition):
        self.CodePosition = CodePosition
    def add_CodePosition(self, value):
        self.CodePosition.append(value)
    def insert_CodePosition_at(self, index, value):
        self.CodePosition.insert(index, value)
    def replace_CodePosition_at(self, index, value):
        self.CodePosition[index] = value
    def get_CodeRelationship(self):
        return self.CodeRelationship
    def set_CodeRelationship(self, CodeRelationship):
        self.CodeRelationship = CodeRelationship
    def add_CodeRelationship(self, value):
        self.CodeRelationship.append(value)
    def insert_CodeRelationship_at(self, index, value):
        self.CodeRelationship.insert(index, value)
    def replace_CodeRelationship_at(self, index, value):
        self.CodeRelationship[index] = value
    def get_ComponentPosition(self):
        return self.ComponentPosition
    def set_ComponentPosition(self, ComponentPosition):
        self.ComponentPosition = ComponentPosition
    def add_ComponentPosition(self, value):
        self.ComponentPosition.append(value)
    def insert_ComponentPosition_at(self, index, value):
        self.ComponentPosition.insert(index, value)
    def replace_ComponentPosition_at(self, index, value):
        self.ComponentPosition[index] = value
    def get_Concept(self):
        return self.Concept
    def set_Concept(self, Concept):
        self.Concept = Concept
    def add_Concept(self, value):
        self.Concept.append(value)
    def insert_Concept_at(self, index, value):
        self.Concept.insert(index, value)
    def replace_Concept_at(self, index, value):
        self.Concept[index] = value
    def get_ConceptMap(self):
        return self.ConceptMap
    def set_ConceptMap(self, ConceptMap):
        self.ConceptMap = ConceptMap
    def add_ConceptMap(self, value):
        self.ConceptMap.append(value)
    def insert_ConceptMap_at(self, index, value):
        self.ConceptMap.insert(index, value)
    def replace_ConceptMap_at(self, index, value):
        self.ConceptMap[index] = value
    def get_ConceptRelationship(self):
        return self.ConceptRelationship
    def set_ConceptRelationship(self, ConceptRelationship):
        self.ConceptRelationship = ConceptRelationship
    def add_ConceptRelationship(self, value):
        self.ConceptRelationship.append(value)
    def insert_ConceptRelationship_at(self, index, value):
        self.ConceptRelationship.insert(index, value)
    def replace_ConceptRelationship_at(self, index, value):
        self.ConceptRelationship[index] = value
    def get_ConceptStructure(self):
        return self.ConceptStructure
    def set_ConceptStructure(self, ConceptStructure):
        self.ConceptStructure = ConceptStructure
    def add_ConceptStructure(self, value):
        self.ConceptStructure.append(value)
    def insert_ConceptStructure_at(self, index, value):
        self.ConceptStructure.insert(index, value)
    def replace_ConceptStructure_at(self, index, value):
        self.ConceptStructure[index] = value
    def get_ConceptSystem(self):
        return self.ConceptSystem
    def set_ConceptSystem(self, ConceptSystem):
        self.ConceptSystem = ConceptSystem
    def add_ConceptSystem(self, value):
        self.ConceptSystem.append(value)
    def insert_ConceptSystem_at(self, index, value):
        self.ConceptSystem.insert(index, value)
    def replace_ConceptSystem_at(self, index, value):
        self.ConceptSystem[index] = value
    def get_ConceptSystemCorrespondence(self):
        return self.ConceptSystemCorrespondence
    def set_ConceptSystemCorrespondence(self, ConceptSystemCorrespondence):
        self.ConceptSystemCorrespondence = ConceptSystemCorrespondence
    def add_ConceptSystemCorrespondence(self, value):
        self.ConceptSystemCorrespondence.append(value)
    def insert_ConceptSystemCorrespondence_at(self, index, value):
        self.ConceptSystemCorrespondence.insert(index, value)
    def replace_ConceptSystemCorrespondence_at(self, index, value):
        self.ConceptSystemCorrespondence[index] = value
    def get_ConceptualDomain(self):
        return self.ConceptualDomain
    def set_ConceptualDomain(self, ConceptualDomain):
        self.ConceptualDomain = ConceptualDomain
    def add_ConceptualDomain(self, value):
        self.ConceptualDomain.append(value)
    def insert_ConceptualDomain_at(self, index, value):
        self.ConceptualDomain.insert(index, value)
    def replace_ConceptualDomain_at(self, index, value):
        self.ConceptualDomain[index] = value
    def get_ConceptualValue(self):
        return self.ConceptualValue
    def set_ConceptualValue(self, ConceptualValue):
        self.ConceptualValue = ConceptualValue
    def add_ConceptualValue(self, value):
        self.ConceptualValue.append(value)
    def insert_ConceptualValue_at(self, index, value):
        self.ConceptualValue.insert(index, value)
    def replace_ConceptualValue_at(self, index, value):
        self.ConceptualValue[index] = value
    def get_ConceptualVariable(self):
        return self.ConceptualVariable
    def set_ConceptualVariable(self, ConceptualVariable):
        self.ConceptualVariable = ConceptualVariable
    def add_ConceptualVariable(self, value):
        self.ConceptualVariable.append(value)
    def insert_ConceptualVariable_at(self, index, value):
        self.ConceptualVariable.insert(index, value)
    def replace_ConceptualVariable_at(self, index, value):
        self.ConceptualVariable[index] = value
    def get_ConditionalControlLogic(self):
        return self.ConditionalControlLogic
    def set_ConditionalControlLogic(self, ConditionalControlLogic):
        self.ConditionalControlLogic = ConditionalControlLogic
    def add_ConditionalControlLogic(self, value):
        self.ConditionalControlLogic.append(value)
    def insert_ConditionalControlLogic_at(self, index, value):
        self.ConditionalControlLogic.insert(index, value)
    def replace_ConditionalControlLogic_at(self, index, value):
        self.ConditionalControlLogic[index] = value
    def get_ContextualComponent(self):
        return self.ContextualComponent
    def set_ContextualComponent(self, ContextualComponent):
        self.ContextualComponent = ContextualComponent
    def add_ContextualComponent(self, value):
        self.ContextualComponent.append(value)
    def insert_ContextualComponent_at(self, index, value):
        self.ContextualComponent.insert(index, value)
    def replace_ContextualComponent_at(self, index, value):
        self.ContextualComponent[index] = value
    def get_ControlLogic(self):
        return self.ControlLogic
    def set_ControlLogic(self, ControlLogic):
        self.ControlLogic = ControlLogic
    def add_ControlLogic(self, value):
        self.ControlLogic.append(value)
    def insert_ControlLogic_at(self, index, value):
        self.ControlLogic.insert(index, value)
    def replace_ControlLogic_at(self, index, value):
        self.ControlLogic[index] = value
    def get_CorrespondenceTable(self):
        return self.CorrespondenceTable
    def set_CorrespondenceTable(self, CorrespondenceTable):
        self.CorrespondenceTable = CorrespondenceTable
    def add_CorrespondenceTable(self, value):
        self.CorrespondenceTable.append(value)
    def insert_CorrespondenceTable_at(self, index, value):
        self.CorrespondenceTable.insert(index, value)
    def replace_CorrespondenceTable_at(self, index, value):
        self.CorrespondenceTable[index] = value
    def get_Curator(self):
        return self.Curator
    def set_Curator(self, Curator):
        self.Curator = Curator
    def add_Curator(self, value):
        self.Curator.append(value)
    def insert_Curator_at(self, index, value):
        self.Curator.insert(index, value)
    def replace_Curator_at(self, index, value):
        self.Curator[index] = value
    def get_DataPoint(self):
        return self.DataPoint
    def set_DataPoint(self, DataPoint):
        self.DataPoint = DataPoint
    def add_DataPoint(self, value):
        self.DataPoint.append(value)
    def insert_DataPoint_at(self, index, value):
        self.DataPoint.insert(index, value)
    def replace_DataPoint_at(self, index, value):
        self.DataPoint[index] = value
    def get_DataPointPosition(self):
        return self.DataPointPosition
    def set_DataPointPosition(self, DataPointPosition):
        self.DataPointPosition = DataPointPosition
    def add_DataPointPosition(self, value):
        self.DataPointPosition.append(value)
    def insert_DataPointPosition_at(self, index, value):
        self.DataPointPosition.insert(index, value)
    def replace_DataPointPosition_at(self, index, value):
        self.DataPointPosition[index] = value
    def get_DataPointRelationship(self):
        return self.DataPointRelationship
    def set_DataPointRelationship(self, DataPointRelationship):
        self.DataPointRelationship = DataPointRelationship
    def add_DataPointRelationship(self, value):
        self.DataPointRelationship.append(value)
    def insert_DataPointRelationship_at(self, index, value):
        self.DataPointRelationship.insert(index, value)
    def replace_DataPointRelationship_at(self, index, value):
        self.DataPointRelationship[index] = value
    def get_DataSet(self):
        return self.DataSet
    def set_DataSet(self, DataSet):
        self.DataSet = DataSet
    def add_DataSet(self, value):
        self.DataSet.append(value)
    def insert_DataSet_at(self, index, value):
        self.DataSet.insert(index, value)
    def replace_DataSet_at(self, index, value):
        self.DataSet[index] = value
    def get_DataStore(self):
        return self.DataStore
    def set_DataStore(self, DataStore):
        self.DataStore = DataStore
    def add_DataStore(self, value):
        self.DataStore.append(value)
    def insert_DataStore_at(self, index, value):
        self.DataStore.insert(index, value)
    def replace_DataStore_at(self, index, value):
        self.DataStore[index] = value
    def get_DataStructure(self):
        return self.DataStructure
    def set_DataStructure(self, DataStructure):
        self.DataStructure = DataStructure
    def add_DataStructure(self, value):
        self.DataStructure.append(value)
    def insert_DataStructure_at(self, index, value):
        self.DataStructure.insert(index, value)
    def replace_DataStructure_at(self, index, value):
        self.DataStructure[index] = value
    def get_DataStructureComponent(self):
        return self.DataStructureComponent
    def set_DataStructureComponent(self, DataStructureComponent):
        self.DataStructureComponent = DataStructureComponent
    def add_DataStructureComponent(self, value):
        self.DataStructureComponent.append(value)
    def insert_DataStructureComponent_at(self, index, value):
        self.DataStructureComponent.insert(index, value)
    def replace_DataStructureComponent_at(self, index, value):
        self.DataStructureComponent[index] = value
    def get_Datum(self):
        return self.Datum
    def set_Datum(self, Datum):
        self.Datum = Datum
    def add_Datum(self, value):
        self.Datum.append(value)
    def insert_Datum_at(self, index, value):
        self.Datum.insert(index, value)
    def replace_Datum_at(self, index, value):
        self.Datum[index] = value
    def get_Descriptor(self):
        return self.Descriptor
    def set_Descriptor(self, Descriptor):
        self.Descriptor = Descriptor
    def add_Descriptor(self, value):
        self.Descriptor.append(value)
    def insert_Descriptor_at(self, index, value):
        self.Descriptor.insert(index, value)
    def replace_Descriptor_at(self, index, value):
        self.Descriptor[index] = value
    def get_DescriptorValueDomain(self):
        return self.DescriptorValueDomain
    def set_DescriptorValueDomain(self, DescriptorValueDomain):
        self.DescriptorValueDomain = DescriptorValueDomain
    def add_DescriptorValueDomain(self, value):
        self.DescriptorValueDomain.append(value)
    def insert_DescriptorValueDomain_at(self, index, value):
        self.DescriptorValueDomain.insert(index, value)
    def replace_DescriptorValueDomain_at(self, index, value):
        self.DescriptorValueDomain[index] = value
    def get_DescriptorVariable(self):
        return self.DescriptorVariable
    def set_DescriptorVariable(self, DescriptorVariable):
        self.DescriptorVariable = DescriptorVariable
    def add_DescriptorVariable(self, value):
        self.DescriptorVariable.append(value)
    def insert_DescriptorVariable_at(self, index, value):
        self.DescriptorVariable.insert(index, value)
    def replace_DescriptorVariable_at(self, index, value):
        self.DescriptorVariable[index] = value
    def get_DeterministicImperative(self):
        return self.DeterministicImperative
    def set_DeterministicImperative(self, DeterministicImperative):
        self.DeterministicImperative = DeterministicImperative
    def add_DeterministicImperative(self, value):
        self.DeterministicImperative.append(value)
    def insert_DeterministicImperative_at(self, index, value):
        self.DeterministicImperative.insert(index, value)
    def replace_DeterministicImperative_at(self, index, value):
        self.DeterministicImperative[index] = value
    def get_DimensionComponent(self):
        return self.DimensionComponent
    def set_DimensionComponent(self, DimensionComponent):
        self.DimensionComponent = DimensionComponent
    def add_DimensionComponent(self, value):
        self.DimensionComponent.append(value)
    def insert_DimensionComponent_at(self, index, value):
        self.DimensionComponent.insert(index, value)
    def replace_DimensionComponent_at(self, index, value):
        self.DimensionComponent[index] = value
    def get_DimensionGroup(self):
        return self.DimensionGroup
    def set_DimensionGroup(self, DimensionGroup):
        self.DimensionGroup = DimensionGroup
    def add_DimensionGroup(self, value):
        self.DimensionGroup.append(value)
    def insert_DimensionGroup_at(self, index, value):
        self.DimensionGroup.insert(index, value)
    def replace_DimensionGroup_at(self, index, value):
        self.DimensionGroup[index] = value
    def get_DimensionalDataSet(self):
        return self.DimensionalDataSet
    def set_DimensionalDataSet(self, DimensionalDataSet):
        self.DimensionalDataSet = DimensionalDataSet
    def add_DimensionalDataSet(self, value):
        self.DimensionalDataSet.append(value)
    def insert_DimensionalDataSet_at(self, index, value):
        self.DimensionalDataSet.insert(index, value)
    def replace_DimensionalDataSet_at(self, index, value):
        self.DimensionalDataSet[index] = value
    def get_DimensionalDataStructure(self):
        return self.DimensionalDataStructure
    def set_DimensionalDataStructure(self, DimensionalDataStructure):
        self.DimensionalDataStructure = DimensionalDataStructure
    def add_DimensionalDataStructure(self, value):
        self.DimensionalDataStructure.append(value)
    def insert_DimensionalDataStructure_at(self, index, value):
        self.DimensionalDataStructure.insert(index, value)
    def replace_DimensionalDataStructure_at(self, index, value):
        self.DimensionalDataStructure[index] = value
    def get_DimensionalKey(self):
        return self.DimensionalKey
    def set_DimensionalKey(self, DimensionalKey):
        self.DimensionalKey = DimensionalKey
    def add_DimensionalKey(self, value):
        self.DimensionalKey.append(value)
    def insert_DimensionalKey_at(self, index, value):
        self.DimensionalKey.insert(index, value)
    def replace_DimensionalKey_at(self, index, value):
        self.DimensionalKey[index] = value
    def get_DimensionalKeyDefinition(self):
        return self.DimensionalKeyDefinition
    def set_DimensionalKeyDefinition(self, DimensionalKeyDefinition):
        self.DimensionalKeyDefinition = DimensionalKeyDefinition
    def add_DimensionalKeyDefinition(self, value):
        self.DimensionalKeyDefinition.append(value)
    def insert_DimensionalKeyDefinition_at(self, index, value):
        self.DimensionalKeyDefinition.insert(index, value)
    def replace_DimensionalKeyDefinition_at(self, index, value):
        self.DimensionalKeyDefinition[index] = value
    def get_DimensionalKeyDefinitionMember(self):
        return self.DimensionalKeyDefinitionMember
    def set_DimensionalKeyDefinitionMember(self, DimensionalKeyDefinitionMember):
        self.DimensionalKeyDefinitionMember = DimensionalKeyDefinitionMember
    def add_DimensionalKeyDefinitionMember(self, value):
        self.DimensionalKeyDefinitionMember.append(value)
    def insert_DimensionalKeyDefinitionMember_at(self, index, value):
        self.DimensionalKeyDefinitionMember.insert(index, value)
    def replace_DimensionalKeyDefinitionMember_at(self, index, value):
        self.DimensionalKeyDefinitionMember[index] = value
    def get_DimensionalKeyMember(self):
        return self.DimensionalKeyMember
    def set_DimensionalKeyMember(self, DimensionalKeyMember):
        self.DimensionalKeyMember = DimensionalKeyMember
    def add_DimensionalKeyMember(self, value):
        self.DimensionalKeyMember.append(value)
    def insert_DimensionalKeyMember_at(self, index, value):
        self.DimensionalKeyMember.insert(index, value)
    def replace_DimensionalKeyMember_at(self, index, value):
        self.DimensionalKeyMember[index] = value
    def get_EnumerationDomain(self):
        return self.EnumerationDomain
    def set_EnumerationDomain(self, EnumerationDomain):
        self.EnumerationDomain = EnumerationDomain
    def add_EnumerationDomain(self, value):
        self.EnumerationDomain.append(value)
    def insert_EnumerationDomain_at(self, index, value):
        self.EnumerationDomain.insert(index, value)
    def replace_EnumerationDomain_at(self, index, value):
        self.EnumerationDomain[index] = value
    def get_ForeignKey(self):
        return self.ForeignKey
    def set_ForeignKey(self, ForeignKey):
        self.ForeignKey = ForeignKey
    def add_ForeignKey(self, value):
        self.ForeignKey.append(value)
    def insert_ForeignKey_at(self, index, value):
        self.ForeignKey.insert(index, value)
    def replace_ForeignKey_at(self, index, value):
        self.ForeignKey[index] = value
    def get_ForeignKeyComponent(self):
        return self.ForeignKeyComponent
    def set_ForeignKeyComponent(self, ForeignKeyComponent):
        self.ForeignKeyComponent = ForeignKeyComponent
    def add_ForeignKeyComponent(self, value):
        self.ForeignKeyComponent.append(value)
    def insert_ForeignKeyComponent_at(self, index, value):
        self.ForeignKeyComponent.insert(index, value)
    def replace_ForeignKeyComponent_at(self, index, value):
        self.ForeignKeyComponent[index] = value
    def get_IdentifierComponent(self):
        return self.IdentifierComponent
    def set_IdentifierComponent(self, IdentifierComponent):
        self.IdentifierComponent = IdentifierComponent
    def add_IdentifierComponent(self, value):
        self.IdentifierComponent.append(value)
    def insert_IdentifierComponent_at(self, index, value):
        self.IdentifierComponent.insert(index, value)
    def replace_IdentifierComponent_at(self, index, value):
        self.IdentifierComponent[index] = value
    def get_Individual(self):
        return self.Individual
    def set_Individual(self, Individual):
        self.Individual = Individual
    def add_Individual(self, value):
        self.Individual.append(value)
    def insert_Individual_at(self, index, value):
        self.Individual.insert(index, value)
    def replace_Individual_at(self, index, value):
        self.Individual[index] = value
    def get_InformationFlowDefinition(self):
        return self.InformationFlowDefinition
    def set_InformationFlowDefinition(self, InformationFlowDefinition):
        self.InformationFlowDefinition = InformationFlowDefinition
    def add_InformationFlowDefinition(self, value):
        self.InformationFlowDefinition.append(value)
    def insert_InformationFlowDefinition_at(self, index, value):
        self.InformationFlowDefinition.insert(index, value)
    def replace_InformationFlowDefinition_at(self, index, value):
        self.InformationFlowDefinition[index] = value
    def get_InstanceKey(self):
        return self.InstanceKey
    def set_InstanceKey(self, InstanceKey):
        self.InstanceKey = InstanceKey
    def add_InstanceKey(self, value):
        self.InstanceKey.append(value)
    def insert_InstanceKey_at(self, index, value):
        self.InstanceKey.insert(index, value)
    def replace_InstanceKey_at(self, index, value):
        self.InstanceKey[index] = value
    def get_InstanceValue(self):
        return self.InstanceValue
    def set_InstanceValue(self, InstanceValue):
        self.InstanceValue = InstanceValue
    def add_InstanceValue(self, value):
        self.InstanceValue.append(value)
    def insert_InstanceValue_at(self, index, value):
        self.InstanceValue.insert(index, value)
    def replace_InstanceValue_at(self, index, value):
        self.InstanceValue[index] = value
    def get_InstanceVariable(self):
        return self.InstanceVariable
    def set_InstanceVariable(self, InstanceVariable):
        self.InstanceVariable = InstanceVariable
    def add_InstanceVariable(self, value):
        self.InstanceVariable.append(value)
    def insert_InstanceVariable_at(self, index, value):
        self.InstanceVariable.insert(index, value)
    def replace_InstanceVariable_at(self, index, value):
        self.InstanceVariable[index] = value
    def get_InstanceVariableMap(self):
        return self.InstanceVariableMap
    def set_InstanceVariableMap(self, InstanceVariableMap):
        self.InstanceVariableMap = InstanceVariableMap
    def add_InstanceVariableMap(self, value):
        self.InstanceVariableMap.append(value)
    def insert_InstanceVariableMap_at(self, index, value):
        self.InstanceVariableMap.insert(index, value)
    def replace_InstanceVariableMap_at(self, index, value):
        self.InstanceVariableMap[index] = value
    def get_Key(self):
        return self.Key
    def set_Key(self, Key):
        self.Key = Key
    def add_Key(self, value):
        self.Key.append(value)
    def insert_Key_at(self, index, value):
        self.Key.insert(index, value)
    def replace_Key_at(self, index, value):
        self.Key[index] = value
    def get_KeyDefinition(self):
        return self.KeyDefinition
    def set_KeyDefinition(self, KeyDefinition):
        self.KeyDefinition = KeyDefinition
    def add_KeyDefinition(self, value):
        self.KeyDefinition.append(value)
    def insert_KeyDefinition_at(self, index, value):
        self.KeyDefinition.insert(index, value)
    def replace_KeyDefinition_at(self, index, value):
        self.KeyDefinition[index] = value
    def get_KeyDefinitionMember(self):
        return self.KeyDefinitionMember
    def set_KeyDefinitionMember(self, KeyDefinitionMember):
        self.KeyDefinitionMember = KeyDefinitionMember
    def add_KeyDefinitionMember(self, value):
        self.KeyDefinitionMember.append(value)
    def insert_KeyDefinitionMember_at(self, index, value):
        self.KeyDefinitionMember.insert(index, value)
    def replace_KeyDefinitionMember_at(self, index, value):
        self.KeyDefinitionMember[index] = value
    def get_KeyMember(self):
        return self.KeyMember
    def set_KeyMember(self, KeyMember):
        self.KeyMember = KeyMember
    def add_KeyMember(self, value):
        self.KeyMember.append(value)
    def insert_KeyMember_at(self, index, value):
        self.KeyMember.insert(index, value)
    def replace_KeyMember_at(self, index, value):
        self.KeyMember[index] = value
    def get_KeyValueDataStore(self):
        return self.KeyValueDataStore
    def set_KeyValueDataStore(self, KeyValueDataStore):
        self.KeyValueDataStore = KeyValueDataStore
    def add_KeyValueDataStore(self, value):
        self.KeyValueDataStore.append(value)
    def insert_KeyValueDataStore_at(self, index, value):
        self.KeyValueDataStore.insert(index, value)
    def replace_KeyValueDataStore_at(self, index, value):
        self.KeyValueDataStore[index] = value
    def get_KeyValueStructure(self):
        return self.KeyValueStructure
    def set_KeyValueStructure(self, KeyValueStructure):
        self.KeyValueStructure = KeyValueStructure
    def add_KeyValueStructure(self, value):
        self.KeyValueStructure.append(value)
    def insert_KeyValueStructure_at(self, index, value):
        self.KeyValueStructure.insert(index, value)
    def replace_KeyValueStructure_at(self, index, value):
        self.KeyValueStructure[index] = value
    def get_Level(self):
        return self.Level
    def set_Level(self, Level):
        self.Level = Level
    def add_Level(self, value):
        self.Level.append(value)
    def insert_Level_at(self, index, value):
        self.Level.insert(index, value)
    def replace_Level_at(self, index, value):
        self.Level[index] = value
    def get_LevelStructure(self):
        return self.LevelStructure
    def set_LevelStructure(self, LevelStructure):
        self.LevelStructure = LevelStructure
    def add_LevelStructure(self, value):
        self.LevelStructure.append(value)
    def insert_LevelStructure_at(self, index, value):
        self.LevelStructure.insert(index, value)
    def replace_LevelStructure_at(self, index, value):
        self.LevelStructure[index] = value
    def get_LogicalRecord(self):
        return self.LogicalRecord
    def set_LogicalRecord(self, LogicalRecord):
        self.LogicalRecord = LogicalRecord
    def add_LogicalRecord(self, value):
        self.LogicalRecord.append(value)
    def insert_LogicalRecord_at(self, index, value):
        self.LogicalRecord.insert(index, value)
    def replace_LogicalRecord_at(self, index, value):
        self.LogicalRecord[index] = value
    def get_LogicalRecordPosition(self):
        return self.LogicalRecordPosition
    def set_LogicalRecordPosition(self, LogicalRecordPosition):
        self.LogicalRecordPosition = LogicalRecordPosition
    def add_LogicalRecordPosition(self, value):
        self.LogicalRecordPosition.append(value)
    def insert_LogicalRecordPosition_at(self, index, value):
        self.LogicalRecordPosition.insert(index, value)
    def replace_LogicalRecordPosition_at(self, index, value):
        self.LogicalRecordPosition[index] = value
    def get_LogicalRecordRelationStructure(self):
        return self.LogicalRecordRelationStructure
    def set_LogicalRecordRelationStructure(self, LogicalRecordRelationStructure):
        self.LogicalRecordRelationStructure = LogicalRecordRelationStructure
    def add_LogicalRecordRelationStructure(self, value):
        self.LogicalRecordRelationStructure.append(value)
    def insert_LogicalRecordRelationStructure_at(self, index, value):
        self.LogicalRecordRelationStructure.insert(index, value)
    def replace_LogicalRecordRelationStructure_at(self, index, value):
        self.LogicalRecordRelationStructure[index] = value
    def get_LogicalRecordRelationship(self):
        return self.LogicalRecordRelationship
    def set_LogicalRecordRelationship(self, LogicalRecordRelationship):
        self.LogicalRecordRelationship = LogicalRecordRelationship
    def add_LogicalRecordRelationship(self, value):
        self.LogicalRecordRelationship.append(value)
    def insert_LogicalRecordRelationship_at(self, index, value):
        self.LogicalRecordRelationship.insert(index, value)
    def replace_LogicalRecordRelationship_at(self, index, value):
        self.LogicalRecordRelationship[index] = value
    def get_LongDataSet(self):
        return self.LongDataSet
    def set_LongDataSet(self, LongDataSet):
        self.LongDataSet = LongDataSet
    def add_LongDataSet(self, value):
        self.LongDataSet.append(value)
    def insert_LongDataSet_at(self, index, value):
        self.LongDataSet.insert(index, value)
    def replace_LongDataSet_at(self, index, value):
        self.LongDataSet[index] = value
    def get_LongDataStructure(self):
        return self.LongDataStructure
    def set_LongDataStructure(self, LongDataStructure):
        self.LongDataStructure = LongDataStructure
    def add_LongDataStructure(self, value):
        self.LongDataStructure.append(value)
    def insert_LongDataStructure_at(self, index, value):
        self.LongDataStructure.insert(index, value)
    def replace_LongDataStructure_at(self, index, value):
        self.LongDataStructure[index] = value
    def get_LongKey(self):
        return self.LongKey
    def set_LongKey(self, LongKey):
        self.LongKey = LongKey
    def add_LongKey(self, value):
        self.LongKey.append(value)
    def insert_LongKey_at(self, index, value):
        self.LongKey.insert(index, value)
    def replace_LongKey_at(self, index, value):
        self.LongKey[index] = value
    def get_LongMainKeyMember(self):
        return self.LongMainKeyMember
    def set_LongMainKeyMember(self, LongMainKeyMember):
        self.LongMainKeyMember = LongMainKeyMember
    def add_LongMainKeyMember(self, value):
        self.LongMainKeyMember.append(value)
    def insert_LongMainKeyMember_at(self, index, value):
        self.LongMainKeyMember.insert(index, value)
    def replace_LongMainKeyMember_at(self, index, value):
        self.LongMainKeyMember[index] = value
    def get_Machine(self):
        return self.Machine
    def set_Machine(self, Machine):
        self.Machine = Machine
    def add_Machine(self, value):
        self.Machine.append(value)
    def insert_Machine_at(self, index, value):
        self.Machine.insert(index, value)
    def replace_Machine_at(self, index, value):
        self.Machine[index] = value
    def get_MainKeyMember(self):
        return self.MainKeyMember
    def set_MainKeyMember(self, MainKeyMember):
        self.MainKeyMember = MainKeyMember
    def add_MainKeyMember(self, value):
        self.MainKeyMember.append(value)
    def insert_MainKeyMember_at(self, index, value):
        self.MainKeyMember.insert(index, value)
    def replace_MainKeyMember_at(self, index, value):
        self.MainKeyMember[index] = value
    def get_MeasureComponent(self):
        return self.MeasureComponent
    def set_MeasureComponent(self, MeasureComponent):
        self.MeasureComponent = MeasureComponent
    def add_MeasureComponent(self, value):
        self.MeasureComponent.append(value)
    def insert_MeasureComponent_at(self, index, value):
        self.MeasureComponent.insert(index, value)
    def replace_MeasureComponent_at(self, index, value):
        self.MeasureComponent[index] = value
    def get_NonDeterministicDeclarative(self):
        return self.NonDeterministicDeclarative
    def set_NonDeterministicDeclarative(self, NonDeterministicDeclarative):
        self.NonDeterministicDeclarative = NonDeterministicDeclarative
    def add_NonDeterministicDeclarative(self, value):
        self.NonDeterministicDeclarative.append(value)
    def insert_NonDeterministicDeclarative_at(self, index, value):
        self.NonDeterministicDeclarative.insert(index, value)
    def replace_NonDeterministicDeclarative_at(self, index, value):
        self.NonDeterministicDeclarative[index] = value
    def get_Notation(self):
        return self.Notation
    def set_Notation(self, Notation):
        self.Notation = Notation
    def add_Notation(self, value):
        self.Notation.append(value)
    def insert_Notation_at(self, index, value):
        self.Notation.insert(index, value)
    def replace_Notation_at(self, index, value):
        self.Notation[index] = value
    def get_Organization(self):
        return self.Organization
    def set_Organization(self, Organization):
        self.Organization = Organization
    def add_Organization(self, value):
        self.Organization.append(value)
    def insert_Organization_at(self, index, value):
        self.Organization.insert(index, value)
    def replace_Organization_at(self, index, value):
        self.Organization[index] = value
    def get_Parameter(self):
        return self.Parameter
    def set_Parameter(self, Parameter):
        self.Parameter = Parameter
    def add_Parameter(self, value):
        self.Parameter.append(value)
    def insert_Parameter_at(self, index, value):
        self.Parameter.insert(index, value)
    def replace_Parameter_at(self, index, value):
        self.Parameter[index] = value
    def get_PhysicalDataSet(self):
        return self.PhysicalDataSet
    def set_PhysicalDataSet(self, PhysicalDataSet):
        self.PhysicalDataSet = PhysicalDataSet
    def add_PhysicalDataSet(self, value):
        self.PhysicalDataSet.append(value)
    def insert_PhysicalDataSet_at(self, index, value):
        self.PhysicalDataSet.insert(index, value)
    def replace_PhysicalDataSet_at(self, index, value):
        self.PhysicalDataSet[index] = value
    def get_PhysicalDataSetStructure(self):
        return self.PhysicalDataSetStructure
    def set_PhysicalDataSetStructure(self, PhysicalDataSetStructure):
        self.PhysicalDataSetStructure = PhysicalDataSetStructure
    def add_PhysicalDataSetStructure(self, value):
        self.PhysicalDataSetStructure.append(value)
    def insert_PhysicalDataSetStructure_at(self, index, value):
        self.PhysicalDataSetStructure.insert(index, value)
    def replace_PhysicalDataSetStructure_at(self, index, value):
        self.PhysicalDataSetStructure[index] = value
    def get_PhysicalLayoutRelationStructure(self):
        return self.PhysicalLayoutRelationStructure
    def set_PhysicalLayoutRelationStructure(self, PhysicalLayoutRelationStructure):
        self.PhysicalLayoutRelationStructure = PhysicalLayoutRelationStructure
    def add_PhysicalLayoutRelationStructure(self, value):
        self.PhysicalLayoutRelationStructure.append(value)
    def insert_PhysicalLayoutRelationStructure_at(self, index, value):
        self.PhysicalLayoutRelationStructure.insert(index, value)
    def replace_PhysicalLayoutRelationStructure_at(self, index, value):
        self.PhysicalLayoutRelationStructure[index] = value
    def get_PhysicalRecordSegment(self):
        return self.PhysicalRecordSegment
    def set_PhysicalRecordSegment(self, PhysicalRecordSegment):
        self.PhysicalRecordSegment = PhysicalRecordSegment
    def add_PhysicalRecordSegment(self, value):
        self.PhysicalRecordSegment.append(value)
    def insert_PhysicalRecordSegment_at(self, index, value):
        self.PhysicalRecordSegment.insert(index, value)
    def replace_PhysicalRecordSegment_at(self, index, value):
        self.PhysicalRecordSegment[index] = value
    def get_PhysicalRecordSegmentPosition(self):
        return self.PhysicalRecordSegmentPosition
    def set_PhysicalRecordSegmentPosition(self, PhysicalRecordSegmentPosition):
        self.PhysicalRecordSegmentPosition = PhysicalRecordSegmentPosition
    def add_PhysicalRecordSegmentPosition(self, value):
        self.PhysicalRecordSegmentPosition.append(value)
    def insert_PhysicalRecordSegmentPosition_at(self, index, value):
        self.PhysicalRecordSegmentPosition.insert(index, value)
    def replace_PhysicalRecordSegmentPosition_at(self, index, value):
        self.PhysicalRecordSegmentPosition[index] = value
    def get_PhysicalRecordSegmentRelationship(self):
        return self.PhysicalRecordSegmentRelationship
    def set_PhysicalRecordSegmentRelationship(self, PhysicalRecordSegmentRelationship):
        self.PhysicalRecordSegmentRelationship = PhysicalRecordSegmentRelationship
    def add_PhysicalRecordSegmentRelationship(self, value):
        self.PhysicalRecordSegmentRelationship.append(value)
    def insert_PhysicalRecordSegmentRelationship_at(self, index, value):
        self.PhysicalRecordSegmentRelationship.insert(index, value)
    def replace_PhysicalRecordSegmentRelationship_at(self, index, value):
        self.PhysicalRecordSegmentRelationship[index] = value
    def get_PhysicalRecordSegmentStructure(self):
        return self.PhysicalRecordSegmentStructure
    def set_PhysicalRecordSegmentStructure(self, PhysicalRecordSegmentStructure):
        self.PhysicalRecordSegmentStructure = PhysicalRecordSegmentStructure
    def add_PhysicalRecordSegmentStructure(self, value):
        self.PhysicalRecordSegmentStructure.append(value)
    def insert_PhysicalRecordSegmentStructure_at(self, index, value):
        self.PhysicalRecordSegmentStructure.insert(index, value)
    def replace_PhysicalRecordSegmentStructure_at(self, index, value):
        self.PhysicalRecordSegmentStructure[index] = value
    def get_PhysicalSegmentLayout(self):
        return self.PhysicalSegmentLayout
    def set_PhysicalSegmentLayout(self, PhysicalSegmentLayout):
        self.PhysicalSegmentLayout = PhysicalSegmentLayout
    def add_PhysicalSegmentLayout(self, value):
        self.PhysicalSegmentLayout.append(value)
    def insert_PhysicalSegmentLayout_at(self, index, value):
        self.PhysicalSegmentLayout.insert(index, value)
    def replace_PhysicalSegmentLayout_at(self, index, value):
        self.PhysicalSegmentLayout[index] = value
    def get_PhysicalSegmentLocation(self):
        return self.PhysicalSegmentLocation
    def set_PhysicalSegmentLocation(self, PhysicalSegmentLocation):
        self.PhysicalSegmentLocation = PhysicalSegmentLocation
    def add_PhysicalSegmentLocation(self, value):
        self.PhysicalSegmentLocation.append(value)
    def insert_PhysicalSegmentLocation_at(self, index, value):
        self.PhysicalSegmentLocation.insert(index, value)
    def replace_PhysicalSegmentLocation_at(self, index, value):
        self.PhysicalSegmentLocation[index] = value
    def get_Population(self):
        return self.Population
    def set_Population(self, Population):
        self.Population = Population
    def add_Population(self, value):
        self.Population.append(value)
    def insert_Population_at(self, index, value):
        self.Population.insert(index, value)
    def replace_Population_at(self, index, value):
        self.Population[index] = value
    def get_PrimaryKey(self):
        return self.PrimaryKey
    def set_PrimaryKey(self, PrimaryKey):
        self.PrimaryKey = PrimaryKey
    def add_PrimaryKey(self, value):
        self.PrimaryKey.append(value)
    def insert_PrimaryKey_at(self, index, value):
        self.PrimaryKey.insert(index, value)
    def replace_PrimaryKey_at(self, index, value):
        self.PrimaryKey[index] = value
    def get_PrimaryKeyComponent(self):
        return self.PrimaryKeyComponent
    def set_PrimaryKeyComponent(self, PrimaryKeyComponent):
        self.PrimaryKeyComponent = PrimaryKeyComponent
    def add_PrimaryKeyComponent(self, value):
        self.PrimaryKeyComponent.append(value)
    def insert_PrimaryKeyComponent_at(self, index, value):
        self.PrimaryKeyComponent.insert(index, value)
    def replace_PrimaryKeyComponent_at(self, index, value):
        self.PrimaryKeyComponent[index] = value
    def get_ProcessingAgent(self):
        return self.ProcessingAgent
    def set_ProcessingAgent(self, ProcessingAgent):
        self.ProcessingAgent = ProcessingAgent
    def add_ProcessingAgent(self, value):
        self.ProcessingAgent.append(value)
    def insert_ProcessingAgent_at(self, index, value):
        self.ProcessingAgent.insert(index, value)
    def replace_ProcessingAgent_at(self, index, value):
        self.ProcessingAgent[index] = value
    def get_ProductionEnvironment(self):
        return self.ProductionEnvironment
    def set_ProductionEnvironment(self, ProductionEnvironment):
        self.ProductionEnvironment = ProductionEnvironment
    def add_ProductionEnvironment(self, value):
        self.ProductionEnvironment.append(value)
    def insert_ProductionEnvironment_at(self, index, value):
        self.ProductionEnvironment.insert(index, value)
    def replace_ProductionEnvironment_at(self, index, value):
        self.ProductionEnvironment[index] = value
    def get_QualifiedMeasure(self):
        return self.QualifiedMeasure
    def set_QualifiedMeasure(self, QualifiedMeasure):
        self.QualifiedMeasure = QualifiedMeasure
    def add_QualifiedMeasure(self, value):
        self.QualifiedMeasure.append(value)
    def insert_QualifiedMeasure_at(self, index, value):
        self.QualifiedMeasure.insert(index, value)
    def replace_QualifiedMeasure_at(self, index, value):
        self.QualifiedMeasure[index] = value
    def get_RecordRelation(self):
        return self.RecordRelation
    def set_RecordRelation(self, RecordRelation):
        self.RecordRelation = RecordRelation
    def add_RecordRelation(self, value):
        self.RecordRelation.append(value)
    def insert_RecordRelation_at(self, index, value):
        self.RecordRelation.insert(index, value)
    def replace_RecordRelation_at(self, index, value):
        self.RecordRelation[index] = value
    def get_ReferenceValue(self):
        return self.ReferenceValue
    def set_ReferenceValue(self, ReferenceValue):
        self.ReferenceValue = ReferenceValue
    def add_ReferenceValue(self, value):
        self.ReferenceValue.append(value)
    def insert_ReferenceValue_at(self, index, value):
        self.ReferenceValue.insert(index, value)
    def replace_ReferenceValue_at(self, index, value):
        self.ReferenceValue[index] = value
    def get_ReferenceValueDomain(self):
        return self.ReferenceValueDomain
    def set_ReferenceValueDomain(self, ReferenceValueDomain):
        self.ReferenceValueDomain = ReferenceValueDomain
    def add_ReferenceValueDomain(self, value):
        self.ReferenceValueDomain.append(value)
    def insert_ReferenceValueDomain_at(self, index, value):
        self.ReferenceValueDomain.insert(index, value)
    def replace_ReferenceValueDomain_at(self, index, value):
        self.ReferenceValueDomain[index] = value
    def get_ReferenceVariable(self):
        return self.ReferenceVariable
    def set_ReferenceVariable(self, ReferenceVariable):
        self.ReferenceVariable = ReferenceVariable
    def add_ReferenceVariable(self, value):
        self.ReferenceVariable.append(value)
    def insert_ReferenceVariable_at(self, index, value):
        self.ReferenceVariable.insert(index, value)
    def replace_ReferenceVariable_at(self, index, value):
        self.ReferenceVariable[index] = value
    def get_RepresentedVariable(self):
        return self.RepresentedVariable
    def set_RepresentedVariable(self, RepresentedVariable):
        self.RepresentedVariable = RepresentedVariable
    def add_RepresentedVariable(self, value):
        self.RepresentedVariable.append(value)
    def insert_RepresentedVariable_at(self, index, value):
        self.RepresentedVariable.insert(index, value)
    def replace_RepresentedVariable_at(self, index, value):
        self.RepresentedVariable[index] = value
    def get_RevisableDatum(self):
        return self.RevisableDatum
    def set_RevisableDatum(self, RevisableDatum):
        self.RevisableDatum = RevisableDatum
    def add_RevisableDatum(self, value):
        self.RevisableDatum.append(value)
    def insert_RevisableDatum_at(self, index, value):
        self.RevisableDatum.insert(index, value)
    def replace_RevisableDatum_at(self, index, value):
        self.RevisableDatum[index] = value
    def get_Revision(self):
        return self.Revision
    def set_Revision(self, Revision):
        self.Revision = Revision
    def add_Revision(self, value):
        self.Revision.append(value)
    def insert_Revision_at(self, index, value):
        self.Revision.insert(index, value)
    def replace_Revision_at(self, index, value):
        self.Revision[index] = value
    def get_Rule(self):
        return self.Rule
    def set_Rule(self, Rule):
        self.Rule = Rule
    def add_Rule(self, value):
        self.Rule.append(value)
    def insert_Rule_at(self, index, value):
        self.Rule.insert(index, value)
    def replace_Rule_at(self, index, value):
        self.Rule[index] = value
    def get_RuleBasedScheduling(self):
        return self.RuleBasedScheduling
    def set_RuleBasedScheduling(self, RuleBasedScheduling):
        self.RuleBasedScheduling = RuleBasedScheduling
    def add_RuleBasedScheduling(self, value):
        self.RuleBasedScheduling.append(value)
    def insert_RuleBasedScheduling_at(self, index, value):
        self.RuleBasedScheduling.insert(index, value)
    def replace_RuleBasedScheduling_at(self, index, value):
        self.RuleBasedScheduling[index] = value
    def get_RuleSet(self):
        return self.RuleSet
    def set_RuleSet(self, RuleSet):
        self.RuleSet = RuleSet
    def add_RuleSet(self, value):
        self.RuleSet.append(value)
    def insert_RuleSet_at(self, index, value):
        self.RuleSet.insert(index, value)
    def replace_RuleSet_at(self, index, value):
        self.RuleSet[index] = value
    def get_ScopedMeasure(self):
        return self.ScopedMeasure
    def set_ScopedMeasure(self, ScopedMeasure):
        self.ScopedMeasure = ScopedMeasure
    def add_ScopedMeasure(self, value):
        self.ScopedMeasure.append(value)
    def insert_ScopedMeasure_at(self, index, value):
        self.ScopedMeasure.insert(index, value)
    def replace_ScopedMeasure_at(self, index, value):
        self.ScopedMeasure[index] = value
    def get_SegmentByText(self):
        return self.SegmentByText
    def set_SegmentByText(self, SegmentByText):
        self.SegmentByText = SegmentByText
    def add_SegmentByText(self, value):
        self.SegmentByText.append(value)
    def insert_SegmentByText_at(self, index, value):
        self.SegmentByText.insert(index, value)
    def replace_SegmentByText_at(self, index, value):
        self.SegmentByText[index] = value
    def get_SentinelConceptualDomain(self):
        return self.SentinelConceptualDomain
    def set_SentinelConceptualDomain(self, SentinelConceptualDomain):
        self.SentinelConceptualDomain = SentinelConceptualDomain
    def add_SentinelConceptualDomain(self, value):
        self.SentinelConceptualDomain.append(value)
    def insert_SentinelConceptualDomain_at(self, index, value):
        self.SentinelConceptualDomain.insert(index, value)
    def replace_SentinelConceptualDomain_at(self, index, value):
        self.SentinelConceptualDomain[index] = value
    def get_SentinelValueDomain(self):
        return self.SentinelValueDomain
    def set_SentinelValueDomain(self, SentinelValueDomain):
        self.SentinelValueDomain = SentinelValueDomain
    def add_SentinelValueDomain(self, value):
        self.SentinelValueDomain.append(value)
    def insert_SentinelValueDomain_at(self, index, value):
        self.SentinelValueDomain.insert(index, value)
    def replace_SentinelValueDomain_at(self, index, value):
        self.SentinelValueDomain[index] = value
    def get_Sequence(self):
        return self.Sequence
    def set_Sequence(self, Sequence):
        self.Sequence = Sequence
    def add_Sequence(self, value):
        self.Sequence.append(value)
    def insert_Sequence_at(self, index, value):
        self.Sequence.insert(index, value)
    def replace_Sequence_at(self, index, value):
        self.Sequence[index] = value
    def get_SequencePosition(self):
        return self.SequencePosition
    def set_SequencePosition(self, SequencePosition):
        self.SequencePosition = SequencePosition
    def add_SequencePosition(self, value):
        self.SequencePosition.append(value)
    def insert_SequencePosition_at(self, index, value):
        self.SequencePosition.insert(index, value)
    def replace_SequencePosition_at(self, index, value):
        self.SequencePosition[index] = value
    def get_Service(self):
        return self.Service
    def set_Service(self, Service):
        self.Service = Service
    def add_Service(self, value):
        self.Service.append(value)
    def insert_Service_at(self, index, value):
        self.Service.insert(index, value)
    def replace_Service_at(self, index, value):
        self.Service[index] = value
    def get_StatisticalClassification(self):
        return self.StatisticalClassification
    def set_StatisticalClassification(self, StatisticalClassification):
        self.StatisticalClassification = StatisticalClassification
    def add_StatisticalClassification(self, value):
        self.StatisticalClassification.append(value)
    def insert_StatisticalClassification_at(self, index, value):
        self.StatisticalClassification.insert(index, value)
    def replace_StatisticalClassification_at(self, index, value):
        self.StatisticalClassification[index] = value
    def get_StatisticalClassificationRelationship(self):
        return self.StatisticalClassificationRelationship
    def set_StatisticalClassificationRelationship(self, StatisticalClassificationRelationship):
        self.StatisticalClassificationRelationship = StatisticalClassificationRelationship
    def add_StatisticalClassificationRelationship(self, value):
        self.StatisticalClassificationRelationship.append(value)
    def insert_StatisticalClassificationRelationship_at(self, index, value):
        self.StatisticalClassificationRelationship.insert(index, value)
    def replace_StatisticalClassificationRelationship_at(self, index, value):
        self.StatisticalClassificationRelationship[index] = value
    def get_Step(self):
        return self.Step
    def set_Step(self, Step):
        self.Step = Step
    def add_Step(self, value):
        self.Step.append(value)
    def insert_Step_at(self, index, value):
        self.Step.insert(index, value)
    def replace_Step_at(self, index, value):
        self.Step[index] = value
    def get_SubstantiveConceptualDomain(self):
        return self.SubstantiveConceptualDomain
    def set_SubstantiveConceptualDomain(self, SubstantiveConceptualDomain):
        self.SubstantiveConceptualDomain = SubstantiveConceptualDomain
    def add_SubstantiveConceptualDomain(self, value):
        self.SubstantiveConceptualDomain.append(value)
    def insert_SubstantiveConceptualDomain_at(self, index, value):
        self.SubstantiveConceptualDomain.insert(index, value)
    def replace_SubstantiveConceptualDomain_at(self, index, value):
        self.SubstantiveConceptualDomain[index] = value
    def get_SubstantiveValueDomain(self):
        return self.SubstantiveValueDomain
    def set_SubstantiveValueDomain(self, SubstantiveValueDomain):
        self.SubstantiveValueDomain = SubstantiveValueDomain
    def add_SubstantiveValueDomain(self, value):
        self.SubstantiveValueDomain.append(value)
    def insert_SubstantiveValueDomain_at(self, index, value):
        self.SubstantiveValueDomain.insert(index, value)
    def replace_SubstantiveValueDomain_at(self, index, value):
        self.SubstantiveValueDomain[index] = value
    def get_SyntheticIdComponent(self):
        return self.SyntheticIdComponent
    def set_SyntheticIdComponent(self, SyntheticIdComponent):
        self.SyntheticIdComponent = SyntheticIdComponent
    def add_SyntheticIdComponent(self, value):
        self.SyntheticIdComponent.append(value)
    def insert_SyntheticIdComponent_at(self, index, value):
        self.SyntheticIdComponent.insert(index, value)
    def replace_SyntheticIdComponent_at(self, index, value):
        self.SyntheticIdComponent[index] = value
    def get_TemporalConstraints(self):
        return self.TemporalConstraints
    def set_TemporalConstraints(self, TemporalConstraints):
        self.TemporalConstraints = TemporalConstraints
    def add_TemporalConstraints(self, value):
        self.TemporalConstraints.append(value)
    def insert_TemporalConstraints_at(self, index, value):
        self.TemporalConstraints.insert(index, value)
    def replace_TemporalConstraints_at(self, index, value):
        self.TemporalConstraints[index] = value
    def get_TemporalControlConstruct(self):
        return self.TemporalControlConstruct
    def set_TemporalControlConstruct(self, TemporalControlConstruct):
        self.TemporalControlConstruct = TemporalControlConstruct
    def add_TemporalControlConstruct(self, value):
        self.TemporalControlConstruct.append(value)
    def insert_TemporalControlConstruct_at(self, index, value):
        self.TemporalControlConstruct.insert(index, value)
    def replace_TemporalControlConstruct_at(self, index, value):
        self.TemporalControlConstruct[index] = value
    def get_Unit(self):
        return self.Unit
    def set_Unit(self, Unit):
        self.Unit = Unit
    def add_Unit(self, value):
        self.Unit.append(value)
    def insert_Unit_at(self, index, value):
        self.Unit.insert(index, value)
    def replace_Unit_at(self, index, value):
        self.Unit[index] = value
    def get_UnitSegmentLayout(self):
        return self.UnitSegmentLayout
    def set_UnitSegmentLayout(self, UnitSegmentLayout):
        self.UnitSegmentLayout = UnitSegmentLayout
    def add_UnitSegmentLayout(self, value):
        self.UnitSegmentLayout.append(value)
    def insert_UnitSegmentLayout_at(self, index, value):
        self.UnitSegmentLayout.insert(index, value)
    def replace_UnitSegmentLayout_at(self, index, value):
        self.UnitSegmentLayout[index] = value
    def get_UnitType(self):
        return self.UnitType
    def set_UnitType(self, UnitType):
        self.UnitType = UnitType
    def add_UnitType(self, value):
        self.UnitType.append(value)
    def insert_UnitType_at(self, index, value):
        self.UnitType.insert(index, value)
    def replace_UnitType_at(self, index, value):
        self.UnitType[index] = value
    def get_Universe(self):
        return self.Universe
    def set_Universe(self, Universe):
        self.Universe = Universe
    def add_Universe(self, value):
        self.Universe.append(value)
    def insert_Universe_at(self, index, value):
        self.Universe.insert(index, value)
    def replace_Universe_at(self, index, value):
        self.Universe[index] = value
    def get_ValueAndConceptDescription(self):
        return self.ValueAndConceptDescription
    def set_ValueAndConceptDescription(self, ValueAndConceptDescription):
        self.ValueAndConceptDescription = ValueAndConceptDescription
    def add_ValueAndConceptDescription(self, value):
        self.ValueAndConceptDescription.append(value)
    def insert_ValueAndConceptDescription_at(self, index, value):
        self.ValueAndConceptDescription.insert(index, value)
    def replace_ValueAndConceptDescription_at(self, index, value):
        self.ValueAndConceptDescription[index] = value
    def get_ValueDomain(self):
        return self.ValueDomain
    def set_ValueDomain(self, ValueDomain):
        self.ValueDomain = ValueDomain
    def add_ValueDomain(self, value):
        self.ValueDomain.append(value)
    def insert_ValueDomain_at(self, index, value):
        self.ValueDomain.insert(index, value)
    def replace_ValueDomain_at(self, index, value):
        self.ValueDomain[index] = value
    def get_ValueMapping(self):
        return self.ValueMapping
    def set_ValueMapping(self, ValueMapping):
        self.ValueMapping = ValueMapping
    def add_ValueMapping(self, value):
        self.ValueMapping.append(value)
    def insert_ValueMapping_at(self, index, value):
        self.ValueMapping.insert(index, value)
    def replace_ValueMapping_at(self, index, value):
        self.ValueMapping[index] = value
    def get_ValueMappingPosition(self):
        return self.ValueMappingPosition
    def set_ValueMappingPosition(self, ValueMappingPosition):
        self.ValueMappingPosition = ValueMappingPosition
    def add_ValueMappingPosition(self, value):
        self.ValueMappingPosition.append(value)
    def insert_ValueMappingPosition_at(self, index, value):
        self.ValueMappingPosition.insert(index, value)
    def replace_ValueMappingPosition_at(self, index, value):
        self.ValueMappingPosition[index] = value
    def get_ValueMappingRelationship(self):
        return self.ValueMappingRelationship
    def set_ValueMappingRelationship(self, ValueMappingRelationship):
        self.ValueMappingRelationship = ValueMappingRelationship
    def add_ValueMappingRelationship(self, value):
        self.ValueMappingRelationship.append(value)
    def insert_ValueMappingRelationship_at(self, index, value):
        self.ValueMappingRelationship.insert(index, value)
    def replace_ValueMappingRelationship_at(self, index, value):
        self.ValueMappingRelationship[index] = value
    def get_VariableCollection(self):
        return self.VariableCollection
    def set_VariableCollection(self, VariableCollection):
        self.VariableCollection = VariableCollection
    def add_VariableCollection(self, value):
        self.VariableCollection.append(value)
    def insert_VariableCollection_at(self, index, value):
        self.VariableCollection.insert(index, value)
    def replace_VariableCollection_at(self, index, value):
        self.VariableCollection[index] = value
    def get_VariableDescriptorComponent(self):
        return self.VariableDescriptorComponent
    def set_VariableDescriptorComponent(self, VariableDescriptorComponent):
        self.VariableDescriptorComponent = VariableDescriptorComponent
    def add_VariableDescriptorComponent(self, value):
        self.VariableDescriptorComponent.append(value)
    def insert_VariableDescriptorComponent_at(self, index, value):
        self.VariableDescriptorComponent.insert(index, value)
    def replace_VariableDescriptorComponent_at(self, index, value):
        self.VariableDescriptorComponent[index] = value
    def get_VariablePosition(self):
        return self.VariablePosition
    def set_VariablePosition(self, VariablePosition):
        self.VariablePosition = VariablePosition
    def add_VariablePosition(self, value):
        self.VariablePosition.append(value)
    def insert_VariablePosition_at(self, index, value):
        self.VariablePosition.insert(index, value)
    def replace_VariablePosition_at(self, index, value):
        self.VariablePosition[index] = value
    def get_VariableRelationship(self):
        return self.VariableRelationship
    def set_VariableRelationship(self, VariableRelationship):
        self.VariableRelationship = VariableRelationship
    def add_VariableRelationship(self, value):
        self.VariableRelationship.append(value)
    def insert_VariableRelationship_at(self, index, value):
        self.VariableRelationship.insert(index, value)
    def replace_VariableRelationship_at(self, index, value):
        self.VariableRelationship[index] = value
    def get_VariableStructure(self):
        return self.VariableStructure
    def set_VariableStructure(self, VariableStructure):
        self.VariableStructure = VariableStructure
    def add_VariableStructure(self, value):
        self.VariableStructure.append(value)
    def insert_VariableStructure_at(self, index, value):
        self.VariableStructure.insert(index, value)
    def replace_VariableStructure_at(self, index, value):
        self.VariableStructure[index] = value
    def get_VariableValueComponent(self):
        return self.VariableValueComponent
    def set_VariableValueComponent(self, VariableValueComponent):
        self.VariableValueComponent = VariableValueComponent
    def add_VariableValueComponent(self, value):
        self.VariableValueComponent.append(value)
    def insert_VariableValueComponent_at(self, index, value):
        self.VariableValueComponent.insert(index, value)
    def replace_VariableValueComponent_at(self, index, value):
        self.VariableValueComponent[index] = value
    def get_WideDataSet(self):
        return self.WideDataSet
    def set_WideDataSet(self, WideDataSet):
        self.WideDataSet = WideDataSet
    def add_WideDataSet(self, value):
        self.WideDataSet.append(value)
    def insert_WideDataSet_at(self, index, value):
        self.WideDataSet.insert(index, value)
    def replace_WideDataSet_at(self, index, value):
        self.WideDataSet[index] = value
    def get_WideDataStructure(self):
        return self.WideDataStructure
    def set_WideDataStructure(self, WideDataStructure):
        self.WideDataStructure = WideDataStructure
    def add_WideDataStructure(self, value):
        self.WideDataStructure.append(value)
    def insert_WideDataStructure_at(self, index, value):
        self.WideDataStructure.insert(index, value)
    def replace_WideDataStructure_at(self, index, value):
        self.WideDataStructure[index] = value
    def get_WideKey(self):
        return self.WideKey
    def set_WideKey(self, WideKey):
        self.WideKey = WideKey
    def add_WideKey(self, value):
        self.WideKey.append(value)
    def insert_WideKey_at(self, index, value):
        self.WideKey.insert(index, value)
    def replace_WideKey_at(self, index, value):
        self.WideKey[index] = value
    def get_WideKeyMember(self):
        return self.WideKeyMember
    def set_WideKeyMember(self, WideKeyMember):
        self.WideKeyMember = WideKeyMember
    def add_WideKeyMember(self, value):
        self.WideKeyMember.append(value)
    def insert_WideKeyMember_at(self, index, value):
        self.WideKeyMember.insert(index, value)
    def replace_WideKeyMember_at(self, index, value):
        self.WideKeyMember[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.supportingInformation or
            self.Activity or
            self.Agent or
            self.AgentListing or
            self.AgentPosition or
            self.AgentRelationship or
            self.AgentStructure or
            self.AllenIntervalAlgebra or
            self.AttributeComponent or
            self.AuthorizationSource or
            self.Category or
            self.CategoryPosition or
            self.CategoryRelationStructure or
            self.CategoryRelationship or
            self.CategorySet or
            self.CategoryStatistic or
            self.ClassificationFamily or
            self.ClassificationIndex or
            self.ClassificationIndexEntry or
            self.ClassificationIndexEntryPosition or
            self.ClassificationItem or
            self.ClassificationItemPosition or
            self.ClassificationItemRelationship or
            self.ClassificationItemStructure or
            self.ClassificationPosition or
            self.ClassificationSeries or
            self.ClassificationSeriesStructure or
            self.Code or
            self.CodeList or
            self.CodeListStructure or
            self.CodePosition or
            self.CodeRelationship or
            self.ComponentPosition or
            self.Concept or
            self.ConceptMap or
            self.ConceptRelationship or
            self.ConceptStructure or
            self.ConceptSystem or
            self.ConceptSystemCorrespondence or
            self.ConceptualDomain or
            self.ConceptualValue or
            self.ConceptualVariable or
            self.ConditionalControlLogic or
            self.ContextualComponent or
            self.ControlLogic or
            self.CorrespondenceTable or
            self.Curator or
            self.DataPoint or
            self.DataPointPosition or
            self.DataPointRelationship or
            self.DataSet or
            self.DataStore or
            self.DataStructure or
            self.DataStructureComponent or
            self.Datum or
            self.Descriptor or
            self.DescriptorValueDomain or
            self.DescriptorVariable or
            self.DeterministicImperative or
            self.DimensionComponent or
            self.DimensionGroup or
            self.DimensionalDataSet or
            self.DimensionalDataStructure or
            self.DimensionalKey or
            self.DimensionalKeyDefinition or
            self.DimensionalKeyDefinitionMember or
            self.DimensionalKeyMember or
            self.EnumerationDomain or
            self.ForeignKey or
            self.ForeignKeyComponent or
            self.IdentifierComponent or
            self.Individual or
            self.InformationFlowDefinition or
            self.InstanceKey or
            self.InstanceValue or
            self.InstanceVariable or
            self.InstanceVariableMap or
            self.Key or
            self.KeyDefinition or
            self.KeyDefinitionMember or
            self.KeyMember or
            self.KeyValueDataStore or
            self.KeyValueStructure or
            self.Level or
            self.LevelStructure or
            self.LogicalRecord or
            self.LogicalRecordPosition or
            self.LogicalRecordRelationStructure or
            self.LogicalRecordRelationship or
            self.LongDataSet or
            self.LongDataStructure or
            self.LongKey or
            self.LongMainKeyMember or
            self.Machine or
            self.MainKeyMember or
            self.MeasureComponent or
            self.NonDeterministicDeclarative or
            self.Notation or
            self.Organization or
            self.Parameter or
            self.PhysicalDataSet or
            self.PhysicalDataSetStructure or
            self.PhysicalLayoutRelationStructure or
            self.PhysicalRecordSegment or
            self.PhysicalRecordSegmentPosition or
            self.PhysicalRecordSegmentRelationship or
            self.PhysicalRecordSegmentStructure or
            self.PhysicalSegmentLayout or
            self.PhysicalSegmentLocation or
            self.Population or
            self.PrimaryKey or
            self.PrimaryKeyComponent or
            self.ProcessingAgent or
            self.ProductionEnvironment or
            self.QualifiedMeasure or
            self.RecordRelation or
            self.ReferenceValue or
            self.ReferenceValueDomain or
            self.ReferenceVariable or
            self.RepresentedVariable or
            self.RevisableDatum or
            self.Revision or
            self.Rule or
            self.RuleBasedScheduling or
            self.RuleSet or
            self.ScopedMeasure or
            self.SegmentByText or
            self.SentinelConceptualDomain or
            self.SentinelValueDomain or
            self.Sequence or
            self.SequencePosition or
            self.Service or
            self.StatisticalClassification or
            self.StatisticalClassificationRelationship or
            self.Step or
            self.SubstantiveConceptualDomain or
            self.SubstantiveValueDomain or
            self.SyntheticIdComponent or
            self.TemporalConstraints or
            self.TemporalControlConstruct or
            self.Unit or
            self.UnitSegmentLayout or
            self.UnitType or
            self.Universe or
            self.ValueAndConceptDescription or
            self.ValueDomain or
            self.ValueMapping or
            self.ValueMappingPosition or
            self.ValueMappingRelationship or
            self.VariableCollection or
            self.VariableDescriptorComponent or
            self.VariablePosition or
            self.VariableRelationship or
            self.VariableStructure or
            self.VariableValueComponent or
            self.WideDataSet or
            self.WideDataStructure or
            self.WideKey or
            self.WideKeyMember
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Wrapper', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for supportingInformation_ in self.supportingInformation:
            supportingInformation_.to_etree(element, name_='supportingInformation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Activity_ in self.Activity:
            Activity_.to_etree(element, name_='Activity', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Agent_ in self.Agent:
            Agent_.to_etree(element, name_='Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AgentListing_ in self.AgentListing:
            AgentListing_.to_etree(element, name_='AgentListing', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AgentPosition_ in self.AgentPosition:
            AgentPosition_.to_etree(element, name_='AgentPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AgentRelationship_ in self.AgentRelationship:
            AgentRelationship_.to_etree(element, name_='AgentRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AgentStructure_ in self.AgentStructure:
            AgentStructure_.to_etree(element, name_='AgentStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AllenIntervalAlgebra_ in self.AllenIntervalAlgebra:
            AllenIntervalAlgebra_.to_etree(element, name_='AllenIntervalAlgebra', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AttributeComponent_ in self.AttributeComponent:
            AttributeComponent_.to_etree(element, name_='AttributeComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AuthorizationSource_ in self.AuthorizationSource:
            AuthorizationSource_.to_etree(element, name_='AuthorizationSource', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Category_ in self.Category:
            Category_.to_etree(element, name_='Category', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategoryPosition_ in self.CategoryPosition:
            CategoryPosition_.to_etree(element, name_='CategoryPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategoryRelationStructure_ in self.CategoryRelationStructure:
            CategoryRelationStructure_.to_etree(element, name_='CategoryRelationStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategoryRelationship_ in self.CategoryRelationship:
            CategoryRelationship_.to_etree(element, name_='CategoryRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategorySet_ in self.CategorySet:
            CategorySet_.to_etree(element, name_='CategorySet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategoryStatistic_ in self.CategoryStatistic:
            CategoryStatistic_.to_etree(element, name_='CategoryStatistic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationFamily_ in self.ClassificationFamily:
            ClassificationFamily_.to_etree(element, name_='ClassificationFamily', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationIndex_ in self.ClassificationIndex:
            ClassificationIndex_.to_etree(element, name_='ClassificationIndex', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationIndexEntry_ in self.ClassificationIndexEntry:
            ClassificationIndexEntry_.to_etree(element, name_='ClassificationIndexEntry', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationIndexEntryPosition_ in self.ClassificationIndexEntryPosition:
            ClassificationIndexEntryPosition_.to_etree(element, name_='ClassificationIndexEntryPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationItem_ in self.ClassificationItem:
            ClassificationItem_.to_etree(element, name_='ClassificationItem', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationItemPosition_ in self.ClassificationItemPosition:
            ClassificationItemPosition_.to_etree(element, name_='ClassificationItemPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationItemRelationship_ in self.ClassificationItemRelationship:
            ClassificationItemRelationship_.to_etree(element, name_='ClassificationItemRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationItemStructure_ in self.ClassificationItemStructure:
            ClassificationItemStructure_.to_etree(element, name_='ClassificationItemStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationPosition_ in self.ClassificationPosition:
            ClassificationPosition_.to_etree(element, name_='ClassificationPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationSeries_ in self.ClassificationSeries:
            ClassificationSeries_.to_etree(element, name_='ClassificationSeries', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationSeriesStructure_ in self.ClassificationSeriesStructure:
            ClassificationSeriesStructure_.to_etree(element, name_='ClassificationSeriesStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Code_ in self.Code:
            Code_.to_etree(element, name_='Code', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CodeList_ in self.CodeList:
            CodeList_.to_etree(element, name_='CodeList', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CodeListStructure_ in self.CodeListStructure:
            CodeListStructure_.to_etree(element, name_='CodeListStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CodePosition_ in self.CodePosition:
            CodePosition_.to_etree(element, name_='CodePosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CodeRelationship_ in self.CodeRelationship:
            CodeRelationship_.to_etree(element, name_='CodeRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ComponentPosition_ in self.ComponentPosition:
            ComponentPosition_.to_etree(element, name_='ComponentPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Concept_ in self.Concept:
            Concept_.to_etree(element, name_='Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptMap_ in self.ConceptMap:
            ConceptMap_.to_etree(element, name_='ConceptMap', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptRelationship_ in self.ConceptRelationship:
            ConceptRelationship_.to_etree(element, name_='ConceptRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptStructure_ in self.ConceptStructure:
            ConceptStructure_.to_etree(element, name_='ConceptStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptSystem_ in self.ConceptSystem:
            ConceptSystem_.to_etree(element, name_='ConceptSystem', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptSystemCorrespondence_ in self.ConceptSystemCorrespondence:
            ConceptSystemCorrespondence_.to_etree(element, name_='ConceptSystemCorrespondence', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptualDomain_ in self.ConceptualDomain:
            ConceptualDomain_.to_etree(element, name_='ConceptualDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptualValue_ in self.ConceptualValue:
            ConceptualValue_.to_etree(element, name_='ConceptualValue', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptualVariable_ in self.ConceptualVariable:
            ConceptualVariable_.to_etree(element, name_='ConceptualVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConditionalControlLogic_ in self.ConditionalControlLogic:
            ConditionalControlLogic_.to_etree(element, name_='ConditionalControlLogic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ContextualComponent_ in self.ContextualComponent:
            ContextualComponent_.to_etree(element, name_='ContextualComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ControlLogic_ in self.ControlLogic:
            ControlLogic_.to_etree(element, name_='ControlLogic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CorrespondenceTable_ in self.CorrespondenceTable:
            CorrespondenceTable_.to_etree(element, name_='CorrespondenceTable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Curator_ in self.Curator:
            Curator_.to_etree(element, name_='Curator', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataPoint_ in self.DataPoint:
            DataPoint_.to_etree(element, name_='DataPoint', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataPointPosition_ in self.DataPointPosition:
            DataPointPosition_.to_etree(element, name_='DataPointPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataPointRelationship_ in self.DataPointRelationship:
            DataPointRelationship_.to_etree(element, name_='DataPointRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataSet_ in self.DataSet:
            DataSet_.to_etree(element, name_='DataSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataStore_ in self.DataStore:
            DataStore_.to_etree(element, name_='DataStore', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataStructure_ in self.DataStructure:
            DataStructure_.to_etree(element, name_='DataStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataStructureComponent_ in self.DataStructureComponent:
            DataStructureComponent_.to_etree(element, name_='DataStructureComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Datum_ in self.Datum:
            Datum_.to_etree(element, name_='Datum', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Descriptor_ in self.Descriptor:
            Descriptor_.to_etree(element, name_='Descriptor', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DescriptorValueDomain_ in self.DescriptorValueDomain:
            DescriptorValueDomain_.to_etree(element, name_='DescriptorValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DescriptorVariable_ in self.DescriptorVariable:
            DescriptorVariable_.to_etree(element, name_='DescriptorVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DeterministicImperative_ in self.DeterministicImperative:
            DeterministicImperative_.to_etree(element, name_='DeterministicImperative', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionComponent_ in self.DimensionComponent:
            DimensionComponent_.to_etree(element, name_='DimensionComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionGroup_ in self.DimensionGroup:
            DimensionGroup_.to_etree(element, name_='DimensionGroup', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionalDataSet_ in self.DimensionalDataSet:
            DimensionalDataSet_.to_etree(element, name_='DimensionalDataSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionalDataStructure_ in self.DimensionalDataStructure:
            DimensionalDataStructure_.to_etree(element, name_='DimensionalDataStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionalKey_ in self.DimensionalKey:
            DimensionalKey_.to_etree(element, name_='DimensionalKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionalKeyDefinition_ in self.DimensionalKeyDefinition:
            DimensionalKeyDefinition_.to_etree(element, name_='DimensionalKeyDefinition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionalKeyDefinitionMember_ in self.DimensionalKeyDefinitionMember:
            DimensionalKeyDefinitionMember_.to_etree(element, name_='DimensionalKeyDefinitionMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionalKeyMember_ in self.DimensionalKeyMember:
            DimensionalKeyMember_.to_etree(element, name_='DimensionalKeyMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for EnumerationDomain_ in self.EnumerationDomain:
            EnumerationDomain_.to_etree(element, name_='EnumerationDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ForeignKey_ in self.ForeignKey:
            ForeignKey_.to_etree(element, name_='ForeignKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ForeignKeyComponent_ in self.ForeignKeyComponent:
            ForeignKeyComponent_.to_etree(element, name_='ForeignKeyComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for IdentifierComponent_ in self.IdentifierComponent:
            IdentifierComponent_.to_etree(element, name_='IdentifierComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Individual_ in self.Individual:
            Individual_.to_etree(element, name_='Individual', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for InformationFlowDefinition_ in self.InformationFlowDefinition:
            InformationFlowDefinition_.to_etree(element, name_='InformationFlowDefinition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for InstanceKey_ in self.InstanceKey:
            InstanceKey_.to_etree(element, name_='InstanceKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for InstanceValue_ in self.InstanceValue:
            InstanceValue_.to_etree(element, name_='InstanceValue', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for InstanceVariable_ in self.InstanceVariable:
            InstanceVariable_.to_etree(element, name_='InstanceVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for InstanceVariableMap_ in self.InstanceVariableMap:
            InstanceVariableMap_.to_etree(element, name_='InstanceVariableMap', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Key_ in self.Key:
            Key_.to_etree(element, name_='Key', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for KeyDefinition_ in self.KeyDefinition:
            KeyDefinition_.to_etree(element, name_='KeyDefinition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for KeyDefinitionMember_ in self.KeyDefinitionMember:
            KeyDefinitionMember_.to_etree(element, name_='KeyDefinitionMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for KeyMember_ in self.KeyMember:
            KeyMember_.to_etree(element, name_='KeyMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for KeyValueDataStore_ in self.KeyValueDataStore:
            KeyValueDataStore_.to_etree(element, name_='KeyValueDataStore', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for KeyValueStructure_ in self.KeyValueStructure:
            KeyValueStructure_.to_etree(element, name_='KeyValueStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Level_ in self.Level:
            Level_.to_etree(element, name_='Level', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LevelStructure_ in self.LevelStructure:
            LevelStructure_.to_etree(element, name_='LevelStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecord_ in self.LogicalRecord:
            LogicalRecord_.to_etree(element, name_='LogicalRecord', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecordPosition_ in self.LogicalRecordPosition:
            LogicalRecordPosition_.to_etree(element, name_='LogicalRecordPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecordRelationStructure_ in self.LogicalRecordRelationStructure:
            LogicalRecordRelationStructure_.to_etree(element, name_='LogicalRecordRelationStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecordRelationship_ in self.LogicalRecordRelationship:
            LogicalRecordRelationship_.to_etree(element, name_='LogicalRecordRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LongDataSet_ in self.LongDataSet:
            LongDataSet_.to_etree(element, name_='LongDataSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LongDataStructure_ in self.LongDataStructure:
            LongDataStructure_.to_etree(element, name_='LongDataStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LongKey_ in self.LongKey:
            LongKey_.to_etree(element, name_='LongKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LongMainKeyMember_ in self.LongMainKeyMember:
            LongMainKeyMember_.to_etree(element, name_='LongMainKeyMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Machine_ in self.Machine:
            Machine_.to_etree(element, name_='Machine', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for MainKeyMember_ in self.MainKeyMember:
            MainKeyMember_.to_etree(element, name_='MainKeyMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for MeasureComponent_ in self.MeasureComponent:
            MeasureComponent_.to_etree(element, name_='MeasureComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for NonDeterministicDeclarative_ in self.NonDeterministicDeclarative:
            NonDeterministicDeclarative_.to_etree(element, name_='NonDeterministicDeclarative', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Notation_ in self.Notation:
            Notation_.to_etree(element, name_='Notation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Organization_ in self.Organization:
            Organization_.to_etree(element, name_='Organization', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Parameter_ in self.Parameter:
            Parameter_.to_etree(element, name_='Parameter', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalDataSet_ in self.PhysicalDataSet:
            PhysicalDataSet_.to_etree(element, name_='PhysicalDataSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalDataSetStructure_ in self.PhysicalDataSetStructure:
            PhysicalDataSetStructure_.to_etree(element, name_='PhysicalDataSetStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalLayoutRelationStructure_ in self.PhysicalLayoutRelationStructure:
            PhysicalLayoutRelationStructure_.to_etree(element, name_='PhysicalLayoutRelationStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalRecordSegment_ in self.PhysicalRecordSegment:
            PhysicalRecordSegment_.to_etree(element, name_='PhysicalRecordSegment', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalRecordSegmentPosition_ in self.PhysicalRecordSegmentPosition:
            PhysicalRecordSegmentPosition_.to_etree(element, name_='PhysicalRecordSegmentPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalRecordSegmentRelationship_ in self.PhysicalRecordSegmentRelationship:
            PhysicalRecordSegmentRelationship_.to_etree(element, name_='PhysicalRecordSegmentRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalRecordSegmentStructure_ in self.PhysicalRecordSegmentStructure:
            PhysicalRecordSegmentStructure_.to_etree(element, name_='PhysicalRecordSegmentStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalSegmentLayout_ in self.PhysicalSegmentLayout:
            PhysicalSegmentLayout_.to_etree(element, name_='PhysicalSegmentLayout', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalSegmentLocation_ in self.PhysicalSegmentLocation:
            PhysicalSegmentLocation_.to_etree(element, name_='PhysicalSegmentLocation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Population_ in self.Population:
            Population_.to_etree(element, name_='Population', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PrimaryKey_ in self.PrimaryKey:
            PrimaryKey_.to_etree(element, name_='PrimaryKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PrimaryKeyComponent_ in self.PrimaryKeyComponent:
            PrimaryKeyComponent_.to_etree(element, name_='PrimaryKeyComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ProcessingAgent_ in self.ProcessingAgent:
            ProcessingAgent_.to_etree(element, name_='ProcessingAgent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ProductionEnvironment_ in self.ProductionEnvironment:
            ProductionEnvironment_.to_etree(element, name_='ProductionEnvironment', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for QualifiedMeasure_ in self.QualifiedMeasure:
            QualifiedMeasure_.to_etree(element, name_='QualifiedMeasure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RecordRelation_ in self.RecordRelation:
            RecordRelation_.to_etree(element, name_='RecordRelation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ReferenceValue_ in self.ReferenceValue:
            ReferenceValue_.to_etree(element, name_='ReferenceValue', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ReferenceValueDomain_ in self.ReferenceValueDomain:
            ReferenceValueDomain_.to_etree(element, name_='ReferenceValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ReferenceVariable_ in self.ReferenceVariable:
            ReferenceVariable_.to_etree(element, name_='ReferenceVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RepresentedVariable_ in self.RepresentedVariable:
            RepresentedVariable_.to_etree(element, name_='RepresentedVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RevisableDatum_ in self.RevisableDatum:
            RevisableDatum_.to_etree(element, name_='RevisableDatum', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Revision_ in self.Revision:
            Revision_.to_etree(element, name_='Revision', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Rule_ in self.Rule:
            Rule_.to_etree(element, name_='Rule', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RuleBasedScheduling_ in self.RuleBasedScheduling:
            RuleBasedScheduling_.to_etree(element, name_='RuleBasedScheduling', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RuleSet_ in self.RuleSet:
            RuleSet_.to_etree(element, name_='RuleSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ScopedMeasure_ in self.ScopedMeasure:
            ScopedMeasure_.to_etree(element, name_='ScopedMeasure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SegmentByText_ in self.SegmentByText:
            SegmentByText_.to_etree(element, name_='SegmentByText', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SentinelConceptualDomain_ in self.SentinelConceptualDomain:
            SentinelConceptualDomain_.to_etree(element, name_='SentinelConceptualDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SentinelValueDomain_ in self.SentinelValueDomain:
            SentinelValueDomain_.to_etree(element, name_='SentinelValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Sequence_ in self.Sequence:
            Sequence_.to_etree(element, name_='Sequence', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SequencePosition_ in self.SequencePosition:
            SequencePosition_.to_etree(element, name_='SequencePosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Service_ in self.Service:
            Service_.to_etree(element, name_='Service', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for StatisticalClassification_ in self.StatisticalClassification:
            StatisticalClassification_.to_etree(element, name_='StatisticalClassification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for StatisticalClassificationRelationship_ in self.StatisticalClassificationRelationship:
            StatisticalClassificationRelationship_.to_etree(element, name_='StatisticalClassificationRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Step_ in self.Step:
            Step_.to_etree(element, name_='Step', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SubstantiveConceptualDomain_ in self.SubstantiveConceptualDomain:
            SubstantiveConceptualDomain_.to_etree(element, name_='SubstantiveConceptualDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SubstantiveValueDomain_ in self.SubstantiveValueDomain:
            SubstantiveValueDomain_.to_etree(element, name_='SubstantiveValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for SyntheticIdComponent_ in self.SyntheticIdComponent:
            SyntheticIdComponent_.to_etree(element, name_='SyntheticIdComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for TemporalConstraints_ in self.TemporalConstraints:
            TemporalConstraints_.to_etree(element, name_='TemporalConstraints', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for TemporalControlConstruct_ in self.TemporalControlConstruct:
            TemporalControlConstruct_.to_etree(element, name_='TemporalControlConstruct', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Unit_ in self.Unit:
            Unit_.to_etree(element, name_='Unit', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for UnitSegmentLayout_ in self.UnitSegmentLayout:
            UnitSegmentLayout_.to_etree(element, name_='UnitSegmentLayout', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for UnitType_ in self.UnitType:
            UnitType_.to_etree(element, name_='UnitType', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Universe_ in self.Universe:
            Universe_.to_etree(element, name_='Universe', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ValueAndConceptDescription_ in self.ValueAndConceptDescription:
            ValueAndConceptDescription_.to_etree(element, name_='ValueAndConceptDescription', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ValueDomain_ in self.ValueDomain:
            ValueDomain_.to_etree(element, name_='ValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ValueMapping_ in self.ValueMapping:
            ValueMapping_.to_etree(element, name_='ValueMapping', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ValueMappingPosition_ in self.ValueMappingPosition:
            ValueMappingPosition_.to_etree(element, name_='ValueMappingPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ValueMappingRelationship_ in self.ValueMappingRelationship:
            ValueMappingRelationship_.to_etree(element, name_='ValueMappingRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableCollection_ in self.VariableCollection:
            VariableCollection_.to_etree(element, name_='VariableCollection', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableDescriptorComponent_ in self.VariableDescriptorComponent:
            VariableDescriptorComponent_.to_etree(element, name_='VariableDescriptorComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariablePosition_ in self.VariablePosition:
            VariablePosition_.to_etree(element, name_='VariablePosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableRelationship_ in self.VariableRelationship:
            VariableRelationship_.to_etree(element, name_='VariableRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableStructure_ in self.VariableStructure:
            VariableStructure_.to_etree(element, name_='VariableStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableValueComponent_ in self.VariableValueComponent:
            VariableValueComponent_.to_etree(element, name_='VariableValueComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for WideDataSet_ in self.WideDataSet:
            WideDataSet_.to_etree(element, name_='WideDataSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for WideDataStructure_ in self.WideDataStructure:
            WideDataStructure_.to_etree(element, name_='WideDataStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for WideKey_ in self.WideKey:
            WideKey_.to_etree(element, name_='WideKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for WideKeyMember_ in self.WideKeyMember:
            WideKeyMember_.to_etree(element, name_='WideKeyMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'supportingInformation':
            class_obj_ = self.get_class_obj_(child_, Reference)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supportingInformation.append(obj_)
            obj_.original_tagname_ = 'supportingInformation'
        elif nodeName_ == 'Activity':
            class_obj_ = self.get_class_obj_(child_, Activity)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Activity.append(obj_)
            obj_.original_tagname_ = 'Activity'
        elif nodeName_ == 'Agent':
            class_obj_ = self.get_class_obj_(child_, Agent)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Agent.append(obj_)
            obj_.original_tagname_ = 'Agent'
        elif nodeName_ == 'AgentListing':
            obj_ = AgentListing.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentListing.append(obj_)
            obj_.original_tagname_ = 'AgentListing'
        elif nodeName_ == 'AgentPosition':
            obj_ = AgentPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentPosition.append(obj_)
            obj_.original_tagname_ = 'AgentPosition'
        elif nodeName_ == 'AgentRelationship':
            obj_ = AgentRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentRelationship.append(obj_)
            obj_.original_tagname_ = 'AgentRelationship'
        elif nodeName_ == 'AgentStructure':
            obj_ = AgentStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentStructure.append(obj_)
            obj_.original_tagname_ = 'AgentStructure'
        elif nodeName_ == 'AllenIntervalAlgebra':
            obj_ = AllenIntervalAlgebra.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AllenIntervalAlgebra.append(obj_)
            obj_.original_tagname_ = 'AllenIntervalAlgebra'
        elif nodeName_ == 'AttributeComponent':
            obj_ = AttributeComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeComponent.append(obj_)
            obj_.original_tagname_ = 'AttributeComponent'
        elif nodeName_ == 'AuthorizationSource':
            obj_ = AuthorizationSource.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AuthorizationSource.append(obj_)
            obj_.original_tagname_ = 'AuthorizationSource'
        elif nodeName_ == 'Category':
            obj_ = Category.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Category.append(obj_)
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'CategoryPosition':
            obj_ = CategoryPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryPosition.append(obj_)
            obj_.original_tagname_ = 'CategoryPosition'
        elif nodeName_ == 'CategoryRelationStructure':
            obj_ = CategoryRelationStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryRelationStructure.append(obj_)
            obj_.original_tagname_ = 'CategoryRelationStructure'
        elif nodeName_ == 'CategoryRelationship':
            obj_ = CategoryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryRelationship.append(obj_)
            obj_.original_tagname_ = 'CategoryRelationship'
        elif nodeName_ == 'CategorySet':
            obj_ = CategorySet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategorySet.append(obj_)
            obj_.original_tagname_ = 'CategorySet'
        elif nodeName_ == 'CategoryStatistic':
            obj_ = CategoryStatistic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryStatistic.append(obj_)
            obj_.original_tagname_ = 'CategoryStatistic'
        elif nodeName_ == 'ClassificationFamily':
            obj_ = ClassificationFamily.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationFamily.append(obj_)
            obj_.original_tagname_ = 'ClassificationFamily'
        elif nodeName_ == 'ClassificationIndex':
            obj_ = ClassificationIndex.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationIndex.append(obj_)
            obj_.original_tagname_ = 'ClassificationIndex'
        elif nodeName_ == 'ClassificationIndexEntry':
            obj_ = ClassificationIndexEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationIndexEntry.append(obj_)
            obj_.original_tagname_ = 'ClassificationIndexEntry'
        elif nodeName_ == 'ClassificationIndexEntryPosition':
            obj_ = ClassificationIndexEntryPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationIndexEntryPosition.append(obj_)
            obj_.original_tagname_ = 'ClassificationIndexEntryPosition'
        elif nodeName_ == 'ClassificationItem':
            obj_ = ClassificationItem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItem.append(obj_)
            obj_.original_tagname_ = 'ClassificationItem'
        elif nodeName_ == 'ClassificationItemPosition':
            obj_ = ClassificationItemPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItemPosition.append(obj_)
            obj_.original_tagname_ = 'ClassificationItemPosition'
        elif nodeName_ == 'ClassificationItemRelationship':
            obj_ = ClassificationItemRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItemRelationship.append(obj_)
            obj_.original_tagname_ = 'ClassificationItemRelationship'
        elif nodeName_ == 'ClassificationItemStructure':
            obj_ = ClassificationItemStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItemStructure.append(obj_)
            obj_.original_tagname_ = 'ClassificationItemStructure'
        elif nodeName_ == 'ClassificationPosition':
            obj_ = ClassificationPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationPosition.append(obj_)
            obj_.original_tagname_ = 'ClassificationPosition'
        elif nodeName_ == 'ClassificationSeries':
            obj_ = ClassificationSeries.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationSeries.append(obj_)
            obj_.original_tagname_ = 'ClassificationSeries'
        elif nodeName_ == 'ClassificationSeriesStructure':
            obj_ = ClassificationSeriesStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationSeriesStructure.append(obj_)
            obj_.original_tagname_ = 'ClassificationSeriesStructure'
        elif nodeName_ == 'Code':
            obj_ = Code.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Code.append(obj_)
            obj_.original_tagname_ = 'Code'
        elif nodeName_ == 'CodeList':
            obj_ = CodeList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodeList.append(obj_)
            obj_.original_tagname_ = 'CodeList'
        elif nodeName_ == 'CodeListStructure':
            obj_ = CodeListStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodeListStructure.append(obj_)
            obj_.original_tagname_ = 'CodeListStructure'
        elif nodeName_ == 'CodePosition':
            obj_ = CodePosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodePosition.append(obj_)
            obj_.original_tagname_ = 'CodePosition'
        elif nodeName_ == 'CodeRelationship':
            obj_ = CodeRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodeRelationship.append(obj_)
            obj_.original_tagname_ = 'CodeRelationship'
        elif nodeName_ == 'ComponentPosition':
            obj_ = ComponentPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ComponentPosition.append(obj_)
            obj_.original_tagname_ = 'ComponentPosition'
        elif nodeName_ == 'Concept':
            class_obj_ = self.get_class_obj_(child_, Concept)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Concept.append(obj_)
            obj_.original_tagname_ = 'Concept'
        elif nodeName_ == 'ConceptMap':
            obj_ = ConceptMap.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptMap.append(obj_)
            obj_.original_tagname_ = 'ConceptMap'
        elif nodeName_ == 'ConceptRelationship':
            obj_ = ConceptRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptRelationship.append(obj_)
            obj_.original_tagname_ = 'ConceptRelationship'
        elif nodeName_ == 'ConceptStructure':
            obj_ = ConceptStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptStructure.append(obj_)
            obj_.original_tagname_ = 'ConceptStructure'
        elif nodeName_ == 'ConceptSystem':
            class_obj_ = self.get_class_obj_(child_, ConceptSystem)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptSystem.append(obj_)
            obj_.original_tagname_ = 'ConceptSystem'
        elif nodeName_ == 'ConceptSystemCorrespondence':
            obj_ = ConceptSystemCorrespondence.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptSystemCorrespondence.append(obj_)
            obj_.original_tagname_ = 'ConceptSystemCorrespondence'
        elif nodeName_ == 'ConceptualDomain':
            class_obj_ = self.get_class_obj_(child_, ConceptualDomain)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptualDomain.append(obj_)
            obj_.original_tagname_ = 'ConceptualDomain'
        elif nodeName_ == 'ConceptualValue':
            class_obj_ = self.get_class_obj_(child_, ConceptualValue)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptualValue.append(obj_)
            obj_.original_tagname_ = 'ConceptualValue'
        elif nodeName_ == 'ConceptualVariable':
            class_obj_ = self.get_class_obj_(child_, ConceptualVariable)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptualVariable.append(obj_)
            obj_.original_tagname_ = 'ConceptualVariable'
        elif nodeName_ == 'ConditionalControlLogic':
            obj_ = ConditionalControlLogic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConditionalControlLogic.append(obj_)
            obj_.original_tagname_ = 'ConditionalControlLogic'
        elif nodeName_ == 'ContextualComponent':
            obj_ = ContextualComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextualComponent.append(obj_)
            obj_.original_tagname_ = 'ContextualComponent'
        elif nodeName_ == 'ControlLogic':
            class_obj_ = self.get_class_obj_(child_, ControlLogic)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlLogic.append(obj_)
            obj_.original_tagname_ = 'ControlLogic'
        elif nodeName_ == 'CorrespondenceTable':
            obj_ = CorrespondenceTable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CorrespondenceTable.append(obj_)
            obj_.original_tagname_ = 'CorrespondenceTable'
        elif nodeName_ == 'Curator':
            obj_ = Curator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Curator.append(obj_)
            obj_.original_tagname_ = 'Curator'
        elif nodeName_ == 'DataPoint':
            obj_ = DataPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataPoint.append(obj_)
            obj_.original_tagname_ = 'DataPoint'
        elif nodeName_ == 'DataPointPosition':
            obj_ = DataPointPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataPointPosition.append(obj_)
            obj_.original_tagname_ = 'DataPointPosition'
        elif nodeName_ == 'DataPointRelationship':
            obj_ = DataPointRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataPointRelationship.append(obj_)
            obj_.original_tagname_ = 'DataPointRelationship'
        elif nodeName_ == 'DataSet':
            class_obj_ = self.get_class_obj_(child_, DataSet)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataSet.append(obj_)
            obj_.original_tagname_ = 'DataSet'
        elif nodeName_ == 'DataStore':
            obj_ = DataStore.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStore.append(obj_)
            obj_.original_tagname_ = 'DataStore'
        elif nodeName_ == 'DataStructure':
            class_obj_ = self.get_class_obj_(child_, DataStructure)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStructure.append(obj_)
            obj_.original_tagname_ = 'DataStructure'
        elif nodeName_ == 'DataStructureComponent':
            class_obj_ = self.get_class_obj_(child_, DataStructureComponent)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStructureComponent.append(obj_)
            obj_.original_tagname_ = 'DataStructureComponent'
        elif nodeName_ == 'Datum':
            class_obj_ = self.get_class_obj_(child_, Datum)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Datum.append(obj_)
            obj_.original_tagname_ = 'Datum'
        elif nodeName_ == 'Descriptor':
            obj_ = Descriptor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Descriptor.append(obj_)
            obj_.original_tagname_ = 'Descriptor'
        elif nodeName_ == 'DescriptorValueDomain':
            obj_ = DescriptorValueDomain.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DescriptorValueDomain.append(obj_)
            obj_.original_tagname_ = 'DescriptorValueDomain'
        elif nodeName_ == 'DescriptorVariable':
            obj_ = DescriptorVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DescriptorVariable.append(obj_)
            obj_.original_tagname_ = 'DescriptorVariable'
        elif nodeName_ == 'DeterministicImperative':
            class_obj_ = self.get_class_obj_(child_, DeterministicImperative)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DeterministicImperative.append(obj_)
            obj_.original_tagname_ = 'DeterministicImperative'
        elif nodeName_ == 'DimensionComponent':
            obj_ = DimensionComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionComponent.append(obj_)
            obj_.original_tagname_ = 'DimensionComponent'
        elif nodeName_ == 'DimensionGroup':
            obj_ = DimensionGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionGroup.append(obj_)
            obj_.original_tagname_ = 'DimensionGroup'
        elif nodeName_ == 'DimensionalDataSet':
            obj_ = DimensionalDataSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalDataSet.append(obj_)
            obj_.original_tagname_ = 'DimensionalDataSet'
        elif nodeName_ == 'DimensionalDataStructure':
            obj_ = DimensionalDataStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalDataStructure.append(obj_)
            obj_.original_tagname_ = 'DimensionalDataStructure'
        elif nodeName_ == 'DimensionalKey':
            obj_ = DimensionalKey.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalKey.append(obj_)
            obj_.original_tagname_ = 'DimensionalKey'
        elif nodeName_ == 'DimensionalKeyDefinition':
            obj_ = DimensionalKeyDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalKeyDefinition.append(obj_)
            obj_.original_tagname_ = 'DimensionalKeyDefinition'
        elif nodeName_ == 'DimensionalKeyDefinitionMember':
            obj_ = DimensionalKeyDefinitionMember.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalKeyDefinitionMember.append(obj_)
            obj_.original_tagname_ = 'DimensionalKeyDefinitionMember'
        elif nodeName_ == 'DimensionalKeyMember':
            obj_ = DimensionalKeyMember.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalKeyMember.append(obj_)
            obj_.original_tagname_ = 'DimensionalKeyMember'
        elif nodeName_ == 'EnumerationDomain':
            class_obj_ = self.get_class_obj_(child_, EnumerationDomain)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnumerationDomain.append(obj_)
            obj_.original_tagname_ = 'EnumerationDomain'
        elif nodeName_ == 'ForeignKey':
            obj_ = ForeignKey.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ForeignKey.append(obj_)
            obj_.original_tagname_ = 'ForeignKey'
        elif nodeName_ == 'ForeignKeyComponent':
            obj_ = ForeignKeyComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ForeignKeyComponent.append(obj_)
            obj_.original_tagname_ = 'ForeignKeyComponent'
        elif nodeName_ == 'IdentifierComponent':
            obj_ = IdentifierComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IdentifierComponent.append(obj_)
            obj_.original_tagname_ = 'IdentifierComponent'
        elif nodeName_ == 'Individual':
            obj_ = Individual.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Individual.append(obj_)
            obj_.original_tagname_ = 'Individual'
        elif nodeName_ == 'InformationFlowDefinition':
            obj_ = InformationFlowDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InformationFlowDefinition.append(obj_)
            obj_.original_tagname_ = 'InformationFlowDefinition'
        elif nodeName_ == 'InstanceKey':
            obj_ = InstanceKey.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceKey.append(obj_)
            obj_.original_tagname_ = 'InstanceKey'
        elif nodeName_ == 'InstanceValue':
            class_obj_ = self.get_class_obj_(child_, InstanceValue)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceValue.append(obj_)
            obj_.original_tagname_ = 'InstanceValue'
        elif nodeName_ == 'InstanceVariable':
            obj_ = InstanceVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceVariable.append(obj_)
            obj_.original_tagname_ = 'InstanceVariable'
        elif nodeName_ == 'InstanceVariableMap':
            obj_ = InstanceVariableMap.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceVariableMap.append(obj_)
            obj_.original_tagname_ = 'InstanceVariableMap'
        elif nodeName_ == 'Key':
            class_obj_ = self.get_class_obj_(child_, Key)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Key.append(obj_)
            obj_.original_tagname_ = 'Key'
        elif nodeName_ == 'KeyDefinition':
            class_obj_ = self.get_class_obj_(child_, KeyDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyDefinition.append(obj_)
            obj_.original_tagname_ = 'KeyDefinition'
        elif nodeName_ == 'KeyDefinitionMember':
            obj_ = KeyDefinitionMember.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyDefinitionMember.append(obj_)
            obj_.original_tagname_ = 'KeyDefinitionMember'
        elif nodeName_ == 'KeyMember':
            class_obj_ = self.get_class_obj_(child_, KeyMember)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyMember.append(obj_)
            obj_.original_tagname_ = 'KeyMember'
        elif nodeName_ == 'KeyValueDataStore':
            obj_ = KeyValueDataStore.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyValueDataStore.append(obj_)
            obj_.original_tagname_ = 'KeyValueDataStore'
        elif nodeName_ == 'KeyValueStructure':
            obj_ = KeyValueStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyValueStructure.append(obj_)
            obj_.original_tagname_ = 'KeyValueStructure'
        elif nodeName_ == 'Level':
            obj_ = Level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Level.append(obj_)
            obj_.original_tagname_ = 'Level'
        elif nodeName_ == 'LevelStructure':
            obj_ = LevelStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LevelStructure.append(obj_)
            obj_.original_tagname_ = 'LevelStructure'
        elif nodeName_ == 'LogicalRecord':
            obj_ = LogicalRecord.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecord.append(obj_)
            obj_.original_tagname_ = 'LogicalRecord'
        elif nodeName_ == 'LogicalRecordPosition':
            obj_ = LogicalRecordPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecordPosition.append(obj_)
            obj_.original_tagname_ = 'LogicalRecordPosition'
        elif nodeName_ == 'LogicalRecordRelationStructure':
            obj_ = LogicalRecordRelationStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecordRelationStructure.append(obj_)
            obj_.original_tagname_ = 'LogicalRecordRelationStructure'
        elif nodeName_ == 'LogicalRecordRelationship':
            obj_ = LogicalRecordRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecordRelationship.append(obj_)
            obj_.original_tagname_ = 'LogicalRecordRelationship'
        elif nodeName_ == 'LongDataSet':
            obj_ = LongDataSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LongDataSet.append(obj_)
            obj_.original_tagname_ = 'LongDataSet'
        elif nodeName_ == 'LongDataStructure':
            obj_ = LongDataStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LongDataStructure.append(obj_)
            obj_.original_tagname_ = 'LongDataStructure'
        elif nodeName_ == 'LongKey':
            obj_ = LongKey.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LongKey.append(obj_)
            obj_.original_tagname_ = 'LongKey'
        elif nodeName_ == 'LongMainKeyMember':
            obj_ = LongMainKeyMember.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LongMainKeyMember.append(obj_)
            obj_.original_tagname_ = 'LongMainKeyMember'
        elif nodeName_ == 'Machine':
            obj_ = Machine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Machine.append(obj_)
            obj_.original_tagname_ = 'Machine'
        elif nodeName_ == 'MainKeyMember':
            obj_ = MainKeyMember.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MainKeyMember.append(obj_)
            obj_.original_tagname_ = 'MainKeyMember'
        elif nodeName_ == 'MeasureComponent':
            class_obj_ = self.get_class_obj_(child_, MeasureComponent)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasureComponent.append(obj_)
            obj_.original_tagname_ = 'MeasureComponent'
        elif nodeName_ == 'NonDeterministicDeclarative':
            class_obj_ = self.get_class_obj_(child_, NonDeterministicDeclarative)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NonDeterministicDeclarative.append(obj_)
            obj_.original_tagname_ = 'NonDeterministicDeclarative'
        elif nodeName_ == 'Notation':
            obj_ = Notation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Notation.append(obj_)
            obj_.original_tagname_ = 'Notation'
        elif nodeName_ == 'Organization':
            obj_ = Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organization.append(obj_)
            obj_.original_tagname_ = 'Organization'
        elif nodeName_ == 'Parameter':
            obj_ = Parameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Parameter.append(obj_)
            obj_.original_tagname_ = 'Parameter'
        elif nodeName_ == 'PhysicalDataSet':
            obj_ = PhysicalDataSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalDataSet.append(obj_)
            obj_.original_tagname_ = 'PhysicalDataSet'
        elif nodeName_ == 'PhysicalDataSetStructure':
            obj_ = PhysicalDataSetStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalDataSetStructure.append(obj_)
            obj_.original_tagname_ = 'PhysicalDataSetStructure'
        elif nodeName_ == 'PhysicalLayoutRelationStructure':
            obj_ = PhysicalLayoutRelationStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalLayoutRelationStructure.append(obj_)
            obj_.original_tagname_ = 'PhysicalLayoutRelationStructure'
        elif nodeName_ == 'PhysicalRecordSegment':
            obj_ = PhysicalRecordSegment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegment.append(obj_)
            obj_.original_tagname_ = 'PhysicalRecordSegment'
        elif nodeName_ == 'PhysicalRecordSegmentPosition':
            obj_ = PhysicalRecordSegmentPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegmentPosition.append(obj_)
            obj_.original_tagname_ = 'PhysicalRecordSegmentPosition'
        elif nodeName_ == 'PhysicalRecordSegmentRelationship':
            obj_ = PhysicalRecordSegmentRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegmentRelationship.append(obj_)
            obj_.original_tagname_ = 'PhysicalRecordSegmentRelationship'
        elif nodeName_ == 'PhysicalRecordSegmentStructure':
            obj_ = PhysicalRecordSegmentStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegmentStructure.append(obj_)
            obj_.original_tagname_ = 'PhysicalRecordSegmentStructure'
        elif nodeName_ == 'PhysicalSegmentLayout':
            class_obj_ = self.get_class_obj_(child_, PhysicalSegmentLayout)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalSegmentLayout.append(obj_)
            obj_.original_tagname_ = 'PhysicalSegmentLayout'
        elif nodeName_ == 'PhysicalSegmentLocation':
            class_obj_ = self.get_class_obj_(child_, PhysicalSegmentLocation)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalSegmentLocation.append(obj_)
            obj_.original_tagname_ = 'PhysicalSegmentLocation'
        elif nodeName_ == 'Population':
            obj_ = Population.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Population.append(obj_)
            obj_.original_tagname_ = 'Population'
        elif nodeName_ == 'PrimaryKey':
            obj_ = PrimaryKey.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrimaryKey.append(obj_)
            obj_.original_tagname_ = 'PrimaryKey'
        elif nodeName_ == 'PrimaryKeyComponent':
            obj_ = PrimaryKeyComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrimaryKeyComponent.append(obj_)
            obj_.original_tagname_ = 'PrimaryKeyComponent'
        elif nodeName_ == 'ProcessingAgent':
            class_obj_ = self.get_class_obj_(child_, ProcessingAgent)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ProcessingAgent.append(obj_)
            obj_.original_tagname_ = 'ProcessingAgent'
        elif nodeName_ == 'ProductionEnvironment':
            obj_ = ProductionEnvironment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ProductionEnvironment.append(obj_)
            obj_.original_tagname_ = 'ProductionEnvironment'
        elif nodeName_ == 'QualifiedMeasure':
            obj_ = QualifiedMeasure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.QualifiedMeasure.append(obj_)
            obj_.original_tagname_ = 'QualifiedMeasure'
        elif nodeName_ == 'RecordRelation':
            obj_ = RecordRelation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RecordRelation.append(obj_)
            obj_.original_tagname_ = 'RecordRelation'
        elif nodeName_ == 'ReferenceValue':
            obj_ = ReferenceValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReferenceValue.append(obj_)
            obj_.original_tagname_ = 'ReferenceValue'
        elif nodeName_ == 'ReferenceValueDomain':
            obj_ = ReferenceValueDomain.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReferenceValueDomain.append(obj_)
            obj_.original_tagname_ = 'ReferenceValueDomain'
        elif nodeName_ == 'ReferenceVariable':
            obj_ = ReferenceVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReferenceVariable.append(obj_)
            obj_.original_tagname_ = 'ReferenceVariable'
        elif nodeName_ == 'RepresentedVariable':
            class_obj_ = self.get_class_obj_(child_, RepresentedVariable)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RepresentedVariable.append(obj_)
            obj_.original_tagname_ = 'RepresentedVariable'
        elif nodeName_ == 'RevisableDatum':
            obj_ = RevisableDatum.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RevisableDatum.append(obj_)
            obj_.original_tagname_ = 'RevisableDatum'
        elif nodeName_ == 'Revision':
            obj_ = Revision.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Revision.append(obj_)
            obj_.original_tagname_ = 'Revision'
        elif nodeName_ == 'Rule':
            obj_ = Rule.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Rule.append(obj_)
            obj_.original_tagname_ = 'Rule'
        elif nodeName_ == 'RuleBasedScheduling':
            obj_ = RuleBasedScheduling.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RuleBasedScheduling.append(obj_)
            obj_.original_tagname_ = 'RuleBasedScheduling'
        elif nodeName_ == 'RuleSet':
            obj_ = RuleSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RuleSet.append(obj_)
            obj_.original_tagname_ = 'RuleSet'
        elif nodeName_ == 'ScopedMeasure':
            obj_ = ScopedMeasure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ScopedMeasure.append(obj_)
            obj_.original_tagname_ = 'ScopedMeasure'
        elif nodeName_ == 'SegmentByText':
            obj_ = SegmentByText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SegmentByText.append(obj_)
            obj_.original_tagname_ = 'SegmentByText'
        elif nodeName_ == 'SentinelConceptualDomain':
            obj_ = SentinelConceptualDomain.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SentinelConceptualDomain.append(obj_)
            obj_.original_tagname_ = 'SentinelConceptualDomain'
        elif nodeName_ == 'SentinelValueDomain':
            obj_ = SentinelValueDomain.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SentinelValueDomain.append(obj_)
            obj_.original_tagname_ = 'SentinelValueDomain'
        elif nodeName_ == 'Sequence':
            obj_ = Sequence.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Sequence.append(obj_)
            obj_.original_tagname_ = 'Sequence'
        elif nodeName_ == 'SequencePosition':
            obj_ = SequencePosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SequencePosition.append(obj_)
            obj_.original_tagname_ = 'SequencePosition'
        elif nodeName_ == 'Service':
            obj_ = Service.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Service.append(obj_)
            obj_.original_tagname_ = 'Service'
        elif nodeName_ == 'StatisticalClassification':
            obj_ = StatisticalClassification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassification.append(obj_)
            obj_.original_tagname_ = 'StatisticalClassification'
        elif nodeName_ == 'StatisticalClassificationRelationship':
            obj_ = StatisticalClassificationRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassificationRelationship.append(obj_)
            obj_.original_tagname_ = 'StatisticalClassificationRelationship'
        elif nodeName_ == 'Step':
            obj_ = Step.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Step.append(obj_)
            obj_.original_tagname_ = 'Step'
        elif nodeName_ == 'SubstantiveConceptualDomain':
            obj_ = SubstantiveConceptualDomain.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SubstantiveConceptualDomain.append(obj_)
            obj_.original_tagname_ = 'SubstantiveConceptualDomain'
        elif nodeName_ == 'SubstantiveValueDomain':
            class_obj_ = self.get_class_obj_(child_, SubstantiveValueDomain)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SubstantiveValueDomain.append(obj_)
            obj_.original_tagname_ = 'SubstantiveValueDomain'
        elif nodeName_ == 'SyntheticIdComponent':
            obj_ = SyntheticIdComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SyntheticIdComponent.append(obj_)
            obj_.original_tagname_ = 'SyntheticIdComponent'
        elif nodeName_ == 'TemporalConstraints':
            class_obj_ = self.get_class_obj_(child_, TemporalConstraints)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TemporalConstraints.append(obj_)
            obj_.original_tagname_ = 'TemporalConstraints'
        elif nodeName_ == 'TemporalControlConstruct':
            obj_ = TemporalControlConstruct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TemporalControlConstruct.append(obj_)
            obj_.original_tagname_ = 'TemporalControlConstruct'
        elif nodeName_ == 'Unit':
            obj_ = Unit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Unit.append(obj_)
            obj_.original_tagname_ = 'Unit'
        elif nodeName_ == 'UnitSegmentLayout':
            obj_ = UnitSegmentLayout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UnitSegmentLayout.append(obj_)
            obj_.original_tagname_ = 'UnitSegmentLayout'
        elif nodeName_ == 'UnitType':
            class_obj_ = self.get_class_obj_(child_, UnitType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UnitType.append(obj_)
            obj_.original_tagname_ = 'UnitType'
        elif nodeName_ == 'Universe':
            class_obj_ = self.get_class_obj_(child_, Universe)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Universe.append(obj_)
            obj_.original_tagname_ = 'Universe'
        elif nodeName_ == 'ValueAndConceptDescription':
            obj_ = ValueAndConceptDescription.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueAndConceptDescription.append(obj_)
            obj_.original_tagname_ = 'ValueAndConceptDescription'
        elif nodeName_ == 'ValueDomain':
            class_obj_ = self.get_class_obj_(child_, ValueDomain)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueDomain.append(obj_)
            obj_.original_tagname_ = 'ValueDomain'
        elif nodeName_ == 'ValueMapping':
            obj_ = ValueMapping.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueMapping.append(obj_)
            obj_.original_tagname_ = 'ValueMapping'
        elif nodeName_ == 'ValueMappingPosition':
            obj_ = ValueMappingPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueMappingPosition.append(obj_)
            obj_.original_tagname_ = 'ValueMappingPosition'
        elif nodeName_ == 'ValueMappingRelationship':
            obj_ = ValueMappingRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueMappingRelationship.append(obj_)
            obj_.original_tagname_ = 'ValueMappingRelationship'
        elif nodeName_ == 'VariableCollection':
            obj_ = VariableCollection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableCollection.append(obj_)
            obj_.original_tagname_ = 'VariableCollection'
        elif nodeName_ == 'VariableDescriptorComponent':
            obj_ = VariableDescriptorComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableDescriptorComponent.append(obj_)
            obj_.original_tagname_ = 'VariableDescriptorComponent'
        elif nodeName_ == 'VariablePosition':
            obj_ = VariablePosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariablePosition.append(obj_)
            obj_.original_tagname_ = 'VariablePosition'
        elif nodeName_ == 'VariableRelationship':
            obj_ = VariableRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableRelationship.append(obj_)
            obj_.original_tagname_ = 'VariableRelationship'
        elif nodeName_ == 'VariableStructure':
            obj_ = VariableStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableStructure.append(obj_)
            obj_.original_tagname_ = 'VariableStructure'
        elif nodeName_ == 'VariableValueComponent':
            obj_ = VariableValueComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableValueComponent.append(obj_)
            obj_.original_tagname_ = 'VariableValueComponent'
        elif nodeName_ == 'WideDataSet':
            obj_ = WideDataSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WideDataSet.append(obj_)
            obj_.original_tagname_ = 'WideDataSet'
        elif nodeName_ == 'WideDataStructure':
            obj_ = WideDataStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WideDataStructure.append(obj_)
            obj_.original_tagname_ = 'WideDataStructure'
        elif nodeName_ == 'WideKey':
            obj_ = WideKey.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WideKey.append(obj_)
            obj_.original_tagname_ = 'WideKey'
        elif nodeName_ == 'WideKeyMember':
            obj_ = WideKeyMember.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WideKeyMember.append(obj_)
            obj_.original_tagname_ = 'WideKeyMember'
# end class Wrapper


class Activity(GeneratedsSuper):
    """definition -- Natural language statement conveying the meaning of a concept, differentiating it from other concepts. Supports the use of multiple languages and structured text. 'externalDefinition' can't be used if 'definition' is used.
    description -- A description of the Activity in human-readable language.
    displayLabel -- A human-readable display label for the object. Supports the use of multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.
    entityProduced -- The thing resulting from the activity.
    entityUsed -- A thing employed in the activity.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (linguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    standardModelMapping -- A reference to a standard process model from which the Activity is taken, such as The Generic Statistical Business Process Model (GSBPM), the Generic Longitudinal Business Process Model (GLBPM), Open Archive Information System (OAIS) model, etc. The model and step or sub-step corresponding to the Activity is noted here using the Paired External Controlled Vocabulary Entry. Enter the name of the model in "term" and the step, sub-step, or specific portion of the model in "extent".
    Activity_hasInternal_ControlLogic -- An activity is embedded in the control construct which launches it.
    Activity_hasSubActivity_Activity -- An Activity is a container for SubActivities.
    Activity_has_Step -- Activities may be broken out into Steps. Steps are also a subtype of Activity.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, definition=None, description=None, displayLabel=None, entityProduced=None, entityUsed=None, identifier=None, name=None, standardModelMapping=None, Activity_hasInternal_ControlLogic=None, Activity_hasSubActivity_Activity=None, Activity_has_Step=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.definition = definition
        self.definition_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        if displayLabel is None:
            self.displayLabel = []
        else:
            self.displayLabel = displayLabel
        self.displayLabel_nsprefix_ = None
        if entityProduced is None:
            self.entityProduced = []
        else:
            self.entityProduced = entityProduced
        self.entityProduced_nsprefix_ = None
        if entityUsed is None:
            self.entityUsed = []
        else:
            self.entityUsed = entityUsed
        self.entityUsed_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        if standardModelMapping is None:
            self.standardModelMapping = []
        else:
            self.standardModelMapping = standardModelMapping
        self.standardModelMapping_nsprefix_ = None
        if Activity_hasInternal_ControlLogic is None:
            self.Activity_hasInternal_ControlLogic = []
        else:
            self.Activity_hasInternal_ControlLogic = Activity_hasInternal_ControlLogic
        self.Activity_hasInternal_ControlLogic_nsprefix_ = None
        if Activity_hasSubActivity_Activity is None:
            self.Activity_hasSubActivity_Activity = []
        else:
            self.Activity_hasSubActivity_Activity = Activity_hasSubActivity_Activity
        self.Activity_hasSubActivity_Activity_nsprefix_ = None
        if Activity_has_Step is None:
            self.Activity_has_Step = []
        else:
            self.Activity_has_Step = Activity_has_Step
        self.Activity_has_Step_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Activity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Activity.subclass:
            return Activity.subclass(*args_, **kwargs_)
        else:
            return Activity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_definition(self):
        return self.definition
    def set_definition(self, definition):
        self.definition = definition
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def add_displayLabel(self, value):
        self.displayLabel.append(value)
    def insert_displayLabel_at(self, index, value):
        self.displayLabel.insert(index, value)
    def replace_displayLabel_at(self, index, value):
        self.displayLabel[index] = value
    def get_entityProduced(self):
        return self.entityProduced
    def set_entityProduced(self, entityProduced):
        self.entityProduced = entityProduced
    def add_entityProduced(self, value):
        self.entityProduced.append(value)
    def insert_entityProduced_at(self, index, value):
        self.entityProduced.insert(index, value)
    def replace_entityProduced_at(self, index, value):
        self.entityProduced[index] = value
    def get_entityUsed(self):
        return self.entityUsed
    def set_entityUsed(self, entityUsed):
        self.entityUsed = entityUsed
    def add_entityUsed(self, value):
        self.entityUsed.append(value)
    def insert_entityUsed_at(self, index, value):
        self.entityUsed.insert(index, value)
    def replace_entityUsed_at(self, index, value):
        self.entityUsed[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_standardModelMapping(self):
        return self.standardModelMapping
    def set_standardModelMapping(self, standardModelMapping):
        self.standardModelMapping = standardModelMapping
    def add_standardModelMapping(self, value):
        self.standardModelMapping.append(value)
    def insert_standardModelMapping_at(self, index, value):
        self.standardModelMapping.insert(index, value)
    def replace_standardModelMapping_at(self, index, value):
        self.standardModelMapping[index] = value
    def get_Activity_hasInternal_ControlLogic(self):
        return self.Activity_hasInternal_ControlLogic
    def set_Activity_hasInternal_ControlLogic(self, Activity_hasInternal_ControlLogic):
        self.Activity_hasInternal_ControlLogic = Activity_hasInternal_ControlLogic
    def add_Activity_hasInternal_ControlLogic(self, value):
        self.Activity_hasInternal_ControlLogic.append(value)
    def insert_Activity_hasInternal_ControlLogic_at(self, index, value):
        self.Activity_hasInternal_ControlLogic.insert(index, value)
    def replace_Activity_hasInternal_ControlLogic_at(self, index, value):
        self.Activity_hasInternal_ControlLogic[index] = value
    def get_Activity_hasSubActivity_Activity(self):
        return self.Activity_hasSubActivity_Activity
    def set_Activity_hasSubActivity_Activity(self, Activity_hasSubActivity_Activity):
        self.Activity_hasSubActivity_Activity = Activity_hasSubActivity_Activity
    def add_Activity_hasSubActivity_Activity(self, value):
        self.Activity_hasSubActivity_Activity.append(value)
    def insert_Activity_hasSubActivity_Activity_at(self, index, value):
        self.Activity_hasSubActivity_Activity.insert(index, value)
    def replace_Activity_hasSubActivity_Activity_at(self, index, value):
        self.Activity_hasSubActivity_Activity[index] = value
    def get_Activity_has_Step(self):
        return self.Activity_has_Step
    def set_Activity_has_Step(self, Activity_has_Step):
        self.Activity_has_Step = Activity_has_Step
    def add_Activity_has_Step(self, value):
        self.Activity_has_Step.append(value)
    def insert_Activity_has_Step_at(self, index, value):
        self.Activity_has_Step.insert(index, value)
    def replace_Activity_has_Step_at(self, index, value):
        self.Activity_has_Step[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.definition is not None or
            self.description is not None or
            self.displayLabel or
            self.entityProduced or
            self.entityUsed or
            self.identifier is not None or
            self.name or
            self.standardModelMapping or
            self.Activity_hasInternal_ControlLogic or
            self.Activity_hasSubActivity_Activity or
            self.Activity_has_Step
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Activity', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.definition is not None:
            definition_ = self.definition
            definition_.to_etree(element, name_='definition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.description is not None:
            description_ = self.description
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}description').text = self.gds_format_string(description_)
        for displayLabel_ in self.displayLabel:
            displayLabel_.to_etree(element, name_='displayLabel', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for entityProduced_ in self.entityProduced:
            entityProduced_.to_etree(element, name_='entityProduced', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for entityUsed_ in self.entityUsed:
            entityUsed_.to_etree(element, name_='entityUsed', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for standardModelMapping_ in self.standardModelMapping:
            standardModelMapping_.to_etree(element, name_='standardModelMapping', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Activity_hasInternal_ControlLogic_ in self.Activity_hasInternal_ControlLogic:
            Activity_hasInternal_ControlLogic_.to_etree(element, name_='Activity_hasInternal_ControlLogic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Activity_hasSubActivity_Activity_ in self.Activity_hasSubActivity_Activity:
            Activity_hasSubActivity_Activity_.to_etree(element, name_='Activity_hasSubActivity_Activity', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Activity_has_Step_ in self.Activity_has_Step:
            Activity_has_Step_.to_etree(element, name_='Activity_has_Step', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'definition':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.definition = obj_
            obj_.original_tagname_ = 'definition'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayLabel':
            obj_ = LabelForDisplay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayLabel.append(obj_)
            obj_.original_tagname_ = 'displayLabel'
        elif nodeName_ == 'entityProduced':
            class_obj_ = self.get_class_obj_(child_, Reference)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entityProduced.append(obj_)
            obj_.original_tagname_ = 'entityProduced'
        elif nodeName_ == 'entityUsed':
            class_obj_ = self.get_class_obj_(child_, Reference)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entityUsed.append(obj_)
            obj_.original_tagname_ = 'entityUsed'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'standardModelMapping':
            class_obj_ = self.get_class_obj_(child_, Reference)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.standardModelMapping.append(obj_)
            obj_.original_tagname_ = 'standardModelMapping'
        elif nodeName_ == 'Activity_hasInternal_ControlLogic':
            obj_ = Activity_hasInternal_ControlLogicType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Activity_hasInternal_ControlLogic.append(obj_)
            obj_.original_tagname_ = 'Activity_hasInternal_ControlLogic'
        elif nodeName_ == 'Activity_hasSubActivity_Activity':
            obj_ = Activity_hasSubActivity_ActivityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Activity_hasSubActivity_Activity.append(obj_)
            obj_.original_tagname_ = 'Activity_hasSubActivity_Activity'
        elif nodeName_ == 'Activity_has_Step':
            obj_ = Activity_has_StepType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Activity_has_Step.append(obj_)
            obj_.original_tagname_ = 'Activity_has_Step'
# end class Activity


class Agent(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry. Examples would be creator, contributor, title, copyright, embargo, and license information. A set of information useful for attribution, data discovery, and access. This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    image -- Information regarding image associated with the agent.
    purpose -- Intent or reason for the object/the description of the object.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, identifier=None, image=None, purpose=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Agent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Agent.subclass:
            return Agent.subclass(*args_, **kwargs_)
        else:
            return Agent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.identifier is not None or
            self.image or
            self.purpose is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Agent', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for image_ in self.image:
            image_.to_etree(element, name_='image', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'image':
            obj_ = PrivateImage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.image.append(obj_)
            obj_.original_tagname_ = 'image'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
# end class Agent


class AgentListing(GeneratedsSuper):
    """allowsDuplicates -- If value is False, the members are unique within the collection - if True, there may be duplicates. (Note that a mathematical "bag" permits duplicates and is unordered - a "set" does not have duplicates and may be ordered.)
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    AgentListing_isDefinedBy_Concept -- The conceptual basis for the collection of members.
    AgentListing_isMaintainedBy_Agent -- The unit or group of persons within the organization responsible for the agent listing (i.e., for adding, changing or deleting agent entries).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, allowsDuplicates=None, identifier=None, name=None, purpose=None, AgentListing_isDefinedBy_Concept=None, AgentListing_isMaintainedBy_Agent=None, AgentListing_has_AgentPosition=None, AgentListing_has_Agent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.allowsDuplicates = allowsDuplicates
        self.allowsDuplicates_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        if AgentListing_isDefinedBy_Concept is None:
            self.AgentListing_isDefinedBy_Concept = []
        else:
            self.AgentListing_isDefinedBy_Concept = AgentListing_isDefinedBy_Concept
        self.AgentListing_isDefinedBy_Concept_nsprefix_ = None
        self.AgentListing_isMaintainedBy_Agent = AgentListing_isMaintainedBy_Agent
        self.AgentListing_isMaintainedBy_Agent_nsprefix_ = None
        if AgentListing_has_AgentPosition is None:
            self.AgentListing_has_AgentPosition = []
        else:
            self.AgentListing_has_AgentPosition = AgentListing_has_AgentPosition
        self.AgentListing_has_AgentPosition_nsprefix_ = None
        if AgentListing_has_Agent is None:
            self.AgentListing_has_Agent = []
        else:
            self.AgentListing_has_Agent = AgentListing_has_Agent
        self.AgentListing_has_Agent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentListing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentListing.subclass:
            return AgentListing.subclass(*args_, **kwargs_)
        else:
            return AgentListing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_allowsDuplicates(self):
        return self.allowsDuplicates
    def set_allowsDuplicates(self, allowsDuplicates):
        self.allowsDuplicates = allowsDuplicates
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_AgentListing_isDefinedBy_Concept(self):
        return self.AgentListing_isDefinedBy_Concept
    def set_AgentListing_isDefinedBy_Concept(self, AgentListing_isDefinedBy_Concept):
        self.AgentListing_isDefinedBy_Concept = AgentListing_isDefinedBy_Concept
    def add_AgentListing_isDefinedBy_Concept(self, value):
        self.AgentListing_isDefinedBy_Concept.append(value)
    def insert_AgentListing_isDefinedBy_Concept_at(self, index, value):
        self.AgentListing_isDefinedBy_Concept.insert(index, value)
    def replace_AgentListing_isDefinedBy_Concept_at(self, index, value):
        self.AgentListing_isDefinedBy_Concept[index] = value
    def get_AgentListing_isMaintainedBy_Agent(self):
        return self.AgentListing_isMaintainedBy_Agent
    def set_AgentListing_isMaintainedBy_Agent(self, AgentListing_isMaintainedBy_Agent):
        self.AgentListing_isMaintainedBy_Agent = AgentListing_isMaintainedBy_Agent
    def get_AgentListing_has_AgentPosition(self):
        return self.AgentListing_has_AgentPosition
    def set_AgentListing_has_AgentPosition(self, AgentListing_has_AgentPosition):
        self.AgentListing_has_AgentPosition = AgentListing_has_AgentPosition
    def add_AgentListing_has_AgentPosition(self, value):
        self.AgentListing_has_AgentPosition.append(value)
    def insert_AgentListing_has_AgentPosition_at(self, index, value):
        self.AgentListing_has_AgentPosition.insert(index, value)
    def replace_AgentListing_has_AgentPosition_at(self, index, value):
        self.AgentListing_has_AgentPosition[index] = value
    def get_AgentListing_has_Agent(self):
        return self.AgentListing_has_Agent
    def set_AgentListing_has_Agent(self, AgentListing_has_Agent):
        self.AgentListing_has_Agent = AgentListing_has_Agent
    def add_AgentListing_has_Agent(self, value):
        self.AgentListing_has_Agent.append(value)
    def insert_AgentListing_has_Agent_at(self, index, value):
        self.AgentListing_has_Agent.insert(index, value)
    def replace_AgentListing_has_Agent_at(self, index, value):
        self.AgentListing_has_Agent[index] = value
    def has__content(self):
        if (
            self.allowsDuplicates is not None or
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.AgentListing_isDefinedBy_Concept or
            self.AgentListing_isMaintainedBy_Agent is not None or
            self.AgentListing_has_AgentPosition or
            self.AgentListing_has_Agent
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentListing', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.allowsDuplicates is not None:
            allowsDuplicates_ = self.allowsDuplicates
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}allowsDuplicates').text = self.gds_format_boolean(allowsDuplicates_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AgentListing_isDefinedBy_Concept_ in self.AgentListing_isDefinedBy_Concept:
            AgentListing_isDefinedBy_Concept_.to_etree(element, name_='AgentListing_isDefinedBy_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.AgentListing_isMaintainedBy_Agent is not None:
            AgentListing_isMaintainedBy_Agent_ = self.AgentListing_isMaintainedBy_Agent
            AgentListing_isMaintainedBy_Agent_.to_etree(element, name_='AgentListing_isMaintainedBy_Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AgentListing_has_AgentPosition_ in self.AgentListing_has_AgentPosition:
            AgentListing_has_AgentPosition_.to_etree(element, name_='AgentListing_has_AgentPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AgentListing_has_Agent_ in self.AgentListing_has_Agent:
            AgentListing_has_Agent_.to_etree(element, name_='AgentListing_has_Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allowsDuplicates':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'allowsDuplicates')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowsDuplicates')
            self.allowsDuplicates = ival_
            self.allowsDuplicates_nsprefix_ = child_.prefix
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'AgentListing_isDefinedBy_Concept':
            obj_ = AgentListing_isDefinedBy_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentListing_isDefinedBy_Concept.append(obj_)
            obj_.original_tagname_ = 'AgentListing_isDefinedBy_Concept'
        elif nodeName_ == 'AgentListing_isMaintainedBy_Agent':
            obj_ = AgentListing_isMaintainedBy_AgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentListing_isMaintainedBy_Agent = obj_
            obj_.original_tagname_ = 'AgentListing_isMaintainedBy_Agent'
        elif nodeName_ == 'AgentListing_has_AgentPosition':
            obj_ = AgentListing_has_AgentPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentListing_has_AgentPosition.append(obj_)
            obj_.original_tagname_ = 'AgentListing_has_AgentPosition'
        elif nodeName_ == 'AgentListing_has_Agent':
            obj_ = AgentListing_has_AgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentListing_has_Agent.append(obj_)
            obj_.original_tagname_ = 'AgentListing_has_Agent'
# end class AgentListing


class AgentPosition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    value -- The index of the agent within an agent listing.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, value=None, AgentPosition_indexes_Agent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.AgentPosition_indexes_Agent = AgentPosition_indexes_Agent
        self.AgentPosition_indexes_Agent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentPosition.subclass:
            return AgentPosition.subclass(*args_, **kwargs_)
        else:
            return AgentPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_AgentPosition_indexes_Agent(self):
        return self.AgentPosition_indexes_Agent
    def set_AgentPosition_indexes_Agent(self, AgentPosition_indexes_Agent):
        self.AgentPosition_indexes_Agent = AgentPosition_indexes_Agent
    def has__content(self):
        if (
            self.identifier is not None or
            self.value is not None or
            self.AgentPosition_indexes_Agent is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentPosition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_integer(value_)
        if self.AgentPosition_indexes_Agent is not None:
            AgentPosition_indexes_Agent_ = self.AgentPosition_indexes_Agent
            AgentPosition_indexes_Agent_.to_etree(element, name_='AgentPosition_indexes_Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
        elif nodeName_ == 'AgentPosition_indexes_Agent':
            obj_ = AgentPosition_indexes_AgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentPosition_indexes_Agent = obj_
            obj_.original_tagname_ = 'AgentPosition_indexes_Agent'
# end class AgentPosition


class AgentRelationship(GeneratedsSuper):
    """effectiveDates -- Effective dates of the relationship expressed as a start and end Date (using ISO and/or non-ISO date structures).
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    AgentRelationship_hasSource_Agent -- The subject in the description of a paired relationship
    –
    for example the Parent agent in the hierarchical Parent of Child relationship.
    AgentRelationship_hasTarget_Agent -- The object in the description of a paired relationship
    –
    for example the Object agent in the hierarchical Parent of Child relationship.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, effectiveDates=None, identifier=None, semantics=None, AgentRelationship_hasSource_Agent=None, AgentRelationship_hasTarget_Agent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.effectiveDates = effectiveDates
        self.effectiveDates_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        self.AgentRelationship_hasSource_Agent = AgentRelationship_hasSource_Agent
        self.AgentRelationship_hasSource_Agent_nsprefix_ = None
        self.AgentRelationship_hasTarget_Agent = AgentRelationship_hasTarget_Agent
        self.AgentRelationship_hasTarget_Agent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentRelationship.subclass:
            return AgentRelationship.subclass(*args_, **kwargs_)
        else:
            return AgentRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_effectiveDates(self):
        return self.effectiveDates
    def set_effectiveDates(self, effectiveDates):
        self.effectiveDates = effectiveDates
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_AgentRelationship_hasSource_Agent(self):
        return self.AgentRelationship_hasSource_Agent
    def set_AgentRelationship_hasSource_Agent(self, AgentRelationship_hasSource_Agent):
        self.AgentRelationship_hasSource_Agent = AgentRelationship_hasSource_Agent
    def get_AgentRelationship_hasTarget_Agent(self):
        return self.AgentRelationship_hasTarget_Agent
    def set_AgentRelationship_hasTarget_Agent(self, AgentRelationship_hasTarget_Agent):
        self.AgentRelationship_hasTarget_Agent = AgentRelationship_hasTarget_Agent
    def has__content(self):
        if (
            self.effectiveDates is not None or
            self.identifier is not None or
            self.semantics is not None or
            self.AgentRelationship_hasSource_Agent is not None or
            self.AgentRelationship_hasTarget_Agent is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentRelationship', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.effectiveDates is not None:
            effectiveDates_ = self.effectiveDates
            effectiveDates_.to_etree(element, name_='effectiveDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.AgentRelationship_hasSource_Agent is not None:
            AgentRelationship_hasSource_Agent_ = self.AgentRelationship_hasSource_Agent
            AgentRelationship_hasSource_Agent_.to_etree(element, name_='AgentRelationship_hasSource_Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.AgentRelationship_hasTarget_Agent is not None:
            AgentRelationship_hasTarget_Agent_ = self.AgentRelationship_hasTarget_Agent
            AgentRelationship_hasTarget_Agent_.to_etree(element, name_='AgentRelationship_hasTarget_Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'effectiveDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveDates = obj_
            obj_.original_tagname_ = 'effectiveDates'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'AgentRelationship_hasSource_Agent':
            obj_ = AgentRelationship_hasSource_AgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentRelationship_hasSource_Agent = obj_
            obj_.original_tagname_ = 'AgentRelationship_hasSource_Agent'
        elif nodeName_ == 'AgentRelationship_hasTarget_Agent':
            obj_ = AgentRelationship_hasTarget_AgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentRelationship_hasTarget_Agent = obj_
            obj_.original_tagname_ = 'AgentRelationship_hasTarget_Agent'
# end class AgentRelationship


class AgentStructure(GeneratedsSuper):
    """effectiveDates -- The effective start and end date of the relationship.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    privacy -- Level of privacy regarding this relationship.
    purpose -- Intent or reason for the object/the description of the object.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    specification -- Provides information on reflexivity, transitivity, and symmetry of relationship using a descriptive term from an enumerated list. Use if all relations within this relation structure are of the same specification.
    topology -- Indicates the form of the associations among members of the collection. Specifies the way in which constituent parts are interrelated or arranged.
    totality -- Indicates whether the related collections are comprehensive in terms of their coverage.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, effectiveDates=None, identifier=None, name=None, privacy=None, purpose=None, semantics=None, specification=None, topology=None, totality=None, AgentStructure_structures_AgentListing=None, AgentStructure_has_AgentRelationship=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.effectiveDates = effectiveDates
        self.effectiveDates_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.privacy = privacy
        self.privacy_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        self.specification = specification
        self.specification_nsprefix_ = None
        self.topology = topology
        self.topology_nsprefix_ = None
        self.totality = totality
        self.validate_StructureExtent(self.totality)
        self.totality_nsprefix_ = None
        self.AgentStructure_structures_AgentListing = AgentStructure_structures_AgentListing
        self.AgentStructure_structures_AgentListing_nsprefix_ = None
        if AgentStructure_has_AgentRelationship is None:
            self.AgentStructure_has_AgentRelationship = []
        else:
            self.AgentStructure_has_AgentRelationship = AgentStructure_has_AgentRelationship
        self.AgentStructure_has_AgentRelationship_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentStructure.subclass:
            return AgentStructure.subclass(*args_, **kwargs_)
        else:
            return AgentStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_effectiveDates(self):
        return self.effectiveDates
    def set_effectiveDates(self, effectiveDates):
        self.effectiveDates = effectiveDates
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_privacy(self):
        return self.privacy
    def set_privacy(self, privacy):
        self.privacy = privacy
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_specification(self):
        return self.specification
    def set_specification(self, specification):
        self.specification = specification
    def get_topology(self):
        return self.topology
    def set_topology(self, topology):
        self.topology = topology
    def get_totality(self):
        return self.totality
    def set_totality(self, totality):
        self.totality = totality
    def get_AgentStructure_structures_AgentListing(self):
        return self.AgentStructure_structures_AgentListing
    def set_AgentStructure_structures_AgentListing(self, AgentStructure_structures_AgentListing):
        self.AgentStructure_structures_AgentListing = AgentStructure_structures_AgentListing
    def get_AgentStructure_has_AgentRelationship(self):
        return self.AgentStructure_has_AgentRelationship
    def set_AgentStructure_has_AgentRelationship(self, AgentStructure_has_AgentRelationship):
        self.AgentStructure_has_AgentRelationship = AgentStructure_has_AgentRelationship
    def add_AgentStructure_has_AgentRelationship(self, value):
        self.AgentStructure_has_AgentRelationship.append(value)
    def insert_AgentStructure_has_AgentRelationship_at(self, index, value):
        self.AgentStructure_has_AgentRelationship.insert(index, value)
    def replace_AgentStructure_has_AgentRelationship_at(self, index, value):
        self.AgentStructure_has_AgentRelationship[index] = value
    def validate_StructureExtent(self, value):
        result = True
        # Validate type StructureExtent, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Partial', 'Total']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StructureExtent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.effectiveDates is not None or
            self.identifier is not None or
            self.name or
            self.privacy is not None or
            self.purpose is not None or
            self.semantics is not None or
            self.specification is not None or
            self.topology is not None or
            self.totality is not None or
            self.AgentStructure_structures_AgentListing is not None or
            self.AgentStructure_has_AgentRelationship
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.effectiveDates is not None:
            effectiveDates_ = self.effectiveDates
            effectiveDates_.to_etree(element, name_='effectiveDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.privacy is not None:
            privacy_ = self.privacy
            privacy_.to_etree(element, name_='privacy', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.specification is not None:
            specification_ = self.specification
            specification_.to_etree(element, name_='specification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.topology is not None:
            topology_ = self.topology
            topology_.to_etree(element, name_='topology', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.totality is not None:
            totality_ = self.totality
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}totality').text = self.gds_format_string(totality_)
        if self.AgentStructure_structures_AgentListing is not None:
            AgentStructure_structures_AgentListing_ = self.AgentStructure_structures_AgentListing
            AgentStructure_structures_AgentListing_.to_etree(element, name_='AgentStructure_structures_AgentListing', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AgentStructure_has_AgentRelationship_ in self.AgentStructure_has_AgentRelationship:
            AgentStructure_has_AgentRelationship_.to_etree(element, name_='AgentStructure_has_AgentRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'effectiveDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveDates = obj_
            obj_.original_tagname_ = 'effectiveDates'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'privacy':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.privacy = obj_
            obj_.original_tagname_ = 'privacy'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'specification':
            obj_ = StructureSpecification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specification = obj_
            obj_.original_tagname_ = 'specification'
        elif nodeName_ == 'topology':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.topology = obj_
            obj_.original_tagname_ = 'topology'
        elif nodeName_ == 'totality':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totality')
            value_ = self.gds_validate_string(value_, node, 'totality')
            self.totality = value_
            self.totality_nsprefix_ = child_.prefix
            # validate type StructureExtent
            self.validate_StructureExtent(self.totality)
        elif nodeName_ == 'AgentStructure_structures_AgentListing':
            obj_ = AgentStructure_structures_AgentListingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentStructure_structures_AgentListing = obj_
            obj_.original_tagname_ = 'AgentStructure_structures_AgentListing'
        elif nodeName_ == 'AgentStructure_has_AgentRelationship':
            obj_ = AgentStructure_has_AgentRelationshipType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AgentStructure_has_AgentRelationship.append(obj_)
            obj_.original_tagname_ = 'AgentStructure_has_AgentRelationship'
# end class AgentStructure


class AuthorizationSource(GeneratedsSuper):
    """authorizationDate -- Identifies the date of authorization.
    catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    legalMandate -- Provide a legal citation to a law authorizing the study/data collection. For example, a legal citation for a law authorizing a country's census.
    purpose -- Intent or reason for the object/the description of the object.
    statementOfAuthorization -- Text of the authorization (law, mandate, approved business case).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, authorizationDate=None, catalogDetails=None, identifier=None, legalMandate=None, purpose=None, statementOfAuthorization=None, AuthorizationSource_has_Agent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.authorizationDate = authorizationDate
        self.authorizationDate_nsprefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.legalMandate = legalMandate
        self.legalMandate_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.statementOfAuthorization = statementOfAuthorization
        self.statementOfAuthorization_nsprefix_ = None
        if AuthorizationSource_has_Agent is None:
            self.AuthorizationSource_has_Agent = []
        else:
            self.AuthorizationSource_has_Agent = AuthorizationSource_has_Agent
        self.AuthorizationSource_has_Agent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuthorizationSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuthorizationSource.subclass:
            return AuthorizationSource.subclass(*args_, **kwargs_)
        else:
            return AuthorizationSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_authorizationDate(self):
        return self.authorizationDate
    def set_authorizationDate(self, authorizationDate):
        self.authorizationDate = authorizationDate
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_legalMandate(self):
        return self.legalMandate
    def set_legalMandate(self, legalMandate):
        self.legalMandate = legalMandate
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_statementOfAuthorization(self):
        return self.statementOfAuthorization
    def set_statementOfAuthorization(self, statementOfAuthorization):
        self.statementOfAuthorization = statementOfAuthorization
    def get_AuthorizationSource_has_Agent(self):
        return self.AuthorizationSource_has_Agent
    def set_AuthorizationSource_has_Agent(self, AuthorizationSource_has_Agent):
        self.AuthorizationSource_has_Agent = AuthorizationSource_has_Agent
    def add_AuthorizationSource_has_Agent(self, value):
        self.AuthorizationSource_has_Agent.append(value)
    def insert_AuthorizationSource_has_Agent_at(self, index, value):
        self.AuthorizationSource_has_Agent.insert(index, value)
    def replace_AuthorizationSource_has_Agent_at(self, index, value):
        self.AuthorizationSource_has_Agent[index] = value
    def has__content(self):
        if (
            self.authorizationDate is not None or
            self.catalogDetails is not None or
            self.identifier is not None or
            self.legalMandate is not None or
            self.purpose is not None or
            self.statementOfAuthorization is not None or
            self.AuthorizationSource_has_Agent
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AuthorizationSource', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.authorizationDate is not None:
            authorizationDate_ = self.authorizationDate
            authorizationDate_.to_etree(element, name_='authorizationDate', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.legalMandate is not None:
            legalMandate_ = self.legalMandate
            legalMandate_.to_etree(element, name_='legalMandate', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.statementOfAuthorization is not None:
            statementOfAuthorization_ = self.statementOfAuthorization
            statementOfAuthorization_.to_etree(element, name_='statementOfAuthorization', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for AuthorizationSource_has_Agent_ in self.AuthorizationSource_has_Agent:
            AuthorizationSource_has_Agent_.to_etree(element, name_='AuthorizationSource_has_Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'authorizationDate':
            obj_ = CombinedDate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.authorizationDate = obj_
            obj_.original_tagname_ = 'authorizationDate'
        elif nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'legalMandate':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.legalMandate = obj_
            obj_.original_tagname_ = 'legalMandate'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'statementOfAuthorization':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statementOfAuthorization = obj_
            obj_.original_tagname_ = 'statementOfAuthorization'
        elif nodeName_ == 'AuthorizationSource_has_Agent':
            obj_ = AuthorizationSource_has_AgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AuthorizationSource_has_Agent.append(obj_)
            obj_.original_tagname_ = 'AuthorizationSource_has_Agent'
# end class AuthorizationSource


class CategoryPosition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    value -- Index value of the member in an ordered array.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, value=None, CategoryPosition_indexes_Category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.CategoryPosition_indexes_Category = CategoryPosition_indexes_Category
        self.CategoryPosition_indexes_Category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryPosition.subclass:
            return CategoryPosition.subclass(*args_, **kwargs_)
        else:
            return CategoryPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_CategoryPosition_indexes_Category(self):
        return self.CategoryPosition_indexes_Category
    def set_CategoryPosition_indexes_Category(self, CategoryPosition_indexes_Category):
        self.CategoryPosition_indexes_Category = CategoryPosition_indexes_Category
    def has__content(self):
        if (
            self.identifier is not None or
            self.value is not None or
            self.CategoryPosition_indexes_Category is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategoryPosition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_integer(value_)
        if self.CategoryPosition_indexes_Category is not None:
            CategoryPosition_indexes_Category_ = self.CategoryPosition_indexes_Category
            CategoryPosition_indexes_Category_.to_etree(element, name_='CategoryPosition_indexes_Category', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
        elif nodeName_ == 'CategoryPosition_indexes_Category':
            obj_ = CategoryPosition_indexes_CategoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryPosition_indexes_Category = obj_
            obj_.original_tagname_ = 'CategoryPosition_indexes_Category'
# end class CategoryPosition


class CategoryRelationStructure(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    specification -- Provides information on reflexivity, transitivity, and symmetry of relationship using a descriptive term from an enumerated list. Use if all relations within this relation structure are of the same specification.
    topology -- Indicates the form of the associations among members of the collection. Specifies the way in which constituent parts are interrelated or arranged.
    totality -- Indicates whether the related collections are comprehensive in terms of their coverage.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, name=None, purpose=None, semantics=None, specification=None, topology=None, totality=None, CategoryRelationStructure_structures_CategorySet=None, CategoryRelationStructure_has_CategoryRelationship=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        self.specification = specification
        self.specification_nsprefix_ = None
        self.topology = topology
        self.topology_nsprefix_ = None
        self.totality = totality
        self.validate_StructureExtent(self.totality)
        self.totality_nsprefix_ = None
        self.CategoryRelationStructure_structures_CategorySet = CategoryRelationStructure_structures_CategorySet
        self.CategoryRelationStructure_structures_CategorySet_nsprefix_ = None
        if CategoryRelationStructure_has_CategoryRelationship is None:
            self.CategoryRelationStructure_has_CategoryRelationship = []
        else:
            self.CategoryRelationStructure_has_CategoryRelationship = CategoryRelationStructure_has_CategoryRelationship
        self.CategoryRelationStructure_has_CategoryRelationship_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryRelationStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryRelationStructure.subclass:
            return CategoryRelationStructure.subclass(*args_, **kwargs_)
        else:
            return CategoryRelationStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_specification(self):
        return self.specification
    def set_specification(self, specification):
        self.specification = specification
    def get_topology(self):
        return self.topology
    def set_topology(self, topology):
        self.topology = topology
    def get_totality(self):
        return self.totality
    def set_totality(self, totality):
        self.totality = totality
    def get_CategoryRelationStructure_structures_CategorySet(self):
        return self.CategoryRelationStructure_structures_CategorySet
    def set_CategoryRelationStructure_structures_CategorySet(self, CategoryRelationStructure_structures_CategorySet):
        self.CategoryRelationStructure_structures_CategorySet = CategoryRelationStructure_structures_CategorySet
    def get_CategoryRelationStructure_has_CategoryRelationship(self):
        return self.CategoryRelationStructure_has_CategoryRelationship
    def set_CategoryRelationStructure_has_CategoryRelationship(self, CategoryRelationStructure_has_CategoryRelationship):
        self.CategoryRelationStructure_has_CategoryRelationship = CategoryRelationStructure_has_CategoryRelationship
    def add_CategoryRelationStructure_has_CategoryRelationship(self, value):
        self.CategoryRelationStructure_has_CategoryRelationship.append(value)
    def insert_CategoryRelationStructure_has_CategoryRelationship_at(self, index, value):
        self.CategoryRelationStructure_has_CategoryRelationship.insert(index, value)
    def replace_CategoryRelationStructure_has_CategoryRelationship_at(self, index, value):
        self.CategoryRelationStructure_has_CategoryRelationship[index] = value
    def validate_StructureExtent(self, value):
        result = True
        # Validate type StructureExtent, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Partial', 'Total']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StructureExtent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.semantics is not None or
            self.specification is not None or
            self.topology is not None or
            self.totality is not None or
            self.CategoryRelationStructure_structures_CategorySet is not None or
            self.CategoryRelationStructure_has_CategoryRelationship
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategoryRelationStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.specification is not None:
            specification_ = self.specification
            specification_.to_etree(element, name_='specification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.topology is not None:
            topology_ = self.topology
            topology_.to_etree(element, name_='topology', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.totality is not None:
            totality_ = self.totality
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}totality').text = self.gds_format_string(totality_)
        if self.CategoryRelationStructure_structures_CategorySet is not None:
            CategoryRelationStructure_structures_CategorySet_ = self.CategoryRelationStructure_structures_CategorySet
            CategoryRelationStructure_structures_CategorySet_.to_etree(element, name_='CategoryRelationStructure_structures_CategorySet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategoryRelationStructure_has_CategoryRelationship_ in self.CategoryRelationStructure_has_CategoryRelationship:
            CategoryRelationStructure_has_CategoryRelationship_.to_etree(element, name_='CategoryRelationStructure_has_CategoryRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'specification':
            obj_ = StructureSpecification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specification = obj_
            obj_.original_tagname_ = 'specification'
        elif nodeName_ == 'topology':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.topology = obj_
            obj_.original_tagname_ = 'topology'
        elif nodeName_ == 'totality':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totality')
            value_ = self.gds_validate_string(value_, node, 'totality')
            self.totality = value_
            self.totality_nsprefix_ = child_.prefix
            # validate type StructureExtent
            self.validate_StructureExtent(self.totality)
        elif nodeName_ == 'CategoryRelationStructure_structures_CategorySet':
            obj_ = CategoryRelationStructure_structures_CategorySetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryRelationStructure_structures_CategorySet = obj_
            obj_.original_tagname_ = 'CategoryRelationStructure_structures_CategorySet'
        elif nodeName_ == 'CategoryRelationStructure_has_CategoryRelationship':
            obj_ = CategoryRelationStructure_has_CategoryRelationshipType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryRelationStructure_has_CategoryRelationship.append(obj_)
            obj_.original_tagname_ = 'CategoryRelationStructure_has_CategoryRelationship'
# end class CategoryRelationStructure


class CategoryRelationship(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    CategoryRelationship_hasTarget_Category -- Second member in a relationship. Note that this can be realized as a collection to support tuples.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, semantics=None, CategoryRelationship_hasSource_Category=None, CategoryRelationship_hasTarget_Category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        if CategoryRelationship_hasSource_Category is None:
            self.CategoryRelationship_hasSource_Category = []
        else:
            self.CategoryRelationship_hasSource_Category = CategoryRelationship_hasSource_Category
        self.CategoryRelationship_hasSource_Category_nsprefix_ = None
        if CategoryRelationship_hasTarget_Category is None:
            self.CategoryRelationship_hasTarget_Category = []
        else:
            self.CategoryRelationship_hasTarget_Category = CategoryRelationship_hasTarget_Category
        self.CategoryRelationship_hasTarget_Category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryRelationship.subclass:
            return CategoryRelationship.subclass(*args_, **kwargs_)
        else:
            return CategoryRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_CategoryRelationship_hasSource_Category(self):
        return self.CategoryRelationship_hasSource_Category
    def set_CategoryRelationship_hasSource_Category(self, CategoryRelationship_hasSource_Category):
        self.CategoryRelationship_hasSource_Category = CategoryRelationship_hasSource_Category
    def add_CategoryRelationship_hasSource_Category(self, value):
        self.CategoryRelationship_hasSource_Category.append(value)
    def insert_CategoryRelationship_hasSource_Category_at(self, index, value):
        self.CategoryRelationship_hasSource_Category.insert(index, value)
    def replace_CategoryRelationship_hasSource_Category_at(self, index, value):
        self.CategoryRelationship_hasSource_Category[index] = value
    def get_CategoryRelationship_hasTarget_Category(self):
        return self.CategoryRelationship_hasTarget_Category
    def set_CategoryRelationship_hasTarget_Category(self, CategoryRelationship_hasTarget_Category):
        self.CategoryRelationship_hasTarget_Category = CategoryRelationship_hasTarget_Category
    def add_CategoryRelationship_hasTarget_Category(self, value):
        self.CategoryRelationship_hasTarget_Category.append(value)
    def insert_CategoryRelationship_hasTarget_Category_at(self, index, value):
        self.CategoryRelationship_hasTarget_Category.insert(index, value)
    def replace_CategoryRelationship_hasTarget_Category_at(self, index, value):
        self.CategoryRelationship_hasTarget_Category[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.semantics is not None or
            self.CategoryRelationship_hasSource_Category or
            self.CategoryRelationship_hasTarget_Category
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategoryRelationship', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategoryRelationship_hasSource_Category_ in self.CategoryRelationship_hasSource_Category:
            CategoryRelationship_hasSource_Category_.to_etree(element, name_='CategoryRelationship_hasSource_Category', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategoryRelationship_hasTarget_Category_ in self.CategoryRelationship_hasTarget_Category:
            CategoryRelationship_hasTarget_Category_.to_etree(element, name_='CategoryRelationship_hasTarget_Category', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'CategoryRelationship_hasSource_Category':
            obj_ = CategoryRelationship_hasSource_CategoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryRelationship_hasSource_Category.append(obj_)
            obj_.original_tagname_ = 'CategoryRelationship_hasSource_Category'
        elif nodeName_ == 'CategoryRelationship_hasTarget_Category':
            obj_ = CategoryRelationship_hasTarget_CategoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryRelationship_hasTarget_Category.append(obj_)
            obj_.original_tagname_ = 'CategoryRelationship_hasTarget_Category'
# end class CategoryRelationship


class CategoryStatistic(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    statistic -- The value of the identified type of statistic for the category. May be repeated to provide unweighted or weighted values and different computation bases.
    typeOfCategoryStatistic -- Indicates the type of information about the appearance of categories within the instance variable.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, statistic=None, typeOfCategoryStatistic=None, CategoryStatistic_appliesTo_InstanceVariable=None, CategoryStatistic_for_Category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if statistic is None:
            self.statistic = []
        else:
            self.statistic = statistic
        self.statistic_nsprefix_ = None
        self.typeOfCategoryStatistic = typeOfCategoryStatistic
        self.typeOfCategoryStatistic_nsprefix_ = None
        if CategoryStatistic_appliesTo_InstanceVariable is None:
            self.CategoryStatistic_appliesTo_InstanceVariable = []
        else:
            self.CategoryStatistic_appliesTo_InstanceVariable = CategoryStatistic_appliesTo_InstanceVariable
        self.CategoryStatistic_appliesTo_InstanceVariable_nsprefix_ = None
        self.CategoryStatistic_for_Category = CategoryStatistic_for_Category
        self.CategoryStatistic_for_Category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryStatistic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryStatistic.subclass:
            return CategoryStatistic.subclass(*args_, **kwargs_)
        else:
            return CategoryStatistic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_statistic(self):
        return self.statistic
    def set_statistic(self, statistic):
        self.statistic = statistic
    def add_statistic(self, value):
        self.statistic.append(value)
    def insert_statistic_at(self, index, value):
        self.statistic.insert(index, value)
    def replace_statistic_at(self, index, value):
        self.statistic[index] = value
    def get_typeOfCategoryStatistic(self):
        return self.typeOfCategoryStatistic
    def set_typeOfCategoryStatistic(self, typeOfCategoryStatistic):
        self.typeOfCategoryStatistic = typeOfCategoryStatistic
    def get_CategoryStatistic_appliesTo_InstanceVariable(self):
        return self.CategoryStatistic_appliesTo_InstanceVariable
    def set_CategoryStatistic_appliesTo_InstanceVariable(self, CategoryStatistic_appliesTo_InstanceVariable):
        self.CategoryStatistic_appliesTo_InstanceVariable = CategoryStatistic_appliesTo_InstanceVariable
    def add_CategoryStatistic_appliesTo_InstanceVariable(self, value):
        self.CategoryStatistic_appliesTo_InstanceVariable.append(value)
    def insert_CategoryStatistic_appliesTo_InstanceVariable_at(self, index, value):
        self.CategoryStatistic_appliesTo_InstanceVariable.insert(index, value)
    def replace_CategoryStatistic_appliesTo_InstanceVariable_at(self, index, value):
        self.CategoryStatistic_appliesTo_InstanceVariable[index] = value
    def get_CategoryStatistic_for_Category(self):
        return self.CategoryStatistic_for_Category
    def set_CategoryStatistic_for_Category(self, CategoryStatistic_for_Category):
        self.CategoryStatistic_for_Category = CategoryStatistic_for_Category
    def has__content(self):
        if (
            self.identifier is not None or
            self.statistic or
            self.typeOfCategoryStatistic is not None or
            self.CategoryStatistic_appliesTo_InstanceVariable or
            self.CategoryStatistic_for_Category is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategoryStatistic', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for statistic_ in self.statistic:
            statistic_.to_etree(element, name_='statistic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.typeOfCategoryStatistic is not None:
            typeOfCategoryStatistic_ = self.typeOfCategoryStatistic
            typeOfCategoryStatistic_.to_etree(element, name_='typeOfCategoryStatistic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategoryStatistic_appliesTo_InstanceVariable_ in self.CategoryStatistic_appliesTo_InstanceVariable:
            CategoryStatistic_appliesTo_InstanceVariable_.to_etree(element, name_='CategoryStatistic_appliesTo_InstanceVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.CategoryStatistic_for_Category is not None:
            CategoryStatistic_for_Category_ = self.CategoryStatistic_for_Category
            CategoryStatistic_for_Category_.to_etree(element, name_='CategoryStatistic_for_Category', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'statistic':
            obj_ = Statistic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statistic.append(obj_)
            obj_.original_tagname_ = 'statistic'
        elif nodeName_ == 'typeOfCategoryStatistic':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfCategoryStatistic = obj_
            obj_.original_tagname_ = 'typeOfCategoryStatistic'
        elif nodeName_ == 'CategoryStatistic_appliesTo_InstanceVariable':
            obj_ = CategoryStatistic_appliesTo_InstanceVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryStatistic_appliesTo_InstanceVariable.append(obj_)
            obj_.original_tagname_ = 'CategoryStatistic_appliesTo_InstanceVariable'
        elif nodeName_ == 'CategoryStatistic_for_Category':
            obj_ = CategoryStatistic_for_CategoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoryStatistic_for_Category = obj_
            obj_.original_tagname_ = 'CategoryStatistic_for_Category'
# end class CategoryStatistic


class ClassificationFamily(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    ClassificationFamily_uses_ClassificationIndex -- Classification indexes associated to the classification family.
    ClassificationFamily_isDefinedBy_Concept -- The conceptual basis for the collection of members.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, identifier=None, name=None, purpose=None, ClassificationFamily_uses_ClassificationIndex=None, ClassificationFamily_isDefinedBy_Concept=None, ClassificationFamily_groups_ClassificationSeries=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        if ClassificationFamily_uses_ClassificationIndex is None:
            self.ClassificationFamily_uses_ClassificationIndex = []
        else:
            self.ClassificationFamily_uses_ClassificationIndex = ClassificationFamily_uses_ClassificationIndex
        self.ClassificationFamily_uses_ClassificationIndex_nsprefix_ = None
        if ClassificationFamily_isDefinedBy_Concept is None:
            self.ClassificationFamily_isDefinedBy_Concept = []
        else:
            self.ClassificationFamily_isDefinedBy_Concept = ClassificationFamily_isDefinedBy_Concept
        self.ClassificationFamily_isDefinedBy_Concept_nsprefix_ = None
        if ClassificationFamily_groups_ClassificationSeries is None:
            self.ClassificationFamily_groups_ClassificationSeries = []
        else:
            self.ClassificationFamily_groups_ClassificationSeries = ClassificationFamily_groups_ClassificationSeries
        self.ClassificationFamily_groups_ClassificationSeries_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationFamily)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationFamily.subclass:
            return ClassificationFamily.subclass(*args_, **kwargs_)
        else:
            return ClassificationFamily(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_ClassificationFamily_uses_ClassificationIndex(self):
        return self.ClassificationFamily_uses_ClassificationIndex
    def set_ClassificationFamily_uses_ClassificationIndex(self, ClassificationFamily_uses_ClassificationIndex):
        self.ClassificationFamily_uses_ClassificationIndex = ClassificationFamily_uses_ClassificationIndex
    def add_ClassificationFamily_uses_ClassificationIndex(self, value):
        self.ClassificationFamily_uses_ClassificationIndex.append(value)
    def insert_ClassificationFamily_uses_ClassificationIndex_at(self, index, value):
        self.ClassificationFamily_uses_ClassificationIndex.insert(index, value)
    def replace_ClassificationFamily_uses_ClassificationIndex_at(self, index, value):
        self.ClassificationFamily_uses_ClassificationIndex[index] = value
    def get_ClassificationFamily_isDefinedBy_Concept(self):
        return self.ClassificationFamily_isDefinedBy_Concept
    def set_ClassificationFamily_isDefinedBy_Concept(self, ClassificationFamily_isDefinedBy_Concept):
        self.ClassificationFamily_isDefinedBy_Concept = ClassificationFamily_isDefinedBy_Concept
    def add_ClassificationFamily_isDefinedBy_Concept(self, value):
        self.ClassificationFamily_isDefinedBy_Concept.append(value)
    def insert_ClassificationFamily_isDefinedBy_Concept_at(self, index, value):
        self.ClassificationFamily_isDefinedBy_Concept.insert(index, value)
    def replace_ClassificationFamily_isDefinedBy_Concept_at(self, index, value):
        self.ClassificationFamily_isDefinedBy_Concept[index] = value
    def get_ClassificationFamily_groups_ClassificationSeries(self):
        return self.ClassificationFamily_groups_ClassificationSeries
    def set_ClassificationFamily_groups_ClassificationSeries(self, ClassificationFamily_groups_ClassificationSeries):
        self.ClassificationFamily_groups_ClassificationSeries = ClassificationFamily_groups_ClassificationSeries
    def add_ClassificationFamily_groups_ClassificationSeries(self, value):
        self.ClassificationFamily_groups_ClassificationSeries.append(value)
    def insert_ClassificationFamily_groups_ClassificationSeries_at(self, index, value):
        self.ClassificationFamily_groups_ClassificationSeries.insert(index, value)
    def replace_ClassificationFamily_groups_ClassificationSeries_at(self, index, value):
        self.ClassificationFamily_groups_ClassificationSeries[index] = value
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.ClassificationFamily_uses_ClassificationIndex or
            self.ClassificationFamily_isDefinedBy_Concept or
            self.ClassificationFamily_groups_ClassificationSeries
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationFamily', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationFamily_uses_ClassificationIndex_ in self.ClassificationFamily_uses_ClassificationIndex:
            ClassificationFamily_uses_ClassificationIndex_.to_etree(element, name_='ClassificationFamily_uses_ClassificationIndex', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationFamily_isDefinedBy_Concept_ in self.ClassificationFamily_isDefinedBy_Concept:
            ClassificationFamily_isDefinedBy_Concept_.to_etree(element, name_='ClassificationFamily_isDefinedBy_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationFamily_groups_ClassificationSeries_ in self.ClassificationFamily_groups_ClassificationSeries:
            ClassificationFamily_groups_ClassificationSeries_.to_etree(element, name_='ClassificationFamily_groups_ClassificationSeries', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'ClassificationFamily_uses_ClassificationIndex':
            obj_ = ClassificationFamily_uses_ClassificationIndexType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationFamily_uses_ClassificationIndex.append(obj_)
            obj_.original_tagname_ = 'ClassificationFamily_uses_ClassificationIndex'
        elif nodeName_ == 'ClassificationFamily_isDefinedBy_Concept':
            obj_ = ClassificationFamily_isDefinedBy_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationFamily_isDefinedBy_Concept.append(obj_)
            obj_.original_tagname_ = 'ClassificationFamily_isDefinedBy_Concept'
        elif nodeName_ == 'ClassificationFamily_groups_ClassificationSeries':
            obj_ = ClassificationFamily_groups_ClassificationSeriesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationFamily_groups_ClassificationSeries.append(obj_)
            obj_.original_tagname_ = 'ClassificationFamily_groups_ClassificationSeries'
# end class ClassificationFamily


class ClassificationIndex(GeneratedsSuper):
    """allowsDuplicates -- If value is False, the members are unique within the collection - if True, there may be duplicates. (Note that a mathematical
    “
    bag
    ”
    permits duplicates and is unordered - a
    “
    set
    ”
    does not have duplicates and may be ordered.)
    availableLanguage -- A list of languages in which the Statistical Classification is available. If a Classification Index exists in several languages, the number of entries in each language may be different, as the number of terms describing any given phenomenon can change from one language to another. However, the same phenomena should be described in each language. Supports the indication of multiple languages within a single property. Supports use of codes defined by the RFC 1766.
    catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    codingInstruction -- Additional information which drives the coding process for all entries in a Classification Index.
    corrections -- Verbal summary description of corrections, which have occurred within the Classification Index. Corrections include changing the item code associated with a classification index entry.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    releaseDate -- Date when the current version of the classification index was released.
    ClassificationIndex_isMaintainedBy_Agent -- The unit or group of persons within the organization responsible for the classification index (i.e., for adding, changing or deleting classification index entries).
    ClassificationIndex_hasContact_Agent -- Person(s) who may be contacted for additional information about the classification index.
    ClassificationIndex_isDefinedBy_Concept -- The conceptual basis for the collection of members.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, allowsDuplicates=None, availableLanguage=None, catalogDetails=None, codingInstruction=None, corrections=None, identifier=None, name=None, purpose=None, releaseDate=None, ClassificationIndex_isMaintainedBy_Agent=None, ClassificationIndex_hasContact_Agent=None, ClassificationIndex_isDefinedBy_Concept=None, ClassificationIndex_has_ClassificationIndexEntryPosition=None, ClassificationIndex_has_ClassificationIndexEntry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.allowsDuplicates = allowsDuplicates
        self.allowsDuplicates_nsprefix_ = None
        if availableLanguage is None:
            self.availableLanguage = []
        else:
            self.availableLanguage = availableLanguage
        self.availableLanguage_nsprefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        if codingInstruction is None:
            self.codingInstruction = []
        else:
            self.codingInstruction = codingInstruction
        self.codingInstruction_nsprefix_ = None
        if corrections is None:
            self.corrections = []
        else:
            self.corrections = corrections
        self.corrections_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.releaseDate = releaseDate
        self.releaseDate_nsprefix_ = None
        self.ClassificationIndex_isMaintainedBy_Agent = ClassificationIndex_isMaintainedBy_Agent
        self.ClassificationIndex_isMaintainedBy_Agent_nsprefix_ = None
        if ClassificationIndex_hasContact_Agent is None:
            self.ClassificationIndex_hasContact_Agent = []
        else:
            self.ClassificationIndex_hasContact_Agent = ClassificationIndex_hasContact_Agent
        self.ClassificationIndex_hasContact_Agent_nsprefix_ = None
        if ClassificationIndex_isDefinedBy_Concept is None:
            self.ClassificationIndex_isDefinedBy_Concept = []
        else:
            self.ClassificationIndex_isDefinedBy_Concept = ClassificationIndex_isDefinedBy_Concept
        self.ClassificationIndex_isDefinedBy_Concept_nsprefix_ = None
        if ClassificationIndex_has_ClassificationIndexEntryPosition is None:
            self.ClassificationIndex_has_ClassificationIndexEntryPosition = []
        else:
            self.ClassificationIndex_has_ClassificationIndexEntryPosition = ClassificationIndex_has_ClassificationIndexEntryPosition
        self.ClassificationIndex_has_ClassificationIndexEntryPosition_nsprefix_ = None
        if ClassificationIndex_has_ClassificationIndexEntry is None:
            self.ClassificationIndex_has_ClassificationIndexEntry = []
        else:
            self.ClassificationIndex_has_ClassificationIndexEntry = ClassificationIndex_has_ClassificationIndexEntry
        self.ClassificationIndex_has_ClassificationIndexEntry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationIndex.subclass:
            return ClassificationIndex.subclass(*args_, **kwargs_)
        else:
            return ClassificationIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_allowsDuplicates(self):
        return self.allowsDuplicates
    def set_allowsDuplicates(self, allowsDuplicates):
        self.allowsDuplicates = allowsDuplicates
    def get_availableLanguage(self):
        return self.availableLanguage
    def set_availableLanguage(self, availableLanguage):
        self.availableLanguage = availableLanguage
    def add_availableLanguage(self, value):
        self.availableLanguage.append(value)
    def insert_availableLanguage_at(self, index, value):
        self.availableLanguage.insert(index, value)
    def replace_availableLanguage_at(self, index, value):
        self.availableLanguage[index] = value
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_codingInstruction(self):
        return self.codingInstruction
    def set_codingInstruction(self, codingInstruction):
        self.codingInstruction = codingInstruction
    def add_codingInstruction(self, value):
        self.codingInstruction.append(value)
    def insert_codingInstruction_at(self, index, value):
        self.codingInstruction.insert(index, value)
    def replace_codingInstruction_at(self, index, value):
        self.codingInstruction[index] = value
    def get_corrections(self):
        return self.corrections
    def set_corrections(self, corrections):
        self.corrections = corrections
    def add_corrections(self, value):
        self.corrections.append(value)
    def insert_corrections_at(self, index, value):
        self.corrections.insert(index, value)
    def replace_corrections_at(self, index, value):
        self.corrections[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_releaseDate(self):
        return self.releaseDate
    def set_releaseDate(self, releaseDate):
        self.releaseDate = releaseDate
    def get_ClassificationIndex_isMaintainedBy_Agent(self):
        return self.ClassificationIndex_isMaintainedBy_Agent
    def set_ClassificationIndex_isMaintainedBy_Agent(self, ClassificationIndex_isMaintainedBy_Agent):
        self.ClassificationIndex_isMaintainedBy_Agent = ClassificationIndex_isMaintainedBy_Agent
    def get_ClassificationIndex_hasContact_Agent(self):
        return self.ClassificationIndex_hasContact_Agent
    def set_ClassificationIndex_hasContact_Agent(self, ClassificationIndex_hasContact_Agent):
        self.ClassificationIndex_hasContact_Agent = ClassificationIndex_hasContact_Agent
    def add_ClassificationIndex_hasContact_Agent(self, value):
        self.ClassificationIndex_hasContact_Agent.append(value)
    def insert_ClassificationIndex_hasContact_Agent_at(self, index, value):
        self.ClassificationIndex_hasContact_Agent.insert(index, value)
    def replace_ClassificationIndex_hasContact_Agent_at(self, index, value):
        self.ClassificationIndex_hasContact_Agent[index] = value
    def get_ClassificationIndex_isDefinedBy_Concept(self):
        return self.ClassificationIndex_isDefinedBy_Concept
    def set_ClassificationIndex_isDefinedBy_Concept(self, ClassificationIndex_isDefinedBy_Concept):
        self.ClassificationIndex_isDefinedBy_Concept = ClassificationIndex_isDefinedBy_Concept
    def add_ClassificationIndex_isDefinedBy_Concept(self, value):
        self.ClassificationIndex_isDefinedBy_Concept.append(value)
    def insert_ClassificationIndex_isDefinedBy_Concept_at(self, index, value):
        self.ClassificationIndex_isDefinedBy_Concept.insert(index, value)
    def replace_ClassificationIndex_isDefinedBy_Concept_at(self, index, value):
        self.ClassificationIndex_isDefinedBy_Concept[index] = value
    def get_ClassificationIndex_has_ClassificationIndexEntryPosition(self):
        return self.ClassificationIndex_has_ClassificationIndexEntryPosition
    def set_ClassificationIndex_has_ClassificationIndexEntryPosition(self, ClassificationIndex_has_ClassificationIndexEntryPosition):
        self.ClassificationIndex_has_ClassificationIndexEntryPosition = ClassificationIndex_has_ClassificationIndexEntryPosition
    def add_ClassificationIndex_has_ClassificationIndexEntryPosition(self, value):
        self.ClassificationIndex_has_ClassificationIndexEntryPosition.append(value)
    def insert_ClassificationIndex_has_ClassificationIndexEntryPosition_at(self, index, value):
        self.ClassificationIndex_has_ClassificationIndexEntryPosition.insert(index, value)
    def replace_ClassificationIndex_has_ClassificationIndexEntryPosition_at(self, index, value):
        self.ClassificationIndex_has_ClassificationIndexEntryPosition[index] = value
    def get_ClassificationIndex_has_ClassificationIndexEntry(self):
        return self.ClassificationIndex_has_ClassificationIndexEntry
    def set_ClassificationIndex_has_ClassificationIndexEntry(self, ClassificationIndex_has_ClassificationIndexEntry):
        self.ClassificationIndex_has_ClassificationIndexEntry = ClassificationIndex_has_ClassificationIndexEntry
    def add_ClassificationIndex_has_ClassificationIndexEntry(self, value):
        self.ClassificationIndex_has_ClassificationIndexEntry.append(value)
    def insert_ClassificationIndex_has_ClassificationIndexEntry_at(self, index, value):
        self.ClassificationIndex_has_ClassificationIndexEntry.insert(index, value)
    def replace_ClassificationIndex_has_ClassificationIndexEntry_at(self, index, value):
        self.ClassificationIndex_has_ClassificationIndexEntry[index] = value
    def has__content(self):
        if (
            self.allowsDuplicates is not None or
            self.availableLanguage or
            self.catalogDetails is not None or
            self.codingInstruction or
            self.corrections or
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.releaseDate is not None or
            self.ClassificationIndex_isMaintainedBy_Agent is not None or
            self.ClassificationIndex_hasContact_Agent or
            self.ClassificationIndex_isDefinedBy_Concept or
            self.ClassificationIndex_has_ClassificationIndexEntryPosition or
            self.ClassificationIndex_has_ClassificationIndexEntry
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationIndex', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.allowsDuplicates is not None:
            allowsDuplicates_ = self.allowsDuplicates
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}allowsDuplicates').text = self.gds_format_boolean(allowsDuplicates_)
        for availableLanguage_ in self.availableLanguage:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}availableLanguage').text = self.gds_format_string(availableLanguage_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for codingInstruction_ in self.codingInstruction:
            codingInstruction_.to_etree(element, name_='codingInstruction', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for corrections_ in self.corrections:
            corrections_.to_etree(element, name_='corrections', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.releaseDate is not None:
            releaseDate_ = self.releaseDate
            releaseDate_.to_etree(element, name_='releaseDate', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ClassificationIndex_isMaintainedBy_Agent is not None:
            ClassificationIndex_isMaintainedBy_Agent_ = self.ClassificationIndex_isMaintainedBy_Agent
            ClassificationIndex_isMaintainedBy_Agent_.to_etree(element, name_='ClassificationIndex_isMaintainedBy_Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationIndex_hasContact_Agent_ in self.ClassificationIndex_hasContact_Agent:
            ClassificationIndex_hasContact_Agent_.to_etree(element, name_='ClassificationIndex_hasContact_Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationIndex_isDefinedBy_Concept_ in self.ClassificationIndex_isDefinedBy_Concept:
            ClassificationIndex_isDefinedBy_Concept_.to_etree(element, name_='ClassificationIndex_isDefinedBy_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationIndex_has_ClassificationIndexEntryPosition_ in self.ClassificationIndex_has_ClassificationIndexEntryPosition:
            ClassificationIndex_has_ClassificationIndexEntryPosition_.to_etree(element, name_='ClassificationIndex_has_ClassificationIndexEntryPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationIndex_has_ClassificationIndexEntry_ in self.ClassificationIndex_has_ClassificationIndexEntry:
            ClassificationIndex_has_ClassificationIndexEntry_.to_etree(element, name_='ClassificationIndex_has_ClassificationIndexEntry', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allowsDuplicates':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'allowsDuplicates')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowsDuplicates')
            self.allowsDuplicates = ival_
            self.allowsDuplicates_nsprefix_ = child_.prefix
        elif nodeName_ == 'availableLanguage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'availableLanguage')
            value_ = self.gds_validate_string(value_, node, 'availableLanguage')
            self.availableLanguage.append(value_)
            self.availableLanguage_nsprefix_ = child_.prefix
        elif nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'codingInstruction':
            obj_ = CommandCode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.codingInstruction.append(obj_)
            obj_.original_tagname_ = 'codingInstruction'
        elif nodeName_ == 'corrections':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.corrections.append(obj_)
            obj_.original_tagname_ = 'corrections'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'releaseDate':
            obj_ = CombinedDate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.releaseDate = obj_
            obj_.original_tagname_ = 'releaseDate'
        elif nodeName_ == 'ClassificationIndex_isMaintainedBy_Agent':
            obj_ = ClassificationIndex_isMaintainedBy_AgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationIndex_isMaintainedBy_Agent = obj_
            obj_.original_tagname_ = 'ClassificationIndex_isMaintainedBy_Agent'
        elif nodeName_ == 'ClassificationIndex_hasContact_Agent':
            obj_ = ClassificationIndex_hasContact_AgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationIndex_hasContact_Agent.append(obj_)
            obj_.original_tagname_ = 'ClassificationIndex_hasContact_Agent'
        elif nodeName_ == 'ClassificationIndex_isDefinedBy_Concept':
            obj_ = ClassificationIndex_isDefinedBy_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationIndex_isDefinedBy_Concept.append(obj_)
            obj_.original_tagname_ = 'ClassificationIndex_isDefinedBy_Concept'
        elif nodeName_ == 'ClassificationIndex_has_ClassificationIndexEntryPosition':
            obj_ = ClassificationIndex_has_ClassificationIndexEntryPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationIndex_has_ClassificationIndexEntryPosition.append(obj_)
            obj_.original_tagname_ = 'ClassificationIndex_has_ClassificationIndexEntryPosition'
        elif nodeName_ == 'ClassificationIndex_has_ClassificationIndexEntry':
            obj_ = ClassificationIndex_has_ClassificationIndexEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationIndex_has_ClassificationIndexEntry.append(obj_)
            obj_.original_tagname_ = 'ClassificationIndex_has_ClassificationIndexEntry'
# end class ClassificationIndex


class ClassificationIndexEntry(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    codingInstruction -- Additional information which drives the coding process for the Index Entry. Required when coding is dependent upon one or many other factors.
    entry -- Text describing the type of object/unit or object property.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    validDates -- The dates describing the validity period of the object. The date from which the object became valid must be defined if the map belongs to a "floating" construct. The date at which the object became invalid must be defined if the map belongs to a "floating" construct and is no longer valid.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, codingInstruction=None, entry=None, identifier=None, validDates=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.codingInstruction = codingInstruction
        self.codingInstruction_nsprefix_ = None
        self.entry = entry
        self.entry_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.validDates = validDates
        self.validDates_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationIndexEntry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationIndexEntry.subclass:
            return ClassificationIndexEntry.subclass(*args_, **kwargs_)
        else:
            return ClassificationIndexEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_codingInstruction(self):
        return self.codingInstruction
    def set_codingInstruction(self, codingInstruction):
        self.codingInstruction = codingInstruction
    def get_entry(self):
        return self.entry
    def set_entry(self, entry):
        self.entry = entry
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_validDates(self):
        return self.validDates
    def set_validDates(self, validDates):
        self.validDates = validDates
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.codingInstruction is not None or
            self.entry is not None or
            self.identifier is not None or
            self.validDates is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationIndexEntry', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.codingInstruction is not None:
            codingInstruction_ = self.codingInstruction
            codingInstruction_.to_etree(element, name_='codingInstruction', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.entry is not None:
            entry_ = self.entry
            entry_.to_etree(element, name_='entry', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validDates is not None:
            validDates_ = self.validDates
            validDates_.to_etree(element, name_='validDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'codingInstruction':
            obj_ = CommandCode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.codingInstruction = obj_
            obj_.original_tagname_ = 'codingInstruction'
        elif nodeName_ == 'entry':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entry = obj_
            obj_.original_tagname_ = 'entry'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'validDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validDates = obj_
            obj_.original_tagname_ = 'validDates'
# end class ClassificationIndexEntry


class ClassificationIndexEntryPosition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    value -- Index value of the member in an ordered array.
    ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry -- Restricts member target class to classification index entry.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, value=None, ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry = ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry
        self.ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationIndexEntryPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationIndexEntryPosition.subclass:
            return ClassificationIndexEntryPosition.subclass(*args_, **kwargs_)
        else:
            return ClassificationIndexEntryPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry(self):
        return self.ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry
    def set_ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry(self, ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry):
        self.ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry = ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry
    def has__content(self):
        if (
            self.identifier is not None or
            self.value is not None or
            self.ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationIndexEntryPosition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_integer(value_)
        if self.ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry is not None:
            ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_ = self.ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry
            ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry_.to_etree(element, name_='ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
        elif nodeName_ == 'ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry':
            obj_ = ClassificationIndexEntryPosition_indexes_ClassificationIndexEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry = obj_
            obj_.original_tagname_ = 'ClassificationIndexEntryPosition_indexes_ClassificationIndexEntry'
# end class ClassificationIndexEntryPosition


class ClassificationItem(GeneratedsSuper):
    """changeFromPreviousVersion -- Describes the changes, which the item has been subject to from the previous version to the actual statistical classification.
    changeLog -- Describes the changes, which the item has been subject to during the life time of the actual statistical classification.
    explanatoryNotes -- A classification item may be associated with explanatory notes, which further describe and clarify the contents of the category. Explanatory notes consist of: General note: Contains either additional information about the category, or a general description of the category, which is not structured according to the "includes", "includes also", "excludes" pattern. Includes: Specifies the contents of the category. Includes also: A list of borderline cases, which belong to the described category. Excludes: A list of borderline cases, which do not belong to the described category. Excluded cases may contain a reference to the classification items to which the excluded cases belong.
    futureNotes -- The future events describe an intended or implemented change (or a number of changes) related to an invalid item (e.g., these changes may have turned the now invalid item into one or several successor items). This allows for the possibility of following successors of the item in the future.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    isGenerated -- Indicates whether or not the item has been generated to make the level to which it belongs complete.
    isValid -- Indicates whether or not the item is currently valid. If updates are allowed in the Statistical Classification, an item may be restricted in its validity, i.e. it may become valid or invalid after the Statistical Classification has been released.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage. A Classification Item has an official name as provided by the owner or maintenance unit. The name describes the content of the category. The name is unique within the Statistical Classification to which the item belongs, except for categories that are identical at more than one level in a hierarchical classification. Use the context attribute to differentiate official names or alternate names for the Classification Item.
    validDates -- The dates describing the validity period of the object. The date from which the object became valid must be defined if the map belongs to a "floating" construct. The date at which the object became invalid must be defined if the map belongs to a "floating" construct and is no longer valid.
    ClassificationItem_excludes_ClassificationItem -- Classification items to which the excluded cases belong (as described in explanatory notes).
    ClassificationItem_denotes_Category -- A definition for the code. Specialization of denotes for categories.
    ClassificationItem_uses_Notation -- Classification item uses a notation.
    ClassificationItem_hasRulingBy_AuthorizationSource -- Case law rulings related to the classification item.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, changeFromPreviousVersion=None, changeLog=None, explanatoryNotes=None, futureNotes=None, identifier=None, isGenerated=None, isValid=None, name=None, validDates=None, ClassificationItem_excludes_ClassificationItem=None, ClassificationItem_denotes_Category=None, ClassificationItem_uses_Notation=None, ClassificationItem_hasRulingBy_AuthorizationSource=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.changeFromPreviousVersion = changeFromPreviousVersion
        self.changeFromPreviousVersion_nsprefix_ = None
        self.changeLog = changeLog
        self.changeLog_nsprefix_ = None
        if explanatoryNotes is None:
            self.explanatoryNotes = []
        else:
            self.explanatoryNotes = explanatoryNotes
        self.explanatoryNotes_nsprefix_ = None
        if futureNotes is None:
            self.futureNotes = []
        else:
            self.futureNotes = futureNotes
        self.futureNotes_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.isGenerated = isGenerated
        self.isGenerated_nsprefix_ = None
        self.isValid = isValid
        self.isValid_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.validDates = validDates
        self.validDates_nsprefix_ = None
        if ClassificationItem_excludes_ClassificationItem is None:
            self.ClassificationItem_excludes_ClassificationItem = []
        else:
            self.ClassificationItem_excludes_ClassificationItem = ClassificationItem_excludes_ClassificationItem
        self.ClassificationItem_excludes_ClassificationItem_nsprefix_ = None
        self.ClassificationItem_denotes_Category = ClassificationItem_denotes_Category
        self.ClassificationItem_denotes_Category_nsprefix_ = None
        self.ClassificationItem_uses_Notation = ClassificationItem_uses_Notation
        self.ClassificationItem_uses_Notation_nsprefix_ = None
        if ClassificationItem_hasRulingBy_AuthorizationSource is None:
            self.ClassificationItem_hasRulingBy_AuthorizationSource = []
        else:
            self.ClassificationItem_hasRulingBy_AuthorizationSource = ClassificationItem_hasRulingBy_AuthorizationSource
        self.ClassificationItem_hasRulingBy_AuthorizationSource_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationItem.subclass:
            return ClassificationItem.subclass(*args_, **kwargs_)
        else:
            return ClassificationItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_changeFromPreviousVersion(self):
        return self.changeFromPreviousVersion
    def set_changeFromPreviousVersion(self, changeFromPreviousVersion):
        self.changeFromPreviousVersion = changeFromPreviousVersion
    def get_changeLog(self):
        return self.changeLog
    def set_changeLog(self, changeLog):
        self.changeLog = changeLog
    def get_explanatoryNotes(self):
        return self.explanatoryNotes
    def set_explanatoryNotes(self, explanatoryNotes):
        self.explanatoryNotes = explanatoryNotes
    def add_explanatoryNotes(self, value):
        self.explanatoryNotes.append(value)
    def insert_explanatoryNotes_at(self, index, value):
        self.explanatoryNotes.insert(index, value)
    def replace_explanatoryNotes_at(self, index, value):
        self.explanatoryNotes[index] = value
    def get_futureNotes(self):
        return self.futureNotes
    def set_futureNotes(self, futureNotes):
        self.futureNotes = futureNotes
    def add_futureNotes(self, value):
        self.futureNotes.append(value)
    def insert_futureNotes_at(self, index, value):
        self.futureNotes.insert(index, value)
    def replace_futureNotes_at(self, index, value):
        self.futureNotes[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_isGenerated(self):
        return self.isGenerated
    def set_isGenerated(self, isGenerated):
        self.isGenerated = isGenerated
    def get_isValid(self):
        return self.isValid
    def set_isValid(self, isValid):
        self.isValid = isValid
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_validDates(self):
        return self.validDates
    def set_validDates(self, validDates):
        self.validDates = validDates
    def get_ClassificationItem_excludes_ClassificationItem(self):
        return self.ClassificationItem_excludes_ClassificationItem
    def set_ClassificationItem_excludes_ClassificationItem(self, ClassificationItem_excludes_ClassificationItem):
        self.ClassificationItem_excludes_ClassificationItem = ClassificationItem_excludes_ClassificationItem
    def add_ClassificationItem_excludes_ClassificationItem(self, value):
        self.ClassificationItem_excludes_ClassificationItem.append(value)
    def insert_ClassificationItem_excludes_ClassificationItem_at(self, index, value):
        self.ClassificationItem_excludes_ClassificationItem.insert(index, value)
    def replace_ClassificationItem_excludes_ClassificationItem_at(self, index, value):
        self.ClassificationItem_excludes_ClassificationItem[index] = value
    def get_ClassificationItem_denotes_Category(self):
        return self.ClassificationItem_denotes_Category
    def set_ClassificationItem_denotes_Category(self, ClassificationItem_denotes_Category):
        self.ClassificationItem_denotes_Category = ClassificationItem_denotes_Category
    def get_ClassificationItem_uses_Notation(self):
        return self.ClassificationItem_uses_Notation
    def set_ClassificationItem_uses_Notation(self, ClassificationItem_uses_Notation):
        self.ClassificationItem_uses_Notation = ClassificationItem_uses_Notation
    def get_ClassificationItem_hasRulingBy_AuthorizationSource(self):
        return self.ClassificationItem_hasRulingBy_AuthorizationSource
    def set_ClassificationItem_hasRulingBy_AuthorizationSource(self, ClassificationItem_hasRulingBy_AuthorizationSource):
        self.ClassificationItem_hasRulingBy_AuthorizationSource = ClassificationItem_hasRulingBy_AuthorizationSource
    def add_ClassificationItem_hasRulingBy_AuthorizationSource(self, value):
        self.ClassificationItem_hasRulingBy_AuthorizationSource.append(value)
    def insert_ClassificationItem_hasRulingBy_AuthorizationSource_at(self, index, value):
        self.ClassificationItem_hasRulingBy_AuthorizationSource.insert(index, value)
    def replace_ClassificationItem_hasRulingBy_AuthorizationSource_at(self, index, value):
        self.ClassificationItem_hasRulingBy_AuthorizationSource[index] = value
    def has__content(self):
        if (
            self.changeFromPreviousVersion is not None or
            self.changeLog is not None or
            self.explanatoryNotes or
            self.futureNotes or
            self.identifier is not None or
            self.isGenerated is not None or
            self.isValid is not None or
            self.name or
            self.validDates is not None or
            self.ClassificationItem_excludes_ClassificationItem or
            self.ClassificationItem_denotes_Category is not None or
            self.ClassificationItem_uses_Notation is not None or
            self.ClassificationItem_hasRulingBy_AuthorizationSource
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationItem', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.changeFromPreviousVersion is not None:
            changeFromPreviousVersion_ = self.changeFromPreviousVersion
            changeFromPreviousVersion_.to_etree(element, name_='changeFromPreviousVersion', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.changeLog is not None:
            changeLog_ = self.changeLog
            changeLog_.to_etree(element, name_='changeLog', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for explanatoryNotes_ in self.explanatoryNotes:
            explanatoryNotes_.to_etree(element, name_='explanatoryNotes', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for futureNotes_ in self.futureNotes:
            futureNotes_.to_etree(element, name_='futureNotes', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isGenerated is not None:
            isGenerated_ = self.isGenerated
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isGenerated').text = self.gds_format_boolean(isGenerated_)
        if self.isValid is not None:
            isValid_ = self.isValid
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isValid').text = self.gds_format_boolean(isValid_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validDates is not None:
            validDates_ = self.validDates
            validDates_.to_etree(element, name_='validDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationItem_excludes_ClassificationItem_ in self.ClassificationItem_excludes_ClassificationItem:
            ClassificationItem_excludes_ClassificationItem_.to_etree(element, name_='ClassificationItem_excludes_ClassificationItem', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ClassificationItem_denotes_Category is not None:
            ClassificationItem_denotes_Category_ = self.ClassificationItem_denotes_Category
            ClassificationItem_denotes_Category_.to_etree(element, name_='ClassificationItem_denotes_Category', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ClassificationItem_uses_Notation is not None:
            ClassificationItem_uses_Notation_ = self.ClassificationItem_uses_Notation
            ClassificationItem_uses_Notation_.to_etree(element, name_='ClassificationItem_uses_Notation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationItem_hasRulingBy_AuthorizationSource_ in self.ClassificationItem_hasRulingBy_AuthorizationSource:
            ClassificationItem_hasRulingBy_AuthorizationSource_.to_etree(element, name_='ClassificationItem_hasRulingBy_AuthorizationSource', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'changeFromPreviousVersion':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.changeFromPreviousVersion = obj_
            obj_.original_tagname_ = 'changeFromPreviousVersion'
        elif nodeName_ == 'changeLog':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.changeLog = obj_
            obj_.original_tagname_ = 'changeLog'
        elif nodeName_ == 'explanatoryNotes':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.explanatoryNotes.append(obj_)
            obj_.original_tagname_ = 'explanatoryNotes'
        elif nodeName_ == 'futureNotes':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.futureNotes.append(obj_)
            obj_.original_tagname_ = 'futureNotes'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'isGenerated':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isGenerated')
            ival_ = self.gds_validate_boolean(ival_, node, 'isGenerated')
            self.isGenerated = ival_
            self.isGenerated_nsprefix_ = child_.prefix
        elif nodeName_ == 'isValid':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isValid')
            ival_ = self.gds_validate_boolean(ival_, node, 'isValid')
            self.isValid = ival_
            self.isValid_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'validDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validDates = obj_
            obj_.original_tagname_ = 'validDates'
        elif nodeName_ == 'ClassificationItem_excludes_ClassificationItem':
            obj_ = ClassificationItem_excludes_ClassificationItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItem_excludes_ClassificationItem.append(obj_)
            obj_.original_tagname_ = 'ClassificationItem_excludes_ClassificationItem'
        elif nodeName_ == 'ClassificationItem_denotes_Category':
            obj_ = ClassificationItem_denotes_CategoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItem_denotes_Category = obj_
            obj_.original_tagname_ = 'ClassificationItem_denotes_Category'
        elif nodeName_ == 'ClassificationItem_uses_Notation':
            obj_ = ClassificationItem_uses_NotationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItem_uses_Notation = obj_
            obj_.original_tagname_ = 'ClassificationItem_uses_Notation'
        elif nodeName_ == 'ClassificationItem_hasRulingBy_AuthorizationSource':
            obj_ = ClassificationItem_hasRulingBy_AuthorizationSourceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItem_hasRulingBy_AuthorizationSource.append(obj_)
            obj_.original_tagname_ = 'ClassificationItem_hasRulingBy_AuthorizationSource'
# end class ClassificationItem


class ClassificationItemPosition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    value -- Index value of the member in an ordered array.
    ClassificationItemPosition_indexes_ClassificationItem -- Classification item position indexes zero to one classification items. The member containing the designation of the classification item.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, value=None, ClassificationItemPosition_indexes_ClassificationItem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.ClassificationItemPosition_indexes_ClassificationItem = ClassificationItemPosition_indexes_ClassificationItem
        self.ClassificationItemPosition_indexes_ClassificationItem_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationItemPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationItemPosition.subclass:
            return ClassificationItemPosition.subclass(*args_, **kwargs_)
        else:
            return ClassificationItemPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_ClassificationItemPosition_indexes_ClassificationItem(self):
        return self.ClassificationItemPosition_indexes_ClassificationItem
    def set_ClassificationItemPosition_indexes_ClassificationItem(self, ClassificationItemPosition_indexes_ClassificationItem):
        self.ClassificationItemPosition_indexes_ClassificationItem = ClassificationItemPosition_indexes_ClassificationItem
    def has__content(self):
        if (
            self.identifier is not None or
            self.value is not None or
            self.ClassificationItemPosition_indexes_ClassificationItem is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationItemPosition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_integer(value_)
        if self.ClassificationItemPosition_indexes_ClassificationItem is not None:
            ClassificationItemPosition_indexes_ClassificationItem_ = self.ClassificationItemPosition_indexes_ClassificationItem
            ClassificationItemPosition_indexes_ClassificationItem_.to_etree(element, name_='ClassificationItemPosition_indexes_ClassificationItem', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
        elif nodeName_ == 'ClassificationItemPosition_indexes_ClassificationItem':
            obj_ = ClassificationItemPosition_indexes_ClassificationItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItemPosition_indexes_ClassificationItem = obj_
            obj_.original_tagname_ = 'ClassificationItemPosition_indexes_ClassificationItem'
# end class ClassificationItemPosition


class ClassificationItemRelationship(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    ClassificationItemRelationship_hasTarget_ClassificationItem -- Note that this can be realized as a collection to support tuples.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, semantics=None, ClassificationItemRelationship_hasSource_ClassificationItem=None, ClassificationItemRelationship_hasTarget_ClassificationItem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        if ClassificationItemRelationship_hasSource_ClassificationItem is None:
            self.ClassificationItemRelationship_hasSource_ClassificationItem = []
        else:
            self.ClassificationItemRelationship_hasSource_ClassificationItem = ClassificationItemRelationship_hasSource_ClassificationItem
        self.ClassificationItemRelationship_hasSource_ClassificationItem_nsprefix_ = None
        if ClassificationItemRelationship_hasTarget_ClassificationItem is None:
            self.ClassificationItemRelationship_hasTarget_ClassificationItem = []
        else:
            self.ClassificationItemRelationship_hasTarget_ClassificationItem = ClassificationItemRelationship_hasTarget_ClassificationItem
        self.ClassificationItemRelationship_hasTarget_ClassificationItem_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationItemRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationItemRelationship.subclass:
            return ClassificationItemRelationship.subclass(*args_, **kwargs_)
        else:
            return ClassificationItemRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_ClassificationItemRelationship_hasSource_ClassificationItem(self):
        return self.ClassificationItemRelationship_hasSource_ClassificationItem
    def set_ClassificationItemRelationship_hasSource_ClassificationItem(self, ClassificationItemRelationship_hasSource_ClassificationItem):
        self.ClassificationItemRelationship_hasSource_ClassificationItem = ClassificationItemRelationship_hasSource_ClassificationItem
    def add_ClassificationItemRelationship_hasSource_ClassificationItem(self, value):
        self.ClassificationItemRelationship_hasSource_ClassificationItem.append(value)
    def insert_ClassificationItemRelationship_hasSource_ClassificationItem_at(self, index, value):
        self.ClassificationItemRelationship_hasSource_ClassificationItem.insert(index, value)
    def replace_ClassificationItemRelationship_hasSource_ClassificationItem_at(self, index, value):
        self.ClassificationItemRelationship_hasSource_ClassificationItem[index] = value
    def get_ClassificationItemRelationship_hasTarget_ClassificationItem(self):
        return self.ClassificationItemRelationship_hasTarget_ClassificationItem
    def set_ClassificationItemRelationship_hasTarget_ClassificationItem(self, ClassificationItemRelationship_hasTarget_ClassificationItem):
        self.ClassificationItemRelationship_hasTarget_ClassificationItem = ClassificationItemRelationship_hasTarget_ClassificationItem
    def add_ClassificationItemRelationship_hasTarget_ClassificationItem(self, value):
        self.ClassificationItemRelationship_hasTarget_ClassificationItem.append(value)
    def insert_ClassificationItemRelationship_hasTarget_ClassificationItem_at(self, index, value):
        self.ClassificationItemRelationship_hasTarget_ClassificationItem.insert(index, value)
    def replace_ClassificationItemRelationship_hasTarget_ClassificationItem_at(self, index, value):
        self.ClassificationItemRelationship_hasTarget_ClassificationItem[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.semantics is not None or
            self.ClassificationItemRelationship_hasSource_ClassificationItem or
            self.ClassificationItemRelationship_hasTarget_ClassificationItem
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationItemRelationship', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationItemRelationship_hasSource_ClassificationItem_ in self.ClassificationItemRelationship_hasSource_ClassificationItem:
            ClassificationItemRelationship_hasSource_ClassificationItem_.to_etree(element, name_='ClassificationItemRelationship_hasSource_ClassificationItem', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationItemRelationship_hasTarget_ClassificationItem_ in self.ClassificationItemRelationship_hasTarget_ClassificationItem:
            ClassificationItemRelationship_hasTarget_ClassificationItem_.to_etree(element, name_='ClassificationItemRelationship_hasTarget_ClassificationItem', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'ClassificationItemRelationship_hasSource_ClassificationItem':
            obj_ = ClassificationItemRelationship_hasSource_ClassificationItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItemRelationship_hasSource_ClassificationItem.append(obj_)
            obj_.original_tagname_ = 'ClassificationItemRelationship_hasSource_ClassificationItem'
        elif nodeName_ == 'ClassificationItemRelationship_hasTarget_ClassificationItem':
            obj_ = ClassificationItemRelationship_hasTarget_ClassificationItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItemRelationship_hasTarget_ClassificationItem.append(obj_)
            obj_.original_tagname_ = 'ClassificationItemRelationship_hasTarget_ClassificationItem'
# end class ClassificationItemRelationship


class ClassificationItemStructure(GeneratedsSuper):
    """displayLabel -- A human-readable display label for the object. Supports the use of multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    specification -- Provides information on reflexivity, transitivity, and symmetry of relationship using a descriptive term from an enumerated list. Use if all relations within this relation structure are of the same specification.
    topology -- Indicates the form of the associations among members of the collection. Specifies the way in which constituent parts are interrelated or arranged.
    totality -- Indicates whether the related collections are comprehensive in terms of their coverage.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, displayLabel=None, identifier=None, name=None, purpose=None, semantics=None, specification=None, topology=None, totality=None, ClassificationItemStructure_structures_StatisticalClassification=None, ClassificationItemStructure_has_ClassificationItemRelationship=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if displayLabel is None:
            self.displayLabel = []
        else:
            self.displayLabel = displayLabel
        self.displayLabel_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        self.specification = specification
        self.specification_nsprefix_ = None
        self.topology = topology
        self.topology_nsprefix_ = None
        self.totality = totality
        self.validate_StructureExtent(self.totality)
        self.totality_nsprefix_ = None
        self.ClassificationItemStructure_structures_StatisticalClassification = ClassificationItemStructure_structures_StatisticalClassification
        self.ClassificationItemStructure_structures_StatisticalClassification_nsprefix_ = None
        if ClassificationItemStructure_has_ClassificationItemRelationship is None:
            self.ClassificationItemStructure_has_ClassificationItemRelationship = []
        else:
            self.ClassificationItemStructure_has_ClassificationItemRelationship = ClassificationItemStructure_has_ClassificationItemRelationship
        self.ClassificationItemStructure_has_ClassificationItemRelationship_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationItemStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationItemStructure.subclass:
            return ClassificationItemStructure.subclass(*args_, **kwargs_)
        else:
            return ClassificationItemStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def add_displayLabel(self, value):
        self.displayLabel.append(value)
    def insert_displayLabel_at(self, index, value):
        self.displayLabel.insert(index, value)
    def replace_displayLabel_at(self, index, value):
        self.displayLabel[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_specification(self):
        return self.specification
    def set_specification(self, specification):
        self.specification = specification
    def get_topology(self):
        return self.topology
    def set_topology(self, topology):
        self.topology = topology
    def get_totality(self):
        return self.totality
    def set_totality(self, totality):
        self.totality = totality
    def get_ClassificationItemStructure_structures_StatisticalClassification(self):
        return self.ClassificationItemStructure_structures_StatisticalClassification
    def set_ClassificationItemStructure_structures_StatisticalClassification(self, ClassificationItemStructure_structures_StatisticalClassification):
        self.ClassificationItemStructure_structures_StatisticalClassification = ClassificationItemStructure_structures_StatisticalClassification
    def get_ClassificationItemStructure_has_ClassificationItemRelationship(self):
        return self.ClassificationItemStructure_has_ClassificationItemRelationship
    def set_ClassificationItemStructure_has_ClassificationItemRelationship(self, ClassificationItemStructure_has_ClassificationItemRelationship):
        self.ClassificationItemStructure_has_ClassificationItemRelationship = ClassificationItemStructure_has_ClassificationItemRelationship
    def add_ClassificationItemStructure_has_ClassificationItemRelationship(self, value):
        self.ClassificationItemStructure_has_ClassificationItemRelationship.append(value)
    def insert_ClassificationItemStructure_has_ClassificationItemRelationship_at(self, index, value):
        self.ClassificationItemStructure_has_ClassificationItemRelationship.insert(index, value)
    def replace_ClassificationItemStructure_has_ClassificationItemRelationship_at(self, index, value):
        self.ClassificationItemStructure_has_ClassificationItemRelationship[index] = value
    def validate_StructureExtent(self, value):
        result = True
        # Validate type StructureExtent, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Partial', 'Total']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StructureExtent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.displayLabel or
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.semantics is not None or
            self.specification is not None or
            self.topology is not None or
            self.totality is not None or
            self.ClassificationItemStructure_structures_StatisticalClassification is not None or
            self.ClassificationItemStructure_has_ClassificationItemRelationship
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationItemStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        for displayLabel_ in self.displayLabel:
            displayLabel_.to_etree(element, name_='displayLabel', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.specification is not None:
            specification_ = self.specification
            specification_.to_etree(element, name_='specification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.topology is not None:
            topology_ = self.topology
            topology_.to_etree(element, name_='topology', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.totality is not None:
            totality_ = self.totality
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}totality').text = self.gds_format_string(totality_)
        if self.ClassificationItemStructure_structures_StatisticalClassification is not None:
            ClassificationItemStructure_structures_StatisticalClassification_ = self.ClassificationItemStructure_structures_StatisticalClassification
            ClassificationItemStructure_structures_StatisticalClassification_.to_etree(element, name_='ClassificationItemStructure_structures_StatisticalClassification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationItemStructure_has_ClassificationItemRelationship_ in self.ClassificationItemStructure_has_ClassificationItemRelationship:
            ClassificationItemStructure_has_ClassificationItemRelationship_.to_etree(element, name_='ClassificationItemStructure_has_ClassificationItemRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'displayLabel':
            obj_ = LabelForDisplay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayLabel.append(obj_)
            obj_.original_tagname_ = 'displayLabel'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'specification':
            obj_ = StructureSpecification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specification = obj_
            obj_.original_tagname_ = 'specification'
        elif nodeName_ == 'topology':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.topology = obj_
            obj_.original_tagname_ = 'topology'
        elif nodeName_ == 'totality':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totality')
            value_ = self.gds_validate_string(value_, node, 'totality')
            self.totality = value_
            self.totality_nsprefix_ = child_.prefix
            # validate type StructureExtent
            self.validate_StructureExtent(self.totality)
        elif nodeName_ == 'ClassificationItemStructure_structures_StatisticalClassification':
            obj_ = ClassificationItemStructure_structures_StatisticalClassificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItemStructure_structures_StatisticalClassification = obj_
            obj_.original_tagname_ = 'ClassificationItemStructure_structures_StatisticalClassification'
        elif nodeName_ == 'ClassificationItemStructure_has_ClassificationItemRelationship':
            obj_ = ClassificationItemStructure_has_ClassificationItemRelationshipType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationItemStructure_has_ClassificationItemRelationship.append(obj_)
            obj_.original_tagname_ = 'ClassificationItemStructure_has_ClassificationItemRelationship'
# end class ClassificationItemStructure


class ClassificationPosition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    value -- Index value of the member in an ordered array.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, value=None, ClassificationPosition_indexes_StatisticalClassification=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.ClassificationPosition_indexes_StatisticalClassification = ClassificationPosition_indexes_StatisticalClassification
        self.ClassificationPosition_indexes_StatisticalClassification_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationPosition.subclass:
            return ClassificationPosition.subclass(*args_, **kwargs_)
        else:
            return ClassificationPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_ClassificationPosition_indexes_StatisticalClassification(self):
        return self.ClassificationPosition_indexes_StatisticalClassification
    def set_ClassificationPosition_indexes_StatisticalClassification(self, ClassificationPosition_indexes_StatisticalClassification):
        self.ClassificationPosition_indexes_StatisticalClassification = ClassificationPosition_indexes_StatisticalClassification
    def has__content(self):
        if (
            self.identifier is not None or
            self.value is not None or
            self.ClassificationPosition_indexes_StatisticalClassification is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationPosition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_integer(value_)
        if self.ClassificationPosition_indexes_StatisticalClassification is not None:
            ClassificationPosition_indexes_StatisticalClassification_ = self.ClassificationPosition_indexes_StatisticalClassification
            ClassificationPosition_indexes_StatisticalClassification_.to_etree(element, name_='ClassificationPosition_indexes_StatisticalClassification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
        elif nodeName_ == 'ClassificationPosition_indexes_StatisticalClassification':
            obj_ = ClassificationPosition_indexes_StatisticalClassificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationPosition_indexes_StatisticalClassification = obj_
            obj_.original_tagname_ = 'ClassificationPosition_indexes_StatisticalClassification'
# end class ClassificationPosition


class ClassificationSeries(GeneratedsSuper):
    """allowsDuplicates -- If value is False, the members are unique within the collection - if True, there may be duplicates. (Note that a mathematical
    “
    bag
    ”
    permits duplicates and is unordered - a
    “
    set
    ”
    does not have duplicates and may be ordered.)
    catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    context -- Classification series can be designed in a specific context of use. This property indicates that context, and supports the use of an external controlled vocabulary for this purpose.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    keyword -- A classification series can be associated with one or a number of keywords.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    objectsOrUnitsClassified -- A classification series is designed to classify a specific type of object/unit according to a specific attribute.
    purpose -- Intent or reason for the object/the description of the object.
    subject -- Scientific domains, disciplines, or areas of statistics in which the classification series is implemented.
    ClassificationSeries_isOwnedBy_Agent -- The statistical office or other authority, which created and maintains the statistical classification(s) related to the classification series. A classification series may have several owners.
    ClassificationSeries_isDefinedBy_Concept -- The conceptual basis for the collection of members.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, allowsDuplicates=None, catalogDetails=None, context=None, identifier=None, keyword=None, name=None, objectsOrUnitsClassified=None, purpose=None, subject=None, ClassificationSeries_isOwnedBy_Agent=None, ClassificationSeries_isDefinedBy_Concept=None, ClassificationSeries_has_StatisticalClassification=None, ClassificationSeries_has_ClassificationPosition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.allowsDuplicates = allowsDuplicates
        self.allowsDuplicates_nsprefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.context = context
        self.context_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if keyword is None:
            self.keyword = []
        else:
            self.keyword = keyword
        self.keyword_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.objectsOrUnitsClassified = objectsOrUnitsClassified
        self.objectsOrUnitsClassified_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        if subject is None:
            self.subject = []
        else:
            self.subject = subject
        self.subject_nsprefix_ = None
        if ClassificationSeries_isOwnedBy_Agent is None:
            self.ClassificationSeries_isOwnedBy_Agent = []
        else:
            self.ClassificationSeries_isOwnedBy_Agent = ClassificationSeries_isOwnedBy_Agent
        self.ClassificationSeries_isOwnedBy_Agent_nsprefix_ = None
        if ClassificationSeries_isDefinedBy_Concept is None:
            self.ClassificationSeries_isDefinedBy_Concept = []
        else:
            self.ClassificationSeries_isDefinedBy_Concept = ClassificationSeries_isDefinedBy_Concept
        self.ClassificationSeries_isDefinedBy_Concept_nsprefix_ = None
        if ClassificationSeries_has_StatisticalClassification is None:
            self.ClassificationSeries_has_StatisticalClassification = []
        else:
            self.ClassificationSeries_has_StatisticalClassification = ClassificationSeries_has_StatisticalClassification
        self.ClassificationSeries_has_StatisticalClassification_nsprefix_ = None
        if ClassificationSeries_has_ClassificationPosition is None:
            self.ClassificationSeries_has_ClassificationPosition = []
        else:
            self.ClassificationSeries_has_ClassificationPosition = ClassificationSeries_has_ClassificationPosition
        self.ClassificationSeries_has_ClassificationPosition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationSeries)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationSeries.subclass:
            return ClassificationSeries.subclass(*args_, **kwargs_)
        else:
            return ClassificationSeries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_allowsDuplicates(self):
        return self.allowsDuplicates
    def set_allowsDuplicates(self, allowsDuplicates):
        self.allowsDuplicates = allowsDuplicates
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_context(self):
        return self.context
    def set_context(self, context):
        self.context = context
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_keyword(self):
        return self.keyword
    def set_keyword(self, keyword):
        self.keyword = keyword
    def add_keyword(self, value):
        self.keyword.append(value)
    def insert_keyword_at(self, index, value):
        self.keyword.insert(index, value)
    def replace_keyword_at(self, index, value):
        self.keyword[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_objectsOrUnitsClassified(self):
        return self.objectsOrUnitsClassified
    def set_objectsOrUnitsClassified(self, objectsOrUnitsClassified):
        self.objectsOrUnitsClassified = objectsOrUnitsClassified
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def add_subject(self, value):
        self.subject.append(value)
    def insert_subject_at(self, index, value):
        self.subject.insert(index, value)
    def replace_subject_at(self, index, value):
        self.subject[index] = value
    def get_ClassificationSeries_isOwnedBy_Agent(self):
        return self.ClassificationSeries_isOwnedBy_Agent
    def set_ClassificationSeries_isOwnedBy_Agent(self, ClassificationSeries_isOwnedBy_Agent):
        self.ClassificationSeries_isOwnedBy_Agent = ClassificationSeries_isOwnedBy_Agent
    def add_ClassificationSeries_isOwnedBy_Agent(self, value):
        self.ClassificationSeries_isOwnedBy_Agent.append(value)
    def insert_ClassificationSeries_isOwnedBy_Agent_at(self, index, value):
        self.ClassificationSeries_isOwnedBy_Agent.insert(index, value)
    def replace_ClassificationSeries_isOwnedBy_Agent_at(self, index, value):
        self.ClassificationSeries_isOwnedBy_Agent[index] = value
    def get_ClassificationSeries_isDefinedBy_Concept(self):
        return self.ClassificationSeries_isDefinedBy_Concept
    def set_ClassificationSeries_isDefinedBy_Concept(self, ClassificationSeries_isDefinedBy_Concept):
        self.ClassificationSeries_isDefinedBy_Concept = ClassificationSeries_isDefinedBy_Concept
    def add_ClassificationSeries_isDefinedBy_Concept(self, value):
        self.ClassificationSeries_isDefinedBy_Concept.append(value)
    def insert_ClassificationSeries_isDefinedBy_Concept_at(self, index, value):
        self.ClassificationSeries_isDefinedBy_Concept.insert(index, value)
    def replace_ClassificationSeries_isDefinedBy_Concept_at(self, index, value):
        self.ClassificationSeries_isDefinedBy_Concept[index] = value
    def get_ClassificationSeries_has_StatisticalClassification(self):
        return self.ClassificationSeries_has_StatisticalClassification
    def set_ClassificationSeries_has_StatisticalClassification(self, ClassificationSeries_has_StatisticalClassification):
        self.ClassificationSeries_has_StatisticalClassification = ClassificationSeries_has_StatisticalClassification
    def add_ClassificationSeries_has_StatisticalClassification(self, value):
        self.ClassificationSeries_has_StatisticalClassification.append(value)
    def insert_ClassificationSeries_has_StatisticalClassification_at(self, index, value):
        self.ClassificationSeries_has_StatisticalClassification.insert(index, value)
    def replace_ClassificationSeries_has_StatisticalClassification_at(self, index, value):
        self.ClassificationSeries_has_StatisticalClassification[index] = value
    def get_ClassificationSeries_has_ClassificationPosition(self):
        return self.ClassificationSeries_has_ClassificationPosition
    def set_ClassificationSeries_has_ClassificationPosition(self, ClassificationSeries_has_ClassificationPosition):
        self.ClassificationSeries_has_ClassificationPosition = ClassificationSeries_has_ClassificationPosition
    def add_ClassificationSeries_has_ClassificationPosition(self, value):
        self.ClassificationSeries_has_ClassificationPosition.append(value)
    def insert_ClassificationSeries_has_ClassificationPosition_at(self, index, value):
        self.ClassificationSeries_has_ClassificationPosition.insert(index, value)
    def replace_ClassificationSeries_has_ClassificationPosition_at(self, index, value):
        self.ClassificationSeries_has_ClassificationPosition[index] = value
    def has__content(self):
        if (
            self.allowsDuplicates is not None or
            self.catalogDetails is not None or
            self.context is not None or
            self.identifier is not None or
            self.keyword or
            self.name or
            self.objectsOrUnitsClassified is not None or
            self.purpose is not None or
            self.subject or
            self.ClassificationSeries_isOwnedBy_Agent or
            self.ClassificationSeries_isDefinedBy_Concept or
            self.ClassificationSeries_has_StatisticalClassification or
            self.ClassificationSeries_has_ClassificationPosition
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationSeries', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.allowsDuplicates is not None:
            allowsDuplicates_ = self.allowsDuplicates
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}allowsDuplicates').text = self.gds_format_boolean(allowsDuplicates_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.context is not None:
            context_ = self.context
            context_.to_etree(element, name_='context', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for keyword_ in self.keyword:
            keyword_.to_etree(element, name_='keyword', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.objectsOrUnitsClassified is not None:
            objectsOrUnitsClassified_ = self.objectsOrUnitsClassified
            objectsOrUnitsClassified_.to_etree(element, name_='objectsOrUnitsClassified', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for subject_ in self.subject:
            subject_.to_etree(element, name_='subject', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationSeries_isOwnedBy_Agent_ in self.ClassificationSeries_isOwnedBy_Agent:
            ClassificationSeries_isOwnedBy_Agent_.to_etree(element, name_='ClassificationSeries_isOwnedBy_Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationSeries_isDefinedBy_Concept_ in self.ClassificationSeries_isDefinedBy_Concept:
            ClassificationSeries_isDefinedBy_Concept_.to_etree(element, name_='ClassificationSeries_isDefinedBy_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationSeries_has_StatisticalClassification_ in self.ClassificationSeries_has_StatisticalClassification:
            ClassificationSeries_has_StatisticalClassification_.to_etree(element, name_='ClassificationSeries_has_StatisticalClassification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationSeries_has_ClassificationPosition_ in self.ClassificationSeries_has_ClassificationPosition:
            ClassificationSeries_has_ClassificationPosition_.to_etree(element, name_='ClassificationSeries_has_ClassificationPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allowsDuplicates':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'allowsDuplicates')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowsDuplicates')
            self.allowsDuplicates = ival_
            self.allowsDuplicates_nsprefix_ = child_.prefix
        elif nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'context':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.context = obj_
            obj_.original_tagname_ = 'context'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'keyword':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.keyword.append(obj_)
            obj_.original_tagname_ = 'keyword'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'objectsOrUnitsClassified':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.objectsOrUnitsClassified = obj_
            obj_.original_tagname_ = 'objectsOrUnitsClassified'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'subject':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject.append(obj_)
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'ClassificationSeries_isOwnedBy_Agent':
            obj_ = ClassificationSeries_isOwnedBy_AgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationSeries_isOwnedBy_Agent.append(obj_)
            obj_.original_tagname_ = 'ClassificationSeries_isOwnedBy_Agent'
        elif nodeName_ == 'ClassificationSeries_isDefinedBy_Concept':
            obj_ = ClassificationSeries_isDefinedBy_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationSeries_isDefinedBy_Concept.append(obj_)
            obj_.original_tagname_ = 'ClassificationSeries_isDefinedBy_Concept'
        elif nodeName_ == 'ClassificationSeries_has_StatisticalClassification':
            obj_ = ClassificationSeries_has_StatisticalClassificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationSeries_has_StatisticalClassification.append(obj_)
            obj_.original_tagname_ = 'ClassificationSeries_has_StatisticalClassification'
        elif nodeName_ == 'ClassificationSeries_has_ClassificationPosition':
            obj_ = ClassificationSeries_has_ClassificationPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationSeries_has_ClassificationPosition.append(obj_)
            obj_.original_tagname_ = 'ClassificationSeries_has_ClassificationPosition'
# end class ClassificationSeries


class ClassificationSeriesStructure(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    specification -- Provides information on reflexivity, transitivity, and symmetry of relationship using a descriptive term from an enumerated list. Use if all relations within this relation structure are of the same specification.
    topology -- Indicates the form of the associations among members of the collection. Specifies the way in which constituent parts are interrelated or arranged.
    totality -- Indicates whether the related collections are comprehensive in terms of their coverage.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, name=None, purpose=None, semantics=None, specification=None, topology=None, totality=None, ClassificationSeriesStructure_structures_ClassificationSeries=None, ClassificationSeriesStructure_has_StatisticalClassificationRelationship=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        self.specification = specification
        self.specification_nsprefix_ = None
        self.topology = topology
        self.topology_nsprefix_ = None
        self.totality = totality
        self.validate_StructureExtent(self.totality)
        self.totality_nsprefix_ = None
        self.ClassificationSeriesStructure_structures_ClassificationSeries = ClassificationSeriesStructure_structures_ClassificationSeries
        self.ClassificationSeriesStructure_structures_ClassificationSeries_nsprefix_ = None
        if ClassificationSeriesStructure_has_StatisticalClassificationRelationship is None:
            self.ClassificationSeriesStructure_has_StatisticalClassificationRelationship = []
        else:
            self.ClassificationSeriesStructure_has_StatisticalClassificationRelationship = ClassificationSeriesStructure_has_StatisticalClassificationRelationship
        self.ClassificationSeriesStructure_has_StatisticalClassificationRelationship_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationSeriesStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationSeriesStructure.subclass:
            return ClassificationSeriesStructure.subclass(*args_, **kwargs_)
        else:
            return ClassificationSeriesStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_specification(self):
        return self.specification
    def set_specification(self, specification):
        self.specification = specification
    def get_topology(self):
        return self.topology
    def set_topology(self, topology):
        self.topology = topology
    def get_totality(self):
        return self.totality
    def set_totality(self, totality):
        self.totality = totality
    def get_ClassificationSeriesStructure_structures_ClassificationSeries(self):
        return self.ClassificationSeriesStructure_structures_ClassificationSeries
    def set_ClassificationSeriesStructure_structures_ClassificationSeries(self, ClassificationSeriesStructure_structures_ClassificationSeries):
        self.ClassificationSeriesStructure_structures_ClassificationSeries = ClassificationSeriesStructure_structures_ClassificationSeries
    def get_ClassificationSeriesStructure_has_StatisticalClassificationRelationship(self):
        return self.ClassificationSeriesStructure_has_StatisticalClassificationRelationship
    def set_ClassificationSeriesStructure_has_StatisticalClassificationRelationship(self, ClassificationSeriesStructure_has_StatisticalClassificationRelationship):
        self.ClassificationSeriesStructure_has_StatisticalClassificationRelationship = ClassificationSeriesStructure_has_StatisticalClassificationRelationship
    def add_ClassificationSeriesStructure_has_StatisticalClassificationRelationship(self, value):
        self.ClassificationSeriesStructure_has_StatisticalClassificationRelationship.append(value)
    def insert_ClassificationSeriesStructure_has_StatisticalClassificationRelationship_at(self, index, value):
        self.ClassificationSeriesStructure_has_StatisticalClassificationRelationship.insert(index, value)
    def replace_ClassificationSeriesStructure_has_StatisticalClassificationRelationship_at(self, index, value):
        self.ClassificationSeriesStructure_has_StatisticalClassificationRelationship[index] = value
    def validate_StructureExtent(self, value):
        result = True
        # Validate type StructureExtent, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Partial', 'Total']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StructureExtent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.semantics is not None or
            self.specification is not None or
            self.topology is not None or
            self.totality is not None or
            self.ClassificationSeriesStructure_structures_ClassificationSeries is not None or
            self.ClassificationSeriesStructure_has_StatisticalClassificationRelationship
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationSeriesStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.specification is not None:
            specification_ = self.specification
            specification_.to_etree(element, name_='specification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.topology is not None:
            topology_ = self.topology
            topology_.to_etree(element, name_='topology', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.totality is not None:
            totality_ = self.totality
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}totality').text = self.gds_format_string(totality_)
        if self.ClassificationSeriesStructure_structures_ClassificationSeries is not None:
            ClassificationSeriesStructure_structures_ClassificationSeries_ = self.ClassificationSeriesStructure_structures_ClassificationSeries
            ClassificationSeriesStructure_structures_ClassificationSeries_.to_etree(element, name_='ClassificationSeriesStructure_structures_ClassificationSeries', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ClassificationSeriesStructure_has_StatisticalClassificationRelationship_ in self.ClassificationSeriesStructure_has_StatisticalClassificationRelationship:
            ClassificationSeriesStructure_has_StatisticalClassificationRelationship_.to_etree(element, name_='ClassificationSeriesStructure_has_StatisticalClassificationRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'specification':
            obj_ = StructureSpecification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specification = obj_
            obj_.original_tagname_ = 'specification'
        elif nodeName_ == 'topology':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.topology = obj_
            obj_.original_tagname_ = 'topology'
        elif nodeName_ == 'totality':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totality')
            value_ = self.gds_validate_string(value_, node, 'totality')
            self.totality = value_
            self.totality_nsprefix_ = child_.prefix
            # validate type StructureExtent
            self.validate_StructureExtent(self.totality)
        elif nodeName_ == 'ClassificationSeriesStructure_structures_ClassificationSeries':
            obj_ = ClassificationSeriesStructure_structures_ClassificationSeriesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationSeriesStructure_structures_ClassificationSeries = obj_
            obj_.original_tagname_ = 'ClassificationSeriesStructure_structures_ClassificationSeries'
        elif nodeName_ == 'ClassificationSeriesStructure_has_StatisticalClassificationRelationship':
            obj_ = ClassificationSeriesStructure_has_StatisticalClassificationRelationshipType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationSeriesStructure_has_StatisticalClassificationRelationship.append(obj_)
            obj_.original_tagname_ = 'ClassificationSeriesStructure_has_StatisticalClassificationRelationship'
# end class ClassificationSeriesStructure


class Code(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    Code_denotes_Category -- A definition for the code. Specialization of denotes for categories.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, Code_denotes_Category=None, Code_uses_Notation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.Code_denotes_Category = Code_denotes_Category
        self.Code_denotes_Category_nsprefix_ = None
        self.Code_uses_Notation = Code_uses_Notation
        self.Code_uses_Notation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Code)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Code.subclass:
            return Code.subclass(*args_, **kwargs_)
        else:
            return Code(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_Code_denotes_Category(self):
        return self.Code_denotes_Category
    def set_Code_denotes_Category(self, Code_denotes_Category):
        self.Code_denotes_Category = Code_denotes_Category
    def get_Code_uses_Notation(self):
        return self.Code_uses_Notation
    def set_Code_uses_Notation(self, Code_uses_Notation):
        self.Code_uses_Notation = Code_uses_Notation
    def has__content(self):
        if (
            self.identifier is not None or
            self.Code_denotes_Category is not None or
            self.Code_uses_Notation is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Code', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.Code_denotes_Category is not None:
            Code_denotes_Category_ = self.Code_denotes_Category
            Code_denotes_Category_.to_etree(element, name_='Code_denotes_Category', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.Code_uses_Notation is not None:
            Code_uses_Notation_ = self.Code_uses_Notation
            Code_uses_Notation_.to_etree(element, name_='Code_uses_Notation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'Code_denotes_Category':
            obj_ = Code_denotes_CategoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Code_denotes_Category = obj_
            obj_.original_tagname_ = 'Code_denotes_Category'
        elif nodeName_ == 'Code_uses_Notation':
            obj_ = Code_uses_NotationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Code_uses_Notation = obj_
            obj_.original_tagname_ = 'Code_uses_Notation'
# end class Code


class CodeListStructure(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    specification -- Provides information on reflexivity, transitivity, and symmetry of relationship using a descriptive term from an enumerated list. Use if all relations within this relation structure are of the same specification.
    topology -- Indicates the form of the associations among members of the collection. Specifies the way in which constituent parts are interrelated or arranged.
    totality -- Indicates whether the related collections are comprehensive in terms of their coverage.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, name=None, purpose=None, semantics=None, specification=None, topology=None, totality=None, CodeListStructure_structures_CodeList=None, CodeListStructure_has_CodeRelationship=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        self.specification = specification
        self.specification_nsprefix_ = None
        self.topology = topology
        self.topology_nsprefix_ = None
        self.totality = totality
        self.validate_StructureExtent(self.totality)
        self.totality_nsprefix_ = None
        self.CodeListStructure_structures_CodeList = CodeListStructure_structures_CodeList
        self.CodeListStructure_structures_CodeList_nsprefix_ = None
        if CodeListStructure_has_CodeRelationship is None:
            self.CodeListStructure_has_CodeRelationship = []
        else:
            self.CodeListStructure_has_CodeRelationship = CodeListStructure_has_CodeRelationship
        self.CodeListStructure_has_CodeRelationship_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeListStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeListStructure.subclass:
            return CodeListStructure.subclass(*args_, **kwargs_)
        else:
            return CodeListStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_specification(self):
        return self.specification
    def set_specification(self, specification):
        self.specification = specification
    def get_topology(self):
        return self.topology
    def set_topology(self, topology):
        self.topology = topology
    def get_totality(self):
        return self.totality
    def set_totality(self, totality):
        self.totality = totality
    def get_CodeListStructure_structures_CodeList(self):
        return self.CodeListStructure_structures_CodeList
    def set_CodeListStructure_structures_CodeList(self, CodeListStructure_structures_CodeList):
        self.CodeListStructure_structures_CodeList = CodeListStructure_structures_CodeList
    def get_CodeListStructure_has_CodeRelationship(self):
        return self.CodeListStructure_has_CodeRelationship
    def set_CodeListStructure_has_CodeRelationship(self, CodeListStructure_has_CodeRelationship):
        self.CodeListStructure_has_CodeRelationship = CodeListStructure_has_CodeRelationship
    def add_CodeListStructure_has_CodeRelationship(self, value):
        self.CodeListStructure_has_CodeRelationship.append(value)
    def insert_CodeListStructure_has_CodeRelationship_at(self, index, value):
        self.CodeListStructure_has_CodeRelationship.insert(index, value)
    def replace_CodeListStructure_has_CodeRelationship_at(self, index, value):
        self.CodeListStructure_has_CodeRelationship[index] = value
    def validate_StructureExtent(self, value):
        result = True
        # Validate type StructureExtent, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Partial', 'Total']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StructureExtent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.semantics is not None or
            self.specification is not None or
            self.topology is not None or
            self.totality is not None or
            self.CodeListStructure_structures_CodeList is not None or
            self.CodeListStructure_has_CodeRelationship
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CodeListStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.specification is not None:
            specification_ = self.specification
            specification_.to_etree(element, name_='specification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.topology is not None:
            topology_ = self.topology
            topology_.to_etree(element, name_='topology', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.totality is not None:
            totality_ = self.totality
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}totality').text = self.gds_format_string(totality_)
        if self.CodeListStructure_structures_CodeList is not None:
            CodeListStructure_structures_CodeList_ = self.CodeListStructure_structures_CodeList
            CodeListStructure_structures_CodeList_.to_etree(element, name_='CodeListStructure_structures_CodeList', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CodeListStructure_has_CodeRelationship_ in self.CodeListStructure_has_CodeRelationship:
            CodeListStructure_has_CodeRelationship_.to_etree(element, name_='CodeListStructure_has_CodeRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'specification':
            obj_ = StructureSpecification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specification = obj_
            obj_.original_tagname_ = 'specification'
        elif nodeName_ == 'topology':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.topology = obj_
            obj_.original_tagname_ = 'topology'
        elif nodeName_ == 'totality':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totality')
            value_ = self.gds_validate_string(value_, node, 'totality')
            self.totality = value_
            self.totality_nsprefix_ = child_.prefix
            # validate type StructureExtent
            self.validate_StructureExtent(self.totality)
        elif nodeName_ == 'CodeListStructure_structures_CodeList':
            obj_ = CodeListStructure_structures_CodeListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodeListStructure_structures_CodeList = obj_
            obj_.original_tagname_ = 'CodeListStructure_structures_CodeList'
        elif nodeName_ == 'CodeListStructure_has_CodeRelationship':
            obj_ = CodeListStructure_has_CodeRelationshipType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodeListStructure_has_CodeRelationship.append(obj_)
            obj_.original_tagname_ = 'CodeListStructure_has_CodeRelationship'
# end class CodeListStructure


class CodePosition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    value -- Index value of the member in an ordered array.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, value=None, CodePosition_indexes_Code=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.CodePosition_indexes_Code = CodePosition_indexes_Code
        self.CodePosition_indexes_Code_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodePosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodePosition.subclass:
            return CodePosition.subclass(*args_, **kwargs_)
        else:
            return CodePosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_CodePosition_indexes_Code(self):
        return self.CodePosition_indexes_Code
    def set_CodePosition_indexes_Code(self, CodePosition_indexes_Code):
        self.CodePosition_indexes_Code = CodePosition_indexes_Code
    def has__content(self):
        if (
            self.identifier is not None or
            self.value is not None or
            self.CodePosition_indexes_Code is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CodePosition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_integer(value_)
        if self.CodePosition_indexes_Code is not None:
            CodePosition_indexes_Code_ = self.CodePosition_indexes_Code
            CodePosition_indexes_Code_.to_etree(element, name_='CodePosition_indexes_Code', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
        elif nodeName_ == 'CodePosition_indexes_Code':
            obj_ = CodePosition_indexes_CodeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodePosition_indexes_Code = obj_
            obj_.original_tagname_ = 'CodePosition_indexes_Code'
# end class CodePosition


class CodeRelationship(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    CodeRelationship_hasTarget_Code -- Note that this can be realized as a collection to support tuples.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, semantics=None, CodeRelationship_hasTarget_Code=None, CodeRelationship_hasSource_Code=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        if CodeRelationship_hasTarget_Code is None:
            self.CodeRelationship_hasTarget_Code = []
        else:
            self.CodeRelationship_hasTarget_Code = CodeRelationship_hasTarget_Code
        self.CodeRelationship_hasTarget_Code_nsprefix_ = None
        if CodeRelationship_hasSource_Code is None:
            self.CodeRelationship_hasSource_Code = []
        else:
            self.CodeRelationship_hasSource_Code = CodeRelationship_hasSource_Code
        self.CodeRelationship_hasSource_Code_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeRelationship.subclass:
            return CodeRelationship.subclass(*args_, **kwargs_)
        else:
            return CodeRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_CodeRelationship_hasTarget_Code(self):
        return self.CodeRelationship_hasTarget_Code
    def set_CodeRelationship_hasTarget_Code(self, CodeRelationship_hasTarget_Code):
        self.CodeRelationship_hasTarget_Code = CodeRelationship_hasTarget_Code
    def add_CodeRelationship_hasTarget_Code(self, value):
        self.CodeRelationship_hasTarget_Code.append(value)
    def insert_CodeRelationship_hasTarget_Code_at(self, index, value):
        self.CodeRelationship_hasTarget_Code.insert(index, value)
    def replace_CodeRelationship_hasTarget_Code_at(self, index, value):
        self.CodeRelationship_hasTarget_Code[index] = value
    def get_CodeRelationship_hasSource_Code(self):
        return self.CodeRelationship_hasSource_Code
    def set_CodeRelationship_hasSource_Code(self, CodeRelationship_hasSource_Code):
        self.CodeRelationship_hasSource_Code = CodeRelationship_hasSource_Code
    def add_CodeRelationship_hasSource_Code(self, value):
        self.CodeRelationship_hasSource_Code.append(value)
    def insert_CodeRelationship_hasSource_Code_at(self, index, value):
        self.CodeRelationship_hasSource_Code.insert(index, value)
    def replace_CodeRelationship_hasSource_Code_at(self, index, value):
        self.CodeRelationship_hasSource_Code[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.semantics is not None or
            self.CodeRelationship_hasTarget_Code or
            self.CodeRelationship_hasSource_Code
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CodeRelationship', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CodeRelationship_hasTarget_Code_ in self.CodeRelationship_hasTarget_Code:
            CodeRelationship_hasTarget_Code_.to_etree(element, name_='CodeRelationship_hasTarget_Code', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CodeRelationship_hasSource_Code_ in self.CodeRelationship_hasSource_Code:
            CodeRelationship_hasSource_Code_.to_etree(element, name_='CodeRelationship_hasSource_Code', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'CodeRelationship_hasTarget_Code':
            obj_ = CodeRelationship_hasTarget_CodeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodeRelationship_hasTarget_Code.append(obj_)
            obj_.original_tagname_ = 'CodeRelationship_hasTarget_Code'
        elif nodeName_ == 'CodeRelationship_hasSource_Code':
            obj_ = CodeRelationship_hasSource_CodeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodeRelationship_hasSource_Code.append(obj_)
            obj_.original_tagname_ = 'CodeRelationship_hasSource_Code'
# end class CodeRelationship


class ComponentPosition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    value -- Index value of the member in an ordered array.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, value=None, ComponentPosition_indexes_DataStructureComponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.ComponentPosition_indexes_DataStructureComponent = ComponentPosition_indexes_DataStructureComponent
        self.ComponentPosition_indexes_DataStructureComponent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComponentPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComponentPosition.subclass:
            return ComponentPosition.subclass(*args_, **kwargs_)
        else:
            return ComponentPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_ComponentPosition_indexes_DataStructureComponent(self):
        return self.ComponentPosition_indexes_DataStructureComponent
    def set_ComponentPosition_indexes_DataStructureComponent(self, ComponentPosition_indexes_DataStructureComponent):
        self.ComponentPosition_indexes_DataStructureComponent = ComponentPosition_indexes_DataStructureComponent
    def has__content(self):
        if (
            self.identifier is not None or
            self.value is not None or
            self.ComponentPosition_indexes_DataStructureComponent is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ComponentPosition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_integer(value_)
        if self.ComponentPosition_indexes_DataStructureComponent is not None:
            ComponentPosition_indexes_DataStructureComponent_ = self.ComponentPosition_indexes_DataStructureComponent
            ComponentPosition_indexes_DataStructureComponent_.to_etree(element, name_='ComponentPosition_indexes_DataStructureComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
        elif nodeName_ == 'ComponentPosition_indexes_DataStructureComponent':
            obj_ = ComponentPosition_indexes_DataStructureComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ComponentPosition_indexes_DataStructureComponent = obj_
            obj_.original_tagname_ = 'ComponentPosition_indexes_DataStructureComponent'
# end class ComponentPosition


class Concept(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry. Examples would be creator, contributor, title, copyright, embargo, and license information. A set of information useful for attribution, data discovery, and access. This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    definition -- Natural language statement conveying the meaning of a concept, differentiating it from other concepts. Supports the use of multiple languages and structured text. 'externalDefinition' can't be used if 'definition' is used.
    displayLabel -- A human-readable display label for the object. Supports the use of multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.
    externalDefinition -- A reference to an external definition of a concept (that is, a concept which is described outside the content of the DDI-CDI metadata description). An example is a SKOS concept. The definition property is assumed to duplicate the external one referenced if externalDefinition is used. Other corresponding properties are assumed to be included unchanged if used.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (linguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, externalDefinition=None, identifier=None, name=None, Concept_uses_Concept=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.definition = definition
        self.definition_nsprefix_ = None
        if displayLabel is None:
            self.displayLabel = []
        else:
            self.displayLabel = displayLabel
        self.displayLabel_nsprefix_ = None
        self.externalDefinition = externalDefinition
        self.externalDefinition_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        if Concept_uses_Concept is None:
            self.Concept_uses_Concept = []
        else:
            self.Concept_uses_Concept = Concept_uses_Concept
        self.Concept_uses_Concept_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Concept)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Concept.subclass:
            return Concept.subclass(*args_, **kwargs_)
        else:
            return Concept(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_definition(self):
        return self.definition
    def set_definition(self, definition):
        self.definition = definition
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def add_displayLabel(self, value):
        self.displayLabel.append(value)
    def insert_displayLabel_at(self, index, value):
        self.displayLabel.insert(index, value)
    def replace_displayLabel_at(self, index, value):
        self.displayLabel[index] = value
    def get_externalDefinition(self):
        return self.externalDefinition
    def set_externalDefinition(self, externalDefinition):
        self.externalDefinition = externalDefinition
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_Concept_uses_Concept(self):
        return self.Concept_uses_Concept
    def set_Concept_uses_Concept(self, Concept_uses_Concept):
        self.Concept_uses_Concept = Concept_uses_Concept
    def add_Concept_uses_Concept(self, value):
        self.Concept_uses_Concept.append(value)
    def insert_Concept_uses_Concept_at(self, index, value):
        self.Concept_uses_Concept.insert(index, value)
    def replace_Concept_uses_Concept_at(self, index, value):
        self.Concept_uses_Concept[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.definition is not None or
            self.displayLabel or
            self.externalDefinition is not None or
            self.identifier is not None or
            self.name or
            self.Concept_uses_Concept
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Concept', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.definition is not None:
            definition_ = self.definition
            definition_.to_etree(element, name_='definition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for displayLabel_ in self.displayLabel:
            displayLabel_.to_etree(element, name_='displayLabel', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.externalDefinition is not None:
            externalDefinition_ = self.externalDefinition
            externalDefinition_.to_etree(element, name_='externalDefinition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Concept_uses_Concept_ in self.Concept_uses_Concept:
            Concept_uses_Concept_.to_etree(element, name_='Concept_uses_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'definition':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.definition = obj_
            obj_.original_tagname_ = 'definition'
        elif nodeName_ == 'displayLabel':
            obj_ = LabelForDisplay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayLabel.append(obj_)
            obj_.original_tagname_ = 'displayLabel'
        elif nodeName_ == 'externalDefinition':
            class_obj_ = self.get_class_obj_(child_, Reference)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalDefinition = obj_
            obj_.original_tagname_ = 'externalDefinition'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'Concept_uses_Concept':
            obj_ = Concept_uses_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Concept_uses_Concept.append(obj_)
            obj_.original_tagname_ = 'Concept_uses_Concept'
# end class Concept


class ConceptMap(GeneratedsSuper):
    """correspondence -- Type of correspondence in terms of commonalities and differences between two members.
    displayLabel -- A human-readable display label for the object. Supports the use of multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    usage -- Explanation of the ways in which the object is employed.
    validDates -- The dates describing the validity period of the object. The date from which the object became valid must be defined if the map belongs to a "floating" construct. The date at which the object became invalid must be defined if the map belongs to a "floating" construct and is no longer valid.
    ConceptMap_hasSource_Concept -- Concept map has one to many source concepts.
    ConceptMap_hasTarget_Concept -- Concept map has one to many target concepts.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, correspondence=None, displayLabel=None, identifier=None, usage=None, validDates=None, ConceptMap_hasSource_Concept=None, ConceptMap_hasTarget_Concept=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.correspondence = correspondence
        self.correspondence_nsprefix_ = None
        self.displayLabel = displayLabel
        self.displayLabel_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.usage = usage
        self.usage_nsprefix_ = None
        self.validDates = validDates
        self.validDates_nsprefix_ = None
        if ConceptMap_hasSource_Concept is None:
            self.ConceptMap_hasSource_Concept = []
        else:
            self.ConceptMap_hasSource_Concept = ConceptMap_hasSource_Concept
        self.ConceptMap_hasSource_Concept_nsprefix_ = None
        if ConceptMap_hasTarget_Concept is None:
            self.ConceptMap_hasTarget_Concept = []
        else:
            self.ConceptMap_hasTarget_Concept = ConceptMap_hasTarget_Concept
        self.ConceptMap_hasTarget_Concept_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptMap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptMap.subclass:
            return ConceptMap.subclass(*args_, **kwargs_)
        else:
            return ConceptMap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_correspondence(self):
        return self.correspondence
    def set_correspondence(self, correspondence):
        self.correspondence = correspondence
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_validDates(self):
        return self.validDates
    def set_validDates(self, validDates):
        self.validDates = validDates
    def get_ConceptMap_hasSource_Concept(self):
        return self.ConceptMap_hasSource_Concept
    def set_ConceptMap_hasSource_Concept(self, ConceptMap_hasSource_Concept):
        self.ConceptMap_hasSource_Concept = ConceptMap_hasSource_Concept
    def add_ConceptMap_hasSource_Concept(self, value):
        self.ConceptMap_hasSource_Concept.append(value)
    def insert_ConceptMap_hasSource_Concept_at(self, index, value):
        self.ConceptMap_hasSource_Concept.insert(index, value)
    def replace_ConceptMap_hasSource_Concept_at(self, index, value):
        self.ConceptMap_hasSource_Concept[index] = value
    def get_ConceptMap_hasTarget_Concept(self):
        return self.ConceptMap_hasTarget_Concept
    def set_ConceptMap_hasTarget_Concept(self, ConceptMap_hasTarget_Concept):
        self.ConceptMap_hasTarget_Concept = ConceptMap_hasTarget_Concept
    def add_ConceptMap_hasTarget_Concept(self, value):
        self.ConceptMap_hasTarget_Concept.append(value)
    def insert_ConceptMap_hasTarget_Concept_at(self, index, value):
        self.ConceptMap_hasTarget_Concept.insert(index, value)
    def replace_ConceptMap_hasTarget_Concept_at(self, index, value):
        self.ConceptMap_hasTarget_Concept[index] = value
    def has__content(self):
        if (
            self.correspondence is not None or
            self.displayLabel is not None or
            self.identifier is not None or
            self.usage is not None or
            self.validDates is not None or
            self.ConceptMap_hasSource_Concept or
            self.ConceptMap_hasTarget_Concept
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptMap', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.correspondence is not None:
            correspondence_ = self.correspondence
            correspondence_.to_etree(element, name_='correspondence', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.displayLabel is not None:
            displayLabel_ = self.displayLabel
            displayLabel_.to_etree(element, name_='displayLabel', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.usage is not None:
            usage_ = self.usage
            usage_.to_etree(element, name_='usage', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validDates is not None:
            validDates_ = self.validDates
            validDates_.to_etree(element, name_='validDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptMap_hasSource_Concept_ in self.ConceptMap_hasSource_Concept:
            ConceptMap_hasSource_Concept_.to_etree(element, name_='ConceptMap_hasSource_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptMap_hasTarget_Concept_ in self.ConceptMap_hasTarget_Concept:
            ConceptMap_hasTarget_Concept_.to_etree(element, name_='ConceptMap_hasTarget_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'correspondence':
            obj_ = CorrespondenceDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.correspondence = obj_
            obj_.original_tagname_ = 'correspondence'
        elif nodeName_ == 'displayLabel':
            obj_ = LabelForDisplay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayLabel = obj_
            obj_.original_tagname_ = 'displayLabel'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'usage':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.usage = obj_
            obj_.original_tagname_ = 'usage'
        elif nodeName_ == 'validDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validDates = obj_
            obj_.original_tagname_ = 'validDates'
        elif nodeName_ == 'ConceptMap_hasSource_Concept':
            obj_ = ConceptMap_hasSource_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptMap_hasSource_Concept.append(obj_)
            obj_.original_tagname_ = 'ConceptMap_hasSource_Concept'
        elif nodeName_ == 'ConceptMap_hasTarget_Concept':
            obj_ = ConceptMap_hasTarget_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptMap_hasTarget_Concept.append(obj_)
            obj_.original_tagname_ = 'ConceptMap_hasTarget_Concept'
# end class ConceptMap


class ConceptRelationship(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    ConceptRelationship_hasSource_Concept -- Restricts source object to concept for the relationship.
    ConceptRelationship_hasTarget_Concept -- Restricts target object to concept for the relationship.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, semantics=None, ConceptRelationship_hasSource_Concept=None, ConceptRelationship_hasTarget_Concept=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        self.ConceptRelationship_hasSource_Concept = ConceptRelationship_hasSource_Concept
        self.ConceptRelationship_hasSource_Concept_nsprefix_ = None
        self.ConceptRelationship_hasTarget_Concept = ConceptRelationship_hasTarget_Concept
        self.ConceptRelationship_hasTarget_Concept_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptRelationship.subclass:
            return ConceptRelationship.subclass(*args_, **kwargs_)
        else:
            return ConceptRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_ConceptRelationship_hasSource_Concept(self):
        return self.ConceptRelationship_hasSource_Concept
    def set_ConceptRelationship_hasSource_Concept(self, ConceptRelationship_hasSource_Concept):
        self.ConceptRelationship_hasSource_Concept = ConceptRelationship_hasSource_Concept
    def get_ConceptRelationship_hasTarget_Concept(self):
        return self.ConceptRelationship_hasTarget_Concept
    def set_ConceptRelationship_hasTarget_Concept(self, ConceptRelationship_hasTarget_Concept):
        self.ConceptRelationship_hasTarget_Concept = ConceptRelationship_hasTarget_Concept
    def has__content(self):
        if (
            self.identifier is not None or
            self.semantics is not None or
            self.ConceptRelationship_hasSource_Concept is not None or
            self.ConceptRelationship_hasTarget_Concept is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptRelationship', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ConceptRelationship_hasSource_Concept is not None:
            ConceptRelationship_hasSource_Concept_ = self.ConceptRelationship_hasSource_Concept
            ConceptRelationship_hasSource_Concept_.to_etree(element, name_='ConceptRelationship_hasSource_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ConceptRelationship_hasTarget_Concept is not None:
            ConceptRelationship_hasTarget_Concept_ = self.ConceptRelationship_hasTarget_Concept
            ConceptRelationship_hasTarget_Concept_.to_etree(element, name_='ConceptRelationship_hasTarget_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'ConceptRelationship_hasSource_Concept':
            obj_ = ConceptRelationship_hasSource_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptRelationship_hasSource_Concept = obj_
            obj_.original_tagname_ = 'ConceptRelationship_hasSource_Concept'
        elif nodeName_ == 'ConceptRelationship_hasTarget_Concept':
            obj_ = ConceptRelationship_hasTarget_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptRelationship_hasTarget_Concept = obj_
            obj_.original_tagname_ = 'ConceptRelationship_hasTarget_Concept'
# end class ConceptRelationship


class ConceptStructure(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    specification -- Provides information on reflexivity, transitivity, and symmetry of relationship using a descriptive term from an enumerated list. Use if all relations within this relation structure are of the same specification.
    topology -- Indicates the form of the associations among members of the collection. Specifies the way in which constituent parts are interrelated or arranged.
    totality -- Indicates whether the related collections are comprehensive in terms of their coverage.
    ConceptStructure_structures_ConceptSystem -- Concept structure structures concept system.
    ConceptStructure_has_ConceptRelationship -- Concept structure has zero to many concept relationships.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, name=None, purpose=None, semantics=None, specification=None, topology=None, totality=None, ConceptStructure_structures_ConceptSystem=None, ConceptStructure_has_ConceptRelationship=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        self.specification = specification
        self.specification_nsprefix_ = None
        self.topology = topology
        self.topology_nsprefix_ = None
        self.totality = totality
        self.validate_StructureExtent(self.totality)
        self.totality_nsprefix_ = None
        self.ConceptStructure_structures_ConceptSystem = ConceptStructure_structures_ConceptSystem
        self.ConceptStructure_structures_ConceptSystem_nsprefix_ = None
        if ConceptStructure_has_ConceptRelationship is None:
            self.ConceptStructure_has_ConceptRelationship = []
        else:
            self.ConceptStructure_has_ConceptRelationship = ConceptStructure_has_ConceptRelationship
        self.ConceptStructure_has_ConceptRelationship_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptStructure.subclass:
            return ConceptStructure.subclass(*args_, **kwargs_)
        else:
            return ConceptStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_specification(self):
        return self.specification
    def set_specification(self, specification):
        self.specification = specification
    def get_topology(self):
        return self.topology
    def set_topology(self, topology):
        self.topology = topology
    def get_totality(self):
        return self.totality
    def set_totality(self, totality):
        self.totality = totality
    def get_ConceptStructure_structures_ConceptSystem(self):
        return self.ConceptStructure_structures_ConceptSystem
    def set_ConceptStructure_structures_ConceptSystem(self, ConceptStructure_structures_ConceptSystem):
        self.ConceptStructure_structures_ConceptSystem = ConceptStructure_structures_ConceptSystem
    def get_ConceptStructure_has_ConceptRelationship(self):
        return self.ConceptStructure_has_ConceptRelationship
    def set_ConceptStructure_has_ConceptRelationship(self, ConceptStructure_has_ConceptRelationship):
        self.ConceptStructure_has_ConceptRelationship = ConceptStructure_has_ConceptRelationship
    def add_ConceptStructure_has_ConceptRelationship(self, value):
        self.ConceptStructure_has_ConceptRelationship.append(value)
    def insert_ConceptStructure_has_ConceptRelationship_at(self, index, value):
        self.ConceptStructure_has_ConceptRelationship.insert(index, value)
    def replace_ConceptStructure_has_ConceptRelationship_at(self, index, value):
        self.ConceptStructure_has_ConceptRelationship[index] = value
    def validate_StructureExtent(self, value):
        result = True
        # Validate type StructureExtent, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Partial', 'Total']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StructureExtent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.semantics is not None or
            self.specification is not None or
            self.topology is not None or
            self.totality is not None or
            self.ConceptStructure_structures_ConceptSystem is not None or
            self.ConceptStructure_has_ConceptRelationship
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.specification is not None:
            specification_ = self.specification
            specification_.to_etree(element, name_='specification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.topology is not None:
            topology_ = self.topology
            topology_.to_etree(element, name_='topology', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.totality is not None:
            totality_ = self.totality
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}totality').text = self.gds_format_string(totality_)
        if self.ConceptStructure_structures_ConceptSystem is not None:
            ConceptStructure_structures_ConceptSystem_ = self.ConceptStructure_structures_ConceptSystem
            ConceptStructure_structures_ConceptSystem_.to_etree(element, name_='ConceptStructure_structures_ConceptSystem', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptStructure_has_ConceptRelationship_ in self.ConceptStructure_has_ConceptRelationship:
            ConceptStructure_has_ConceptRelationship_.to_etree(element, name_='ConceptStructure_has_ConceptRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'specification':
            obj_ = StructureSpecification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specification = obj_
            obj_.original_tagname_ = 'specification'
        elif nodeName_ == 'topology':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.topology = obj_
            obj_.original_tagname_ = 'topology'
        elif nodeName_ == 'totality':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totality')
            value_ = self.gds_validate_string(value_, node, 'totality')
            self.totality = value_
            self.totality_nsprefix_ = child_.prefix
            # validate type StructureExtent
            self.validate_StructureExtent(self.totality)
        elif nodeName_ == 'ConceptStructure_structures_ConceptSystem':
            obj_ = ConceptStructure_structures_ConceptSystemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptStructure_structures_ConceptSystem = obj_
            obj_.original_tagname_ = 'ConceptStructure_structures_ConceptSystem'
        elif nodeName_ == 'ConceptStructure_has_ConceptRelationship':
            obj_ = ConceptStructure_has_ConceptRelationshipType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptStructure_has_ConceptRelationship.append(obj_)
            obj_.original_tagname_ = 'ConceptStructure_has_ConceptRelationship'
# end class ConceptStructure


class ConceptSystem(GeneratedsSuper):
    """allowsDuplicates -- If value is False, the members are unique within the collection - if True, there may be duplicates. (Note that a mathematical
    “
    bag
    ”
    permits duplicates and is unordered - a
    “
    set
    ”
    does not have duplicates and may be ordered.)
    catalogDetails -- Bundles the information useful for a data catalog entry. Examples would be creator, contributor, title, copyright, embargo, and license information. A set of information useful for attribution, data discovery, and access. This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    externalDefinition -- A reference to an external definition of a concept (that is, a concept which is described outside the content of the DDI-CDI metadata description). An example is a SKOS concept. The definition property is assumed to duplicate the external one referenced if externalDefinition is used. Other corresponding properties are assumed to be included unchanged if used.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    ConceptSystem_isDefinedBy_Concept -- Concept system is defined by zero to many concepts. The conceptual basis for the collection of members.
    ConceptSystem_has_Concept -- Concept system has zero to many concepts.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, allowsDuplicates=None, catalogDetails=None, externalDefinition=None, identifier=None, name=None, purpose=None, ConceptSystem_isDefinedBy_Concept=None, ConceptSystem_has_Concept=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.allowsDuplicates = allowsDuplicates
        self.allowsDuplicates_nsprefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.externalDefinition = externalDefinition
        self.externalDefinition_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        if ConceptSystem_isDefinedBy_Concept is None:
            self.ConceptSystem_isDefinedBy_Concept = []
        else:
            self.ConceptSystem_isDefinedBy_Concept = ConceptSystem_isDefinedBy_Concept
        self.ConceptSystem_isDefinedBy_Concept_nsprefix_ = None
        if ConceptSystem_has_Concept is None:
            self.ConceptSystem_has_Concept = []
        else:
            self.ConceptSystem_has_Concept = ConceptSystem_has_Concept
        self.ConceptSystem_has_Concept_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptSystem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptSystem.subclass:
            return ConceptSystem.subclass(*args_, **kwargs_)
        else:
            return ConceptSystem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_allowsDuplicates(self):
        return self.allowsDuplicates
    def set_allowsDuplicates(self, allowsDuplicates):
        self.allowsDuplicates = allowsDuplicates
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_externalDefinition(self):
        return self.externalDefinition
    def set_externalDefinition(self, externalDefinition):
        self.externalDefinition = externalDefinition
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_ConceptSystem_isDefinedBy_Concept(self):
        return self.ConceptSystem_isDefinedBy_Concept
    def set_ConceptSystem_isDefinedBy_Concept(self, ConceptSystem_isDefinedBy_Concept):
        self.ConceptSystem_isDefinedBy_Concept = ConceptSystem_isDefinedBy_Concept
    def add_ConceptSystem_isDefinedBy_Concept(self, value):
        self.ConceptSystem_isDefinedBy_Concept.append(value)
    def insert_ConceptSystem_isDefinedBy_Concept_at(self, index, value):
        self.ConceptSystem_isDefinedBy_Concept.insert(index, value)
    def replace_ConceptSystem_isDefinedBy_Concept_at(self, index, value):
        self.ConceptSystem_isDefinedBy_Concept[index] = value
    def get_ConceptSystem_has_Concept(self):
        return self.ConceptSystem_has_Concept
    def set_ConceptSystem_has_Concept(self, ConceptSystem_has_Concept):
        self.ConceptSystem_has_Concept = ConceptSystem_has_Concept
    def add_ConceptSystem_has_Concept(self, value):
        self.ConceptSystem_has_Concept.append(value)
    def insert_ConceptSystem_has_Concept_at(self, index, value):
        self.ConceptSystem_has_Concept.insert(index, value)
    def replace_ConceptSystem_has_Concept_at(self, index, value):
        self.ConceptSystem_has_Concept[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.allowsDuplicates is not None or
            self.catalogDetails is not None or
            self.externalDefinition is not None or
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.ConceptSystem_isDefinedBy_Concept or
            self.ConceptSystem_has_Concept
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptSystem', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.allowsDuplicates is not None:
            allowsDuplicates_ = self.allowsDuplicates
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}allowsDuplicates').text = self.gds_format_boolean(allowsDuplicates_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.externalDefinition is not None:
            externalDefinition_ = self.externalDefinition
            externalDefinition_.to_etree(element, name_='externalDefinition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptSystem_isDefinedBy_Concept_ in self.ConceptSystem_isDefinedBy_Concept:
            ConceptSystem_isDefinedBy_Concept_.to_etree(element, name_='ConceptSystem_isDefinedBy_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptSystem_has_Concept_ in self.ConceptSystem_has_Concept:
            ConceptSystem_has_Concept_.to_etree(element, name_='ConceptSystem_has_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allowsDuplicates':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'allowsDuplicates')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowsDuplicates')
            self.allowsDuplicates = ival_
            self.allowsDuplicates_nsprefix_ = child_.prefix
        elif nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'externalDefinition':
            class_obj_ = self.get_class_obj_(child_, Reference)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalDefinition = obj_
            obj_.original_tagname_ = 'externalDefinition'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'ConceptSystem_isDefinedBy_Concept':
            obj_ = ConceptSystem_isDefinedBy_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptSystem_isDefinedBy_Concept.append(obj_)
            obj_.original_tagname_ = 'ConceptSystem_isDefinedBy_Concept'
        elif nodeName_ == 'ConceptSystem_has_Concept':
            obj_ = ConceptSystem_has_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptSystem_has_Concept.append(obj_)
            obj_.original_tagname_ = 'ConceptSystem_has_Concept'
# end class ConceptSystem


class ConceptSystemCorrespondence(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry. Examples would be creator, contributor, title, copyright, embargo, and license information. A set of information useful for attribution, data discovery, and access. This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    displayLabel -- A human-readable display label for the object. Supports the use of multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    purpose -- Intent or reason for the object/the description of the object.
    usage -- Explanation of the ways in which the object is employed.
    ConceptSystemCorrespondence_maps_ConceptSystem -- Concept system correspondence maps two to many concept systems. Realization of structures in symmetric relation. When concepts of a single concept system are mapped, the Concept has to appear twice as target.
    ConceptSystemCorrespondence_has_ConceptMap -- Concept system correspondence has zero to many concept maps.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, displayLabel=None, identifier=None, purpose=None, usage=None, ConceptSystemCorrespondence_maps_ConceptSystem=None, ConceptSystemCorrespondence_has_ConceptMap=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        if displayLabel is None:
            self.displayLabel = []
        else:
            self.displayLabel = displayLabel
        self.displayLabel_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.usage = usage
        self.usage_nsprefix_ = None
        if ConceptSystemCorrespondence_maps_ConceptSystem is None:
            self.ConceptSystemCorrespondence_maps_ConceptSystem = []
        else:
            self.ConceptSystemCorrespondence_maps_ConceptSystem = ConceptSystemCorrespondence_maps_ConceptSystem
        self.ConceptSystemCorrespondence_maps_ConceptSystem_nsprefix_ = None
        if ConceptSystemCorrespondence_has_ConceptMap is None:
            self.ConceptSystemCorrespondence_has_ConceptMap = []
        else:
            self.ConceptSystemCorrespondence_has_ConceptMap = ConceptSystemCorrespondence_has_ConceptMap
        self.ConceptSystemCorrespondence_has_ConceptMap_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptSystemCorrespondence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptSystemCorrespondence.subclass:
            return ConceptSystemCorrespondence.subclass(*args_, **kwargs_)
        else:
            return ConceptSystemCorrespondence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def add_displayLabel(self, value):
        self.displayLabel.append(value)
    def insert_displayLabel_at(self, index, value):
        self.displayLabel.insert(index, value)
    def replace_displayLabel_at(self, index, value):
        self.displayLabel[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_ConceptSystemCorrespondence_maps_ConceptSystem(self):
        return self.ConceptSystemCorrespondence_maps_ConceptSystem
    def set_ConceptSystemCorrespondence_maps_ConceptSystem(self, ConceptSystemCorrespondence_maps_ConceptSystem):
        self.ConceptSystemCorrespondence_maps_ConceptSystem = ConceptSystemCorrespondence_maps_ConceptSystem
    def add_ConceptSystemCorrespondence_maps_ConceptSystem(self, value):
        self.ConceptSystemCorrespondence_maps_ConceptSystem.append(value)
    def insert_ConceptSystemCorrespondence_maps_ConceptSystem_at(self, index, value):
        self.ConceptSystemCorrespondence_maps_ConceptSystem.insert(index, value)
    def replace_ConceptSystemCorrespondence_maps_ConceptSystem_at(self, index, value):
        self.ConceptSystemCorrespondence_maps_ConceptSystem[index] = value
    def get_ConceptSystemCorrespondence_has_ConceptMap(self):
        return self.ConceptSystemCorrespondence_has_ConceptMap
    def set_ConceptSystemCorrespondence_has_ConceptMap(self, ConceptSystemCorrespondence_has_ConceptMap):
        self.ConceptSystemCorrespondence_has_ConceptMap = ConceptSystemCorrespondence_has_ConceptMap
    def add_ConceptSystemCorrespondence_has_ConceptMap(self, value):
        self.ConceptSystemCorrespondence_has_ConceptMap.append(value)
    def insert_ConceptSystemCorrespondence_has_ConceptMap_at(self, index, value):
        self.ConceptSystemCorrespondence_has_ConceptMap.insert(index, value)
    def replace_ConceptSystemCorrespondence_has_ConceptMap_at(self, index, value):
        self.ConceptSystemCorrespondence_has_ConceptMap[index] = value
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.displayLabel or
            self.identifier is not None or
            self.purpose is not None or
            self.usage is not None or
            self.ConceptSystemCorrespondence_maps_ConceptSystem or
            self.ConceptSystemCorrespondence_has_ConceptMap
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptSystemCorrespondence', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for displayLabel_ in self.displayLabel:
            displayLabel_.to_etree(element, name_='displayLabel', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.usage is not None:
            usage_ = self.usage
            usage_.to_etree(element, name_='usage', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptSystemCorrespondence_maps_ConceptSystem_ in self.ConceptSystemCorrespondence_maps_ConceptSystem:
            ConceptSystemCorrespondence_maps_ConceptSystem_.to_etree(element, name_='ConceptSystemCorrespondence_maps_ConceptSystem', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ConceptSystemCorrespondence_has_ConceptMap_ in self.ConceptSystemCorrespondence_has_ConceptMap:
            ConceptSystemCorrespondence_has_ConceptMap_.to_etree(element, name_='ConceptSystemCorrespondence_has_ConceptMap', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'displayLabel':
            obj_ = LabelForDisplay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayLabel.append(obj_)
            obj_.original_tagname_ = 'displayLabel'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'usage':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.usage = obj_
            obj_.original_tagname_ = 'usage'
        elif nodeName_ == 'ConceptSystemCorrespondence_maps_ConceptSystem':
            obj_ = ConceptSystemCorrespondence_maps_ConceptSystemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptSystemCorrespondence_maps_ConceptSystem.append(obj_)
            obj_.original_tagname_ = 'ConceptSystemCorrespondence_maps_ConceptSystem'
        elif nodeName_ == 'ConceptSystemCorrespondence_has_ConceptMap':
            obj_ = ConceptSystemCorrespondence_has_ConceptMapType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptSystemCorrespondence_has_ConceptMap.append(obj_)
            obj_.original_tagname_ = 'ConceptSystemCorrespondence_has_ConceptMap'
# end class ConceptSystemCorrespondence


class ConceptualDomain(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry. Examples would be creator, contributor, title, copyright, embargo, and license information. A set of information useful for attribution, data discovery, and access. This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    displayLabel -- A human-readable display label for the object. Supports the use of multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    ConceptualDomain_isDescribedBy_ValueAndConceptDescription -- A description of the concepts in the domain. A numeric domain might use a logical expression to be machine actionable; a text domain might use a regular expression to describe strings that describe the concepts.
    ConceptualDomain_takesConceptsFrom_ConceptSystem -- Conceptual domain takes concept from zero to one concept system.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, displayLabel=None, identifier=None, ConceptualDomain_isDescribedBy_ValueAndConceptDescription=None, ConceptualDomain_takesConceptsFrom_ConceptSystem=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        if displayLabel is None:
            self.displayLabel = []
        else:
            self.displayLabel = displayLabel
        self.displayLabel_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.ConceptualDomain_isDescribedBy_ValueAndConceptDescription = ConceptualDomain_isDescribedBy_ValueAndConceptDescription
        self.ConceptualDomain_isDescribedBy_ValueAndConceptDescription_nsprefix_ = None
        self.ConceptualDomain_takesConceptsFrom_ConceptSystem = ConceptualDomain_takesConceptsFrom_ConceptSystem
        self.ConceptualDomain_takesConceptsFrom_ConceptSystem_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptualDomain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptualDomain.subclass:
            return ConceptualDomain.subclass(*args_, **kwargs_)
        else:
            return ConceptualDomain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def add_displayLabel(self, value):
        self.displayLabel.append(value)
    def insert_displayLabel_at(self, index, value):
        self.displayLabel.insert(index, value)
    def replace_displayLabel_at(self, index, value):
        self.displayLabel[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_ConceptualDomain_isDescribedBy_ValueAndConceptDescription(self):
        return self.ConceptualDomain_isDescribedBy_ValueAndConceptDescription
    def set_ConceptualDomain_isDescribedBy_ValueAndConceptDescription(self, ConceptualDomain_isDescribedBy_ValueAndConceptDescription):
        self.ConceptualDomain_isDescribedBy_ValueAndConceptDescription = ConceptualDomain_isDescribedBy_ValueAndConceptDescription
    def get_ConceptualDomain_takesConceptsFrom_ConceptSystem(self):
        return self.ConceptualDomain_takesConceptsFrom_ConceptSystem
    def set_ConceptualDomain_takesConceptsFrom_ConceptSystem(self, ConceptualDomain_takesConceptsFrom_ConceptSystem):
        self.ConceptualDomain_takesConceptsFrom_ConceptSystem = ConceptualDomain_takesConceptsFrom_ConceptSystem
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.displayLabel or
            self.identifier is not None or
            self.ConceptualDomain_isDescribedBy_ValueAndConceptDescription is not None or
            self.ConceptualDomain_takesConceptsFrom_ConceptSystem is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptualDomain', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for displayLabel_ in self.displayLabel:
            displayLabel_.to_etree(element, name_='displayLabel', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ConceptualDomain_isDescribedBy_ValueAndConceptDescription is not None:
            ConceptualDomain_isDescribedBy_ValueAndConceptDescription_ = self.ConceptualDomain_isDescribedBy_ValueAndConceptDescription
            ConceptualDomain_isDescribedBy_ValueAndConceptDescription_.to_etree(element, name_='ConceptualDomain_isDescribedBy_ValueAndConceptDescription', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ConceptualDomain_takesConceptsFrom_ConceptSystem is not None:
            ConceptualDomain_takesConceptsFrom_ConceptSystem_ = self.ConceptualDomain_takesConceptsFrom_ConceptSystem
            ConceptualDomain_takesConceptsFrom_ConceptSystem_.to_etree(element, name_='ConceptualDomain_takesConceptsFrom_ConceptSystem', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'displayLabel':
            obj_ = LabelForDisplay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayLabel.append(obj_)
            obj_.original_tagname_ = 'displayLabel'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'ConceptualDomain_isDescribedBy_ValueAndConceptDescription':
            obj_ = ConceptualDomain_isDescribedBy_ValueAndConceptDescriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptualDomain_isDescribedBy_ValueAndConceptDescription = obj_
            obj_.original_tagname_ = 'ConceptualDomain_isDescribedBy_ValueAndConceptDescription'
        elif nodeName_ == 'ConceptualDomain_takesConceptsFrom_ConceptSystem':
            obj_ = ConceptualDomain_takesConceptsFrom_ConceptSystemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptualDomain_takesConceptsFrom_ConceptSystem = obj_
            obj_.original_tagname_ = 'ConceptualDomain_takesConceptsFrom_ConceptSystem'
# end class ConceptualDomain


class ConceptualValue(Concept):
    """ConceptualValue_hasConceptFrom_ConceptualDomain -- Conceptual value has concept from one conceptual domain.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Concept
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, externalDefinition=None, identifier=None, name=None, Concept_uses_Concept=None, ConceptualValue_hasConceptFrom_ConceptualDomain=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptualValue"), self).__init__(catalogDetails, definition, displayLabel, externalDefinition, identifier, name, Concept_uses_Concept, extensiontype_,  **kwargs_)
        self.ConceptualValue_hasConceptFrom_ConceptualDomain = ConceptualValue_hasConceptFrom_ConceptualDomain
        self.ConceptualValue_hasConceptFrom_ConceptualDomain_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptualValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptualValue.subclass:
            return ConceptualValue.subclass(*args_, **kwargs_)
        else:
            return ConceptualValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ConceptualValue_hasConceptFrom_ConceptualDomain(self):
        return self.ConceptualValue_hasConceptFrom_ConceptualDomain
    def set_ConceptualValue_hasConceptFrom_ConceptualDomain(self, ConceptualValue_hasConceptFrom_ConceptualDomain):
        self.ConceptualValue_hasConceptFrom_ConceptualDomain = ConceptualValue_hasConceptFrom_ConceptualDomain
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.ConceptualValue_hasConceptFrom_ConceptualDomain is not None or
            super(ConceptualValue, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptualValue', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(ConceptualValue, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.ConceptualValue_hasConceptFrom_ConceptualDomain is not None:
            ConceptualValue_hasConceptFrom_ConceptualDomain_ = self.ConceptualValue_hasConceptFrom_ConceptualDomain
            ConceptualValue_hasConceptFrom_ConceptualDomain_.to_etree(element, name_='ConceptualValue_hasConceptFrom_ConceptualDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ConceptualValue, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ConceptualValue_hasConceptFrom_ConceptualDomain':
            obj_ = ConceptualValue_hasConceptFrom_ConceptualDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptualValue_hasConceptFrom_ConceptualDomain = obj_
            obj_.original_tagname_ = 'ConceptualValue_hasConceptFrom_ConceptualDomain'
        super(ConceptualValue, self)._buildChildren(child_, node, nodeName_, True)
# end class ConceptualValue


class ConceptualVariable(Concept):
    """descriptiveText -- A short natural language account of the characteristics of the object.
    unitOfMeasureKind -- Kind of unit of measure, so that it may be prone to translation to equivalent UOMs. Example values include "acceleration," "temperature," "salinity", etc. This description exists at the conceptual level, indicating a limitation on the type of representations which may be used for the variable as it is made more concrete.
    ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain -- Identifies the conceptual domain containing the set of sentinel concepts used to describe the conceptual variable.
    ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain -- Identifies the substantive conceptual domain containing the set of substantive concepts used to describe the conceptual variable.
    ConceptualVariable_measures_UnitType -- Identifies the unit type associated with the conceptual variable.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Concept
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, externalDefinition=None, identifier=None, name=None, Concept_uses_Concept=None, descriptiveText=None, unitOfMeasureKind=None, ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain=None, ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain=None, ConceptualVariable_measures_UnitType=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptualVariable"), self).__init__(catalogDetails, definition, displayLabel, externalDefinition, identifier, name, Concept_uses_Concept, extensiontype_,  **kwargs_)
        self.descriptiveText = descriptiveText
        self.descriptiveText_nsprefix_ = None
        self.unitOfMeasureKind = unitOfMeasureKind
        self.unitOfMeasureKind_nsprefix_ = None
        self.ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain = ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain
        self.ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_nsprefix_ = None
        self.ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain = ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain
        self.ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_nsprefix_ = None
        self.ConceptualVariable_measures_UnitType = ConceptualVariable_measures_UnitType
        self.ConceptualVariable_measures_UnitType_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptualVariable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptualVariable.subclass:
            return ConceptualVariable.subclass(*args_, **kwargs_)
        else:
            return ConceptualVariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_descriptiveText(self):
        return self.descriptiveText
    def set_descriptiveText(self, descriptiveText):
        self.descriptiveText = descriptiveText
    def get_unitOfMeasureKind(self):
        return self.unitOfMeasureKind
    def set_unitOfMeasureKind(self, unitOfMeasureKind):
        self.unitOfMeasureKind = unitOfMeasureKind
    def get_ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain(self):
        return self.ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain
    def set_ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain(self, ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain):
        self.ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain = ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain
    def get_ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain(self):
        return self.ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain
    def set_ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain(self, ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain):
        self.ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain = ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain
    def get_ConceptualVariable_measures_UnitType(self):
        return self.ConceptualVariable_measures_UnitType
    def set_ConceptualVariable_measures_UnitType(self, ConceptualVariable_measures_UnitType):
        self.ConceptualVariable_measures_UnitType = ConceptualVariable_measures_UnitType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.descriptiveText is not None or
            self.unitOfMeasureKind is not None or
            self.ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain is not None or
            self.ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain is not None or
            self.ConceptualVariable_measures_UnitType is not None or
            super(ConceptualVariable, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptualVariable', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(ConceptualVariable, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.descriptiveText is not None:
            descriptiveText_ = self.descriptiveText
            descriptiveText_.to_etree(element, name_='descriptiveText', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.unitOfMeasureKind is not None:
            unitOfMeasureKind_ = self.unitOfMeasureKind
            unitOfMeasureKind_.to_etree(element, name_='unitOfMeasureKind', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain is not None:
            ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_ = self.ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain
            ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain_.to_etree(element, name_='ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain is not None:
            ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_ = self.ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain
            ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain_.to_etree(element, name_='ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ConceptualVariable_measures_UnitType is not None:
            ConceptualVariable_measures_UnitType_ = self.ConceptualVariable_measures_UnitType
            ConceptualVariable_measures_UnitType_.to_etree(element, name_='ConceptualVariable_measures_UnitType', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ConceptualVariable, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'descriptiveText':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.descriptiveText = obj_
            obj_.original_tagname_ = 'descriptiveText'
        elif nodeName_ == 'unitOfMeasureKind':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unitOfMeasureKind = obj_
            obj_.original_tagname_ = 'unitOfMeasureKind'
        elif nodeName_ == 'ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain':
            obj_ = ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain = obj_
            obj_.original_tagname_ = 'ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain'
        elif nodeName_ == 'ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain':
            obj_ = ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain = obj_
            obj_.original_tagname_ = 'ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain'
        elif nodeName_ == 'ConceptualVariable_measures_UnitType':
            obj_ = ConceptualVariable_measures_UnitTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConceptualVariable_measures_UnitType = obj_
            obj_.original_tagname_ = 'ConceptualVariable_measures_UnitType'
        super(ConceptualVariable, self)._buildChildren(child_, node, nodeName_, True)
# end class ConceptualVariable


class ControlLogic(GeneratedsSuper):
    """description -- A desription of the control logic in human-readable language.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    workflow -- Reference to the system or standard from which the workflow was taken.
    ControlLogic_informs_ProcessingAgent -- Control logic informs a processing agent. The information may be deterministic or non-deterministic.
    ControlLogic_invokes_Activity -- Control logic invokes an activity deterministically (either conditionally or unconditionally) or non-derministically (based on temporal constraints or rule-based scheduling).
    ControlLogic_hasSubControlLogic_ControlLogic -- Control logic is a container of control logic which is in turn a container of control logic ad infinitum so that it is able to represent the structure of a program.
    ControlLogic_has_InformationFlowDefinition -- A control construct has zero or more information flow definitions each of which provides the control construct with zero or more input and output parameters used or produced in the step/sub-step with which it is associated.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, description=None, identifier=None, workflow=None, ControlLogic_informs_ProcessingAgent=None, ControlLogic_invokes_Activity=None, ControlLogic_hasSubControlLogic_ControlLogic=None, ControlLogic_has_InformationFlowDefinition=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.workflow = workflow
        self.workflow_nsprefix_ = None
        if ControlLogic_informs_ProcessingAgent is None:
            self.ControlLogic_informs_ProcessingAgent = []
        else:
            self.ControlLogic_informs_ProcessingAgent = ControlLogic_informs_ProcessingAgent
        self.ControlLogic_informs_ProcessingAgent_nsprefix_ = None
        if ControlLogic_invokes_Activity is None:
            self.ControlLogic_invokes_Activity = []
        else:
            self.ControlLogic_invokes_Activity = ControlLogic_invokes_Activity
        self.ControlLogic_invokes_Activity_nsprefix_ = None
        if ControlLogic_hasSubControlLogic_ControlLogic is None:
            self.ControlLogic_hasSubControlLogic_ControlLogic = []
        else:
            self.ControlLogic_hasSubControlLogic_ControlLogic = ControlLogic_hasSubControlLogic_ControlLogic
        self.ControlLogic_hasSubControlLogic_ControlLogic_nsprefix_ = None
        if ControlLogic_has_InformationFlowDefinition is None:
            self.ControlLogic_has_InformationFlowDefinition = []
        else:
            self.ControlLogic_has_InformationFlowDefinition = ControlLogic_has_InformationFlowDefinition
        self.ControlLogic_has_InformationFlowDefinition_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ControlLogic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ControlLogic.subclass:
            return ControlLogic.subclass(*args_, **kwargs_)
        else:
            return ControlLogic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_workflow(self):
        return self.workflow
    def set_workflow(self, workflow):
        self.workflow = workflow
    def get_ControlLogic_informs_ProcessingAgent(self):
        return self.ControlLogic_informs_ProcessingAgent
    def set_ControlLogic_informs_ProcessingAgent(self, ControlLogic_informs_ProcessingAgent):
        self.ControlLogic_informs_ProcessingAgent = ControlLogic_informs_ProcessingAgent
    def add_ControlLogic_informs_ProcessingAgent(self, value):
        self.ControlLogic_informs_ProcessingAgent.append(value)
    def insert_ControlLogic_informs_ProcessingAgent_at(self, index, value):
        self.ControlLogic_informs_ProcessingAgent.insert(index, value)
    def replace_ControlLogic_informs_ProcessingAgent_at(self, index, value):
        self.ControlLogic_informs_ProcessingAgent[index] = value
    def get_ControlLogic_invokes_Activity(self):
        return self.ControlLogic_invokes_Activity
    def set_ControlLogic_invokes_Activity(self, ControlLogic_invokes_Activity):
        self.ControlLogic_invokes_Activity = ControlLogic_invokes_Activity
    def add_ControlLogic_invokes_Activity(self, value):
        self.ControlLogic_invokes_Activity.append(value)
    def insert_ControlLogic_invokes_Activity_at(self, index, value):
        self.ControlLogic_invokes_Activity.insert(index, value)
    def replace_ControlLogic_invokes_Activity_at(self, index, value):
        self.ControlLogic_invokes_Activity[index] = value
    def get_ControlLogic_hasSubControlLogic_ControlLogic(self):
        return self.ControlLogic_hasSubControlLogic_ControlLogic
    def set_ControlLogic_hasSubControlLogic_ControlLogic(self, ControlLogic_hasSubControlLogic_ControlLogic):
        self.ControlLogic_hasSubControlLogic_ControlLogic = ControlLogic_hasSubControlLogic_ControlLogic
    def add_ControlLogic_hasSubControlLogic_ControlLogic(self, value):
        self.ControlLogic_hasSubControlLogic_ControlLogic.append(value)
    def insert_ControlLogic_hasSubControlLogic_ControlLogic_at(self, index, value):
        self.ControlLogic_hasSubControlLogic_ControlLogic.insert(index, value)
    def replace_ControlLogic_hasSubControlLogic_ControlLogic_at(self, index, value):
        self.ControlLogic_hasSubControlLogic_ControlLogic[index] = value
    def get_ControlLogic_has_InformationFlowDefinition(self):
        return self.ControlLogic_has_InformationFlowDefinition
    def set_ControlLogic_has_InformationFlowDefinition(self, ControlLogic_has_InformationFlowDefinition):
        self.ControlLogic_has_InformationFlowDefinition = ControlLogic_has_InformationFlowDefinition
    def add_ControlLogic_has_InformationFlowDefinition(self, value):
        self.ControlLogic_has_InformationFlowDefinition.append(value)
    def insert_ControlLogic_has_InformationFlowDefinition_at(self, index, value):
        self.ControlLogic_has_InformationFlowDefinition.insert(index, value)
    def replace_ControlLogic_has_InformationFlowDefinition_at(self, index, value):
        self.ControlLogic_has_InformationFlowDefinition[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.description is not None or
            self.identifier is not None or
            self.workflow is not None or
            self.ControlLogic_informs_ProcessingAgent or
            self.ControlLogic_invokes_Activity or
            self.ControlLogic_hasSubControlLogic_ControlLogic or
            self.ControlLogic_has_InformationFlowDefinition
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ControlLogic', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.description is not None:
            description_ = self.description
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}description').text = self.gds_format_string(description_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.workflow is not None:
            workflow_ = self.workflow
            workflow_.to_etree(element, name_='workflow', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ControlLogic_informs_ProcessingAgent_ in self.ControlLogic_informs_ProcessingAgent:
            ControlLogic_informs_ProcessingAgent_.to_etree(element, name_='ControlLogic_informs_ProcessingAgent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ControlLogic_invokes_Activity_ in self.ControlLogic_invokes_Activity:
            ControlLogic_invokes_Activity_.to_etree(element, name_='ControlLogic_invokes_Activity', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ControlLogic_hasSubControlLogic_ControlLogic_ in self.ControlLogic_hasSubControlLogic_ControlLogic:
            ControlLogic_hasSubControlLogic_ControlLogic_.to_etree(element, name_='ControlLogic_hasSubControlLogic_ControlLogic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ControlLogic_has_InformationFlowDefinition_ in self.ControlLogic_has_InformationFlowDefinition:
            ControlLogic_has_InformationFlowDefinition_.to_etree(element, name_='ControlLogic_has_InformationFlowDefinition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'workflow':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.workflow = obj_
            obj_.original_tagname_ = 'workflow'
        elif nodeName_ == 'ControlLogic_informs_ProcessingAgent':
            obj_ = ControlLogic_informs_ProcessingAgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlLogic_informs_ProcessingAgent.append(obj_)
            obj_.original_tagname_ = 'ControlLogic_informs_ProcessingAgent'
        elif nodeName_ == 'ControlLogic_invokes_Activity':
            obj_ = ControlLogic_invokes_ActivityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlLogic_invokes_Activity.append(obj_)
            obj_.original_tagname_ = 'ControlLogic_invokes_Activity'
        elif nodeName_ == 'ControlLogic_hasSubControlLogic_ControlLogic':
            obj_ = ControlLogic_hasSubControlLogic_ControlLogicType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlLogic_hasSubControlLogic_ControlLogic.append(obj_)
            obj_.original_tagname_ = 'ControlLogic_hasSubControlLogic_ControlLogic'
        elif nodeName_ == 'ControlLogic_has_InformationFlowDefinition':
            obj_ = ControlLogic_has_InformationFlowDefinitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlLogic_has_InformationFlowDefinition.append(obj_)
            obj_.original_tagname_ = 'ControlLogic_has_InformationFlowDefinition'
# end class ControlLogic


class CorrespondenceTable(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    effectiveDates -- Effective period of validity of the correspondence table. The correspondence table expresses the relationships between the two classifications as they existed on the period specified in the table.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    CorrespondenceTable_hasSource_Level -- Level from which the correspondence is made. Correspondences might be restricted to a specified level in the node set. In this case, target items are assigned only to source items on the given level. If no level is indicated, source items can be assigned to any level of the target node set.
    CorrespondenceTable_hasTarget_Level -- Level to which the correspondence is made. Correspondences might be restricted to a specified Level in the node set. In this case, target items are assigned only to source items on the given level. If no level is indicated, target items can be assigned to any level of the source node set.
    CorrespondenceTable_isOwnedBy_Agent -- The statistical office, other authority or section that created and maintains the correspondence table. A correspondence table may have several owners.
    CorrespondenceTable_mapsTo_StatisticalClassification -- The statistical classification(s) from which the correspondence is made.
    CorrespondenceTable_hasContact_Agent -- The person(s) who may be contacted for additional information about the correspondence table. Can be an individual or organization.
    CorrespondenceTable_isMaintainedBy_Agent -- The unit or group of persons who are responsible for the correspondence table (i.e., for maintaining and updating it).
    CorrespondenceTable_has_ConceptMap -- Correspondence table has zero to many concept maps.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, effectiveDates=None, identifier=None, CorrespondenceTable_hasSource_Level=None, CorrespondenceTable_hasTarget_Level=None, CorrespondenceTable_isOwnedBy_Agent=None, CorrespondenceTable_mapsTo_StatisticalClassification=None, CorrespondenceTable_hasContact_Agent=None, CorrespondenceTable_isMaintainedBy_Agent=None, CorrespondenceTable_has_ConceptMap=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.effectiveDates = effectiveDates
        self.effectiveDates_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.CorrespondenceTable_hasSource_Level = CorrespondenceTable_hasSource_Level
        self.CorrespondenceTable_hasSource_Level_nsprefix_ = None
        self.CorrespondenceTable_hasTarget_Level = CorrespondenceTable_hasTarget_Level
        self.CorrespondenceTable_hasTarget_Level_nsprefix_ = None
        if CorrespondenceTable_isOwnedBy_Agent is None:
            self.CorrespondenceTable_isOwnedBy_Agent = []
        else:
            self.CorrespondenceTable_isOwnedBy_Agent = CorrespondenceTable_isOwnedBy_Agent
        self.CorrespondenceTable_isOwnedBy_Agent_nsprefix_ = None
        if CorrespondenceTable_mapsTo_StatisticalClassification is None:
            self.CorrespondenceTable_mapsTo_StatisticalClassification = []
        else:
            self.CorrespondenceTable_mapsTo_StatisticalClassification = CorrespondenceTable_mapsTo_StatisticalClassification
        self.CorrespondenceTable_mapsTo_StatisticalClassification_nsprefix_ = None
        if CorrespondenceTable_hasContact_Agent is None:
            self.CorrespondenceTable_hasContact_Agent = []
        else:
            self.CorrespondenceTable_hasContact_Agent = CorrespondenceTable_hasContact_Agent
        self.CorrespondenceTable_hasContact_Agent_nsprefix_ = None
        self.CorrespondenceTable_isMaintainedBy_Agent = CorrespondenceTable_isMaintainedBy_Agent
        self.CorrespondenceTable_isMaintainedBy_Agent_nsprefix_ = None
        if CorrespondenceTable_has_ConceptMap is None:
            self.CorrespondenceTable_has_ConceptMap = []
        else:
            self.CorrespondenceTable_has_ConceptMap = CorrespondenceTable_has_ConceptMap
        self.CorrespondenceTable_has_ConceptMap_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrespondenceTable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrespondenceTable.subclass:
            return CorrespondenceTable.subclass(*args_, **kwargs_)
        else:
            return CorrespondenceTable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_effectiveDates(self):
        return self.effectiveDates
    def set_effectiveDates(self, effectiveDates):
        self.effectiveDates = effectiveDates
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_CorrespondenceTable_hasSource_Level(self):
        return self.CorrespondenceTable_hasSource_Level
    def set_CorrespondenceTable_hasSource_Level(self, CorrespondenceTable_hasSource_Level):
        self.CorrespondenceTable_hasSource_Level = CorrespondenceTable_hasSource_Level
    def get_CorrespondenceTable_hasTarget_Level(self):
        return self.CorrespondenceTable_hasTarget_Level
    def set_CorrespondenceTable_hasTarget_Level(self, CorrespondenceTable_hasTarget_Level):
        self.CorrespondenceTable_hasTarget_Level = CorrespondenceTable_hasTarget_Level
    def get_CorrespondenceTable_isOwnedBy_Agent(self):
        return self.CorrespondenceTable_isOwnedBy_Agent
    def set_CorrespondenceTable_isOwnedBy_Agent(self, CorrespondenceTable_isOwnedBy_Agent):
        self.CorrespondenceTable_isOwnedBy_Agent = CorrespondenceTable_isOwnedBy_Agent
    def add_CorrespondenceTable_isOwnedBy_Agent(self, value):
        self.CorrespondenceTable_isOwnedBy_Agent.append(value)
    def insert_CorrespondenceTable_isOwnedBy_Agent_at(self, index, value):
        self.CorrespondenceTable_isOwnedBy_Agent.insert(index, value)
    def replace_CorrespondenceTable_isOwnedBy_Agent_at(self, index, value):
        self.CorrespondenceTable_isOwnedBy_Agent[index] = value
    def get_CorrespondenceTable_mapsTo_StatisticalClassification(self):
        return self.CorrespondenceTable_mapsTo_StatisticalClassification
    def set_CorrespondenceTable_mapsTo_StatisticalClassification(self, CorrespondenceTable_mapsTo_StatisticalClassification):
        self.CorrespondenceTable_mapsTo_StatisticalClassification = CorrespondenceTable_mapsTo_StatisticalClassification
    def add_CorrespondenceTable_mapsTo_StatisticalClassification(self, value):
        self.CorrespondenceTable_mapsTo_StatisticalClassification.append(value)
    def insert_CorrespondenceTable_mapsTo_StatisticalClassification_at(self, index, value):
        self.CorrespondenceTable_mapsTo_StatisticalClassification.insert(index, value)
    def replace_CorrespondenceTable_mapsTo_StatisticalClassification_at(self, index, value):
        self.CorrespondenceTable_mapsTo_StatisticalClassification[index] = value
    def get_CorrespondenceTable_hasContact_Agent(self):
        return self.CorrespondenceTable_hasContact_Agent
    def set_CorrespondenceTable_hasContact_Agent(self, CorrespondenceTable_hasContact_Agent):
        self.CorrespondenceTable_hasContact_Agent = CorrespondenceTable_hasContact_Agent
    def add_CorrespondenceTable_hasContact_Agent(self, value):
        self.CorrespondenceTable_hasContact_Agent.append(value)
    def insert_CorrespondenceTable_hasContact_Agent_at(self, index, value):
        self.CorrespondenceTable_hasContact_Agent.insert(index, value)
    def replace_CorrespondenceTable_hasContact_Agent_at(self, index, value):
        self.CorrespondenceTable_hasContact_Agent[index] = value
    def get_CorrespondenceTable_isMaintainedBy_Agent(self):
        return self.CorrespondenceTable_isMaintainedBy_Agent
    def set_CorrespondenceTable_isMaintainedBy_Agent(self, CorrespondenceTable_isMaintainedBy_Agent):
        self.CorrespondenceTable_isMaintainedBy_Agent = CorrespondenceTable_isMaintainedBy_Agent
    def get_CorrespondenceTable_has_ConceptMap(self):
        return self.CorrespondenceTable_has_ConceptMap
    def set_CorrespondenceTable_has_ConceptMap(self, CorrespondenceTable_has_ConceptMap):
        self.CorrespondenceTable_has_ConceptMap = CorrespondenceTable_has_ConceptMap
    def add_CorrespondenceTable_has_ConceptMap(self, value):
        self.CorrespondenceTable_has_ConceptMap.append(value)
    def insert_CorrespondenceTable_has_ConceptMap_at(self, index, value):
        self.CorrespondenceTable_has_ConceptMap.insert(index, value)
    def replace_CorrespondenceTable_has_ConceptMap_at(self, index, value):
        self.CorrespondenceTable_has_ConceptMap[index] = value
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.effectiveDates is not None or
            self.identifier is not None or
            self.CorrespondenceTable_hasSource_Level is not None or
            self.CorrespondenceTable_hasTarget_Level is not None or
            self.CorrespondenceTable_isOwnedBy_Agent or
            self.CorrespondenceTable_mapsTo_StatisticalClassification or
            self.CorrespondenceTable_hasContact_Agent or
            self.CorrespondenceTable_isMaintainedBy_Agent is not None or
            self.CorrespondenceTable_has_ConceptMap
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CorrespondenceTable', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.effectiveDates is not None:
            effectiveDates_ = self.effectiveDates
            effectiveDates_.to_etree(element, name_='effectiveDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.CorrespondenceTable_hasSource_Level is not None:
            CorrespondenceTable_hasSource_Level_ = self.CorrespondenceTable_hasSource_Level
            CorrespondenceTable_hasSource_Level_.to_etree(element, name_='CorrespondenceTable_hasSource_Level', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.CorrespondenceTable_hasTarget_Level is not None:
            CorrespondenceTable_hasTarget_Level_ = self.CorrespondenceTable_hasTarget_Level
            CorrespondenceTable_hasTarget_Level_.to_etree(element, name_='CorrespondenceTable_hasTarget_Level', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CorrespondenceTable_isOwnedBy_Agent_ in self.CorrespondenceTable_isOwnedBy_Agent:
            CorrespondenceTable_isOwnedBy_Agent_.to_etree(element, name_='CorrespondenceTable_isOwnedBy_Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CorrespondenceTable_mapsTo_StatisticalClassification_ in self.CorrespondenceTable_mapsTo_StatisticalClassification:
            CorrespondenceTable_mapsTo_StatisticalClassification_.to_etree(element, name_='CorrespondenceTable_mapsTo_StatisticalClassification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CorrespondenceTable_hasContact_Agent_ in self.CorrespondenceTable_hasContact_Agent:
            CorrespondenceTable_hasContact_Agent_.to_etree(element, name_='CorrespondenceTable_hasContact_Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.CorrespondenceTable_isMaintainedBy_Agent is not None:
            CorrespondenceTable_isMaintainedBy_Agent_ = self.CorrespondenceTable_isMaintainedBy_Agent
            CorrespondenceTable_isMaintainedBy_Agent_.to_etree(element, name_='CorrespondenceTable_isMaintainedBy_Agent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CorrespondenceTable_has_ConceptMap_ in self.CorrespondenceTable_has_ConceptMap:
            CorrespondenceTable_has_ConceptMap_.to_etree(element, name_='CorrespondenceTable_has_ConceptMap', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'effectiveDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveDates = obj_
            obj_.original_tagname_ = 'effectiveDates'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'CorrespondenceTable_hasSource_Level':
            obj_ = CorrespondenceTable_hasSource_LevelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CorrespondenceTable_hasSource_Level = obj_
            obj_.original_tagname_ = 'CorrespondenceTable_hasSource_Level'
        elif nodeName_ == 'CorrespondenceTable_hasTarget_Level':
            obj_ = CorrespondenceTable_hasTarget_LevelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CorrespondenceTable_hasTarget_Level = obj_
            obj_.original_tagname_ = 'CorrespondenceTable_hasTarget_Level'
        elif nodeName_ == 'CorrespondenceTable_isOwnedBy_Agent':
            obj_ = CorrespondenceTable_isOwnedBy_AgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CorrespondenceTable_isOwnedBy_Agent.append(obj_)
            obj_.original_tagname_ = 'CorrespondenceTable_isOwnedBy_Agent'
        elif nodeName_ == 'CorrespondenceTable_mapsTo_StatisticalClassification':
            obj_ = CorrespondenceTable_mapsTo_StatisticalClassificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CorrespondenceTable_mapsTo_StatisticalClassification.append(obj_)
            obj_.original_tagname_ = 'CorrespondenceTable_mapsTo_StatisticalClassification'
        elif nodeName_ == 'CorrespondenceTable_hasContact_Agent':
            obj_ = CorrespondenceTable_hasContact_AgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CorrespondenceTable_hasContact_Agent.append(obj_)
            obj_.original_tagname_ = 'CorrespondenceTable_hasContact_Agent'
        elif nodeName_ == 'CorrespondenceTable_isMaintainedBy_Agent':
            obj_ = CorrespondenceTable_isMaintainedBy_AgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CorrespondenceTable_isMaintainedBy_Agent = obj_
            obj_.original_tagname_ = 'CorrespondenceTable_isMaintainedBy_Agent'
        elif nodeName_ == 'CorrespondenceTable_has_ConceptMap':
            obj_ = CorrespondenceTable_has_ConceptMapType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CorrespondenceTable_has_ConceptMap.append(obj_)
            obj_.original_tagname_ = 'CorrespondenceTable_has_ConceptMap'
# end class CorrespondenceTable


class DataPoint(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry. Examples would be creator, contributor, title, copyright, embargo, and license information. A set of information useful for attribution, data discovery, and access. This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    DataPoint_isDescribedBy_InstanceVariable -- The instance variable delimits the values which can populate a data point. Data point is described by one instance variable.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, identifier=None, DataPoint_correspondsTo_DataStructureComponent=None, DataPoint_isDescribedBy_InstanceVariable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if DataPoint_correspondsTo_DataStructureComponent is None:
            self.DataPoint_correspondsTo_DataStructureComponent = []
        else:
            self.DataPoint_correspondsTo_DataStructureComponent = DataPoint_correspondsTo_DataStructureComponent
        self.DataPoint_correspondsTo_DataStructureComponent_nsprefix_ = None
        self.DataPoint_isDescribedBy_InstanceVariable = DataPoint_isDescribedBy_InstanceVariable
        self.DataPoint_isDescribedBy_InstanceVariable_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataPoint.subclass:
            return DataPoint.subclass(*args_, **kwargs_)
        else:
            return DataPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_DataPoint_correspondsTo_DataStructureComponent(self):
        return self.DataPoint_correspondsTo_DataStructureComponent
    def set_DataPoint_correspondsTo_DataStructureComponent(self, DataPoint_correspondsTo_DataStructureComponent):
        self.DataPoint_correspondsTo_DataStructureComponent = DataPoint_correspondsTo_DataStructureComponent
    def add_DataPoint_correspondsTo_DataStructureComponent(self, value):
        self.DataPoint_correspondsTo_DataStructureComponent.append(value)
    def insert_DataPoint_correspondsTo_DataStructureComponent_at(self, index, value):
        self.DataPoint_correspondsTo_DataStructureComponent.insert(index, value)
    def replace_DataPoint_correspondsTo_DataStructureComponent_at(self, index, value):
        self.DataPoint_correspondsTo_DataStructureComponent[index] = value
    def get_DataPoint_isDescribedBy_InstanceVariable(self):
        return self.DataPoint_isDescribedBy_InstanceVariable
    def set_DataPoint_isDescribedBy_InstanceVariable(self, DataPoint_isDescribedBy_InstanceVariable):
        self.DataPoint_isDescribedBy_InstanceVariable = DataPoint_isDescribedBy_InstanceVariable
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.identifier is not None or
            self.DataPoint_correspondsTo_DataStructureComponent or
            self.DataPoint_isDescribedBy_InstanceVariable is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataPoint', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataPoint_correspondsTo_DataStructureComponent_ in self.DataPoint_correspondsTo_DataStructureComponent:
            DataPoint_correspondsTo_DataStructureComponent_.to_etree(element, name_='DataPoint_correspondsTo_DataStructureComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.DataPoint_isDescribedBy_InstanceVariable is not None:
            DataPoint_isDescribedBy_InstanceVariable_ = self.DataPoint_isDescribedBy_InstanceVariable
            DataPoint_isDescribedBy_InstanceVariable_.to_etree(element, name_='DataPoint_isDescribedBy_InstanceVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'DataPoint_correspondsTo_DataStructureComponent':
            obj_ = DataPoint_correspondsTo_DataStructureComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataPoint_correspondsTo_DataStructureComponent.append(obj_)
            obj_.original_tagname_ = 'DataPoint_correspondsTo_DataStructureComponent'
        elif nodeName_ == 'DataPoint_isDescribedBy_InstanceVariable':
            obj_ = DataPoint_isDescribedBy_InstanceVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataPoint_isDescribedBy_InstanceVariable = obj_
            obj_.original_tagname_ = 'DataPoint_isDescribedBy_InstanceVariable'
# end class DataPoint


class DataPointPosition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    value -- Index value of the member in an ordered array.
    DataPointPosition_indexes_DataPoint -- Data point position indexes zero to one data point.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, value=None, DataPointPosition_indexes_DataPoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.DataPointPosition_indexes_DataPoint = DataPointPosition_indexes_DataPoint
        self.DataPointPosition_indexes_DataPoint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataPointPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataPointPosition.subclass:
            return DataPointPosition.subclass(*args_, **kwargs_)
        else:
            return DataPointPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_DataPointPosition_indexes_DataPoint(self):
        return self.DataPointPosition_indexes_DataPoint
    def set_DataPointPosition_indexes_DataPoint(self, DataPointPosition_indexes_DataPoint):
        self.DataPointPosition_indexes_DataPoint = DataPointPosition_indexes_DataPoint
    def has__content(self):
        if (
            self.identifier is not None or
            self.value is not None or
            self.DataPointPosition_indexes_DataPoint is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataPointPosition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_integer(value_)
        if self.DataPointPosition_indexes_DataPoint is not None:
            DataPointPosition_indexes_DataPoint_ = self.DataPointPosition_indexes_DataPoint
            DataPointPosition_indexes_DataPoint_.to_etree(element, name_='DataPointPosition_indexes_DataPoint', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
        elif nodeName_ == 'DataPointPosition_indexes_DataPoint':
            obj_ = DataPointPosition_indexes_DataPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataPointPosition_indexes_DataPoint = obj_
            obj_.original_tagname_ = 'DataPointPosition_indexes_DataPoint'
# end class DataPointPosition


class DataPointRelationship(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    DataPointRelationship_hasTarget_DataPoint -- Data point relationship has zero to many target data points.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, semantics=None, DataPointRelationship_hasTarget_DataPoint=None, DataPointRelationship_hasSource_DataPoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        if DataPointRelationship_hasTarget_DataPoint is None:
            self.DataPointRelationship_hasTarget_DataPoint = []
        else:
            self.DataPointRelationship_hasTarget_DataPoint = DataPointRelationship_hasTarget_DataPoint
        self.DataPointRelationship_hasTarget_DataPoint_nsprefix_ = None
        if DataPointRelationship_hasSource_DataPoint is None:
            self.DataPointRelationship_hasSource_DataPoint = []
        else:
            self.DataPointRelationship_hasSource_DataPoint = DataPointRelationship_hasSource_DataPoint
        self.DataPointRelationship_hasSource_DataPoint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataPointRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataPointRelationship.subclass:
            return DataPointRelationship.subclass(*args_, **kwargs_)
        else:
            return DataPointRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_DataPointRelationship_hasTarget_DataPoint(self):
        return self.DataPointRelationship_hasTarget_DataPoint
    def set_DataPointRelationship_hasTarget_DataPoint(self, DataPointRelationship_hasTarget_DataPoint):
        self.DataPointRelationship_hasTarget_DataPoint = DataPointRelationship_hasTarget_DataPoint
    def add_DataPointRelationship_hasTarget_DataPoint(self, value):
        self.DataPointRelationship_hasTarget_DataPoint.append(value)
    def insert_DataPointRelationship_hasTarget_DataPoint_at(self, index, value):
        self.DataPointRelationship_hasTarget_DataPoint.insert(index, value)
    def replace_DataPointRelationship_hasTarget_DataPoint_at(self, index, value):
        self.DataPointRelationship_hasTarget_DataPoint[index] = value
    def get_DataPointRelationship_hasSource_DataPoint(self):
        return self.DataPointRelationship_hasSource_DataPoint
    def set_DataPointRelationship_hasSource_DataPoint(self, DataPointRelationship_hasSource_DataPoint):
        self.DataPointRelationship_hasSource_DataPoint = DataPointRelationship_hasSource_DataPoint
    def add_DataPointRelationship_hasSource_DataPoint(self, value):
        self.DataPointRelationship_hasSource_DataPoint.append(value)
    def insert_DataPointRelationship_hasSource_DataPoint_at(self, index, value):
        self.DataPointRelationship_hasSource_DataPoint.insert(index, value)
    def replace_DataPointRelationship_hasSource_DataPoint_at(self, index, value):
        self.DataPointRelationship_hasSource_DataPoint[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.semantics is not None or
            self.DataPointRelationship_hasTarget_DataPoint or
            self.DataPointRelationship_hasSource_DataPoint
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataPointRelationship', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataPointRelationship_hasTarget_DataPoint_ in self.DataPointRelationship_hasTarget_DataPoint:
            DataPointRelationship_hasTarget_DataPoint_.to_etree(element, name_='DataPointRelationship_hasTarget_DataPoint', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataPointRelationship_hasSource_DataPoint_ in self.DataPointRelationship_hasSource_DataPoint:
            DataPointRelationship_hasSource_DataPoint_.to_etree(element, name_='DataPointRelationship_hasSource_DataPoint', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'DataPointRelationship_hasTarget_DataPoint':
            obj_ = DataPointRelationship_hasTarget_DataPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataPointRelationship_hasTarget_DataPoint.append(obj_)
            obj_.original_tagname_ = 'DataPointRelationship_hasTarget_DataPoint'
        elif nodeName_ == 'DataPointRelationship_hasSource_DataPoint':
            obj_ = DataPointRelationship_hasSource_DataPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataPointRelationship_hasSource_DataPoint.append(obj_)
            obj_.original_tagname_ = 'DataPointRelationship_hasSource_DataPoint'
# end class DataPointRelationship


class DataSet(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry. Examples would be creator, contributor, title, copyright, embargo, and license information. A set of information useful for attribution, data discovery, and access. This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, identifier=None, DataSet_isStructuredBy_DataStructure=None, DataSet_has_DataPoint=None, DataSet_has_Key=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if DataSet_isStructuredBy_DataStructure is None:
            self.DataSet_isStructuredBy_DataStructure = []
        else:
            self.DataSet_isStructuredBy_DataStructure = DataSet_isStructuredBy_DataStructure
        self.DataSet_isStructuredBy_DataStructure_nsprefix_ = None
        if DataSet_has_DataPoint is None:
            self.DataSet_has_DataPoint = []
        else:
            self.DataSet_has_DataPoint = DataSet_has_DataPoint
        self.DataSet_has_DataPoint_nsprefix_ = None
        if DataSet_has_Key is None:
            self.DataSet_has_Key = []
        else:
            self.DataSet_has_Key = DataSet_has_Key
        self.DataSet_has_Key_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataSet.subclass:
            return DataSet.subclass(*args_, **kwargs_)
        else:
            return DataSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_DataSet_isStructuredBy_DataStructure(self):
        return self.DataSet_isStructuredBy_DataStructure
    def set_DataSet_isStructuredBy_DataStructure(self, DataSet_isStructuredBy_DataStructure):
        self.DataSet_isStructuredBy_DataStructure = DataSet_isStructuredBy_DataStructure
    def add_DataSet_isStructuredBy_DataStructure(self, value):
        self.DataSet_isStructuredBy_DataStructure.append(value)
    def insert_DataSet_isStructuredBy_DataStructure_at(self, index, value):
        self.DataSet_isStructuredBy_DataStructure.insert(index, value)
    def replace_DataSet_isStructuredBy_DataStructure_at(self, index, value):
        self.DataSet_isStructuredBy_DataStructure[index] = value
    def get_DataSet_has_DataPoint(self):
        return self.DataSet_has_DataPoint
    def set_DataSet_has_DataPoint(self, DataSet_has_DataPoint):
        self.DataSet_has_DataPoint = DataSet_has_DataPoint
    def add_DataSet_has_DataPoint(self, value):
        self.DataSet_has_DataPoint.append(value)
    def insert_DataSet_has_DataPoint_at(self, index, value):
        self.DataSet_has_DataPoint.insert(index, value)
    def replace_DataSet_has_DataPoint_at(self, index, value):
        self.DataSet_has_DataPoint[index] = value
    def get_DataSet_has_Key(self):
        return self.DataSet_has_Key
    def set_DataSet_has_Key(self, DataSet_has_Key):
        self.DataSet_has_Key = DataSet_has_Key
    def add_DataSet_has_Key(self, value):
        self.DataSet_has_Key.append(value)
    def insert_DataSet_has_Key_at(self, index, value):
        self.DataSet_has_Key.insert(index, value)
    def replace_DataSet_has_Key_at(self, index, value):
        self.DataSet_has_Key[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.identifier is not None or
            self.DataSet_isStructuredBy_DataStructure or
            self.DataSet_has_DataPoint or
            self.DataSet_has_Key
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataSet', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataSet_isStructuredBy_DataStructure_ in self.DataSet_isStructuredBy_DataStructure:
            DataSet_isStructuredBy_DataStructure_.to_etree(element, name_='DataSet_isStructuredBy_DataStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataSet_has_DataPoint_ in self.DataSet_has_DataPoint:
            DataSet_has_DataPoint_.to_etree(element, name_='DataSet_has_DataPoint', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataSet_has_Key_ in self.DataSet_has_Key:
            DataSet_has_Key_.to_etree(element, name_='DataSet_has_Key', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'DataSet_isStructuredBy_DataStructure':
            obj_ = DataSet_isStructuredBy_DataStructureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataSet_isStructuredBy_DataStructure.append(obj_)
            obj_.original_tagname_ = 'DataSet_isStructuredBy_DataStructure'
        elif nodeName_ == 'DataSet_has_DataPoint':
            obj_ = DataSet_has_DataPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataSet_has_DataPoint.append(obj_)
            obj_.original_tagname_ = 'DataSet_has_DataPoint'
        elif nodeName_ == 'DataSet_has_Key':
            obj_ = DataSet_has_KeyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataSet_has_Key.append(obj_)
            obj_.original_tagname_ = 'DataSet_has_Key'
# end class DataSet


class DataStore(GeneratedsSuper):
    """aboutMissing -- General information about missing data, e.g., that missing data have been standardized across the collection, missing data are present because of merging, etc.-  corresponds to DDI2.5 dataMsng.
    allowsDuplicates -- If value is False, the members are unique within the collection - if True, there may be duplicates. (Note that a mathematical
    “
    bag
    ”
    permits duplicates and is unordered - a
    “
    set
    ”
    does not have duplicates and may be ordered.)
    catalogDetails -- Bundles the information useful for a data catalog entry. Examples would be creator, contributor, title, copyright, embargo, and license information. A set of information useful for attribution, data discovery, and access. This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    characterSet -- Default character set used in the Data Store.
    dataStoreType -- The type of datastore. Could be delimited file, fixed record length file, relational database, etc. Points to an external definition which can be part of a controlled vocabulary maintained by the DDI Alliance.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    recordCount -- The number of records in the Data Store.
    DataStore_isDefinedBy_Concept -- The conceptual basis for the collection of members.
    DataStore_has_RecordRelation -- The record relation that defines the relationship and linking requirements between logical records in the data store.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, aboutMissing=None, allowsDuplicates=None, catalogDetails=None, characterSet=None, dataStoreType=None, identifier=None, name=None, purpose=None, recordCount=None, DataStore_isDefinedBy_Concept=None, DataStore_has_LogicalRecordPosition=None, DataStore_has_LogicalRecord=None, DataStore_has_RecordRelation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.aboutMissing = aboutMissing
        self.aboutMissing_nsprefix_ = None
        self.allowsDuplicates = allowsDuplicates
        self.allowsDuplicates_nsprefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.characterSet = characterSet
        self.characterSet_nsprefix_ = None
        self.dataStoreType = dataStoreType
        self.dataStoreType_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.recordCount = recordCount
        self.recordCount_nsprefix_ = None
        if DataStore_isDefinedBy_Concept is None:
            self.DataStore_isDefinedBy_Concept = []
        else:
            self.DataStore_isDefinedBy_Concept = DataStore_isDefinedBy_Concept
        self.DataStore_isDefinedBy_Concept_nsprefix_ = None
        if DataStore_has_LogicalRecordPosition is None:
            self.DataStore_has_LogicalRecordPosition = []
        else:
            self.DataStore_has_LogicalRecordPosition = DataStore_has_LogicalRecordPosition
        self.DataStore_has_LogicalRecordPosition_nsprefix_ = None
        if DataStore_has_LogicalRecord is None:
            self.DataStore_has_LogicalRecord = []
        else:
            self.DataStore_has_LogicalRecord = DataStore_has_LogicalRecord
        self.DataStore_has_LogicalRecord_nsprefix_ = None
        self.DataStore_has_RecordRelation = DataStore_has_RecordRelation
        self.DataStore_has_RecordRelation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataStore)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataStore.subclass:
            return DataStore.subclass(*args_, **kwargs_)
        else:
            return DataStore(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_aboutMissing(self):
        return self.aboutMissing
    def set_aboutMissing(self, aboutMissing):
        self.aboutMissing = aboutMissing
    def get_allowsDuplicates(self):
        return self.allowsDuplicates
    def set_allowsDuplicates(self, allowsDuplicates):
        self.allowsDuplicates = allowsDuplicates
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_characterSet(self):
        return self.characterSet
    def set_characterSet(self, characterSet):
        self.characterSet = characterSet
    def get_dataStoreType(self):
        return self.dataStoreType
    def set_dataStoreType(self, dataStoreType):
        self.dataStoreType = dataStoreType
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_recordCount(self):
        return self.recordCount
    def set_recordCount(self, recordCount):
        self.recordCount = recordCount
    def get_DataStore_isDefinedBy_Concept(self):
        return self.DataStore_isDefinedBy_Concept
    def set_DataStore_isDefinedBy_Concept(self, DataStore_isDefinedBy_Concept):
        self.DataStore_isDefinedBy_Concept = DataStore_isDefinedBy_Concept
    def add_DataStore_isDefinedBy_Concept(self, value):
        self.DataStore_isDefinedBy_Concept.append(value)
    def insert_DataStore_isDefinedBy_Concept_at(self, index, value):
        self.DataStore_isDefinedBy_Concept.insert(index, value)
    def replace_DataStore_isDefinedBy_Concept_at(self, index, value):
        self.DataStore_isDefinedBy_Concept[index] = value
    def get_DataStore_has_LogicalRecordPosition(self):
        return self.DataStore_has_LogicalRecordPosition
    def set_DataStore_has_LogicalRecordPosition(self, DataStore_has_LogicalRecordPosition):
        self.DataStore_has_LogicalRecordPosition = DataStore_has_LogicalRecordPosition
    def add_DataStore_has_LogicalRecordPosition(self, value):
        self.DataStore_has_LogicalRecordPosition.append(value)
    def insert_DataStore_has_LogicalRecordPosition_at(self, index, value):
        self.DataStore_has_LogicalRecordPosition.insert(index, value)
    def replace_DataStore_has_LogicalRecordPosition_at(self, index, value):
        self.DataStore_has_LogicalRecordPosition[index] = value
    def get_DataStore_has_LogicalRecord(self):
        return self.DataStore_has_LogicalRecord
    def set_DataStore_has_LogicalRecord(self, DataStore_has_LogicalRecord):
        self.DataStore_has_LogicalRecord = DataStore_has_LogicalRecord
    def add_DataStore_has_LogicalRecord(self, value):
        self.DataStore_has_LogicalRecord.append(value)
    def insert_DataStore_has_LogicalRecord_at(self, index, value):
        self.DataStore_has_LogicalRecord.insert(index, value)
    def replace_DataStore_has_LogicalRecord_at(self, index, value):
        self.DataStore_has_LogicalRecord[index] = value
    def get_DataStore_has_RecordRelation(self):
        return self.DataStore_has_RecordRelation
    def set_DataStore_has_RecordRelation(self, DataStore_has_RecordRelation):
        self.DataStore_has_RecordRelation = DataStore_has_RecordRelation
    def has__content(self):
        if (
            self.aboutMissing is not None or
            self.allowsDuplicates is not None or
            self.catalogDetails is not None or
            self.characterSet is not None or
            self.dataStoreType is not None or
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.recordCount is not None or
            self.DataStore_isDefinedBy_Concept or
            self.DataStore_has_LogicalRecordPosition or
            self.DataStore_has_LogicalRecord or
            self.DataStore_has_RecordRelation is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataStore', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.aboutMissing is not None:
            aboutMissing_ = self.aboutMissing
            aboutMissing_.to_etree(element, name_='aboutMissing', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.allowsDuplicates is not None:
            allowsDuplicates_ = self.allowsDuplicates
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}allowsDuplicates').text = self.gds_format_boolean(allowsDuplicates_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.characterSet is not None:
            characterSet_ = self.characterSet
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}characterSet').text = self.gds_format_string(characterSet_)
        if self.dataStoreType is not None:
            dataStoreType_ = self.dataStoreType
            dataStoreType_.to_etree(element, name_='dataStoreType', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.recordCount is not None:
            recordCount_ = self.recordCount
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}recordCount').text = self.gds_format_integer(recordCount_)
        for DataStore_isDefinedBy_Concept_ in self.DataStore_isDefinedBy_Concept:
            DataStore_isDefinedBy_Concept_.to_etree(element, name_='DataStore_isDefinedBy_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataStore_has_LogicalRecordPosition_ in self.DataStore_has_LogicalRecordPosition:
            DataStore_has_LogicalRecordPosition_.to_etree(element, name_='DataStore_has_LogicalRecordPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataStore_has_LogicalRecord_ in self.DataStore_has_LogicalRecord:
            DataStore_has_LogicalRecord_.to_etree(element, name_='DataStore_has_LogicalRecord', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.DataStore_has_RecordRelation is not None:
            DataStore_has_RecordRelation_ = self.DataStore_has_RecordRelation
            DataStore_has_RecordRelation_.to_etree(element, name_='DataStore_has_RecordRelation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'aboutMissing':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.aboutMissing = obj_
            obj_.original_tagname_ = 'aboutMissing'
        elif nodeName_ == 'allowsDuplicates':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'allowsDuplicates')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowsDuplicates')
            self.allowsDuplicates = ival_
            self.allowsDuplicates_nsprefix_ = child_.prefix
        elif nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'characterSet':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'characterSet')
            value_ = self.gds_validate_string(value_, node, 'characterSet')
            self.characterSet = value_
            self.characterSet_nsprefix_ = child_.prefix
        elif nodeName_ == 'dataStoreType':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataStoreType = obj_
            obj_.original_tagname_ = 'dataStoreType'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'recordCount' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'recordCount')
            ival_ = self.gds_validate_integer(ival_, node, 'recordCount')
            self.recordCount = ival_
            self.recordCount_nsprefix_ = child_.prefix
        elif nodeName_ == 'DataStore_isDefinedBy_Concept':
            obj_ = DataStore_isDefinedBy_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStore_isDefinedBy_Concept.append(obj_)
            obj_.original_tagname_ = 'DataStore_isDefinedBy_Concept'
        elif nodeName_ == 'DataStore_has_LogicalRecordPosition':
            obj_ = DataStore_has_LogicalRecordPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStore_has_LogicalRecordPosition.append(obj_)
            obj_.original_tagname_ = 'DataStore_has_LogicalRecordPosition'
        elif nodeName_ == 'DataStore_has_LogicalRecord':
            obj_ = DataStore_has_LogicalRecordType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStore_has_LogicalRecord.append(obj_)
            obj_.original_tagname_ = 'DataStore_has_LogicalRecord'
        elif nodeName_ == 'DataStore_has_RecordRelation':
            obj_ = DataStore_has_RecordRelationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStore_has_RecordRelation = obj_
            obj_.original_tagname_ = 'DataStore_has_RecordRelation'
# end class DataStore


class DataStructureComponent(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    semantic -- Qualifies the purpose or use expressed as a paired external controlled vocabulary.
    specialization -- The role played by the component for the data set for purposes of harmonization and integration, typically regarding geography, time, etc.
    DataStructureComponent_isDefinedBy_RepresentedVariable -- Data structure component is defined by zero to one represented variable.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if semantic is None:
            self.semantic = []
        else:
            self.semantic = semantic
        self.semantic_nsprefix_ = None
        self.specialization = specialization
        self.specialization_nsprefix_ = None
        self.DataStructureComponent_isDefinedBy_RepresentedVariable = DataStructureComponent_isDefinedBy_RepresentedVariable
        self.DataStructureComponent_isDefinedBy_RepresentedVariable_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataStructureComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataStructureComponent.subclass:
            return DataStructureComponent.subclass(*args_, **kwargs_)
        else:
            return DataStructureComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_semantic(self):
        return self.semantic
    def set_semantic(self, semantic):
        self.semantic = semantic
    def add_semantic(self, value):
        self.semantic.append(value)
    def insert_semantic_at(self, index, value):
        self.semantic.insert(index, value)
    def replace_semantic_at(self, index, value):
        self.semantic[index] = value
    def get_specialization(self):
        return self.specialization
    def set_specialization(self, specialization):
        self.specialization = specialization
    def get_DataStructureComponent_isDefinedBy_RepresentedVariable(self):
        return self.DataStructureComponent_isDefinedBy_RepresentedVariable
    def set_DataStructureComponent_isDefinedBy_RepresentedVariable(self, DataStructureComponent_isDefinedBy_RepresentedVariable):
        self.DataStructureComponent_isDefinedBy_RepresentedVariable = DataStructureComponent_isDefinedBy_RepresentedVariable
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.identifier is not None or
            self.semantic or
            self.specialization is not None or
            self.DataStructureComponent_isDefinedBy_RepresentedVariable is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataStructureComponent', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for semantic_ in self.semantic:
            semantic_.to_etree(element, name_='semantic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.specialization is not None:
            specialization_ = self.specialization
            specialization_.to_etree(element, name_='specialization', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.DataStructureComponent_isDefinedBy_RepresentedVariable is not None:
            DataStructureComponent_isDefinedBy_RepresentedVariable_ = self.DataStructureComponent_isDefinedBy_RepresentedVariable
            DataStructureComponent_isDefinedBy_RepresentedVariable_.to_etree(element, name_='DataStructureComponent_isDefinedBy_RepresentedVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'semantic':
            obj_ = PairedControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantic.append(obj_)
            obj_.original_tagname_ = 'semantic'
        elif nodeName_ == 'specialization':
            class_obj_ = self.get_class_obj_(child_, SpecializationRole)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specialization = obj_
            obj_.original_tagname_ = 'specialization'
        elif nodeName_ == 'DataStructureComponent_isDefinedBy_RepresentedVariable':
            obj_ = DataStructureComponent_isDefinedBy_RepresentedVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStructureComponent_isDefinedBy_RepresentedVariable = obj_
            obj_.original_tagname_ = 'DataStructureComponent_isDefinedBy_RepresentedVariable'
# end class DataStructureComponent


class Datum(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry. Examples would be creator, contributor, title, copyright, embargo, and license information. A set of information useful for attribution, data discovery, and access. This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    Datum_isBoundedBy_InstanceVariable -- A datum is bounded by an instance variable. The datum is drawn from a set of values, either substantive or sentinel described by the value domain of the instance variable.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, identifier=None, Datum_uses_Notation=None, Datum_denotes_ConceptualValue=None, Datum_uses_InstanceValue=None, Datum_isBoundedBy_InstanceVariable=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.Datum_uses_Notation = Datum_uses_Notation
        self.Datum_uses_Notation_nsprefix_ = None
        self.Datum_denotes_ConceptualValue = Datum_denotes_ConceptualValue
        self.Datum_denotes_ConceptualValue_nsprefix_ = None
        if Datum_uses_InstanceValue is None:
            self.Datum_uses_InstanceValue = []
        else:
            self.Datum_uses_InstanceValue = Datum_uses_InstanceValue
        self.Datum_uses_InstanceValue_nsprefix_ = None
        if Datum_isBoundedBy_InstanceVariable is None:
            self.Datum_isBoundedBy_InstanceVariable = []
        else:
            self.Datum_isBoundedBy_InstanceVariable = Datum_isBoundedBy_InstanceVariable
        self.Datum_isBoundedBy_InstanceVariable_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Datum)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Datum.subclass:
            return Datum.subclass(*args_, **kwargs_)
        else:
            return Datum(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_Datum_uses_Notation(self):
        return self.Datum_uses_Notation
    def set_Datum_uses_Notation(self, Datum_uses_Notation):
        self.Datum_uses_Notation = Datum_uses_Notation
    def get_Datum_denotes_ConceptualValue(self):
        return self.Datum_denotes_ConceptualValue
    def set_Datum_denotes_ConceptualValue(self, Datum_denotes_ConceptualValue):
        self.Datum_denotes_ConceptualValue = Datum_denotes_ConceptualValue
    def get_Datum_uses_InstanceValue(self):
        return self.Datum_uses_InstanceValue
    def set_Datum_uses_InstanceValue(self, Datum_uses_InstanceValue):
        self.Datum_uses_InstanceValue = Datum_uses_InstanceValue
    def add_Datum_uses_InstanceValue(self, value):
        self.Datum_uses_InstanceValue.append(value)
    def insert_Datum_uses_InstanceValue_at(self, index, value):
        self.Datum_uses_InstanceValue.insert(index, value)
    def replace_Datum_uses_InstanceValue_at(self, index, value):
        self.Datum_uses_InstanceValue[index] = value
    def get_Datum_isBoundedBy_InstanceVariable(self):
        return self.Datum_isBoundedBy_InstanceVariable
    def set_Datum_isBoundedBy_InstanceVariable(self, Datum_isBoundedBy_InstanceVariable):
        self.Datum_isBoundedBy_InstanceVariable = Datum_isBoundedBy_InstanceVariable
    def add_Datum_isBoundedBy_InstanceVariable(self, value):
        self.Datum_isBoundedBy_InstanceVariable.append(value)
    def insert_Datum_isBoundedBy_InstanceVariable_at(self, index, value):
        self.Datum_isBoundedBy_InstanceVariable.insert(index, value)
    def replace_Datum_isBoundedBy_InstanceVariable_at(self, index, value):
        self.Datum_isBoundedBy_InstanceVariable[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.identifier is not None or
            self.Datum_uses_Notation is not None or
            self.Datum_denotes_ConceptualValue is not None or
            self.Datum_uses_InstanceValue or
            self.Datum_isBoundedBy_InstanceVariable
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Datum', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.Datum_uses_Notation is not None:
            Datum_uses_Notation_ = self.Datum_uses_Notation
            Datum_uses_Notation_.to_etree(element, name_='Datum_uses_Notation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.Datum_denotes_ConceptualValue is not None:
            Datum_denotes_ConceptualValue_ = self.Datum_denotes_ConceptualValue
            Datum_denotes_ConceptualValue_.to_etree(element, name_='Datum_denotes_ConceptualValue', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Datum_uses_InstanceValue_ in self.Datum_uses_InstanceValue:
            Datum_uses_InstanceValue_.to_etree(element, name_='Datum_uses_InstanceValue', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Datum_isBoundedBy_InstanceVariable_ in self.Datum_isBoundedBy_InstanceVariable:
            Datum_isBoundedBy_InstanceVariable_.to_etree(element, name_='Datum_isBoundedBy_InstanceVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'Datum_uses_Notation':
            obj_ = Datum_uses_NotationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Datum_uses_Notation = obj_
            obj_.original_tagname_ = 'Datum_uses_Notation'
        elif nodeName_ == 'Datum_denotes_ConceptualValue':
            obj_ = Datum_denotes_ConceptualValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Datum_denotes_ConceptualValue = obj_
            obj_.original_tagname_ = 'Datum_denotes_ConceptualValue'
        elif nodeName_ == 'Datum_uses_InstanceValue':
            obj_ = Datum_uses_InstanceValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Datum_uses_InstanceValue.append(obj_)
            obj_.original_tagname_ = 'Datum_uses_InstanceValue'
        elif nodeName_ == 'Datum_isBoundedBy_InstanceVariable':
            obj_ = Datum_isBoundedBy_InstanceVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Datum_isBoundedBy_InstanceVariable.append(obj_)
            obj_.original_tagname_ = 'Datum_isBoundedBy_InstanceVariable'
# end class Datum


class DeterministicImperative(ControlLogic):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ControlLogic
    def __init__(self, description=None, identifier=None, workflow=None, ControlLogic_informs_ProcessingAgent=None, ControlLogic_invokes_Activity=None, ControlLogic_hasSubControlLogic_ControlLogic=None, ControlLogic_has_InformationFlowDefinition=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DeterministicImperative"), self).__init__(description, identifier, workflow, ControlLogic_informs_ProcessingAgent, ControlLogic_invokes_Activity, ControlLogic_hasSubControlLogic_ControlLogic, ControlLogic_has_InformationFlowDefinition, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeterministicImperative)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeterministicImperative.subclass:
            return DeterministicImperative.subclass(*args_, **kwargs_)
        else:
            return DeterministicImperative(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            super(DeterministicImperative, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DeterministicImperative', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(DeterministicImperative, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(DeterministicImperative, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DeterministicImperative, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DeterministicImperative


class DimensionComponent(DataStructureComponent):
    """categoricalAdditivity -- Indicates whether categories at a specific level can be combined to provide the value for their shared parent category. Value is True if categories can be added together (collapsed) to create higher-level categories.
    An example would be age categories. Five-year age categories can be collapsed into 10-year age categories.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataStructureComponent
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, categoricalAdditivity=None, DimensionComponent_isStructuredBy_ValueDomain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DimensionComponent"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable,  **kwargs_)
        self.categoricalAdditivity = categoricalAdditivity
        self.categoricalAdditivity_nsprefix_ = None
        self.DimensionComponent_isStructuredBy_ValueDomain = DimensionComponent_isStructuredBy_ValueDomain
        self.DimensionComponent_isStructuredBy_ValueDomain_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionComponent.subclass:
            return DimensionComponent.subclass(*args_, **kwargs_)
        else:
            return DimensionComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_categoricalAdditivity(self):
        return self.categoricalAdditivity
    def set_categoricalAdditivity(self, categoricalAdditivity):
        self.categoricalAdditivity = categoricalAdditivity
    def get_DimensionComponent_isStructuredBy_ValueDomain(self):
        return self.DimensionComponent_isStructuredBy_ValueDomain
    def set_DimensionComponent_isStructuredBy_ValueDomain(self, DimensionComponent_isStructuredBy_ValueDomain):
        self.DimensionComponent_isStructuredBy_ValueDomain = DimensionComponent_isStructuredBy_ValueDomain
    def has__content(self):
        if (
            self.categoricalAdditivity is not None or
            self.DimensionComponent_isStructuredBy_ValueDomain is not None or
            super(DimensionComponent, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionComponent', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(DimensionComponent, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.categoricalAdditivity is not None:
            categoricalAdditivity_ = self.categoricalAdditivity
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}categoricalAdditivity').text = self.gds_format_boolean(categoricalAdditivity_)
        if self.DimensionComponent_isStructuredBy_ValueDomain is not None:
            DimensionComponent_isStructuredBy_ValueDomain_ = self.DimensionComponent_isStructuredBy_ValueDomain
            DimensionComponent_isStructuredBy_ValueDomain_.to_etree(element, name_='DimensionComponent_isStructuredBy_ValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DimensionComponent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'categoricalAdditivity':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'categoricalAdditivity')
            ival_ = self.gds_validate_boolean(ival_, node, 'categoricalAdditivity')
            self.categoricalAdditivity = ival_
            self.categoricalAdditivity_nsprefix_ = child_.prefix
        elif nodeName_ == 'DimensionComponent_isStructuredBy_ValueDomain':
            obj_ = DimensionComponent_isStructuredBy_ValueDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionComponent_isStructuredBy_ValueDomain = obj_
            obj_.original_tagname_ = 'DimensionComponent_isStructuredBy_ValueDomain'
        super(DimensionComponent, self)._buildChildren(child_, node, nodeName_, True)
# end class DimensionComponent


class DimensionGroup(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, name=None, DimensionGroup_has_DimensionComponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        if DimensionGroup_has_DimensionComponent is None:
            self.DimensionGroup_has_DimensionComponent = []
        else:
            self.DimensionGroup_has_DimensionComponent = DimensionGroup_has_DimensionComponent
        self.DimensionGroup_has_DimensionComponent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionGroup.subclass:
            return DimensionGroup.subclass(*args_, **kwargs_)
        else:
            return DimensionGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_DimensionGroup_has_DimensionComponent(self):
        return self.DimensionGroup_has_DimensionComponent
    def set_DimensionGroup_has_DimensionComponent(self, DimensionGroup_has_DimensionComponent):
        self.DimensionGroup_has_DimensionComponent = DimensionGroup_has_DimensionComponent
    def add_DimensionGroup_has_DimensionComponent(self, value):
        self.DimensionGroup_has_DimensionComponent.append(value)
    def insert_DimensionGroup_has_DimensionComponent_at(self, index, value):
        self.DimensionGroup_has_DimensionComponent.insert(index, value)
    def replace_DimensionGroup_has_DimensionComponent_at(self, index, value):
        self.DimensionGroup_has_DimensionComponent[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.name or
            self.DimensionGroup_has_DimensionComponent
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionGroup', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionGroup_has_DimensionComponent_ in self.DimensionGroup_has_DimensionComponent:
            DimensionGroup_has_DimensionComponent_.to_etree(element, name_='DimensionGroup_has_DimensionComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'DimensionGroup_has_DimensionComponent':
            obj_ = DimensionGroup_has_DimensionComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionGroup_has_DimensionComponent.append(obj_)
            obj_.original_tagname_ = 'DimensionGroup_has_DimensionComponent'
# end class DimensionGroup


class DimensionalDataSet(DataSet):
    """name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataSet
    def __init__(self, catalogDetails=None, identifier=None, DataSet_isStructuredBy_DataStructure=None, DataSet_has_DataPoint=None, DataSet_has_Key=None, name=None, DimensionalDataSet_represents_ScopedMeasure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DimensionalDataSet"), self).__init__(catalogDetails, identifier, DataSet_isStructuredBy_DataStructure, DataSet_has_DataPoint, DataSet_has_Key,  **kwargs_)
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        if DimensionalDataSet_represents_ScopedMeasure is None:
            self.DimensionalDataSet_represents_ScopedMeasure = []
        else:
            self.DimensionalDataSet_represents_ScopedMeasure = DimensionalDataSet_represents_ScopedMeasure
        self.DimensionalDataSet_represents_ScopedMeasure_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionalDataSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionalDataSet.subclass:
            return DimensionalDataSet.subclass(*args_, **kwargs_)
        else:
            return DimensionalDataSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_DimensionalDataSet_represents_ScopedMeasure(self):
        return self.DimensionalDataSet_represents_ScopedMeasure
    def set_DimensionalDataSet_represents_ScopedMeasure(self, DimensionalDataSet_represents_ScopedMeasure):
        self.DimensionalDataSet_represents_ScopedMeasure = DimensionalDataSet_represents_ScopedMeasure
    def add_DimensionalDataSet_represents_ScopedMeasure(self, value):
        self.DimensionalDataSet_represents_ScopedMeasure.append(value)
    def insert_DimensionalDataSet_represents_ScopedMeasure_at(self, index, value):
        self.DimensionalDataSet_represents_ScopedMeasure.insert(index, value)
    def replace_DimensionalDataSet_represents_ScopedMeasure_at(self, index, value):
        self.DimensionalDataSet_represents_ScopedMeasure[index] = value
    def has__content(self):
        if (
            self.name or
            self.DimensionalDataSet_represents_ScopedMeasure or
            super(DimensionalDataSet, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionalDataSet', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(DimensionalDataSet, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DimensionalDataSet_represents_ScopedMeasure_ in self.DimensionalDataSet_represents_ScopedMeasure:
            DimensionalDataSet_represents_ScopedMeasure_.to_etree(element, name_='DimensionalDataSet_represents_ScopedMeasure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DimensionalDataSet, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'DimensionalDataSet_represents_ScopedMeasure':
            obj_ = DimensionalDataSet_represents_ScopedMeasureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalDataSet_represents_ScopedMeasure.append(obj_)
            obj_.original_tagname_ = 'DimensionalDataSet_represents_ScopedMeasure'
        super(DimensionalDataSet, self)._buildChildren(child_, node, nodeName_, True)
# end class DimensionalDataSet


class DimensionalKeyDefinitionMember(ConceptualValue):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ConceptualValue
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, externalDefinition=None, identifier=None, name=None, Concept_uses_Concept=None, ConceptualValue_hasConceptFrom_ConceptualDomain=None, DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DimensionalKeyDefinitionMember"), self).__init__(catalogDetails, definition, displayLabel, externalDefinition, identifier, name, Concept_uses_Concept, ConceptualValue_hasConceptFrom_ConceptualDomain,  **kwargs_)
        if DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember is None:
            self.DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember = []
        else:
            self.DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember = DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember
        self.DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionalKeyDefinitionMember)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionalKeyDefinitionMember.subclass:
            return DimensionalKeyDefinitionMember.subclass(*args_, **kwargs_)
        else:
            return DimensionalKeyDefinitionMember(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember(self):
        return self.DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember
    def set_DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember(self, DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember):
        self.DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember = DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember
    def add_DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember(self, value):
        self.DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember.append(value)
    def insert_DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_at(self, index, value):
        self.DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember.insert(index, value)
    def replace_DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_at(self, index, value):
        self.DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember[index] = value
    def has__content(self):
        if (
            self.DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember or
            super(DimensionalKeyDefinitionMember, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionalKeyDefinitionMember', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(DimensionalKeyDefinitionMember, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        for DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_ in self.DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember:
            DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember_.to_etree(element, name_='DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DimensionalKeyDefinitionMember, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember':
            obj_ = DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMemberType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember.append(obj_)
            obj_.original_tagname_ = 'DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMember'
        super(DimensionalKeyDefinitionMember, self)._buildChildren(child_, node, nodeName_, True)
# end class DimensionalKeyDefinitionMember


class EnumerationDomain(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    EnumerationDomain_uses_LevelStructure -- Has meaningful level to which members belong.
    EnumerationDomain_references_CategorySet -- Category set associated with the enumeration.
    EnumerationDomain_isDefinedBy_Concept -- The conceptual basis for the collection of members.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, name=None, purpose=None, EnumerationDomain_uses_LevelStructure=None, EnumerationDomain_references_CategorySet=None, EnumerationDomain_isDefinedBy_Concept=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.EnumerationDomain_uses_LevelStructure = EnumerationDomain_uses_LevelStructure
        self.EnumerationDomain_uses_LevelStructure_nsprefix_ = None
        self.EnumerationDomain_references_CategorySet = EnumerationDomain_references_CategorySet
        self.EnumerationDomain_references_CategorySet_nsprefix_ = None
        if EnumerationDomain_isDefinedBy_Concept is None:
            self.EnumerationDomain_isDefinedBy_Concept = []
        else:
            self.EnumerationDomain_isDefinedBy_Concept = EnumerationDomain_isDefinedBy_Concept
        self.EnumerationDomain_isDefinedBy_Concept_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnumerationDomain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnumerationDomain.subclass:
            return EnumerationDomain.subclass(*args_, **kwargs_)
        else:
            return EnumerationDomain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_EnumerationDomain_uses_LevelStructure(self):
        return self.EnumerationDomain_uses_LevelStructure
    def set_EnumerationDomain_uses_LevelStructure(self, EnumerationDomain_uses_LevelStructure):
        self.EnumerationDomain_uses_LevelStructure = EnumerationDomain_uses_LevelStructure
    def get_EnumerationDomain_references_CategorySet(self):
        return self.EnumerationDomain_references_CategorySet
    def set_EnumerationDomain_references_CategorySet(self, EnumerationDomain_references_CategorySet):
        self.EnumerationDomain_references_CategorySet = EnumerationDomain_references_CategorySet
    def get_EnumerationDomain_isDefinedBy_Concept(self):
        return self.EnumerationDomain_isDefinedBy_Concept
    def set_EnumerationDomain_isDefinedBy_Concept(self, EnumerationDomain_isDefinedBy_Concept):
        self.EnumerationDomain_isDefinedBy_Concept = EnumerationDomain_isDefinedBy_Concept
    def add_EnumerationDomain_isDefinedBy_Concept(self, value):
        self.EnumerationDomain_isDefinedBy_Concept.append(value)
    def insert_EnumerationDomain_isDefinedBy_Concept_at(self, index, value):
        self.EnumerationDomain_isDefinedBy_Concept.insert(index, value)
    def replace_EnumerationDomain_isDefinedBy_Concept_at(self, index, value):
        self.EnumerationDomain_isDefinedBy_Concept[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.EnumerationDomain_uses_LevelStructure is not None or
            self.EnumerationDomain_references_CategorySet is not None or
            self.EnumerationDomain_isDefinedBy_Concept
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='EnumerationDomain', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.EnumerationDomain_uses_LevelStructure is not None:
            EnumerationDomain_uses_LevelStructure_ = self.EnumerationDomain_uses_LevelStructure
            EnumerationDomain_uses_LevelStructure_.to_etree(element, name_='EnumerationDomain_uses_LevelStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.EnumerationDomain_references_CategorySet is not None:
            EnumerationDomain_references_CategorySet_ = self.EnumerationDomain_references_CategorySet
            EnumerationDomain_references_CategorySet_.to_etree(element, name_='EnumerationDomain_references_CategorySet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for EnumerationDomain_isDefinedBy_Concept_ in self.EnumerationDomain_isDefinedBy_Concept:
            EnumerationDomain_isDefinedBy_Concept_.to_etree(element, name_='EnumerationDomain_isDefinedBy_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'EnumerationDomain_uses_LevelStructure':
            obj_ = EnumerationDomain_uses_LevelStructureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnumerationDomain_uses_LevelStructure = obj_
            obj_.original_tagname_ = 'EnumerationDomain_uses_LevelStructure'
        elif nodeName_ == 'EnumerationDomain_references_CategorySet':
            obj_ = EnumerationDomain_references_CategorySetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnumerationDomain_references_CategorySet = obj_
            obj_.original_tagname_ = 'EnumerationDomain_references_CategorySet'
        elif nodeName_ == 'EnumerationDomain_isDefinedBy_Concept':
            obj_ = EnumerationDomain_isDefinedBy_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnumerationDomain_isDefinedBy_Concept.append(obj_)
            obj_.original_tagname_ = 'EnumerationDomain_isDefinedBy_Concept'
# end class EnumerationDomain


class ForeignKey(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, ForeignKey_isComposedOf_ForeignKeyComponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if ForeignKey_isComposedOf_ForeignKeyComponent is None:
            self.ForeignKey_isComposedOf_ForeignKeyComponent = []
        else:
            self.ForeignKey_isComposedOf_ForeignKeyComponent = ForeignKey_isComposedOf_ForeignKeyComponent
        self.ForeignKey_isComposedOf_ForeignKeyComponent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForeignKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForeignKey.subclass:
            return ForeignKey.subclass(*args_, **kwargs_)
        else:
            return ForeignKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_ForeignKey_isComposedOf_ForeignKeyComponent(self):
        return self.ForeignKey_isComposedOf_ForeignKeyComponent
    def set_ForeignKey_isComposedOf_ForeignKeyComponent(self, ForeignKey_isComposedOf_ForeignKeyComponent):
        self.ForeignKey_isComposedOf_ForeignKeyComponent = ForeignKey_isComposedOf_ForeignKeyComponent
    def add_ForeignKey_isComposedOf_ForeignKeyComponent(self, value):
        self.ForeignKey_isComposedOf_ForeignKeyComponent.append(value)
    def insert_ForeignKey_isComposedOf_ForeignKeyComponent_at(self, index, value):
        self.ForeignKey_isComposedOf_ForeignKeyComponent.insert(index, value)
    def replace_ForeignKey_isComposedOf_ForeignKeyComponent_at(self, index, value):
        self.ForeignKey_isComposedOf_ForeignKeyComponent[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.ForeignKey_isComposedOf_ForeignKeyComponent
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ForeignKey', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ForeignKey_isComposedOf_ForeignKeyComponent_ in self.ForeignKey_isComposedOf_ForeignKeyComponent:
            ForeignKey_isComposedOf_ForeignKeyComponent_.to_etree(element, name_='ForeignKey_isComposedOf_ForeignKeyComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'ForeignKey_isComposedOf_ForeignKeyComponent':
            obj_ = ForeignKey_isComposedOf_ForeignKeyComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ForeignKey_isComposedOf_ForeignKeyComponent.append(obj_)
            obj_.original_tagname_ = 'ForeignKey_isComposedOf_ForeignKeyComponent'
# end class ForeignKey


class ForeignKeyComponent(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, ForeignKeyComponent_references_PrimaryKeyComponent=None, ForeignKeyComponent_correspondsTo_DataStructureComponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.ForeignKeyComponent_references_PrimaryKeyComponent = ForeignKeyComponent_references_PrimaryKeyComponent
        self.ForeignKeyComponent_references_PrimaryKeyComponent_nsprefix_ = None
        self.ForeignKeyComponent_correspondsTo_DataStructureComponent = ForeignKeyComponent_correspondsTo_DataStructureComponent
        self.ForeignKeyComponent_correspondsTo_DataStructureComponent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForeignKeyComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForeignKeyComponent.subclass:
            return ForeignKeyComponent.subclass(*args_, **kwargs_)
        else:
            return ForeignKeyComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_ForeignKeyComponent_references_PrimaryKeyComponent(self):
        return self.ForeignKeyComponent_references_PrimaryKeyComponent
    def set_ForeignKeyComponent_references_PrimaryKeyComponent(self, ForeignKeyComponent_references_PrimaryKeyComponent):
        self.ForeignKeyComponent_references_PrimaryKeyComponent = ForeignKeyComponent_references_PrimaryKeyComponent
    def get_ForeignKeyComponent_correspondsTo_DataStructureComponent(self):
        return self.ForeignKeyComponent_correspondsTo_DataStructureComponent
    def set_ForeignKeyComponent_correspondsTo_DataStructureComponent(self, ForeignKeyComponent_correspondsTo_DataStructureComponent):
        self.ForeignKeyComponent_correspondsTo_DataStructureComponent = ForeignKeyComponent_correspondsTo_DataStructureComponent
    def has__content(self):
        if (
            self.identifier is not None or
            self.ForeignKeyComponent_references_PrimaryKeyComponent is not None or
            self.ForeignKeyComponent_correspondsTo_DataStructureComponent is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ForeignKeyComponent', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ForeignKeyComponent_references_PrimaryKeyComponent is not None:
            ForeignKeyComponent_references_PrimaryKeyComponent_ = self.ForeignKeyComponent_references_PrimaryKeyComponent
            ForeignKeyComponent_references_PrimaryKeyComponent_.to_etree(element, name_='ForeignKeyComponent_references_PrimaryKeyComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ForeignKeyComponent_correspondsTo_DataStructureComponent is not None:
            ForeignKeyComponent_correspondsTo_DataStructureComponent_ = self.ForeignKeyComponent_correspondsTo_DataStructureComponent
            ForeignKeyComponent_correspondsTo_DataStructureComponent_.to_etree(element, name_='ForeignKeyComponent_correspondsTo_DataStructureComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'ForeignKeyComponent_references_PrimaryKeyComponent':
            obj_ = ForeignKeyComponent_references_PrimaryKeyComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ForeignKeyComponent_references_PrimaryKeyComponent = obj_
            obj_.original_tagname_ = 'ForeignKeyComponent_references_PrimaryKeyComponent'
        elif nodeName_ == 'ForeignKeyComponent_correspondsTo_DataStructureComponent':
            obj_ = ForeignKeyComponent_correspondsTo_DataStructureComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ForeignKeyComponent_correspondsTo_DataStructureComponent = obj_
            obj_.original_tagname_ = 'ForeignKeyComponent_correspondsTo_DataStructureComponent'
# end class ForeignKeyComponent


class IdentifierComponent(DataStructureComponent):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataStructureComponent
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IdentifierComponent"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifierComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifierComponent.subclass:
            return IdentifierComponent.subclass(*args_, **kwargs_)
        else:
            return IdentifierComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(IdentifierComponent, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='IdentifierComponent', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(IdentifierComponent, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IdentifierComponent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IdentifierComponent, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifierComponent


class Individual(Agent):
    """contactInformation -- Contact information for the individual including location specification, address, URL, phone numbers, and other means of communication access. Sets of information can be repeated and date-stamped.
    individualName -- Name of an individual broken out into its component parts of prefix, first/given name, middle name, last/family/surname, and suffix.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Agent
    def __init__(self, catalogDetails=None, identifier=None, image=None, purpose=None, contactInformation=None, individualName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Individual"), self).__init__(catalogDetails, identifier, image, purpose,  **kwargs_)
        self.contactInformation = contactInformation
        self.contactInformation_nsprefix_ = None
        if individualName is None:
            self.individualName = []
        else:
            self.individualName = individualName
        self.individualName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Individual)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Individual.subclass:
            return Individual.subclass(*args_, **kwargs_)
        else:
            return Individual(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_contactInformation(self):
        return self.contactInformation
    def set_contactInformation(self, contactInformation):
        self.contactInformation = contactInformation
    def get_individualName(self):
        return self.individualName
    def set_individualName(self, individualName):
        self.individualName = individualName
    def add_individualName(self, value):
        self.individualName.append(value)
    def insert_individualName_at(self, index, value):
        self.individualName.insert(index, value)
    def replace_individualName_at(self, index, value):
        self.individualName[index] = value
    def has__content(self):
        if (
            self.contactInformation is not None or
            self.individualName or
            super(Individual, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Individual', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(Individual, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.contactInformation is not None:
            contactInformation_ = self.contactInformation
            contactInformation_.to_etree(element, name_='contactInformation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for individualName_ in self.individualName:
            individualName_.to_etree(element, name_='individualName', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Individual, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contactInformation':
            obj_ = ContactInformation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contactInformation = obj_
            obj_.original_tagname_ = 'contactInformation'
        elif nodeName_ == 'individualName':
            obj_ = IndividualName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.individualName.append(obj_)
            obj_.original_tagname_ = 'individualName'
        super(Individual, self)._buildChildren(child_, node, nodeName_, True)
# end class Individual


class InformationFlowDefinition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    InformationFlowDefinition_from_Parameter -- From parameters are the outputs from a control construct produced in its step/sub-step.
    InformationFlowDefinition_to_Parameter -- To parameters are the inputs to a control construct used in its step/sub-step.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, InformationFlowDefinition_from_Parameter=None, InformationFlowDefinition_to_Parameter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.InformationFlowDefinition_from_Parameter = InformationFlowDefinition_from_Parameter
        self.InformationFlowDefinition_from_Parameter_nsprefix_ = None
        if InformationFlowDefinition_to_Parameter is None:
            self.InformationFlowDefinition_to_Parameter = []
        else:
            self.InformationFlowDefinition_to_Parameter = InformationFlowDefinition_to_Parameter
        self.InformationFlowDefinition_to_Parameter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformationFlowDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformationFlowDefinition.subclass:
            return InformationFlowDefinition.subclass(*args_, **kwargs_)
        else:
            return InformationFlowDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_InformationFlowDefinition_from_Parameter(self):
        return self.InformationFlowDefinition_from_Parameter
    def set_InformationFlowDefinition_from_Parameter(self, InformationFlowDefinition_from_Parameter):
        self.InformationFlowDefinition_from_Parameter = InformationFlowDefinition_from_Parameter
    def get_InformationFlowDefinition_to_Parameter(self):
        return self.InformationFlowDefinition_to_Parameter
    def set_InformationFlowDefinition_to_Parameter(self, InformationFlowDefinition_to_Parameter):
        self.InformationFlowDefinition_to_Parameter = InformationFlowDefinition_to_Parameter
    def add_InformationFlowDefinition_to_Parameter(self, value):
        self.InformationFlowDefinition_to_Parameter.append(value)
    def insert_InformationFlowDefinition_to_Parameter_at(self, index, value):
        self.InformationFlowDefinition_to_Parameter.insert(index, value)
    def replace_InformationFlowDefinition_to_Parameter_at(self, index, value):
        self.InformationFlowDefinition_to_Parameter[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.InformationFlowDefinition_from_Parameter is not None or
            self.InformationFlowDefinition_to_Parameter
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InformationFlowDefinition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.InformationFlowDefinition_from_Parameter is not None:
            InformationFlowDefinition_from_Parameter_ = self.InformationFlowDefinition_from_Parameter
            InformationFlowDefinition_from_Parameter_.to_etree(element, name_='InformationFlowDefinition_from_Parameter', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for InformationFlowDefinition_to_Parameter_ in self.InformationFlowDefinition_to_Parameter:
            InformationFlowDefinition_to_Parameter_.to_etree(element, name_='InformationFlowDefinition_to_Parameter', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'InformationFlowDefinition_from_Parameter':
            obj_ = InformationFlowDefinition_from_ParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InformationFlowDefinition_from_Parameter = obj_
            obj_.original_tagname_ = 'InformationFlowDefinition_from_Parameter'
        elif nodeName_ == 'InformationFlowDefinition_to_Parameter':
            obj_ = InformationFlowDefinition_to_ParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InformationFlowDefinition_to_Parameter.append(obj_)
            obj_.original_tagname_ = 'InformationFlowDefinition_to_Parameter'
# end class InformationFlowDefinition


class InstanceValue(GeneratedsSuper):
    """content -- The content of this value expressed as a string.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    whiteSpace -- The usual setting "collapse" states that leading and trailing white space will be removed and multiple adjacent white spaces will be treated as a single white space. When setting to "replace" all occurrences of #x9 (tab), #xA (line feed) and #xD (carriage return) are replaced with #x20 (space) but leading and trailing spaces will be retained. If the existence of any of these white spaces is critical to the understanding of the content, change the value of this attribute to "preserve".
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, content=None, identifier=None, whiteSpace=None, InstanceValue_hasValueFrom_ValueDomain=None, InstanceValue_isStoredIn_DataPoint=None, InstanceValue_represents_ConceptualValue=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.content = content
        self.content_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.whiteSpace = whiteSpace
        self.validate_WhiteSpaceRule(self.whiteSpace)
        self.whiteSpace_nsprefix_ = None
        self.InstanceValue_hasValueFrom_ValueDomain = InstanceValue_hasValueFrom_ValueDomain
        self.InstanceValue_hasValueFrom_ValueDomain_nsprefix_ = None
        self.InstanceValue_isStoredIn_DataPoint = InstanceValue_isStoredIn_DataPoint
        self.InstanceValue_isStoredIn_DataPoint_nsprefix_ = None
        self.InstanceValue_represents_ConceptualValue = InstanceValue_represents_ConceptualValue
        self.InstanceValue_represents_ConceptualValue_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceValue.subclass:
            return InstanceValue.subclass(*args_, **kwargs_)
        else:
            return InstanceValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_whiteSpace(self):
        return self.whiteSpace
    def set_whiteSpace(self, whiteSpace):
        self.whiteSpace = whiteSpace
    def get_InstanceValue_hasValueFrom_ValueDomain(self):
        return self.InstanceValue_hasValueFrom_ValueDomain
    def set_InstanceValue_hasValueFrom_ValueDomain(self, InstanceValue_hasValueFrom_ValueDomain):
        self.InstanceValue_hasValueFrom_ValueDomain = InstanceValue_hasValueFrom_ValueDomain
    def get_InstanceValue_isStoredIn_DataPoint(self):
        return self.InstanceValue_isStoredIn_DataPoint
    def set_InstanceValue_isStoredIn_DataPoint(self, InstanceValue_isStoredIn_DataPoint):
        self.InstanceValue_isStoredIn_DataPoint = InstanceValue_isStoredIn_DataPoint
    def get_InstanceValue_represents_ConceptualValue(self):
        return self.InstanceValue_represents_ConceptualValue
    def set_InstanceValue_represents_ConceptualValue(self, InstanceValue_represents_ConceptualValue):
        self.InstanceValue_represents_ConceptualValue = InstanceValue_represents_ConceptualValue
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_WhiteSpaceRule(self, value):
        result = True
        # Validate type WhiteSpaceRule, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Collapse', 'Preserve', 'Replace']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on WhiteSpaceRule' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.content is not None or
            self.identifier is not None or
            self.whiteSpace is not None or
            self.InstanceValue_hasValueFrom_ValueDomain is not None or
            self.InstanceValue_isStoredIn_DataPoint is not None or
            self.InstanceValue_represents_ConceptualValue is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InstanceValue', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.content is not None:
            content_ = self.content
            content_.to_etree(element, name_='content', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.whiteSpace is not None:
            whiteSpace_ = self.whiteSpace
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}whiteSpace').text = self.gds_format_string(whiteSpace_)
        if self.InstanceValue_hasValueFrom_ValueDomain is not None:
            InstanceValue_hasValueFrom_ValueDomain_ = self.InstanceValue_hasValueFrom_ValueDomain
            InstanceValue_hasValueFrom_ValueDomain_.to_etree(element, name_='InstanceValue_hasValueFrom_ValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.InstanceValue_isStoredIn_DataPoint is not None:
            InstanceValue_isStoredIn_DataPoint_ = self.InstanceValue_isStoredIn_DataPoint
            InstanceValue_isStoredIn_DataPoint_.to_etree(element, name_='InstanceValue_isStoredIn_DataPoint', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.InstanceValue_represents_ConceptualValue is not None:
            InstanceValue_represents_ConceptualValue_ = self.InstanceValue_represents_ConceptualValue
            InstanceValue_represents_ConceptualValue_.to_etree(element, name_='InstanceValue_represents_ConceptualValue', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = TypedString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.content = obj_
            obj_.original_tagname_ = 'content'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'whiteSpace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'whiteSpace')
            value_ = self.gds_validate_string(value_, node, 'whiteSpace')
            self.whiteSpace = value_
            self.whiteSpace_nsprefix_ = child_.prefix
            # validate type WhiteSpaceRule
            self.validate_WhiteSpaceRule(self.whiteSpace)
        elif nodeName_ == 'InstanceValue_hasValueFrom_ValueDomain':
            obj_ = InstanceValue_hasValueFrom_ValueDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceValue_hasValueFrom_ValueDomain = obj_
            obj_.original_tagname_ = 'InstanceValue_hasValueFrom_ValueDomain'
        elif nodeName_ == 'InstanceValue_isStoredIn_DataPoint':
            obj_ = InstanceValue_isStoredIn_DataPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceValue_isStoredIn_DataPoint = obj_
            obj_.original_tagname_ = 'InstanceValue_isStoredIn_DataPoint'
        elif nodeName_ == 'InstanceValue_represents_ConceptualValue':
            obj_ = InstanceValue_represents_ConceptualValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceValue_represents_ConceptualValue = obj_
            obj_.original_tagname_ = 'InstanceValue_represents_ConceptualValue'
# end class InstanceValue


class InstanceVariableMap(GeneratedsSuper):
    """comparison -- Relationship between the source and target instance variables or to the setValue if provided.
    correspondence -- Describes the relationship between the source and target members using both controlled vocabularies and descriptive text. In this context the correspondence refers to the two instance variables, not their value. The relationship would normally be ExactMatch.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    setValue -- A fixed value for the key source Instance Variables.
    InstanceVariableMap_hasTarget_InstanceVariable -- Target instance variables if a directional relation is used.
    InstanceVariableMap_hasSource_InstanceVariable -- The source instance variable for the relationship.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, comparison=None, correspondence=None, identifier=None, setValue=None, InstanceVariableMap_hasTarget_InstanceVariable=None, InstanceVariableMap_hasSource_InstanceVariable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.comparison = comparison
        self.validate_ComparisonOperator(self.comparison)
        self.comparison_nsprefix_ = None
        self.correspondence = correspondence
        self.correspondence_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.setValue = setValue
        self.setValue_nsprefix_ = None
        if InstanceVariableMap_hasTarget_InstanceVariable is None:
            self.InstanceVariableMap_hasTarget_InstanceVariable = []
        else:
            self.InstanceVariableMap_hasTarget_InstanceVariable = InstanceVariableMap_hasTarget_InstanceVariable
        self.InstanceVariableMap_hasTarget_InstanceVariable_nsprefix_ = None
        if InstanceVariableMap_hasSource_InstanceVariable is None:
            self.InstanceVariableMap_hasSource_InstanceVariable = []
        else:
            self.InstanceVariableMap_hasSource_InstanceVariable = InstanceVariableMap_hasSource_InstanceVariable
        self.InstanceVariableMap_hasSource_InstanceVariable_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceVariableMap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceVariableMap.subclass:
            return InstanceVariableMap.subclass(*args_, **kwargs_)
        else:
            return InstanceVariableMap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_comparison(self):
        return self.comparison
    def set_comparison(self, comparison):
        self.comparison = comparison
    def get_correspondence(self):
        return self.correspondence
    def set_correspondence(self, correspondence):
        self.correspondence = correspondence
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_setValue(self):
        return self.setValue
    def set_setValue(self, setValue):
        self.setValue = setValue
    def get_InstanceVariableMap_hasTarget_InstanceVariable(self):
        return self.InstanceVariableMap_hasTarget_InstanceVariable
    def set_InstanceVariableMap_hasTarget_InstanceVariable(self, InstanceVariableMap_hasTarget_InstanceVariable):
        self.InstanceVariableMap_hasTarget_InstanceVariable = InstanceVariableMap_hasTarget_InstanceVariable
    def add_InstanceVariableMap_hasTarget_InstanceVariable(self, value):
        self.InstanceVariableMap_hasTarget_InstanceVariable.append(value)
    def insert_InstanceVariableMap_hasTarget_InstanceVariable_at(self, index, value):
        self.InstanceVariableMap_hasTarget_InstanceVariable.insert(index, value)
    def replace_InstanceVariableMap_hasTarget_InstanceVariable_at(self, index, value):
        self.InstanceVariableMap_hasTarget_InstanceVariable[index] = value
    def get_InstanceVariableMap_hasSource_InstanceVariable(self):
        return self.InstanceVariableMap_hasSource_InstanceVariable
    def set_InstanceVariableMap_hasSource_InstanceVariable(self, InstanceVariableMap_hasSource_InstanceVariable):
        self.InstanceVariableMap_hasSource_InstanceVariable = InstanceVariableMap_hasSource_InstanceVariable
    def add_InstanceVariableMap_hasSource_InstanceVariable(self, value):
        self.InstanceVariableMap_hasSource_InstanceVariable.append(value)
    def insert_InstanceVariableMap_hasSource_InstanceVariable_at(self, index, value):
        self.InstanceVariableMap_hasSource_InstanceVariable.insert(index, value)
    def replace_InstanceVariableMap_hasSource_InstanceVariable_at(self, index, value):
        self.InstanceVariableMap_hasSource_InstanceVariable[index] = value
    def validate_ComparisonOperator(self, value):
        result = True
        # Validate type ComparisonOperator, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Equal', 'GreaterThan', 'GreaterThanOrEqualTo', 'LessThan', 'LessThanOrEqualTo', 'NotEqual']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ComparisonOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.comparison is not None or
            self.correspondence is not None or
            self.identifier is not None or
            self.setValue is not None or
            self.InstanceVariableMap_hasTarget_InstanceVariable or
            self.InstanceVariableMap_hasSource_InstanceVariable
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InstanceVariableMap', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.comparison is not None:
            comparison_ = self.comparison
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}comparison').text = self.gds_format_string(comparison_)
        if self.correspondence is not None:
            correspondence_ = self.correspondence
            correspondence_.to_etree(element, name_='correspondence', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.setValue is not None:
            setValue_ = self.setValue
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}setValue').text = self.gds_format_string(setValue_)
        for InstanceVariableMap_hasTarget_InstanceVariable_ in self.InstanceVariableMap_hasTarget_InstanceVariable:
            InstanceVariableMap_hasTarget_InstanceVariable_.to_etree(element, name_='InstanceVariableMap_hasTarget_InstanceVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for InstanceVariableMap_hasSource_InstanceVariable_ in self.InstanceVariableMap_hasSource_InstanceVariable:
            InstanceVariableMap_hasSource_InstanceVariable_.to_etree(element, name_='InstanceVariableMap_hasSource_InstanceVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'comparison':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'comparison')
            value_ = self.gds_validate_string(value_, node, 'comparison')
            self.comparison = value_
            self.comparison_nsprefix_ = child_.prefix
            # validate type ComparisonOperator
            self.validate_ComparisonOperator(self.comparison)
        elif nodeName_ == 'correspondence':
            obj_ = CorrespondenceDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.correspondence = obj_
            obj_.original_tagname_ = 'correspondence'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'setValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'setValue')
            value_ = self.gds_validate_string(value_, node, 'setValue')
            self.setValue = value_
            self.setValue_nsprefix_ = child_.prefix
        elif nodeName_ == 'InstanceVariableMap_hasTarget_InstanceVariable':
            obj_ = InstanceVariableMap_hasTarget_InstanceVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceVariableMap_hasTarget_InstanceVariable.append(obj_)
            obj_.original_tagname_ = 'InstanceVariableMap_hasTarget_InstanceVariable'
        elif nodeName_ == 'InstanceVariableMap_hasSource_InstanceVariable':
            obj_ = InstanceVariableMap_hasSource_InstanceVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceVariableMap_hasSource_InstanceVariable.append(obj_)
            obj_.original_tagname_ = 'InstanceVariableMap_hasSource_InstanceVariable'
# end class InstanceVariableMap


class Key(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, Key_correspondsTo_Unit=None, Key_represents_KeyDefinition=None, Key_identifies_DataPoint=None, Key_correspondsTo_Universe=None, Key_has_KeyMember=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.Key_correspondsTo_Unit = Key_correspondsTo_Unit
        self.Key_correspondsTo_Unit_nsprefix_ = None
        self.Key_represents_KeyDefinition = Key_represents_KeyDefinition
        self.Key_represents_KeyDefinition_nsprefix_ = None
        if Key_identifies_DataPoint is None:
            self.Key_identifies_DataPoint = []
        else:
            self.Key_identifies_DataPoint = Key_identifies_DataPoint
        self.Key_identifies_DataPoint_nsprefix_ = None
        self.Key_correspondsTo_Universe = Key_correspondsTo_Universe
        self.Key_correspondsTo_Universe_nsprefix_ = None
        if Key_has_KeyMember is None:
            self.Key_has_KeyMember = []
        else:
            self.Key_has_KeyMember = Key_has_KeyMember
        self.Key_has_KeyMember_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Key)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Key.subclass:
            return Key.subclass(*args_, **kwargs_)
        else:
            return Key(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_Key_correspondsTo_Unit(self):
        return self.Key_correspondsTo_Unit
    def set_Key_correspondsTo_Unit(self, Key_correspondsTo_Unit):
        self.Key_correspondsTo_Unit = Key_correspondsTo_Unit
    def get_Key_represents_KeyDefinition(self):
        return self.Key_represents_KeyDefinition
    def set_Key_represents_KeyDefinition(self, Key_represents_KeyDefinition):
        self.Key_represents_KeyDefinition = Key_represents_KeyDefinition
    def get_Key_identifies_DataPoint(self):
        return self.Key_identifies_DataPoint
    def set_Key_identifies_DataPoint(self, Key_identifies_DataPoint):
        self.Key_identifies_DataPoint = Key_identifies_DataPoint
    def add_Key_identifies_DataPoint(self, value):
        self.Key_identifies_DataPoint.append(value)
    def insert_Key_identifies_DataPoint_at(self, index, value):
        self.Key_identifies_DataPoint.insert(index, value)
    def replace_Key_identifies_DataPoint_at(self, index, value):
        self.Key_identifies_DataPoint[index] = value
    def get_Key_correspondsTo_Universe(self):
        return self.Key_correspondsTo_Universe
    def set_Key_correspondsTo_Universe(self, Key_correspondsTo_Universe):
        self.Key_correspondsTo_Universe = Key_correspondsTo_Universe
    def get_Key_has_KeyMember(self):
        return self.Key_has_KeyMember
    def set_Key_has_KeyMember(self, Key_has_KeyMember):
        self.Key_has_KeyMember = Key_has_KeyMember
    def add_Key_has_KeyMember(self, value):
        self.Key_has_KeyMember.append(value)
    def insert_Key_has_KeyMember_at(self, index, value):
        self.Key_has_KeyMember.insert(index, value)
    def replace_Key_has_KeyMember_at(self, index, value):
        self.Key_has_KeyMember[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.identifier is not None or
            self.Key_correspondsTo_Unit is not None or
            self.Key_represents_KeyDefinition is not None or
            self.Key_identifies_DataPoint or
            self.Key_correspondsTo_Universe is not None or
            self.Key_has_KeyMember
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Key', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.Key_correspondsTo_Unit is not None:
            Key_correspondsTo_Unit_ = self.Key_correspondsTo_Unit
            Key_correspondsTo_Unit_.to_etree(element, name_='Key_correspondsTo_Unit', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.Key_represents_KeyDefinition is not None:
            Key_represents_KeyDefinition_ = self.Key_represents_KeyDefinition
            Key_represents_KeyDefinition_.to_etree(element, name_='Key_represents_KeyDefinition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Key_identifies_DataPoint_ in self.Key_identifies_DataPoint:
            Key_identifies_DataPoint_.to_etree(element, name_='Key_identifies_DataPoint', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.Key_correspondsTo_Universe is not None:
            Key_correspondsTo_Universe_ = self.Key_correspondsTo_Universe
            Key_correspondsTo_Universe_.to_etree(element, name_='Key_correspondsTo_Universe', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Key_has_KeyMember_ in self.Key_has_KeyMember:
            Key_has_KeyMember_.to_etree(element, name_='Key_has_KeyMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'Key_correspondsTo_Unit':
            obj_ = Key_correspondsTo_UnitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Key_correspondsTo_Unit = obj_
            obj_.original_tagname_ = 'Key_correspondsTo_Unit'
        elif nodeName_ == 'Key_represents_KeyDefinition':
            obj_ = Key_represents_KeyDefinitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Key_represents_KeyDefinition = obj_
            obj_.original_tagname_ = 'Key_represents_KeyDefinition'
        elif nodeName_ == 'Key_identifies_DataPoint':
            obj_ = Key_identifies_DataPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Key_identifies_DataPoint.append(obj_)
            obj_.original_tagname_ = 'Key_identifies_DataPoint'
        elif nodeName_ == 'Key_correspondsTo_Universe':
            obj_ = Key_correspondsTo_UniverseType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Key_correspondsTo_Universe = obj_
            obj_.original_tagname_ = 'Key_correspondsTo_Universe'
        elif nodeName_ == 'Key_has_KeyMember':
            obj_ = Key_has_KeyMemberType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Key_has_KeyMember.append(obj_)
            obj_.original_tagname_ = 'Key_has_KeyMember'
# end class Key


class KeyDefinition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, KeyDefinition_correspondsTo_Universe=None, KeyDefinition_correspondsTo_Unit=None, KeyDefinition_has_KeyDefinitionMember=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.KeyDefinition_correspondsTo_Universe = KeyDefinition_correspondsTo_Universe
        self.KeyDefinition_correspondsTo_Universe_nsprefix_ = None
        self.KeyDefinition_correspondsTo_Unit = KeyDefinition_correspondsTo_Unit
        self.KeyDefinition_correspondsTo_Unit_nsprefix_ = None
        if KeyDefinition_has_KeyDefinitionMember is None:
            self.KeyDefinition_has_KeyDefinitionMember = []
        else:
            self.KeyDefinition_has_KeyDefinitionMember = KeyDefinition_has_KeyDefinitionMember
        self.KeyDefinition_has_KeyDefinitionMember_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyDefinition.subclass:
            return KeyDefinition.subclass(*args_, **kwargs_)
        else:
            return KeyDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_KeyDefinition_correspondsTo_Universe(self):
        return self.KeyDefinition_correspondsTo_Universe
    def set_KeyDefinition_correspondsTo_Universe(self, KeyDefinition_correspondsTo_Universe):
        self.KeyDefinition_correspondsTo_Universe = KeyDefinition_correspondsTo_Universe
    def get_KeyDefinition_correspondsTo_Unit(self):
        return self.KeyDefinition_correspondsTo_Unit
    def set_KeyDefinition_correspondsTo_Unit(self, KeyDefinition_correspondsTo_Unit):
        self.KeyDefinition_correspondsTo_Unit = KeyDefinition_correspondsTo_Unit
    def get_KeyDefinition_has_KeyDefinitionMember(self):
        return self.KeyDefinition_has_KeyDefinitionMember
    def set_KeyDefinition_has_KeyDefinitionMember(self, KeyDefinition_has_KeyDefinitionMember):
        self.KeyDefinition_has_KeyDefinitionMember = KeyDefinition_has_KeyDefinitionMember
    def add_KeyDefinition_has_KeyDefinitionMember(self, value):
        self.KeyDefinition_has_KeyDefinitionMember.append(value)
    def insert_KeyDefinition_has_KeyDefinitionMember_at(self, index, value):
        self.KeyDefinition_has_KeyDefinitionMember.insert(index, value)
    def replace_KeyDefinition_has_KeyDefinitionMember_at(self, index, value):
        self.KeyDefinition_has_KeyDefinitionMember[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.identifier is not None or
            self.KeyDefinition_correspondsTo_Universe is not None or
            self.KeyDefinition_correspondsTo_Unit is not None or
            self.KeyDefinition_has_KeyDefinitionMember
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='KeyDefinition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.KeyDefinition_correspondsTo_Universe is not None:
            KeyDefinition_correspondsTo_Universe_ = self.KeyDefinition_correspondsTo_Universe
            KeyDefinition_correspondsTo_Universe_.to_etree(element, name_='KeyDefinition_correspondsTo_Universe', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.KeyDefinition_correspondsTo_Unit is not None:
            KeyDefinition_correspondsTo_Unit_ = self.KeyDefinition_correspondsTo_Unit
            KeyDefinition_correspondsTo_Unit_.to_etree(element, name_='KeyDefinition_correspondsTo_Unit', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for KeyDefinition_has_KeyDefinitionMember_ in self.KeyDefinition_has_KeyDefinitionMember:
            KeyDefinition_has_KeyDefinitionMember_.to_etree(element, name_='KeyDefinition_has_KeyDefinitionMember', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'KeyDefinition_correspondsTo_Universe':
            obj_ = KeyDefinition_correspondsTo_UniverseType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyDefinition_correspondsTo_Universe = obj_
            obj_.original_tagname_ = 'KeyDefinition_correspondsTo_Universe'
        elif nodeName_ == 'KeyDefinition_correspondsTo_Unit':
            obj_ = KeyDefinition_correspondsTo_UnitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyDefinition_correspondsTo_Unit = obj_
            obj_.original_tagname_ = 'KeyDefinition_correspondsTo_Unit'
        elif nodeName_ == 'KeyDefinition_has_KeyDefinitionMember':
            obj_ = KeyDefinition_has_KeyDefinitionMemberType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyDefinition_has_KeyDefinitionMember.append(obj_)
            obj_.original_tagname_ = 'KeyDefinition_has_KeyDefinitionMember'
# end class KeyDefinition


class KeyDefinitionMember(ConceptualValue):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ConceptualValue
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, externalDefinition=None, identifier=None, name=None, Concept_uses_Concept=None, ConceptualValue_hasConceptFrom_ConceptualDomain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("KeyDefinitionMember"), self).__init__(catalogDetails, definition, displayLabel, externalDefinition, identifier, name, Concept_uses_Concept, ConceptualValue_hasConceptFrom_ConceptualDomain,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyDefinitionMember)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyDefinitionMember.subclass:
            return KeyDefinitionMember.subclass(*args_, **kwargs_)
        else:
            return KeyDefinitionMember(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(KeyDefinitionMember, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='KeyDefinitionMember', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(KeyDefinitionMember, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(KeyDefinitionMember, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(KeyDefinitionMember, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class KeyDefinitionMember


class KeyMember(InstanceValue):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = InstanceValue
    def __init__(self, content=None, identifier=None, whiteSpace=None, InstanceValue_hasValueFrom_ValueDomain=None, InstanceValue_isStoredIn_DataPoint=None, InstanceValue_represents_ConceptualValue=None, KeyMember_isBasedOn_DataStructureComponent=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("KeyMember"), self).__init__(content, identifier, whiteSpace, InstanceValue_hasValueFrom_ValueDomain, InstanceValue_isStoredIn_DataPoint, InstanceValue_represents_ConceptualValue, extensiontype_,  **kwargs_)
        if KeyMember_isBasedOn_DataStructureComponent is None:
            self.KeyMember_isBasedOn_DataStructureComponent = []
        else:
            self.KeyMember_isBasedOn_DataStructureComponent = KeyMember_isBasedOn_DataStructureComponent
        self.KeyMember_isBasedOn_DataStructureComponent_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyMember)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyMember.subclass:
            return KeyMember.subclass(*args_, **kwargs_)
        else:
            return KeyMember(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_KeyMember_isBasedOn_DataStructureComponent(self):
        return self.KeyMember_isBasedOn_DataStructureComponent
    def set_KeyMember_isBasedOn_DataStructureComponent(self, KeyMember_isBasedOn_DataStructureComponent):
        self.KeyMember_isBasedOn_DataStructureComponent = KeyMember_isBasedOn_DataStructureComponent
    def add_KeyMember_isBasedOn_DataStructureComponent(self, value):
        self.KeyMember_isBasedOn_DataStructureComponent.append(value)
    def insert_KeyMember_isBasedOn_DataStructureComponent_at(self, index, value):
        self.KeyMember_isBasedOn_DataStructureComponent.insert(index, value)
    def replace_KeyMember_isBasedOn_DataStructureComponent_at(self, index, value):
        self.KeyMember_isBasedOn_DataStructureComponent[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.KeyMember_isBasedOn_DataStructureComponent or
            super(KeyMember, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='KeyMember', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(KeyMember, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        for KeyMember_isBasedOn_DataStructureComponent_ in self.KeyMember_isBasedOn_DataStructureComponent:
            KeyMember_isBasedOn_DataStructureComponent_.to_etree(element, name_='KeyMember_isBasedOn_DataStructureComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(KeyMember, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'KeyMember_isBasedOn_DataStructureComponent':
            obj_ = KeyMember_isBasedOn_DataStructureComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyMember_isBasedOn_DataStructureComponent.append(obj_)
            obj_.original_tagname_ = 'KeyMember_isBasedOn_DataStructureComponent'
        super(KeyMember, self)._buildChildren(child_, node, nodeName_, True)
# end class KeyMember


class KeyValueDataStore(DataSet):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataSet
    def __init__(self, catalogDetails=None, identifier=None, DataSet_isStructuredBy_DataStructure=None, DataSet_has_DataPoint=None, DataSet_has_Key=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("KeyValueDataStore"), self).__init__(catalogDetails, identifier, DataSet_isStructuredBy_DataStructure, DataSet_has_DataPoint, DataSet_has_Key,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyValueDataStore)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyValueDataStore.subclass:
            return KeyValueDataStore.subclass(*args_, **kwargs_)
        else:
            return KeyValueDataStore(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(KeyValueDataStore, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='KeyValueDataStore', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(KeyValueDataStore, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(KeyValueDataStore, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(KeyValueDataStore, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class KeyValueDataStore


class Level(GeneratedsSuper):
    """displayLabel -- A human-readable display label for the object. Supports the use of multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    levelNumber -- Provides an association between a level number and optional concept which defines it within an ordered array. Use is required.
    Level_isDefinedBy_Concept -- A concept or concept sub-type which describes the level.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, displayLabel=None, identifier=None, levelNumber=None, Level_isDefinedBy_Concept=None, Level_groups_ClassificationItem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if displayLabel is None:
            self.displayLabel = []
        else:
            self.displayLabel = displayLabel
        self.displayLabel_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.levelNumber = levelNumber
        self.levelNumber_nsprefix_ = None
        self.Level_isDefinedBy_Concept = Level_isDefinedBy_Concept
        self.Level_isDefinedBy_Concept_nsprefix_ = None
        if Level_groups_ClassificationItem is None:
            self.Level_groups_ClassificationItem = []
        else:
            self.Level_groups_ClassificationItem = Level_groups_ClassificationItem
        self.Level_groups_ClassificationItem_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Level)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Level.subclass:
            return Level.subclass(*args_, **kwargs_)
        else:
            return Level(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def add_displayLabel(self, value):
        self.displayLabel.append(value)
    def insert_displayLabel_at(self, index, value):
        self.displayLabel.insert(index, value)
    def replace_displayLabel_at(self, index, value):
        self.displayLabel[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_levelNumber(self):
        return self.levelNumber
    def set_levelNumber(self, levelNumber):
        self.levelNumber = levelNumber
    def get_Level_isDefinedBy_Concept(self):
        return self.Level_isDefinedBy_Concept
    def set_Level_isDefinedBy_Concept(self, Level_isDefinedBy_Concept):
        self.Level_isDefinedBy_Concept = Level_isDefinedBy_Concept
    def get_Level_groups_ClassificationItem(self):
        return self.Level_groups_ClassificationItem
    def set_Level_groups_ClassificationItem(self, Level_groups_ClassificationItem):
        self.Level_groups_ClassificationItem = Level_groups_ClassificationItem
    def add_Level_groups_ClassificationItem(self, value):
        self.Level_groups_ClassificationItem.append(value)
    def insert_Level_groups_ClassificationItem_at(self, index, value):
        self.Level_groups_ClassificationItem.insert(index, value)
    def replace_Level_groups_ClassificationItem_at(self, index, value):
        self.Level_groups_ClassificationItem[index] = value
    def has__content(self):
        if (
            self.displayLabel or
            self.identifier is not None or
            self.levelNumber is not None or
            self.Level_isDefinedBy_Concept is not None or
            self.Level_groups_ClassificationItem
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Level', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        for displayLabel_ in self.displayLabel:
            displayLabel_.to_etree(element, name_='displayLabel', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.levelNumber is not None:
            levelNumber_ = self.levelNumber
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}levelNumber').text = self.gds_format_integer(levelNumber_)
        if self.Level_isDefinedBy_Concept is not None:
            Level_isDefinedBy_Concept_ = self.Level_isDefinedBy_Concept
            Level_isDefinedBy_Concept_.to_etree(element, name_='Level_isDefinedBy_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Level_groups_ClassificationItem_ in self.Level_groups_ClassificationItem:
            Level_groups_ClassificationItem_.to_etree(element, name_='Level_groups_ClassificationItem', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'displayLabel':
            obj_ = LabelForDisplay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayLabel.append(obj_)
            obj_.original_tagname_ = 'displayLabel'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'levelNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'levelNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'levelNumber')
            self.levelNumber = ival_
            self.levelNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'Level_isDefinedBy_Concept':
            obj_ = Level_isDefinedBy_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Level_isDefinedBy_Concept = obj_
            obj_.original_tagname_ = 'Level_isDefinedBy_Concept'
        elif nodeName_ == 'Level_groups_ClassificationItem':
            obj_ = Level_groups_ClassificationItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Level_groups_ClassificationItem.append(obj_)
            obj_.original_tagname_ = 'Level_groups_ClassificationItem'
# end class Level


class LevelStructure(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    usage -- Explanation of the ways in which the object is employed.
    validDateRange -- The period for which the level object is valid, expressed as a start and end date (supports both ISO-standard and non-ISO date formats).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, identifier=None, name=None, usage=None, validDateRange=None, LevelStructure_has_Level=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.usage = usage
        self.usage_nsprefix_ = None
        self.validDateRange = validDateRange
        self.validDateRange_nsprefix_ = None
        if LevelStructure_has_Level is None:
            self.LevelStructure_has_Level = []
        else:
            self.LevelStructure_has_Level = LevelStructure_has_Level
        self.LevelStructure_has_Level_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LevelStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LevelStructure.subclass:
            return LevelStructure.subclass(*args_, **kwargs_)
        else:
            return LevelStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_validDateRange(self):
        return self.validDateRange
    def set_validDateRange(self, validDateRange):
        self.validDateRange = validDateRange
    def get_LevelStructure_has_Level(self):
        return self.LevelStructure_has_Level
    def set_LevelStructure_has_Level(self, LevelStructure_has_Level):
        self.LevelStructure_has_Level = LevelStructure_has_Level
    def add_LevelStructure_has_Level(self, value):
        self.LevelStructure_has_Level.append(value)
    def insert_LevelStructure_has_Level_at(self, index, value):
        self.LevelStructure_has_Level.insert(index, value)
    def replace_LevelStructure_has_Level_at(self, index, value):
        self.LevelStructure_has_Level[index] = value
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.identifier is not None or
            self.name or
            self.usage is not None or
            self.validDateRange is not None or
            self.LevelStructure_has_Level
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LevelStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.usage is not None:
            usage_ = self.usage
            usage_.to_etree(element, name_='usage', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validDateRange is not None:
            validDateRange_ = self.validDateRange
            validDateRange_.to_etree(element, name_='validDateRange', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LevelStructure_has_Level_ in self.LevelStructure_has_Level:
            LevelStructure_has_Level_.to_etree(element, name_='LevelStructure_has_Level', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'usage':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.usage = obj_
            obj_.original_tagname_ = 'usage'
        elif nodeName_ == 'validDateRange':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validDateRange = obj_
            obj_.original_tagname_ = 'validDateRange'
        elif nodeName_ == 'LevelStructure_has_Level':
            obj_ = LevelStructure_has_LevelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LevelStructure_has_Level.append(obj_)
            obj_.original_tagname_ = 'LevelStructure_has_Level'
# end class LevelStructure


class LogicalRecord(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    LogicalRecord_isDefinedBy_Concept -- The conceptual basis for the collection of members.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, LogicalRecord_organizes_DataSet=None, LogicalRecord_isDefinedBy_Concept=None, LogicalRecord_has_InstanceVariable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if LogicalRecord_organizes_DataSet is None:
            self.LogicalRecord_organizes_DataSet = []
        else:
            self.LogicalRecord_organizes_DataSet = LogicalRecord_organizes_DataSet
        self.LogicalRecord_organizes_DataSet_nsprefix_ = None
        if LogicalRecord_isDefinedBy_Concept is None:
            self.LogicalRecord_isDefinedBy_Concept = []
        else:
            self.LogicalRecord_isDefinedBy_Concept = LogicalRecord_isDefinedBy_Concept
        self.LogicalRecord_isDefinedBy_Concept_nsprefix_ = None
        if LogicalRecord_has_InstanceVariable is None:
            self.LogicalRecord_has_InstanceVariable = []
        else:
            self.LogicalRecord_has_InstanceVariable = LogicalRecord_has_InstanceVariable
        self.LogicalRecord_has_InstanceVariable_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalRecord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalRecord.subclass:
            return LogicalRecord.subclass(*args_, **kwargs_)
        else:
            return LogicalRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_LogicalRecord_organizes_DataSet(self):
        return self.LogicalRecord_organizes_DataSet
    def set_LogicalRecord_organizes_DataSet(self, LogicalRecord_organizes_DataSet):
        self.LogicalRecord_organizes_DataSet = LogicalRecord_organizes_DataSet
    def add_LogicalRecord_organizes_DataSet(self, value):
        self.LogicalRecord_organizes_DataSet.append(value)
    def insert_LogicalRecord_organizes_DataSet_at(self, index, value):
        self.LogicalRecord_organizes_DataSet.insert(index, value)
    def replace_LogicalRecord_organizes_DataSet_at(self, index, value):
        self.LogicalRecord_organizes_DataSet[index] = value
    def get_LogicalRecord_isDefinedBy_Concept(self):
        return self.LogicalRecord_isDefinedBy_Concept
    def set_LogicalRecord_isDefinedBy_Concept(self, LogicalRecord_isDefinedBy_Concept):
        self.LogicalRecord_isDefinedBy_Concept = LogicalRecord_isDefinedBy_Concept
    def add_LogicalRecord_isDefinedBy_Concept(self, value):
        self.LogicalRecord_isDefinedBy_Concept.append(value)
    def insert_LogicalRecord_isDefinedBy_Concept_at(self, index, value):
        self.LogicalRecord_isDefinedBy_Concept.insert(index, value)
    def replace_LogicalRecord_isDefinedBy_Concept_at(self, index, value):
        self.LogicalRecord_isDefinedBy_Concept[index] = value
    def get_LogicalRecord_has_InstanceVariable(self):
        return self.LogicalRecord_has_InstanceVariable
    def set_LogicalRecord_has_InstanceVariable(self, LogicalRecord_has_InstanceVariable):
        self.LogicalRecord_has_InstanceVariable = LogicalRecord_has_InstanceVariable
    def add_LogicalRecord_has_InstanceVariable(self, value):
        self.LogicalRecord_has_InstanceVariable.append(value)
    def insert_LogicalRecord_has_InstanceVariable_at(self, index, value):
        self.LogicalRecord_has_InstanceVariable.insert(index, value)
    def replace_LogicalRecord_has_InstanceVariable_at(self, index, value):
        self.LogicalRecord_has_InstanceVariable[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.LogicalRecord_organizes_DataSet or
            self.LogicalRecord_isDefinedBy_Concept or
            self.LogicalRecord_has_InstanceVariable
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LogicalRecord', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecord_organizes_DataSet_ in self.LogicalRecord_organizes_DataSet:
            LogicalRecord_organizes_DataSet_.to_etree(element, name_='LogicalRecord_organizes_DataSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecord_isDefinedBy_Concept_ in self.LogicalRecord_isDefinedBy_Concept:
            LogicalRecord_isDefinedBy_Concept_.to_etree(element, name_='LogicalRecord_isDefinedBy_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecord_has_InstanceVariable_ in self.LogicalRecord_has_InstanceVariable:
            LogicalRecord_has_InstanceVariable_.to_etree(element, name_='LogicalRecord_has_InstanceVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'LogicalRecord_organizes_DataSet':
            obj_ = LogicalRecord_organizes_DataSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecord_organizes_DataSet.append(obj_)
            obj_.original_tagname_ = 'LogicalRecord_organizes_DataSet'
        elif nodeName_ == 'LogicalRecord_isDefinedBy_Concept':
            obj_ = LogicalRecord_isDefinedBy_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecord_isDefinedBy_Concept.append(obj_)
            obj_.original_tagname_ = 'LogicalRecord_isDefinedBy_Concept'
        elif nodeName_ == 'LogicalRecord_has_InstanceVariable':
            obj_ = LogicalRecord_has_InstanceVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecord_has_InstanceVariable.append(obj_)
            obj_.original_tagname_ = 'LogicalRecord_has_InstanceVariable'
# end class LogicalRecord


class LogicalRecordPosition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    value -- Index value of the member in an ordered array.
    LogicalRecordPosition_indexes_LogicalRecord -- Logical record position indexes a logical record.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, value=None, LogicalRecordPosition_indexes_LogicalRecord=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.LogicalRecordPosition_indexes_LogicalRecord = LogicalRecordPosition_indexes_LogicalRecord
        self.LogicalRecordPosition_indexes_LogicalRecord_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalRecordPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalRecordPosition.subclass:
            return LogicalRecordPosition.subclass(*args_, **kwargs_)
        else:
            return LogicalRecordPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_LogicalRecordPosition_indexes_LogicalRecord(self):
        return self.LogicalRecordPosition_indexes_LogicalRecord
    def set_LogicalRecordPosition_indexes_LogicalRecord(self, LogicalRecordPosition_indexes_LogicalRecord):
        self.LogicalRecordPosition_indexes_LogicalRecord = LogicalRecordPosition_indexes_LogicalRecord
    def has__content(self):
        if (
            self.identifier is not None or
            self.value is not None or
            self.LogicalRecordPosition_indexes_LogicalRecord is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LogicalRecordPosition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_integer(value_)
        if self.LogicalRecordPosition_indexes_LogicalRecord is not None:
            LogicalRecordPosition_indexes_LogicalRecord_ = self.LogicalRecordPosition_indexes_LogicalRecord
            LogicalRecordPosition_indexes_LogicalRecord_.to_etree(element, name_='LogicalRecordPosition_indexes_LogicalRecord', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
        elif nodeName_ == 'LogicalRecordPosition_indexes_LogicalRecord':
            obj_ = LogicalRecordPosition_indexes_LogicalRecordType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecordPosition_indexes_LogicalRecord = obj_
            obj_.original_tagname_ = 'LogicalRecordPosition_indexes_LogicalRecord'
# end class LogicalRecordPosition


class LogicalRecordRelationStructure(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    specification -- Provides information on reflexivity, transitivity, and symmetry of relationship using a descriptive term from an enumerated list. Use if all relations within this relation structure are of the same specification.
    topology -- Indicates the form of the associations among members of the collection. Specifies the way in which constituent parts are interrelated or arranged.
    totality -- Indicates whether the related collections are comprehensive in terms of their coverage.
    LogicalRecordRelationStructure_has_LogicalRecordRelationship -- LogicalRecordRelationStructure has zero to many LogicalRecordRelationships.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, name=None, purpose=None, semantics=None, specification=None, topology=None, totality=None, LogicalRecordRelationStructure_structures_DataStore=None, LogicalRecordRelationStructure_has_LogicalRecordRelationship=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        self.specification = specification
        self.specification_nsprefix_ = None
        self.topology = topology
        self.topology_nsprefix_ = None
        self.totality = totality
        self.validate_StructureExtent(self.totality)
        self.totality_nsprefix_ = None
        if LogicalRecordRelationStructure_structures_DataStore is None:
            self.LogicalRecordRelationStructure_structures_DataStore = []
        else:
            self.LogicalRecordRelationStructure_structures_DataStore = LogicalRecordRelationStructure_structures_DataStore
        self.LogicalRecordRelationStructure_structures_DataStore_nsprefix_ = None
        if LogicalRecordRelationStructure_has_LogicalRecordRelationship is None:
            self.LogicalRecordRelationStructure_has_LogicalRecordRelationship = []
        else:
            self.LogicalRecordRelationStructure_has_LogicalRecordRelationship = LogicalRecordRelationStructure_has_LogicalRecordRelationship
        self.LogicalRecordRelationStructure_has_LogicalRecordRelationship_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalRecordRelationStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalRecordRelationStructure.subclass:
            return LogicalRecordRelationStructure.subclass(*args_, **kwargs_)
        else:
            return LogicalRecordRelationStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_specification(self):
        return self.specification
    def set_specification(self, specification):
        self.specification = specification
    def get_topology(self):
        return self.topology
    def set_topology(self, topology):
        self.topology = topology
    def get_totality(self):
        return self.totality
    def set_totality(self, totality):
        self.totality = totality
    def get_LogicalRecordRelationStructure_structures_DataStore(self):
        return self.LogicalRecordRelationStructure_structures_DataStore
    def set_LogicalRecordRelationStructure_structures_DataStore(self, LogicalRecordRelationStructure_structures_DataStore):
        self.LogicalRecordRelationStructure_structures_DataStore = LogicalRecordRelationStructure_structures_DataStore
    def add_LogicalRecordRelationStructure_structures_DataStore(self, value):
        self.LogicalRecordRelationStructure_structures_DataStore.append(value)
    def insert_LogicalRecordRelationStructure_structures_DataStore_at(self, index, value):
        self.LogicalRecordRelationStructure_structures_DataStore.insert(index, value)
    def replace_LogicalRecordRelationStructure_structures_DataStore_at(self, index, value):
        self.LogicalRecordRelationStructure_structures_DataStore[index] = value
    def get_LogicalRecordRelationStructure_has_LogicalRecordRelationship(self):
        return self.LogicalRecordRelationStructure_has_LogicalRecordRelationship
    def set_LogicalRecordRelationStructure_has_LogicalRecordRelationship(self, LogicalRecordRelationStructure_has_LogicalRecordRelationship):
        self.LogicalRecordRelationStructure_has_LogicalRecordRelationship = LogicalRecordRelationStructure_has_LogicalRecordRelationship
    def add_LogicalRecordRelationStructure_has_LogicalRecordRelationship(self, value):
        self.LogicalRecordRelationStructure_has_LogicalRecordRelationship.append(value)
    def insert_LogicalRecordRelationStructure_has_LogicalRecordRelationship_at(self, index, value):
        self.LogicalRecordRelationStructure_has_LogicalRecordRelationship.insert(index, value)
    def replace_LogicalRecordRelationStructure_has_LogicalRecordRelationship_at(self, index, value):
        self.LogicalRecordRelationStructure_has_LogicalRecordRelationship[index] = value
    def validate_StructureExtent(self, value):
        result = True
        # Validate type StructureExtent, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Partial', 'Total']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StructureExtent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.semantics is not None or
            self.specification is not None or
            self.topology is not None or
            self.totality is not None or
            self.LogicalRecordRelationStructure_structures_DataStore or
            self.LogicalRecordRelationStructure_has_LogicalRecordRelationship
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LogicalRecordRelationStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.specification is not None:
            specification_ = self.specification
            specification_.to_etree(element, name_='specification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.topology is not None:
            topology_ = self.topology
            topology_.to_etree(element, name_='topology', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.totality is not None:
            totality_ = self.totality
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}totality').text = self.gds_format_string(totality_)
        for LogicalRecordRelationStructure_structures_DataStore_ in self.LogicalRecordRelationStructure_structures_DataStore:
            LogicalRecordRelationStructure_structures_DataStore_.to_etree(element, name_='LogicalRecordRelationStructure_structures_DataStore', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecordRelationStructure_has_LogicalRecordRelationship_ in self.LogicalRecordRelationStructure_has_LogicalRecordRelationship:
            LogicalRecordRelationStructure_has_LogicalRecordRelationship_.to_etree(element, name_='LogicalRecordRelationStructure_has_LogicalRecordRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'specification':
            obj_ = StructureSpecification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specification = obj_
            obj_.original_tagname_ = 'specification'
        elif nodeName_ == 'topology':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.topology = obj_
            obj_.original_tagname_ = 'topology'
        elif nodeName_ == 'totality':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totality')
            value_ = self.gds_validate_string(value_, node, 'totality')
            self.totality = value_
            self.totality_nsprefix_ = child_.prefix
            # validate type StructureExtent
            self.validate_StructureExtent(self.totality)
        elif nodeName_ == 'LogicalRecordRelationStructure_structures_DataStore':
            obj_ = LogicalRecordRelationStructure_structures_DataStoreType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecordRelationStructure_structures_DataStore.append(obj_)
            obj_.original_tagname_ = 'LogicalRecordRelationStructure_structures_DataStore'
        elif nodeName_ == 'LogicalRecordRelationStructure_has_LogicalRecordRelationship':
            obj_ = LogicalRecordRelationStructure_has_LogicalRecordRelationshipType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecordRelationStructure_has_LogicalRecordRelationship.append(obj_)
            obj_.original_tagname_ = 'LogicalRecordRelationStructure_has_LogicalRecordRelationship'
# end class LogicalRecordRelationStructure


class LogicalRecordRelationship(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    LogicalRecordRelationship_hasTarget_LogicalRecord -- Note that this can be realized as a collection to support tuples.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, semantics=None, LogicalRecordRelationship_hasTarget_LogicalRecord=None, LogicalRecordRelationship_hasSource_LogicalRecord=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        if LogicalRecordRelationship_hasTarget_LogicalRecord is None:
            self.LogicalRecordRelationship_hasTarget_LogicalRecord = []
        else:
            self.LogicalRecordRelationship_hasTarget_LogicalRecord = LogicalRecordRelationship_hasTarget_LogicalRecord
        self.LogicalRecordRelationship_hasTarget_LogicalRecord_nsprefix_ = None
        if LogicalRecordRelationship_hasSource_LogicalRecord is None:
            self.LogicalRecordRelationship_hasSource_LogicalRecord = []
        else:
            self.LogicalRecordRelationship_hasSource_LogicalRecord = LogicalRecordRelationship_hasSource_LogicalRecord
        self.LogicalRecordRelationship_hasSource_LogicalRecord_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalRecordRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalRecordRelationship.subclass:
            return LogicalRecordRelationship.subclass(*args_, **kwargs_)
        else:
            return LogicalRecordRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_LogicalRecordRelationship_hasTarget_LogicalRecord(self):
        return self.LogicalRecordRelationship_hasTarget_LogicalRecord
    def set_LogicalRecordRelationship_hasTarget_LogicalRecord(self, LogicalRecordRelationship_hasTarget_LogicalRecord):
        self.LogicalRecordRelationship_hasTarget_LogicalRecord = LogicalRecordRelationship_hasTarget_LogicalRecord
    def add_LogicalRecordRelationship_hasTarget_LogicalRecord(self, value):
        self.LogicalRecordRelationship_hasTarget_LogicalRecord.append(value)
    def insert_LogicalRecordRelationship_hasTarget_LogicalRecord_at(self, index, value):
        self.LogicalRecordRelationship_hasTarget_LogicalRecord.insert(index, value)
    def replace_LogicalRecordRelationship_hasTarget_LogicalRecord_at(self, index, value):
        self.LogicalRecordRelationship_hasTarget_LogicalRecord[index] = value
    def get_LogicalRecordRelationship_hasSource_LogicalRecord(self):
        return self.LogicalRecordRelationship_hasSource_LogicalRecord
    def set_LogicalRecordRelationship_hasSource_LogicalRecord(self, LogicalRecordRelationship_hasSource_LogicalRecord):
        self.LogicalRecordRelationship_hasSource_LogicalRecord = LogicalRecordRelationship_hasSource_LogicalRecord
    def add_LogicalRecordRelationship_hasSource_LogicalRecord(self, value):
        self.LogicalRecordRelationship_hasSource_LogicalRecord.append(value)
    def insert_LogicalRecordRelationship_hasSource_LogicalRecord_at(self, index, value):
        self.LogicalRecordRelationship_hasSource_LogicalRecord.insert(index, value)
    def replace_LogicalRecordRelationship_hasSource_LogicalRecord_at(self, index, value):
        self.LogicalRecordRelationship_hasSource_LogicalRecord[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.semantics is not None or
            self.LogicalRecordRelationship_hasTarget_LogicalRecord or
            self.LogicalRecordRelationship_hasSource_LogicalRecord
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LogicalRecordRelationship', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecordRelationship_hasTarget_LogicalRecord_ in self.LogicalRecordRelationship_hasTarget_LogicalRecord:
            LogicalRecordRelationship_hasTarget_LogicalRecord_.to_etree(element, name_='LogicalRecordRelationship_hasTarget_LogicalRecord', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for LogicalRecordRelationship_hasSource_LogicalRecord_ in self.LogicalRecordRelationship_hasSource_LogicalRecord:
            LogicalRecordRelationship_hasSource_LogicalRecord_.to_etree(element, name_='LogicalRecordRelationship_hasSource_LogicalRecord', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'LogicalRecordRelationship_hasTarget_LogicalRecord':
            obj_ = LogicalRecordRelationship_hasTarget_LogicalRecordType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecordRelationship_hasTarget_LogicalRecord.append(obj_)
            obj_.original_tagname_ = 'LogicalRecordRelationship_hasTarget_LogicalRecord'
        elif nodeName_ == 'LogicalRecordRelationship_hasSource_LogicalRecord':
            obj_ = LogicalRecordRelationship_hasSource_LogicalRecordType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogicalRecordRelationship_hasSource_LogicalRecord.append(obj_)
            obj_.original_tagname_ = 'LogicalRecordRelationship_hasSource_LogicalRecord'
# end class LogicalRecordRelationship


class LongDataSet(DataSet):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataSet
    def __init__(self, catalogDetails=None, identifier=None, DataSet_isStructuredBy_DataStructure=None, DataSet_has_DataPoint=None, DataSet_has_Key=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LongDataSet"), self).__init__(catalogDetails, identifier, DataSet_isStructuredBy_DataStructure, DataSet_has_DataPoint, DataSet_has_Key,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LongDataSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LongDataSet.subclass:
            return LongDataSet.subclass(*args_, **kwargs_)
        else:
            return LongDataSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(LongDataSet, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LongDataSet', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(LongDataSet, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LongDataSet, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(LongDataSet, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class LongDataSet


class LongKey(Key):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Key
    def __init__(self, identifier=None, Key_correspondsTo_Unit=None, Key_represents_KeyDefinition=None, Key_identifies_DataPoint=None, Key_correspondsTo_Universe=None, Key_has_KeyMember=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LongKey"), self).__init__(identifier, Key_correspondsTo_Unit, Key_represents_KeyDefinition, Key_identifies_DataPoint, Key_correspondsTo_Universe, Key_has_KeyMember,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LongKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LongKey.subclass:
            return LongKey.subclass(*args_, **kwargs_)
        else:
            return LongKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(LongKey, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LongKey', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(LongKey, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LongKey, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(LongKey, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class LongKey


class LongMainKeyMember(KeyMember):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = KeyMember
    def __init__(self, content=None, identifier=None, whiteSpace=None, InstanceValue_hasValueFrom_ValueDomain=None, InstanceValue_isStoredIn_DataPoint=None, InstanceValue_represents_ConceptualValue=None, KeyMember_isBasedOn_DataStructureComponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LongMainKeyMember"), self).__init__(content, identifier, whiteSpace, InstanceValue_hasValueFrom_ValueDomain, InstanceValue_isStoredIn_DataPoint, InstanceValue_represents_ConceptualValue, KeyMember_isBasedOn_DataStructureComponent,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LongMainKeyMember)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LongMainKeyMember.subclass:
            return LongMainKeyMember.subclass(*args_, **kwargs_)
        else:
            return LongMainKeyMember(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(LongMainKeyMember, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LongMainKeyMember', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(LongMainKeyMember, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LongMainKeyMember, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(LongMainKeyMember, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class LongMainKeyMember


class Machine(Agent):
    """accessLocation -- Location of the machine for the purpose of access.
    function -- The business function of the machine according to a classification or typology.
    machineInterface -- Reference to the type of the machine interface according to a classification or typology.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    ownerOperatorContact -- Contact information for the owner/operator including location specification, address, URL, phone numbers, and other means of communication access. Sets of information can be repeated and date-stamped.
    typeOfMachine -- Describes the type of non-human actor (e.g., software, hardware, web service, etc.).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Agent
    def __init__(self, catalogDetails=None, identifier=None, image=None, purpose=None, accessLocation=None, function=None, machineInterface=None, name=None, ownerOperatorContact=None, typeOfMachine=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Machine"), self).__init__(catalogDetails, identifier, image, purpose,  **kwargs_)
        self.accessLocation = accessLocation
        self.accessLocation_nsprefix_ = None
        if function is None:
            self.function = []
        else:
            self.function = function
        self.function_nsprefix_ = None
        if machineInterface is None:
            self.machineInterface = []
        else:
            self.machineInterface = machineInterface
        self.machineInterface_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.ownerOperatorContact = ownerOperatorContact
        self.ownerOperatorContact_nsprefix_ = None
        self.typeOfMachine = typeOfMachine
        self.typeOfMachine_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Machine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Machine.subclass:
            return Machine.subclass(*args_, **kwargs_)
        else:
            return Machine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessLocation(self):
        return self.accessLocation
    def set_accessLocation(self, accessLocation):
        self.accessLocation = accessLocation
    def get_function(self):
        return self.function
    def set_function(self, function):
        self.function = function
    def add_function(self, value):
        self.function.append(value)
    def insert_function_at(self, index, value):
        self.function.insert(index, value)
    def replace_function_at(self, index, value):
        self.function[index] = value
    def get_machineInterface(self):
        return self.machineInterface
    def set_machineInterface(self, machineInterface):
        self.machineInterface = machineInterface
    def add_machineInterface(self, value):
        self.machineInterface.append(value)
    def insert_machineInterface_at(self, index, value):
        self.machineInterface.insert(index, value)
    def replace_machineInterface_at(self, index, value):
        self.machineInterface[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_ownerOperatorContact(self):
        return self.ownerOperatorContact
    def set_ownerOperatorContact(self, ownerOperatorContact):
        self.ownerOperatorContact = ownerOperatorContact
    def get_typeOfMachine(self):
        return self.typeOfMachine
    def set_typeOfMachine(self, typeOfMachine):
        self.typeOfMachine = typeOfMachine
    def has__content(self):
        if (
            self.accessLocation is not None or
            self.function or
            self.machineInterface or
            self.name or
            self.ownerOperatorContact is not None or
            self.typeOfMachine is not None or
            super(Machine, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Machine', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(Machine, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.accessLocation is not None:
            accessLocation_ = self.accessLocation
            accessLocation_.to_etree(element, name_='accessLocation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for function_ in self.function:
            function_.to_etree(element, name_='function', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for machineInterface_ in self.machineInterface:
            machineInterface_.to_etree(element, name_='machineInterface', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ownerOperatorContact is not None:
            ownerOperatorContact_ = self.ownerOperatorContact
            ownerOperatorContact_.to_etree(element, name_='ownerOperatorContact', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.typeOfMachine is not None:
            typeOfMachine_ = self.typeOfMachine
            typeOfMachine_.to_etree(element, name_='typeOfMachine', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Machine, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessLocation':
            obj_ = AccessLocation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessLocation = obj_
            obj_.original_tagname_ = 'accessLocation'
        elif nodeName_ == 'function':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.function.append(obj_)
            obj_.original_tagname_ = 'function'
        elif nodeName_ == 'machineInterface':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.machineInterface.append(obj_)
            obj_.original_tagname_ = 'machineInterface'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'ownerOperatorContact':
            obj_ = ContactInformation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ownerOperatorContact = obj_
            obj_.original_tagname_ = 'ownerOperatorContact'
        elif nodeName_ == 'typeOfMachine':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfMachine = obj_
            obj_.original_tagname_ = 'typeOfMachine'
        super(Machine, self)._buildChildren(child_, node, nodeName_, True)
# end class Machine


class MainKeyMember(KeyMember):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = KeyMember
    def __init__(self, content=None, identifier=None, whiteSpace=None, InstanceValue_hasValueFrom_ValueDomain=None, InstanceValue_isStoredIn_DataPoint=None, InstanceValue_represents_ConceptualValue=None, KeyMember_isBasedOn_DataStructureComponent=None, MainKeyMember_hasValueFrom_SubstantiveValueDomain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MainKeyMember"), self).__init__(content, identifier, whiteSpace, InstanceValue_hasValueFrom_ValueDomain, InstanceValue_isStoredIn_DataPoint, InstanceValue_represents_ConceptualValue, KeyMember_isBasedOn_DataStructureComponent,  **kwargs_)
        self.MainKeyMember_hasValueFrom_SubstantiveValueDomain = MainKeyMember_hasValueFrom_SubstantiveValueDomain
        self.MainKeyMember_hasValueFrom_SubstantiveValueDomain_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MainKeyMember)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MainKeyMember.subclass:
            return MainKeyMember.subclass(*args_, **kwargs_)
        else:
            return MainKeyMember(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MainKeyMember_hasValueFrom_SubstantiveValueDomain(self):
        return self.MainKeyMember_hasValueFrom_SubstantiveValueDomain
    def set_MainKeyMember_hasValueFrom_SubstantiveValueDomain(self, MainKeyMember_hasValueFrom_SubstantiveValueDomain):
        self.MainKeyMember_hasValueFrom_SubstantiveValueDomain = MainKeyMember_hasValueFrom_SubstantiveValueDomain
    def has__content(self):
        if (
            self.MainKeyMember_hasValueFrom_SubstantiveValueDomain is not None or
            super(MainKeyMember, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='MainKeyMember', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(MainKeyMember, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.MainKeyMember_hasValueFrom_SubstantiveValueDomain is not None:
            MainKeyMember_hasValueFrom_SubstantiveValueDomain_ = self.MainKeyMember_hasValueFrom_SubstantiveValueDomain
            MainKeyMember_hasValueFrom_SubstantiveValueDomain_.to_etree(element, name_='MainKeyMember_hasValueFrom_SubstantiveValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MainKeyMember, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MainKeyMember_hasValueFrom_SubstantiveValueDomain':
            obj_ = MainKeyMember_hasValueFrom_SubstantiveValueDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MainKeyMember_hasValueFrom_SubstantiveValueDomain = obj_
            obj_.original_tagname_ = 'MainKeyMember_hasValueFrom_SubstantiveValueDomain'
        super(MainKeyMember, self)._buildChildren(child_, node, nodeName_, True)
# end class MainKeyMember


class MeasureComponent(DataStructureComponent):
    """name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataStructureComponent
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, name=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MeasureComponent"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable, extensiontype_,  **kwargs_)
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureComponent.subclass:
            return MeasureComponent.subclass(*args_, **kwargs_)
        else:
            return MeasureComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.name or
            super(MeasureComponent, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='MeasureComponent', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(MeasureComponent, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(MeasureComponent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        super(MeasureComponent, self)._buildChildren(child_, node, nodeName_, True)
# end class MeasureComponent


class NonDeterministicDeclarative(ControlLogic):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ControlLogic
    def __init__(self, description=None, identifier=None, workflow=None, ControlLogic_informs_ProcessingAgent=None, ControlLogic_invokes_Activity=None, ControlLogic_hasSubControlLogic_ControlLogic=None, ControlLogic_has_InformationFlowDefinition=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("NonDeterministicDeclarative"), self).__init__(description, identifier, workflow, ControlLogic_informs_ProcessingAgent, ControlLogic_invokes_Activity, ControlLogic_hasSubControlLogic_ControlLogic, ControlLogic_has_InformationFlowDefinition, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonDeterministicDeclarative)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonDeterministicDeclarative.subclass:
            return NonDeterministicDeclarative.subclass(*args_, **kwargs_)
        else:
            return NonDeterministicDeclarative(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            super(NonDeterministicDeclarative, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='NonDeterministicDeclarative', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(NonDeterministicDeclarative, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NonDeterministicDeclarative, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(NonDeterministicDeclarative, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class NonDeterministicDeclarative


class Notation(GeneratedsSuper):
    """content -- The actual content of this value as a string.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    whiteSpace -- The usual setting "collapse" states that leading and trailing white space will be removed and multiple adjacent white spaces will be treated as a single white space. When setting to "replace" all occurrences of #x9 (tab), #xA (line feed) and #xD (carriage return) are replaced with #x20 (space) but leading and trailing spaces will be retained. If the existence of any of these white spaces is critical to the understanding of the content, change the value of this attribute to "preserve".
    Notation_represents_Category -- Notation represents zero to many categories.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, content=None, identifier=None, whiteSpace=None, Notation_represents_Category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.content = content
        self.content_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.whiteSpace = whiteSpace
        self.validate_WhiteSpaceRule(self.whiteSpace)
        self.whiteSpace_nsprefix_ = None
        if Notation_represents_Category is None:
            self.Notation_represents_Category = []
        else:
            self.Notation_represents_Category = Notation_represents_Category
        self.Notation_represents_Category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Notation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Notation.subclass:
            return Notation.subclass(*args_, **kwargs_)
        else:
            return Notation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_whiteSpace(self):
        return self.whiteSpace
    def set_whiteSpace(self, whiteSpace):
        self.whiteSpace = whiteSpace
    def get_Notation_represents_Category(self):
        return self.Notation_represents_Category
    def set_Notation_represents_Category(self, Notation_represents_Category):
        self.Notation_represents_Category = Notation_represents_Category
    def add_Notation_represents_Category(self, value):
        self.Notation_represents_Category.append(value)
    def insert_Notation_represents_Category_at(self, index, value):
        self.Notation_represents_Category.insert(index, value)
    def replace_Notation_represents_Category_at(self, index, value):
        self.Notation_represents_Category[index] = value
    def validate_WhiteSpaceRule(self, value):
        result = True
        # Validate type WhiteSpaceRule, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Collapse', 'Preserve', 'Replace']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on WhiteSpaceRule' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.content is not None or
            self.identifier is not None or
            self.whiteSpace is not None or
            self.Notation_represents_Category
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Notation', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.content is not None:
            content_ = self.content
            content_.to_etree(element, name_='content', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.whiteSpace is not None:
            whiteSpace_ = self.whiteSpace
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}whiteSpace').text = self.gds_format_string(whiteSpace_)
        for Notation_represents_Category_ in self.Notation_represents_Category:
            Notation_represents_Category_.to_etree(element, name_='Notation_represents_Category', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = TypedString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.content = obj_
            obj_.original_tagname_ = 'content'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'whiteSpace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'whiteSpace')
            value_ = self.gds_validate_string(value_, node, 'whiteSpace')
            self.whiteSpace = value_
            self.whiteSpace_nsprefix_ = child_.prefix
            # validate type WhiteSpaceRule
            self.validate_WhiteSpaceRule(self.whiteSpace)
        elif nodeName_ == 'Notation_represents_Category':
            obj_ = Notation_represents_CategoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Notation_represents_Category.append(obj_)
            obj_.original_tagname_ = 'Notation_represents_Category'
# end class Notation


class Organization(Agent):
    """contactInformation -- Contact information for the organization including location specification, address, URL, phone numbers, and other means of communication access. Sets of information can be repeated and date-stamped.
    organizationName -- Names by which the organization is known.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Agent
    def __init__(self, catalogDetails=None, identifier=None, image=None, purpose=None, contactInformation=None, organizationName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Organization"), self).__init__(catalogDetails, identifier, image, purpose,  **kwargs_)
        self.contactInformation = contactInformation
        self.contactInformation_nsprefix_ = None
        if organizationName is None:
            self.organizationName = []
        else:
            self.organizationName = organizationName
        self.organizationName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Organization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Organization.subclass:
            return Organization.subclass(*args_, **kwargs_)
        else:
            return Organization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_contactInformation(self):
        return self.contactInformation
    def set_contactInformation(self, contactInformation):
        self.contactInformation = contactInformation
    def get_organizationName(self):
        return self.organizationName
    def set_organizationName(self, organizationName):
        self.organizationName = organizationName
    def add_organizationName(self, value):
        self.organizationName.append(value)
    def insert_organizationName_at(self, index, value):
        self.organizationName.insert(index, value)
    def replace_organizationName_at(self, index, value):
        self.organizationName[index] = value
    def has__content(self):
        if (
            self.contactInformation is not None or
            self.organizationName or
            super(Organization, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Organization', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(Organization, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.contactInformation is not None:
            contactInformation_ = self.contactInformation
            contactInformation_.to_etree(element, name_='contactInformation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for organizationName_ in self.organizationName:
            organizationName_.to_etree(element, name_='organizationName', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Organization, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contactInformation':
            obj_ = ContactInformation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contactInformation = obj_
            obj_.original_tagname_ = 'contactInformation'
        elif nodeName_ == 'organizationName':
            obj_ = OrganizationName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organizationName.append(obj_)
            obj_.original_tagname_ = 'organizationName'
        super(Organization, self)._buildChildren(child_, node, nodeName_, True)
# end class Organization


class Parameter(GeneratedsSuper):
    """entityBound -- Specification of the object being used as a parameter, typically as a reference to a class in the DDI-CDI model, but may also be a specific instance of a class.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (linguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, entityBound=None, identifier=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if entityBound is None:
            self.entityBound = []
        else:
            self.entityBound = entityBound
        self.entityBound_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Parameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Parameter.subclass:
            return Parameter.subclass(*args_, **kwargs_)
        else:
            return Parameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_entityBound(self):
        return self.entityBound
    def set_entityBound(self, entityBound):
        self.entityBound = entityBound
    def add_entityBound(self, value):
        self.entityBound.append(value)
    def insert_entityBound_at(self, index, value):
        self.entityBound.insert(index, value)
    def replace_entityBound_at(self, index, value):
        self.entityBound[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def has__content(self):
        if (
            self.entityBound or
            self.identifier is not None or
            self.name
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Parameter', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        for entityBound_ in self.entityBound:
            entityBound_.to_etree(element, name_='entityBound', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'entityBound':
            class_obj_ = self.get_class_obj_(child_, Reference)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entityBound.append(obj_)
            obj_.original_tagname_ = 'entityBound'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
# end class Parameter


class PhysicalDataSet(GeneratedsSuper):
    """allowsDuplicates -- If value is False, the members are unique within the collection - if True, there may be duplicates. (Note that a mathematical "bag" permits duplicates and is unordered - a "set" does not have duplicates and may be ordered.)
    catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    numberOfSegments -- The number of distinct segments (e.g., segments patterns with different structures, identified separately) in a physical dataset.
    overview -- Short natural language account of the information obtained from the combination of properties and relationships associated with an object.
    physicalFileName -- Use when multiple physical segments are stored in a single file.
    purpose -- Intent or reason for the object/the description of the object.
    PhysicalDataSet_isDefinedBy_Concept -- The conceptual basis for the collection of members.
    PhysicalDataSet_formats_DataStore -- Data store physically represented by the structure description.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, allowsDuplicates=None, catalogDetails=None, identifier=None, name=None, numberOfSegments=None, overview=None, physicalFileName=None, purpose=None, PhysicalDataSet_isDefinedBy_Concept=None, PhysicalDataSet_formats_DataStore=None, PhysicalDataSet_has_InstanceVariable=None, PhysicalDataSet_has_PhysicalRecordSegment=None, PhysicalDataSet_has_PhysicalRecordSegmentPosition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.allowsDuplicates = allowsDuplicates
        self.allowsDuplicates_nsprefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.numberOfSegments = numberOfSegments
        self.numberOfSegments_nsprefix_ = None
        self.overview = overview
        self.overview_nsprefix_ = None
        self.physicalFileName = physicalFileName
        self.physicalFileName_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        if PhysicalDataSet_isDefinedBy_Concept is None:
            self.PhysicalDataSet_isDefinedBy_Concept = []
        else:
            self.PhysicalDataSet_isDefinedBy_Concept = PhysicalDataSet_isDefinedBy_Concept
        self.PhysicalDataSet_isDefinedBy_Concept_nsprefix_ = None
        if PhysicalDataSet_formats_DataStore is None:
            self.PhysicalDataSet_formats_DataStore = []
        else:
            self.PhysicalDataSet_formats_DataStore = PhysicalDataSet_formats_DataStore
        self.PhysicalDataSet_formats_DataStore_nsprefix_ = None
        if PhysicalDataSet_has_InstanceVariable is None:
            self.PhysicalDataSet_has_InstanceVariable = []
        else:
            self.PhysicalDataSet_has_InstanceVariable = PhysicalDataSet_has_InstanceVariable
        self.PhysicalDataSet_has_InstanceVariable_nsprefix_ = None
        if PhysicalDataSet_has_PhysicalRecordSegment is None:
            self.PhysicalDataSet_has_PhysicalRecordSegment = []
        else:
            self.PhysicalDataSet_has_PhysicalRecordSegment = PhysicalDataSet_has_PhysicalRecordSegment
        self.PhysicalDataSet_has_PhysicalRecordSegment_nsprefix_ = None
        if PhysicalDataSet_has_PhysicalRecordSegmentPosition is None:
            self.PhysicalDataSet_has_PhysicalRecordSegmentPosition = []
        else:
            self.PhysicalDataSet_has_PhysicalRecordSegmentPosition = PhysicalDataSet_has_PhysicalRecordSegmentPosition
        self.PhysicalDataSet_has_PhysicalRecordSegmentPosition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalDataSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalDataSet.subclass:
            return PhysicalDataSet.subclass(*args_, **kwargs_)
        else:
            return PhysicalDataSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_allowsDuplicates(self):
        return self.allowsDuplicates
    def set_allowsDuplicates(self, allowsDuplicates):
        self.allowsDuplicates = allowsDuplicates
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_numberOfSegments(self):
        return self.numberOfSegments
    def set_numberOfSegments(self, numberOfSegments):
        self.numberOfSegments = numberOfSegments
    def get_overview(self):
        return self.overview
    def set_overview(self, overview):
        self.overview = overview
    def get_physicalFileName(self):
        return self.physicalFileName
    def set_physicalFileName(self, physicalFileName):
        self.physicalFileName = physicalFileName
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_PhysicalDataSet_isDefinedBy_Concept(self):
        return self.PhysicalDataSet_isDefinedBy_Concept
    def set_PhysicalDataSet_isDefinedBy_Concept(self, PhysicalDataSet_isDefinedBy_Concept):
        self.PhysicalDataSet_isDefinedBy_Concept = PhysicalDataSet_isDefinedBy_Concept
    def add_PhysicalDataSet_isDefinedBy_Concept(self, value):
        self.PhysicalDataSet_isDefinedBy_Concept.append(value)
    def insert_PhysicalDataSet_isDefinedBy_Concept_at(self, index, value):
        self.PhysicalDataSet_isDefinedBy_Concept.insert(index, value)
    def replace_PhysicalDataSet_isDefinedBy_Concept_at(self, index, value):
        self.PhysicalDataSet_isDefinedBy_Concept[index] = value
    def get_PhysicalDataSet_formats_DataStore(self):
        return self.PhysicalDataSet_formats_DataStore
    def set_PhysicalDataSet_formats_DataStore(self, PhysicalDataSet_formats_DataStore):
        self.PhysicalDataSet_formats_DataStore = PhysicalDataSet_formats_DataStore
    def add_PhysicalDataSet_formats_DataStore(self, value):
        self.PhysicalDataSet_formats_DataStore.append(value)
    def insert_PhysicalDataSet_formats_DataStore_at(self, index, value):
        self.PhysicalDataSet_formats_DataStore.insert(index, value)
    def replace_PhysicalDataSet_formats_DataStore_at(self, index, value):
        self.PhysicalDataSet_formats_DataStore[index] = value
    def get_PhysicalDataSet_has_InstanceVariable(self):
        return self.PhysicalDataSet_has_InstanceVariable
    def set_PhysicalDataSet_has_InstanceVariable(self, PhysicalDataSet_has_InstanceVariable):
        self.PhysicalDataSet_has_InstanceVariable = PhysicalDataSet_has_InstanceVariable
    def add_PhysicalDataSet_has_InstanceVariable(self, value):
        self.PhysicalDataSet_has_InstanceVariable.append(value)
    def insert_PhysicalDataSet_has_InstanceVariable_at(self, index, value):
        self.PhysicalDataSet_has_InstanceVariable.insert(index, value)
    def replace_PhysicalDataSet_has_InstanceVariable_at(self, index, value):
        self.PhysicalDataSet_has_InstanceVariable[index] = value
    def get_PhysicalDataSet_has_PhysicalRecordSegment(self):
        return self.PhysicalDataSet_has_PhysicalRecordSegment
    def set_PhysicalDataSet_has_PhysicalRecordSegment(self, PhysicalDataSet_has_PhysicalRecordSegment):
        self.PhysicalDataSet_has_PhysicalRecordSegment = PhysicalDataSet_has_PhysicalRecordSegment
    def add_PhysicalDataSet_has_PhysicalRecordSegment(self, value):
        self.PhysicalDataSet_has_PhysicalRecordSegment.append(value)
    def insert_PhysicalDataSet_has_PhysicalRecordSegment_at(self, index, value):
        self.PhysicalDataSet_has_PhysicalRecordSegment.insert(index, value)
    def replace_PhysicalDataSet_has_PhysicalRecordSegment_at(self, index, value):
        self.PhysicalDataSet_has_PhysicalRecordSegment[index] = value
    def get_PhysicalDataSet_has_PhysicalRecordSegmentPosition(self):
        return self.PhysicalDataSet_has_PhysicalRecordSegmentPosition
    def set_PhysicalDataSet_has_PhysicalRecordSegmentPosition(self, PhysicalDataSet_has_PhysicalRecordSegmentPosition):
        self.PhysicalDataSet_has_PhysicalRecordSegmentPosition = PhysicalDataSet_has_PhysicalRecordSegmentPosition
    def add_PhysicalDataSet_has_PhysicalRecordSegmentPosition(self, value):
        self.PhysicalDataSet_has_PhysicalRecordSegmentPosition.append(value)
    def insert_PhysicalDataSet_has_PhysicalRecordSegmentPosition_at(self, index, value):
        self.PhysicalDataSet_has_PhysicalRecordSegmentPosition.insert(index, value)
    def replace_PhysicalDataSet_has_PhysicalRecordSegmentPosition_at(self, index, value):
        self.PhysicalDataSet_has_PhysicalRecordSegmentPosition[index] = value
    def has__content(self):
        if (
            self.allowsDuplicates is not None or
            self.catalogDetails is not None or
            self.identifier is not None or
            self.name is not None or
            self.numberOfSegments is not None or
            self.overview is not None or
            self.physicalFileName is not None or
            self.purpose is not None or
            self.PhysicalDataSet_isDefinedBy_Concept or
            self.PhysicalDataSet_formats_DataStore or
            self.PhysicalDataSet_has_InstanceVariable or
            self.PhysicalDataSet_has_PhysicalRecordSegment or
            self.PhysicalDataSet_has_PhysicalRecordSegmentPosition
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalDataSet', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.allowsDuplicates is not None:
            allowsDuplicates_ = self.allowsDuplicates
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}allowsDuplicates').text = self.gds_format_boolean(allowsDuplicates_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.name is not None:
            name_ = self.name
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.numberOfSegments is not None:
            numberOfSegments_ = self.numberOfSegments
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}numberOfSegments').text = self.gds_format_integer(numberOfSegments_)
        if self.overview is not None:
            overview_ = self.overview
            overview_.to_etree(element, name_='overview', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.physicalFileName is not None:
            physicalFileName_ = self.physicalFileName
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}physicalFileName').text = self.gds_format_string(physicalFileName_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalDataSet_isDefinedBy_Concept_ in self.PhysicalDataSet_isDefinedBy_Concept:
            PhysicalDataSet_isDefinedBy_Concept_.to_etree(element, name_='PhysicalDataSet_isDefinedBy_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalDataSet_formats_DataStore_ in self.PhysicalDataSet_formats_DataStore:
            PhysicalDataSet_formats_DataStore_.to_etree(element, name_='PhysicalDataSet_formats_DataStore', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalDataSet_has_InstanceVariable_ in self.PhysicalDataSet_has_InstanceVariable:
            PhysicalDataSet_has_InstanceVariable_.to_etree(element, name_='PhysicalDataSet_has_InstanceVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalDataSet_has_PhysicalRecordSegment_ in self.PhysicalDataSet_has_PhysicalRecordSegment:
            PhysicalDataSet_has_PhysicalRecordSegment_.to_etree(element, name_='PhysicalDataSet_has_PhysicalRecordSegment', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalDataSet_has_PhysicalRecordSegmentPosition_ in self.PhysicalDataSet_has_PhysicalRecordSegmentPosition:
            PhysicalDataSet_has_PhysicalRecordSegmentPosition_.to_etree(element, name_='PhysicalDataSet_has_PhysicalRecordSegmentPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allowsDuplicates':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'allowsDuplicates')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowsDuplicates')
            self.allowsDuplicates = ival_
            self.allowsDuplicates_nsprefix_ = child_.prefix
        elif nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'numberOfSegments' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'numberOfSegments')
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfSegments')
            self.numberOfSegments = ival_
            self.numberOfSegments_nsprefix_ = child_.prefix
        elif nodeName_ == 'overview':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.overview = obj_
            obj_.original_tagname_ = 'overview'
        elif nodeName_ == 'physicalFileName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'physicalFileName')
            value_ = self.gds_validate_string(value_, node, 'physicalFileName')
            self.physicalFileName = value_
            self.physicalFileName_nsprefix_ = child_.prefix
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'PhysicalDataSet_isDefinedBy_Concept':
            obj_ = PhysicalDataSet_isDefinedBy_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalDataSet_isDefinedBy_Concept.append(obj_)
            obj_.original_tagname_ = 'PhysicalDataSet_isDefinedBy_Concept'
        elif nodeName_ == 'PhysicalDataSet_formats_DataStore':
            obj_ = PhysicalDataSet_formats_DataStoreType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalDataSet_formats_DataStore.append(obj_)
            obj_.original_tagname_ = 'PhysicalDataSet_formats_DataStore'
        elif nodeName_ == 'PhysicalDataSet_has_InstanceVariable':
            obj_ = PhysicalDataSet_has_InstanceVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalDataSet_has_InstanceVariable.append(obj_)
            obj_.original_tagname_ = 'PhysicalDataSet_has_InstanceVariable'
        elif nodeName_ == 'PhysicalDataSet_has_PhysicalRecordSegment':
            obj_ = PhysicalDataSet_has_PhysicalRecordSegmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalDataSet_has_PhysicalRecordSegment.append(obj_)
            obj_.original_tagname_ = 'PhysicalDataSet_has_PhysicalRecordSegment'
        elif nodeName_ == 'PhysicalDataSet_has_PhysicalRecordSegmentPosition':
            obj_ = PhysicalDataSet_has_PhysicalRecordSegmentPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalDataSet_has_PhysicalRecordSegmentPosition.append(obj_)
            obj_.original_tagname_ = 'PhysicalDataSet_has_PhysicalRecordSegmentPosition'
# end class PhysicalDataSet


class PhysicalDataSetStructure(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    specification -- Provides information on reflexivity, transitivity, and symmetry of relationship using a descriptive term from an enumerated list. Use if all relations within this relation structure are of the same specification.
    topology -- Indicates the form of the associations among members of the collection. Specifies the way in which constituent parts are interrelated or arranged.
    totality -- Indicates whether the related collections are comprehensive in terms of their coverage.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, name=None, purpose=None, semantics=None, specification=None, topology=None, totality=None, PhysicalDataSetStructure_structures_PhysicalDataSet=None, PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        self.specification = specification
        self.specification_nsprefix_ = None
        self.topology = topology
        self.topology_nsprefix_ = None
        self.totality = totality
        self.validate_StructureExtent(self.totality)
        self.totality_nsprefix_ = None
        self.PhysicalDataSetStructure_structures_PhysicalDataSet = PhysicalDataSetStructure_structures_PhysicalDataSet
        self.PhysicalDataSetStructure_structures_PhysicalDataSet_nsprefix_ = None
        if PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship is None:
            self.PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship = []
        else:
            self.PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship = PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship
        self.PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalDataSetStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalDataSetStructure.subclass:
            return PhysicalDataSetStructure.subclass(*args_, **kwargs_)
        else:
            return PhysicalDataSetStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_specification(self):
        return self.specification
    def set_specification(self, specification):
        self.specification = specification
    def get_topology(self):
        return self.topology
    def set_topology(self, topology):
        self.topology = topology
    def get_totality(self):
        return self.totality
    def set_totality(self, totality):
        self.totality = totality
    def get_PhysicalDataSetStructure_structures_PhysicalDataSet(self):
        return self.PhysicalDataSetStructure_structures_PhysicalDataSet
    def set_PhysicalDataSetStructure_structures_PhysicalDataSet(self, PhysicalDataSetStructure_structures_PhysicalDataSet):
        self.PhysicalDataSetStructure_structures_PhysicalDataSet = PhysicalDataSetStructure_structures_PhysicalDataSet
    def get_PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship(self):
        return self.PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship
    def set_PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship(self, PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship):
        self.PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship = PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship
    def add_PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship(self, value):
        self.PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship.append(value)
    def insert_PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_at(self, index, value):
        self.PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship.insert(index, value)
    def replace_PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_at(self, index, value):
        self.PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship[index] = value
    def validate_StructureExtent(self, value):
        result = True
        # Validate type StructureExtent, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Partial', 'Total']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StructureExtent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.identifier is not None or
            self.name is not None or
            self.purpose is not None or
            self.semantics is not None or
            self.specification is not None or
            self.topology is not None or
            self.totality is not None or
            self.PhysicalDataSetStructure_structures_PhysicalDataSet is not None or
            self.PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalDataSetStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.name is not None:
            name_ = self.name
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.specification is not None:
            specification_ = self.specification
            specification_.to_etree(element, name_='specification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.topology is not None:
            topology_ = self.topology
            topology_.to_etree(element, name_='topology', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.totality is not None:
            totality_ = self.totality
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}totality').text = self.gds_format_string(totality_)
        if self.PhysicalDataSetStructure_structures_PhysicalDataSet is not None:
            PhysicalDataSetStructure_structures_PhysicalDataSet_ = self.PhysicalDataSetStructure_structures_PhysicalDataSet
            PhysicalDataSetStructure_structures_PhysicalDataSet_.to_etree(element, name_='PhysicalDataSetStructure_structures_PhysicalDataSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_ in self.PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship:
            PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship_.to_etree(element, name_='PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'specification':
            obj_ = StructureSpecification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specification = obj_
            obj_.original_tagname_ = 'specification'
        elif nodeName_ == 'topology':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.topology = obj_
            obj_.original_tagname_ = 'topology'
        elif nodeName_ == 'totality':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totality')
            value_ = self.gds_validate_string(value_, node, 'totality')
            self.totality = value_
            self.totality_nsprefix_ = child_.prefix
            # validate type StructureExtent
            self.validate_StructureExtent(self.totality)
        elif nodeName_ == 'PhysicalDataSetStructure_structures_PhysicalDataSet':
            obj_ = PhysicalDataSetStructure_structures_PhysicalDataSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalDataSetStructure_structures_PhysicalDataSet = obj_
            obj_.original_tagname_ = 'PhysicalDataSetStructure_structures_PhysicalDataSet'
        elif nodeName_ == 'PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship':
            obj_ = PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationshipType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship.append(obj_)
            obj_.original_tagname_ = 'PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationship'
# end class PhysicalDataSetStructure


class PhysicalLayoutRelationStructure(GeneratedsSuper):
    """criteria -- Intentional definition of the order criteria (e.g. alphabetical, numerical, increasing, decreasing, etc.).
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- A linguistic signifier. Human understandable name (word, phrase, or mnemonic) that reflects the ISO/IEC 11179-5 naming principles. If more than one name is provided then a context to differentiate usage must be provided as well.
    purpose -- Intent or reason for the object/the description of the object.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    specification -- Provides information on reflexivity, transitivity, and symmetry of relationship using a descriptive term from an enumerated list. Use if all relations within this relation structure are of the same specification.
    topology -- Indicates the form of the associations among members of the collection. Specifies the way in which constituent parts are interrelated or arranged.
    totality -- Indicates whether the related collections are comprehensive in terms of their coverage.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, criteria=None, identifier=None, name=None, purpose=None, semantics=None, specification=None, topology=None, totality=None, PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout=None, PhysicalLayoutRelationStructure_has_ValueMappingRelationship=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.criteria = criteria
        self.criteria_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        self.specification = specification
        self.specification_nsprefix_ = None
        self.topology = topology
        self.topology_nsprefix_ = None
        self.totality = totality
        self.validate_StructureExtent(self.totality)
        self.totality_nsprefix_ = None
        self.PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout = PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout
        self.PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_nsprefix_ = None
        if PhysicalLayoutRelationStructure_has_ValueMappingRelationship is None:
            self.PhysicalLayoutRelationStructure_has_ValueMappingRelationship = []
        else:
            self.PhysicalLayoutRelationStructure_has_ValueMappingRelationship = PhysicalLayoutRelationStructure_has_ValueMappingRelationship
        self.PhysicalLayoutRelationStructure_has_ValueMappingRelationship_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalLayoutRelationStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalLayoutRelationStructure.subclass:
            return PhysicalLayoutRelationStructure.subclass(*args_, **kwargs_)
        else:
            return PhysicalLayoutRelationStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_criteria(self):
        return self.criteria
    def set_criteria(self, criteria):
        self.criteria = criteria
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_specification(self):
        return self.specification
    def set_specification(self, specification):
        self.specification = specification
    def get_topology(self):
        return self.topology
    def set_topology(self, topology):
        self.topology = topology
    def get_totality(self):
        return self.totality
    def set_totality(self, totality):
        self.totality = totality
    def get_PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout(self):
        return self.PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout
    def set_PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout(self, PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout):
        self.PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout = PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout
    def get_PhysicalLayoutRelationStructure_has_ValueMappingRelationship(self):
        return self.PhysicalLayoutRelationStructure_has_ValueMappingRelationship
    def set_PhysicalLayoutRelationStructure_has_ValueMappingRelationship(self, PhysicalLayoutRelationStructure_has_ValueMappingRelationship):
        self.PhysicalLayoutRelationStructure_has_ValueMappingRelationship = PhysicalLayoutRelationStructure_has_ValueMappingRelationship
    def add_PhysicalLayoutRelationStructure_has_ValueMappingRelationship(self, value):
        self.PhysicalLayoutRelationStructure_has_ValueMappingRelationship.append(value)
    def insert_PhysicalLayoutRelationStructure_has_ValueMappingRelationship_at(self, index, value):
        self.PhysicalLayoutRelationStructure_has_ValueMappingRelationship.insert(index, value)
    def replace_PhysicalLayoutRelationStructure_has_ValueMappingRelationship_at(self, index, value):
        self.PhysicalLayoutRelationStructure_has_ValueMappingRelationship[index] = value
    def validate_StructureExtent(self, value):
        result = True
        # Validate type StructureExtent, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Partial', 'Total']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StructureExtent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.criteria is not None or
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.semantics is not None or
            self.specification is not None or
            self.topology is not None or
            self.totality is not None or
            self.PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout is not None or
            self.PhysicalLayoutRelationStructure_has_ValueMappingRelationship
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalLayoutRelationStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.criteria is not None:
            criteria_ = self.criteria
            criteria_.to_etree(element, name_='criteria', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.specification is not None:
            specification_ = self.specification
            specification_.to_etree(element, name_='specification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.topology is not None:
            topology_ = self.topology
            topology_.to_etree(element, name_='topology', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.totality is not None:
            totality_ = self.totality
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}totality').text = self.gds_format_string(totality_)
        if self.PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout is not None:
            PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_ = self.PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout
            PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout_.to_etree(element, name_='PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalLayoutRelationStructure_has_ValueMappingRelationship_ in self.PhysicalLayoutRelationStructure_has_ValueMappingRelationship:
            PhysicalLayoutRelationStructure_has_ValueMappingRelationship_.to_etree(element, name_='PhysicalLayoutRelationStructure_has_ValueMappingRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'criteria':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.criteria = obj_
            obj_.original_tagname_ = 'criteria'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'specification':
            obj_ = StructureSpecification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specification = obj_
            obj_.original_tagname_ = 'specification'
        elif nodeName_ == 'topology':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.topology = obj_
            obj_.original_tagname_ = 'topology'
        elif nodeName_ == 'totality':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totality')
            value_ = self.gds_validate_string(value_, node, 'totality')
            self.totality = value_
            self.totality_nsprefix_ = child_.prefix
            # validate type StructureExtent
            self.validate_StructureExtent(self.totality)
        elif nodeName_ == 'PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout':
            obj_ = PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayoutType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout = obj_
            obj_.original_tagname_ = 'PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayout'
        elif nodeName_ == 'PhysicalLayoutRelationStructure_has_ValueMappingRelationship':
            obj_ = PhysicalLayoutRelationStructure_has_ValueMappingRelationshipType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalLayoutRelationStructure_has_ValueMappingRelationship.append(obj_)
            obj_.original_tagname_ = 'PhysicalLayoutRelationStructure_has_ValueMappingRelationship'
# end class PhysicalLayoutRelationStructure


class PhysicalRecordSegment(GeneratedsSuper):
    """allowsDuplicates -- If value is False, the members are unique within the collection - if True, there may be duplicates. (Note that a mathematical
    “
    bag
    ”
    permits duplicates and is unordered - a
    “
    set
    ”
    does not have duplicates and may be ordered.)
    catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    physicalFileName -- Use when each physical segment is stored in its own file.
    purpose -- Intent or reason for the object/the description of the object.
    PhysicalRecordSegment_represents_Population -- A record segment may represent a specific population or sub-population within a larger set of segments. Allows for the identification of this filter for membership in the segment.
    PhysicalRecordSegment_isDefinedBy_Concept -- The conceptual basis for the collection of members.
    PhysicalRecordSegment_mapsTo_LogicalRecord -- Every data record has zero to many physical record segments. It is possible to describe a physical data product and its record segment(s) without reference to a data record.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, allowsDuplicates=None, catalogDetails=None, identifier=None, name=None, physicalFileName=None, purpose=None, PhysicalRecordSegment_represents_Population=None, PhysicalRecordSegment_isDefinedBy_Concept=None, PhysicalRecordSegment_has_PhysicalSegmentLayout=None, PhysicalRecordSegment_mapsTo_LogicalRecord=None, PhysicalRecordSegment_has_DataPointPosition=None, PhysicalRecordSegment_has_DataPoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.allowsDuplicates = allowsDuplicates
        self.allowsDuplicates_nsprefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.physicalFileName = physicalFileName
        self.physicalFileName_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.PhysicalRecordSegment_represents_Population = PhysicalRecordSegment_represents_Population
        self.PhysicalRecordSegment_represents_Population_nsprefix_ = None
        if PhysicalRecordSegment_isDefinedBy_Concept is None:
            self.PhysicalRecordSegment_isDefinedBy_Concept = []
        else:
            self.PhysicalRecordSegment_isDefinedBy_Concept = PhysicalRecordSegment_isDefinedBy_Concept
        self.PhysicalRecordSegment_isDefinedBy_Concept_nsprefix_ = None
        self.PhysicalRecordSegment_has_PhysicalSegmentLayout = PhysicalRecordSegment_has_PhysicalSegmentLayout
        self.PhysicalRecordSegment_has_PhysicalSegmentLayout_nsprefix_ = None
        self.PhysicalRecordSegment_mapsTo_LogicalRecord = PhysicalRecordSegment_mapsTo_LogicalRecord
        self.PhysicalRecordSegment_mapsTo_LogicalRecord_nsprefix_ = None
        if PhysicalRecordSegment_has_DataPointPosition is None:
            self.PhysicalRecordSegment_has_DataPointPosition = []
        else:
            self.PhysicalRecordSegment_has_DataPointPosition = PhysicalRecordSegment_has_DataPointPosition
        self.PhysicalRecordSegment_has_DataPointPosition_nsprefix_ = None
        if PhysicalRecordSegment_has_DataPoint is None:
            self.PhysicalRecordSegment_has_DataPoint = []
        else:
            self.PhysicalRecordSegment_has_DataPoint = PhysicalRecordSegment_has_DataPoint
        self.PhysicalRecordSegment_has_DataPoint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegment.subclass:
            return PhysicalRecordSegment.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_allowsDuplicates(self):
        return self.allowsDuplicates
    def set_allowsDuplicates(self, allowsDuplicates):
        self.allowsDuplicates = allowsDuplicates
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_physicalFileName(self):
        return self.physicalFileName
    def set_physicalFileName(self, physicalFileName):
        self.physicalFileName = physicalFileName
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_PhysicalRecordSegment_represents_Population(self):
        return self.PhysicalRecordSegment_represents_Population
    def set_PhysicalRecordSegment_represents_Population(self, PhysicalRecordSegment_represents_Population):
        self.PhysicalRecordSegment_represents_Population = PhysicalRecordSegment_represents_Population
    def get_PhysicalRecordSegment_isDefinedBy_Concept(self):
        return self.PhysicalRecordSegment_isDefinedBy_Concept
    def set_PhysicalRecordSegment_isDefinedBy_Concept(self, PhysicalRecordSegment_isDefinedBy_Concept):
        self.PhysicalRecordSegment_isDefinedBy_Concept = PhysicalRecordSegment_isDefinedBy_Concept
    def add_PhysicalRecordSegment_isDefinedBy_Concept(self, value):
        self.PhysicalRecordSegment_isDefinedBy_Concept.append(value)
    def insert_PhysicalRecordSegment_isDefinedBy_Concept_at(self, index, value):
        self.PhysicalRecordSegment_isDefinedBy_Concept.insert(index, value)
    def replace_PhysicalRecordSegment_isDefinedBy_Concept_at(self, index, value):
        self.PhysicalRecordSegment_isDefinedBy_Concept[index] = value
    def get_PhysicalRecordSegment_has_PhysicalSegmentLayout(self):
        return self.PhysicalRecordSegment_has_PhysicalSegmentLayout
    def set_PhysicalRecordSegment_has_PhysicalSegmentLayout(self, PhysicalRecordSegment_has_PhysicalSegmentLayout):
        self.PhysicalRecordSegment_has_PhysicalSegmentLayout = PhysicalRecordSegment_has_PhysicalSegmentLayout
    def get_PhysicalRecordSegment_mapsTo_LogicalRecord(self):
        return self.PhysicalRecordSegment_mapsTo_LogicalRecord
    def set_PhysicalRecordSegment_mapsTo_LogicalRecord(self, PhysicalRecordSegment_mapsTo_LogicalRecord):
        self.PhysicalRecordSegment_mapsTo_LogicalRecord = PhysicalRecordSegment_mapsTo_LogicalRecord
    def get_PhysicalRecordSegment_has_DataPointPosition(self):
        return self.PhysicalRecordSegment_has_DataPointPosition
    def set_PhysicalRecordSegment_has_DataPointPosition(self, PhysicalRecordSegment_has_DataPointPosition):
        self.PhysicalRecordSegment_has_DataPointPosition = PhysicalRecordSegment_has_DataPointPosition
    def add_PhysicalRecordSegment_has_DataPointPosition(self, value):
        self.PhysicalRecordSegment_has_DataPointPosition.append(value)
    def insert_PhysicalRecordSegment_has_DataPointPosition_at(self, index, value):
        self.PhysicalRecordSegment_has_DataPointPosition.insert(index, value)
    def replace_PhysicalRecordSegment_has_DataPointPosition_at(self, index, value):
        self.PhysicalRecordSegment_has_DataPointPosition[index] = value
    def get_PhysicalRecordSegment_has_DataPoint(self):
        return self.PhysicalRecordSegment_has_DataPoint
    def set_PhysicalRecordSegment_has_DataPoint(self, PhysicalRecordSegment_has_DataPoint):
        self.PhysicalRecordSegment_has_DataPoint = PhysicalRecordSegment_has_DataPoint
    def add_PhysicalRecordSegment_has_DataPoint(self, value):
        self.PhysicalRecordSegment_has_DataPoint.append(value)
    def insert_PhysicalRecordSegment_has_DataPoint_at(self, index, value):
        self.PhysicalRecordSegment_has_DataPoint.insert(index, value)
    def replace_PhysicalRecordSegment_has_DataPoint_at(self, index, value):
        self.PhysicalRecordSegment_has_DataPoint[index] = value
    def has__content(self):
        if (
            self.allowsDuplicates is not None or
            self.catalogDetails is not None or
            self.identifier is not None or
            self.name or
            self.physicalFileName is not None or
            self.purpose is not None or
            self.PhysicalRecordSegment_represents_Population is not None or
            self.PhysicalRecordSegment_isDefinedBy_Concept or
            self.PhysicalRecordSegment_has_PhysicalSegmentLayout is not None or
            self.PhysicalRecordSegment_mapsTo_LogicalRecord is not None or
            self.PhysicalRecordSegment_has_DataPointPosition or
            self.PhysicalRecordSegment_has_DataPoint
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegment', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.allowsDuplicates is not None:
            allowsDuplicates_ = self.allowsDuplicates
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}allowsDuplicates').text = self.gds_format_boolean(allowsDuplicates_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.physicalFileName is not None:
            physicalFileName_ = self.physicalFileName
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}physicalFileName').text = self.gds_format_string(physicalFileName_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.PhysicalRecordSegment_represents_Population is not None:
            PhysicalRecordSegment_represents_Population_ = self.PhysicalRecordSegment_represents_Population
            PhysicalRecordSegment_represents_Population_.to_etree(element, name_='PhysicalRecordSegment_represents_Population', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalRecordSegment_isDefinedBy_Concept_ in self.PhysicalRecordSegment_isDefinedBy_Concept:
            PhysicalRecordSegment_isDefinedBy_Concept_.to_etree(element, name_='PhysicalRecordSegment_isDefinedBy_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.PhysicalRecordSegment_has_PhysicalSegmentLayout is not None:
            PhysicalRecordSegment_has_PhysicalSegmentLayout_ = self.PhysicalRecordSegment_has_PhysicalSegmentLayout
            PhysicalRecordSegment_has_PhysicalSegmentLayout_.to_etree(element, name_='PhysicalRecordSegment_has_PhysicalSegmentLayout', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.PhysicalRecordSegment_mapsTo_LogicalRecord is not None:
            PhysicalRecordSegment_mapsTo_LogicalRecord_ = self.PhysicalRecordSegment_mapsTo_LogicalRecord
            PhysicalRecordSegment_mapsTo_LogicalRecord_.to_etree(element, name_='PhysicalRecordSegment_mapsTo_LogicalRecord', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalRecordSegment_has_DataPointPosition_ in self.PhysicalRecordSegment_has_DataPointPosition:
            PhysicalRecordSegment_has_DataPointPosition_.to_etree(element, name_='PhysicalRecordSegment_has_DataPointPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalRecordSegment_has_DataPoint_ in self.PhysicalRecordSegment_has_DataPoint:
            PhysicalRecordSegment_has_DataPoint_.to_etree(element, name_='PhysicalRecordSegment_has_DataPoint', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allowsDuplicates':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'allowsDuplicates')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowsDuplicates')
            self.allowsDuplicates = ival_
            self.allowsDuplicates_nsprefix_ = child_.prefix
        elif nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'physicalFileName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'physicalFileName')
            value_ = self.gds_validate_string(value_, node, 'physicalFileName')
            self.physicalFileName = value_
            self.physicalFileName_nsprefix_ = child_.prefix
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'PhysicalRecordSegment_represents_Population':
            obj_ = PhysicalRecordSegment_represents_PopulationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegment_represents_Population = obj_
            obj_.original_tagname_ = 'PhysicalRecordSegment_represents_Population'
        elif nodeName_ == 'PhysicalRecordSegment_isDefinedBy_Concept':
            obj_ = PhysicalRecordSegment_isDefinedBy_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegment_isDefinedBy_Concept.append(obj_)
            obj_.original_tagname_ = 'PhysicalRecordSegment_isDefinedBy_Concept'
        elif nodeName_ == 'PhysicalRecordSegment_has_PhysicalSegmentLayout':
            obj_ = PhysicalRecordSegment_has_PhysicalSegmentLayoutType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegment_has_PhysicalSegmentLayout = obj_
            obj_.original_tagname_ = 'PhysicalRecordSegment_has_PhysicalSegmentLayout'
        elif nodeName_ == 'PhysicalRecordSegment_mapsTo_LogicalRecord':
            obj_ = PhysicalRecordSegment_mapsTo_LogicalRecordType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegment_mapsTo_LogicalRecord = obj_
            obj_.original_tagname_ = 'PhysicalRecordSegment_mapsTo_LogicalRecord'
        elif nodeName_ == 'PhysicalRecordSegment_has_DataPointPosition':
            obj_ = PhysicalRecordSegment_has_DataPointPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegment_has_DataPointPosition.append(obj_)
            obj_.original_tagname_ = 'PhysicalRecordSegment_has_DataPointPosition'
        elif nodeName_ == 'PhysicalRecordSegment_has_DataPoint':
            obj_ = PhysicalRecordSegment_has_DataPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegment_has_DataPoint.append(obj_)
            obj_.original_tagname_ = 'PhysicalRecordSegment_has_DataPoint'
# end class PhysicalRecordSegment


class PhysicalRecordSegmentPosition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    value -- Index value of the member in an ordered array.
    PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment -- Assigns a position to a physical record segment within a physical record.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, value=None, PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment = PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment
        self.PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegmentPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegmentPosition.subclass:
            return PhysicalRecordSegmentPosition.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegmentPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment(self):
        return self.PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment
    def set_PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment(self, PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment):
        self.PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment = PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment
    def has__content(self):
        if (
            self.identifier is not None or
            self.value is not None or
            self.PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegmentPosition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_integer(value_)
        if self.PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment is not None:
            PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_ = self.PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment
            PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment_.to_etree(element, name_='PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
        elif nodeName_ == 'PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment':
            obj_ = PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment = obj_
            obj_.original_tagname_ = 'PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegment'
# end class PhysicalRecordSegmentPosition


class PhysicalRecordSegmentRelationship(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, semantics=None, PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment=None, PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        if PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment is None:
            self.PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment = []
        else:
            self.PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment = PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment
        self.PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_nsprefix_ = None
        self.PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment = PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment
        self.PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegmentRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegmentRelationship.subclass:
            return PhysicalRecordSegmentRelationship.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegmentRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment(self):
        return self.PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment
    def set_PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment(self, PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment):
        self.PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment = PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment
    def add_PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment(self, value):
        self.PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment.append(value)
    def insert_PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_at(self, index, value):
        self.PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment.insert(index, value)
    def replace_PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_at(self, index, value):
        self.PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment[index] = value
    def get_PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment(self):
        return self.PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment
    def set_PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment(self, PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment):
        self.PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment = PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment
    def has__content(self):
        if (
            self.identifier is not None or
            self.semantics is not None or
            self.PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment or
            self.PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegmentRelationship', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_ in self.PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment:
            PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment_.to_etree(element, name_='PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment is not None:
            PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_ = self.PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment
            PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment_.to_etree(element, name_='PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment':
            obj_ = PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment.append(obj_)
            obj_.original_tagname_ = 'PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegment'
        elif nodeName_ == 'PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment':
            obj_ = PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment = obj_
            obj_.original_tagname_ = 'PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegment'
# end class PhysicalRecordSegmentRelationship


class PhysicalRecordSegmentStructure(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- A linguistic signifier. Human understandable name (word, phrase, or mnemonic) that reflects the ISO/IEC 11179-5 naming principles.
    purpose -- Intent or reason for the object/the description of the object.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    specification -- Provides information on reflexivity, transitivity, and symmetry of relationship using a descriptive term from an enumerated list. Use if all relations within this relation structure are of the same specification.
    topology -- Indicates the form of the associations among members of the collection. Specifies the way in which constituent parts are interrelated or arranged.
    totality -- Indicates whether the related collections are comprehensive in terms of their coverage.
    PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment -- There may be cases where there is a more complex structure to a sequence of data points. A cell containing a list, for example, might be considered to have nested data points that are the elements of the list. (For simplicity's sake, each element of the list should be modeled as a data point if this is possible.)
    PhysicalRecordSegmentStructure_has_DataPointRelationship -- PhysicalRecordSegmentStructure has zero to many DataPointRelationships.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, name=None, purpose=None, semantics=None, specification=None, topology=None, totality=None, PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment=None, PhysicalRecordSegmentStructure_has_DataPointRelationship=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        self.specification = specification
        self.specification_nsprefix_ = None
        self.topology = topology
        self.topology_nsprefix_ = None
        self.totality = totality
        self.validate_StructureExtent(self.totality)
        self.totality_nsprefix_ = None
        self.PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment = PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment
        self.PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_nsprefix_ = None
        if PhysicalRecordSegmentStructure_has_DataPointRelationship is None:
            self.PhysicalRecordSegmentStructure_has_DataPointRelationship = []
        else:
            self.PhysicalRecordSegmentStructure_has_DataPointRelationship = PhysicalRecordSegmentStructure_has_DataPointRelationship
        self.PhysicalRecordSegmentStructure_has_DataPointRelationship_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegmentStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegmentStructure.subclass:
            return PhysicalRecordSegmentStructure.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegmentStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_specification(self):
        return self.specification
    def set_specification(self, specification):
        self.specification = specification
    def get_topology(self):
        return self.topology
    def set_topology(self, topology):
        self.topology = topology
    def get_totality(self):
        return self.totality
    def set_totality(self, totality):
        self.totality = totality
    def get_PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment(self):
        return self.PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment
    def set_PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment(self, PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment):
        self.PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment = PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment
    def get_PhysicalRecordSegmentStructure_has_DataPointRelationship(self):
        return self.PhysicalRecordSegmentStructure_has_DataPointRelationship
    def set_PhysicalRecordSegmentStructure_has_DataPointRelationship(self, PhysicalRecordSegmentStructure_has_DataPointRelationship):
        self.PhysicalRecordSegmentStructure_has_DataPointRelationship = PhysicalRecordSegmentStructure_has_DataPointRelationship
    def add_PhysicalRecordSegmentStructure_has_DataPointRelationship(self, value):
        self.PhysicalRecordSegmentStructure_has_DataPointRelationship.append(value)
    def insert_PhysicalRecordSegmentStructure_has_DataPointRelationship_at(self, index, value):
        self.PhysicalRecordSegmentStructure_has_DataPointRelationship.insert(index, value)
    def replace_PhysicalRecordSegmentStructure_has_DataPointRelationship_at(self, index, value):
        self.PhysicalRecordSegmentStructure_has_DataPointRelationship[index] = value
    def validate_StructureExtent(self, value):
        result = True
        # Validate type StructureExtent, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Partial', 'Total']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StructureExtent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.identifier is not None or
            self.name is not None or
            self.purpose is not None or
            self.semantics is not None or
            self.specification is not None or
            self.topology is not None or
            self.totality is not None or
            self.PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment is not None or
            self.PhysicalRecordSegmentStructure_has_DataPointRelationship
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegmentStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.name is not None:
            name_ = self.name
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.specification is not None:
            specification_ = self.specification
            specification_.to_etree(element, name_='specification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.topology is not None:
            topology_ = self.topology
            topology_.to_etree(element, name_='topology', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.totality is not None:
            totality_ = self.totality
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}totality').text = self.gds_format_string(totality_)
        if self.PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment is not None:
            PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_ = self.PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment
            PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment_.to_etree(element, name_='PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalRecordSegmentStructure_has_DataPointRelationship_ in self.PhysicalRecordSegmentStructure_has_DataPointRelationship:
            PhysicalRecordSegmentStructure_has_DataPointRelationship_.to_etree(element, name_='PhysicalRecordSegmentStructure_has_DataPointRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'specification':
            obj_ = StructureSpecification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specification = obj_
            obj_.original_tagname_ = 'specification'
        elif nodeName_ == 'topology':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.topology = obj_
            obj_.original_tagname_ = 'topology'
        elif nodeName_ == 'totality':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totality')
            value_ = self.gds_validate_string(value_, node, 'totality')
            self.totality = value_
            self.totality_nsprefix_ = child_.prefix
            # validate type StructureExtent
            self.validate_StructureExtent(self.totality)
        elif nodeName_ == 'PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment':
            obj_ = PhysicalRecordSegmentStructure_structures_PhysicalRecordSegmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment = obj_
            obj_.original_tagname_ = 'PhysicalRecordSegmentStructure_structures_PhysicalRecordSegment'
        elif nodeName_ == 'PhysicalRecordSegmentStructure_has_DataPointRelationship':
            obj_ = PhysicalRecordSegmentStructure_has_DataPointRelationshipType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalRecordSegmentStructure_has_DataPointRelationship.append(obj_)
            obj_.original_tagname_ = 'PhysicalRecordSegmentStructure_has_DataPointRelationship'
# end class PhysicalRecordSegmentStructure


class PhysicalSegmentLayout(GeneratedsSuper):
    """allowsDuplicates -- If value is False, the members are unique within the collection - if True, there may be duplicates. (Note that a mathematical
    “
    bag
    ”
    permits duplicates and is unordered - a
    “
    set
    ”
    does not have duplicates and may be ordered.)
    arrayBase -- The starting value for the numbering of cells, rows, columns, etc. when they constitute an ordered sequence (an array). Note that in DDI, this is typically either 0 or 1. In related W3C work (Model for Tabular Data and Metadata on the Web), they appear to standardize on 1 (see https://www.w3.org/TR/tabular-data-model/ 4.3 [Columns] and 4.4 [Rows]: "number - the position of the column amongst the columns for the associated table, starting from 1.")
    catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    commentPrefix -- A string used to indicate that an input line is a comment, a string which precedes a comment in the data file. From https://www.w3.org/TR/tabular-metadata/ 5.9 Dialect  commentPrefix: 'An atomic property that sets the comment prefix flag to the single provided value, which MUST be a string. The default is "#".'
    delimiter -- The Delimiting character in the data. Must be used if isDelimited is True. "The separator between cells, set by the delimiter property of a dialect description. The default is ,. See the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-data-model/#encoding). From the "CSV Dialect" specification (https://specs.frictionlessdata.io/csv-dialect/#specification): "delimiter: specifies a one-character string to use as the field separator. Default = ,."
    encoding -- The character encoding of the represented data. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 5.9 Dialect: "encoding - An atomic property that sets the encoding flag to the single provided string value, which MUST be a defined in [encoding]. The default is 'utf-8'." From the same W3C recommendation 7.2 Encoding: "CSV files should be encoded using UTF-8, and should be in Unicode Normal Form C as defined in [UAX15]. If a CSV file is not encoded using UTF-8, the encoding should be specified through the charset parameter in the Content-Type header."
    escapeCharacter -- "The string that is used to escape the quote character within escaped cells, or null" see https://www.w3.org/TR/tabular-data-model/#encoding. From https://www.w3.org/TR/tabular-metadata/ 5.9 Dialect "doubleQuote: A boolean atomic property that, if true, sets the escape character flag to ". If false, to \. The default is true." From http://specs.frictionlessdata.io/csv-dialect/ "doubleQuote: controls the handling of quotes inside fields. If true, two consecutive quotes should be interpreted as one. Default = true".
    hasHeader -- True if the file contains a header containing column names. From https://www.w3.org/TR/tabular-metadata/ 5.9 Dialect "header: A boolean atomic property that, if true, sets the header row count flag to 1, and if false to 0, unless headerRowCount is provided, in which case the value provided for the header property is ignored. The default is true." From http://specs.frictionlessdata.io/csv-dialect/ "header: indicates whether the file includes a header row. If true the first row in the file is a header row, not data. Default = true".
    headerIsCaseSensitive -- If True, the case of the labels in the header is significant. From the "CSV Dialect" specification (http://specs.frictionlessdata.io/csv-dialect/): "caseSensitiveHeader: indicates that case in the header is meaningful. For example, columns CAT and Cat should not be equated. Default = false."
    headerRowCount -- The number of lines in the header From https://www.w3.org/TR/tabular-metadata/ 5.9 Dialect "headerRowCount: A numeric atomic property that sets the header row count flag to the single provided value, which MUST be a non-negative integer. The default is 1."
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    isDelimited -- Indicates whether the data are in a delimited format. If "true," the format is delimited, and the isFixedWidth property must be set to "false." If not set to "true," the property isFixedWitdh must be set to "true."
    isFixedWidth -- Set to true if the file is fixed-width. If true, isDelimited must be set to false.
    lineTerminator -- The strings that can be used at the end of a row, set by the lineTerminators property of a dialect description. The default is [CRLF, LF]. See the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-data-model/#encoding) 5.9 Dialect "lineTerminators: An atomic property that sets the line terminators flag to either an array containing the single provided string value, or the provided array. The default is ['rn', 'n']." Also, from the "CSV Dialect" specification (http://specs.frictionlessdata.io/csv-dialect/): "lineTerminator: specifies the character sequence which should terminate rows. Default = rn."
    name -- A linguistic signifier. Human understandable name (word, phrase, or mnemonic) that reflects the ISO/IEC 11179-5 naming principles. If more than one name is provided provide a context to differentiate usage.
    nullSequence -- A string indicating a null value. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 4.3: "null: the string or strings which cause the value of cells having string value matching any of these values to be null." From the same source, Inherited 5.7: "null: An atomic property giving the string or strings used for null values within the data. If the string value of the cell is equal to any one of these values, the cell value is null. See Parsing Cells in [tabular-data-model] for more details. If not specified, the default for the null property is the empty string ''. The value of this property becomes the null annotation for the described column."
    overview -- Short natural language account of the information obtained from the combination of properties and relationships associated with an object.
    purpose -- Intent or reason for the object/the description of the object.
    quoteCharacter -- "The string that is used around escaped cells, or null, set by the quoteChar property of a dialect description. The default is ".". See W3C Recommendation "Model for Tabular Data and Metadata on the Web", https://www.w3.org/TR/tabular-data-model/#parsing. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 5.9 Dialect: "quoteChar: An atomic property that sets the quote character flag to the single provided value, which MUST be a string or null. If the value is null, the escape character flag is also set to null. The default is '"'." From the CSV Dialect specification (http://specs.frictionlessdata.io/csv-dialect/): "quoteChar: specifies a one-character string to use as the quoting character. Default = "."
    skipBlankRows -- If the value is True, blank rows are ignored. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 5.9 Dialect: "skipBlankRows: A boolean atomic property that sets the skip blank rows flag to the single provided boolean value. The default is false."
    skipDataColumns -- The number of columns to skip at the beginning of the row. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 5.9 Dialect: "skipColumns: A numeric atomic property that sets the skip columns flag to the single provided numeric value, which MUST be a non-negative integer. The default is 0." A value other than 0 will mean that the source numbers of columns will be different from their numbers.
    skipInitialSpace -- If the value is True, skip whitespace at the beginning of a line or following a delimiter. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 5.9 Dialect: "skipInitialSpace: A boolean atomic property that, if true, sets the trim flag to 'start' and if false, to false. If the trim property is provided, the skipInitialSpace property is ignored. The default is false." From the CSV Dialect specification (http://specs.frictionlessdata.io/csv-dialect/): "skipInitialSpace: specifies how to interpret whitespace which immediately follows a delimiter; if false, it means that whitespace immediately after a delimiter should be treated as part of the following field. Default = true."
    skipRows -- Number of input rows to skip preceding the header or data. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 5.9 Dialect: "skipRows: A numeric atomic property that sets the skip rows flag to the single provided numeric value, which MUST be a non-negative integer. The default is 0." A value greater than 0 will mean that the source numbers of rows will be different from their numbers.
    tableDirection -- Indicates the direction in which columns are arranged in each row. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/)  5.3.2: "tableDirection: An atomic property that MUST have a single string value that is one of 'rtl', 'ltr', or 'auto'. Indicates whether the tables in the group should be displayed with the first column on the right, on the left, or based on the first character in the table that has a specific direction. The value of this property becomes the value of the table direction annotation for all the tables in the table group. See Bidirectional Tables in [tabular-data-model] for details. The default value for this property is 'auto'."
    textDirection -- Indicates the reading order of text within cells. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) Inherited 5.7: "textDirection: An atomic property that MUST have a single string value that is one of 'ltr', 'rtl', 'auto' or 'inherit' (the default). Indicates whether the text within cells should be displayed as left-to-right text (ltr), as right-to-left text (rtl), according to the content of the cell (auto) or in the direction inherited from the table direction annotation of the table. The value of this property determines the text direction annotation for the column, and the text direction annotation for the cells within that column: if the value is inherit then the value of the text direction annotation is the value of the table direction annotation on the table, otherwise it is the value of this property. See Bidirectional Tables in [tabular-data-model] for details."
    treatConsecutiveDelimitersAsOne -- If the value is True, consecutive (adjacent) delimiters are treated as a single delimiter; if the value is False consecutive (adjacent) delimiters indicate a missing value.
    trim -- Specifies which spaces to remove from a data value (start, end, both, neither) From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 5.9 Dialect: "trim: An atomic property that, if the boolean true, sets the trim flag to true and if the boolean false to false. If the value provided is a string, sets the trim flag to the provided value, which MUST be one of 'true', 'false', 'start', or 'end'. The default is true."
    PhysicalSegmentLayout_isDefinedBy_Concept -- The conceptual basis for the collection of members.
    PhysicalSegmentLayout_formats_LogicalRecord -- Logical record physically represented by the physical layout.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, allowsDuplicates=None, arrayBase=None, catalogDetails=None, commentPrefix=None, delimiter=None, encoding=None, escapeCharacter=None, hasHeader=None, headerIsCaseSensitive=None, headerRowCount=None, identifier=None, isDelimited=None, isFixedWidth=None, lineTerminator=None, name=None, nullSequence=None, overview=None, purpose=None, quoteCharacter=None, skipBlankRows=None, skipDataColumns=None, skipInitialSpace=None, skipRows=None, tableDirection=None, textDirection=None, treatConsecutiveDelimitersAsOne=None, trim=None, PhysicalSegmentLayout_isDefinedBy_Concept=None, PhysicalSegmentLayout_formats_LogicalRecord=None, PhysicalSegmentLayout_has_ValueMapping=None, PhysicalSegmentLayout_has_ValueMappingPosition=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.allowsDuplicates = allowsDuplicates
        self.allowsDuplicates_nsprefix_ = None
        self.arrayBase = arrayBase
        self.arrayBase_nsprefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.commentPrefix = commentPrefix
        self.commentPrefix_nsprefix_ = None
        self.delimiter = delimiter
        self.delimiter_nsprefix_ = None
        self.encoding = encoding
        self.encoding_nsprefix_ = None
        self.escapeCharacter = escapeCharacter
        self.escapeCharacter_nsprefix_ = None
        self.hasHeader = hasHeader
        self.hasHeader_nsprefix_ = None
        self.headerIsCaseSensitive = headerIsCaseSensitive
        self.headerIsCaseSensitive_nsprefix_ = None
        self.headerRowCount = headerRowCount
        self.headerRowCount_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.isDelimited = isDelimited
        self.isDelimited_nsprefix_ = None
        self.isFixedWidth = isFixedWidth
        self.isFixedWidth_nsprefix_ = None
        if lineTerminator is None:
            self.lineTerminator = []
        else:
            self.lineTerminator = lineTerminator
        self.lineTerminator_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.nullSequence = nullSequence
        self.nullSequence_nsprefix_ = None
        self.overview = overview
        self.overview_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.quoteCharacter = quoteCharacter
        self.quoteCharacter_nsprefix_ = None
        self.skipBlankRows = skipBlankRows
        self.skipBlankRows_nsprefix_ = None
        self.skipDataColumns = skipDataColumns
        self.skipDataColumns_nsprefix_ = None
        self.skipInitialSpace = skipInitialSpace
        self.skipInitialSpace_nsprefix_ = None
        self.skipRows = skipRows
        self.skipRows_nsprefix_ = None
        self.tableDirection = tableDirection
        self.validate_TableDirectionValues(self.tableDirection)
        self.tableDirection_nsprefix_ = None
        self.textDirection = textDirection
        self.validate_TextDirectionValues(self.textDirection)
        self.textDirection_nsprefix_ = None
        self.treatConsecutiveDelimitersAsOne = treatConsecutiveDelimitersAsOne
        self.treatConsecutiveDelimitersAsOne_nsprefix_ = None
        self.trim = trim
        self.validate_TrimValues(self.trim)
        self.trim_nsprefix_ = None
        if PhysicalSegmentLayout_isDefinedBy_Concept is None:
            self.PhysicalSegmentLayout_isDefinedBy_Concept = []
        else:
            self.PhysicalSegmentLayout_isDefinedBy_Concept = PhysicalSegmentLayout_isDefinedBy_Concept
        self.PhysicalSegmentLayout_isDefinedBy_Concept_nsprefix_ = None
        self.PhysicalSegmentLayout_formats_LogicalRecord = PhysicalSegmentLayout_formats_LogicalRecord
        self.PhysicalSegmentLayout_formats_LogicalRecord_nsprefix_ = None
        if PhysicalSegmentLayout_has_ValueMapping is None:
            self.PhysicalSegmentLayout_has_ValueMapping = []
        else:
            self.PhysicalSegmentLayout_has_ValueMapping = PhysicalSegmentLayout_has_ValueMapping
        self.PhysicalSegmentLayout_has_ValueMapping_nsprefix_ = None
        if PhysicalSegmentLayout_has_ValueMappingPosition is None:
            self.PhysicalSegmentLayout_has_ValueMappingPosition = []
        else:
            self.PhysicalSegmentLayout_has_ValueMappingPosition = PhysicalSegmentLayout_has_ValueMappingPosition
        self.PhysicalSegmentLayout_has_ValueMappingPosition_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalSegmentLayout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalSegmentLayout.subclass:
            return PhysicalSegmentLayout.subclass(*args_, **kwargs_)
        else:
            return PhysicalSegmentLayout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_allowsDuplicates(self):
        return self.allowsDuplicates
    def set_allowsDuplicates(self, allowsDuplicates):
        self.allowsDuplicates = allowsDuplicates
    def get_arrayBase(self):
        return self.arrayBase
    def set_arrayBase(self, arrayBase):
        self.arrayBase = arrayBase
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_commentPrefix(self):
        return self.commentPrefix
    def set_commentPrefix(self, commentPrefix):
        self.commentPrefix = commentPrefix
    def get_delimiter(self):
        return self.delimiter
    def set_delimiter(self, delimiter):
        self.delimiter = delimiter
    def get_encoding(self):
        return self.encoding
    def set_encoding(self, encoding):
        self.encoding = encoding
    def get_escapeCharacter(self):
        return self.escapeCharacter
    def set_escapeCharacter(self, escapeCharacter):
        self.escapeCharacter = escapeCharacter
    def get_hasHeader(self):
        return self.hasHeader
    def set_hasHeader(self, hasHeader):
        self.hasHeader = hasHeader
    def get_headerIsCaseSensitive(self):
        return self.headerIsCaseSensitive
    def set_headerIsCaseSensitive(self, headerIsCaseSensitive):
        self.headerIsCaseSensitive = headerIsCaseSensitive
    def get_headerRowCount(self):
        return self.headerRowCount
    def set_headerRowCount(self, headerRowCount):
        self.headerRowCount = headerRowCount
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_isDelimited(self):
        return self.isDelimited
    def set_isDelimited(self, isDelimited):
        self.isDelimited = isDelimited
    def get_isFixedWidth(self):
        return self.isFixedWidth
    def set_isFixedWidth(self, isFixedWidth):
        self.isFixedWidth = isFixedWidth
    def get_lineTerminator(self):
        return self.lineTerminator
    def set_lineTerminator(self, lineTerminator):
        self.lineTerminator = lineTerminator
    def add_lineTerminator(self, value):
        self.lineTerminator.append(value)
    def insert_lineTerminator_at(self, index, value):
        self.lineTerminator.insert(index, value)
    def replace_lineTerminator_at(self, index, value):
        self.lineTerminator[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_nullSequence(self):
        return self.nullSequence
    def set_nullSequence(self, nullSequence):
        self.nullSequence = nullSequence
    def get_overview(self):
        return self.overview
    def set_overview(self, overview):
        self.overview = overview
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_quoteCharacter(self):
        return self.quoteCharacter
    def set_quoteCharacter(self, quoteCharacter):
        self.quoteCharacter = quoteCharacter
    def get_skipBlankRows(self):
        return self.skipBlankRows
    def set_skipBlankRows(self, skipBlankRows):
        self.skipBlankRows = skipBlankRows
    def get_skipDataColumns(self):
        return self.skipDataColumns
    def set_skipDataColumns(self, skipDataColumns):
        self.skipDataColumns = skipDataColumns
    def get_skipInitialSpace(self):
        return self.skipInitialSpace
    def set_skipInitialSpace(self, skipInitialSpace):
        self.skipInitialSpace = skipInitialSpace
    def get_skipRows(self):
        return self.skipRows
    def set_skipRows(self, skipRows):
        self.skipRows = skipRows
    def get_tableDirection(self):
        return self.tableDirection
    def set_tableDirection(self, tableDirection):
        self.tableDirection = tableDirection
    def get_textDirection(self):
        return self.textDirection
    def set_textDirection(self, textDirection):
        self.textDirection = textDirection
    def get_treatConsecutiveDelimitersAsOne(self):
        return self.treatConsecutiveDelimitersAsOne
    def set_treatConsecutiveDelimitersAsOne(self, treatConsecutiveDelimitersAsOne):
        self.treatConsecutiveDelimitersAsOne = treatConsecutiveDelimitersAsOne
    def get_trim(self):
        return self.trim
    def set_trim(self, trim):
        self.trim = trim
    def get_PhysicalSegmentLayout_isDefinedBy_Concept(self):
        return self.PhysicalSegmentLayout_isDefinedBy_Concept
    def set_PhysicalSegmentLayout_isDefinedBy_Concept(self, PhysicalSegmentLayout_isDefinedBy_Concept):
        self.PhysicalSegmentLayout_isDefinedBy_Concept = PhysicalSegmentLayout_isDefinedBy_Concept
    def add_PhysicalSegmentLayout_isDefinedBy_Concept(self, value):
        self.PhysicalSegmentLayout_isDefinedBy_Concept.append(value)
    def insert_PhysicalSegmentLayout_isDefinedBy_Concept_at(self, index, value):
        self.PhysicalSegmentLayout_isDefinedBy_Concept.insert(index, value)
    def replace_PhysicalSegmentLayout_isDefinedBy_Concept_at(self, index, value):
        self.PhysicalSegmentLayout_isDefinedBy_Concept[index] = value
    def get_PhysicalSegmentLayout_formats_LogicalRecord(self):
        return self.PhysicalSegmentLayout_formats_LogicalRecord
    def set_PhysicalSegmentLayout_formats_LogicalRecord(self, PhysicalSegmentLayout_formats_LogicalRecord):
        self.PhysicalSegmentLayout_formats_LogicalRecord = PhysicalSegmentLayout_formats_LogicalRecord
    def get_PhysicalSegmentLayout_has_ValueMapping(self):
        return self.PhysicalSegmentLayout_has_ValueMapping
    def set_PhysicalSegmentLayout_has_ValueMapping(self, PhysicalSegmentLayout_has_ValueMapping):
        self.PhysicalSegmentLayout_has_ValueMapping = PhysicalSegmentLayout_has_ValueMapping
    def add_PhysicalSegmentLayout_has_ValueMapping(self, value):
        self.PhysicalSegmentLayout_has_ValueMapping.append(value)
    def insert_PhysicalSegmentLayout_has_ValueMapping_at(self, index, value):
        self.PhysicalSegmentLayout_has_ValueMapping.insert(index, value)
    def replace_PhysicalSegmentLayout_has_ValueMapping_at(self, index, value):
        self.PhysicalSegmentLayout_has_ValueMapping[index] = value
    def get_PhysicalSegmentLayout_has_ValueMappingPosition(self):
        return self.PhysicalSegmentLayout_has_ValueMappingPosition
    def set_PhysicalSegmentLayout_has_ValueMappingPosition(self, PhysicalSegmentLayout_has_ValueMappingPosition):
        self.PhysicalSegmentLayout_has_ValueMappingPosition = PhysicalSegmentLayout_has_ValueMappingPosition
    def add_PhysicalSegmentLayout_has_ValueMappingPosition(self, value):
        self.PhysicalSegmentLayout_has_ValueMappingPosition.append(value)
    def insert_PhysicalSegmentLayout_has_ValueMappingPosition_at(self, index, value):
        self.PhysicalSegmentLayout_has_ValueMappingPosition.insert(index, value)
    def replace_PhysicalSegmentLayout_has_ValueMappingPosition_at(self, index, value):
        self.PhysicalSegmentLayout_has_ValueMappingPosition[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_TableDirectionValues(self, value):
        result = True
        # Validate type TableDirectionValues, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Auto', 'Ltr', 'Rtl']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TableDirectionValues' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TextDirectionValues(self, value):
        result = True
        # Validate type TextDirectionValues, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Auto', 'Inherit', 'Ltr', 'Rtl']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TextDirectionValues' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TrimValues(self, value):
        result = True
        # Validate type TrimValues, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Both', 'End', 'Neither', 'Start']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TrimValues' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.allowsDuplicates is not None or
            self.arrayBase is not None or
            self.catalogDetails is not None or
            self.commentPrefix is not None or
            self.delimiter is not None or
            self.encoding is not None or
            self.escapeCharacter is not None or
            self.hasHeader is not None or
            self.headerIsCaseSensitive is not None or
            self.headerRowCount is not None or
            self.identifier is not None or
            self.isDelimited is not None or
            self.isFixedWidth is not None or
            self.lineTerminator or
            self.name or
            self.nullSequence is not None or
            self.overview is not None or
            self.purpose is not None or
            self.quoteCharacter is not None or
            self.skipBlankRows is not None or
            self.skipDataColumns is not None or
            self.skipInitialSpace is not None or
            self.skipRows is not None or
            self.tableDirection is not None or
            self.textDirection is not None or
            self.treatConsecutiveDelimitersAsOne is not None or
            self.trim is not None or
            self.PhysicalSegmentLayout_isDefinedBy_Concept or
            self.PhysicalSegmentLayout_formats_LogicalRecord is not None or
            self.PhysicalSegmentLayout_has_ValueMapping or
            self.PhysicalSegmentLayout_has_ValueMappingPosition
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalSegmentLayout', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.allowsDuplicates is not None:
            allowsDuplicates_ = self.allowsDuplicates
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}allowsDuplicates').text = self.gds_format_boolean(allowsDuplicates_)
        if self.arrayBase is not None:
            arrayBase_ = self.arrayBase
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}arrayBase').text = self.gds_format_integer(arrayBase_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.commentPrefix is not None:
            commentPrefix_ = self.commentPrefix
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}commentPrefix').text = self.gds_format_string(commentPrefix_)
        if self.delimiter is not None:
            delimiter_ = self.delimiter
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}delimiter').text = self.gds_format_string(delimiter_)
        if self.encoding is not None:
            encoding_ = self.encoding
            encoding_.to_etree(element, name_='encoding', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.escapeCharacter is not None:
            escapeCharacter_ = self.escapeCharacter
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}escapeCharacter').text = self.gds_format_string(escapeCharacter_)
        if self.hasHeader is not None:
            hasHeader_ = self.hasHeader
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}hasHeader').text = self.gds_format_boolean(hasHeader_)
        if self.headerIsCaseSensitive is not None:
            headerIsCaseSensitive_ = self.headerIsCaseSensitive
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}headerIsCaseSensitive').text = self.gds_format_boolean(headerIsCaseSensitive_)
        if self.headerRowCount is not None:
            headerRowCount_ = self.headerRowCount
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}headerRowCount').text = self.gds_format_integer(headerRowCount_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isDelimited is not None:
            isDelimited_ = self.isDelimited
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isDelimited').text = self.gds_format_boolean(isDelimited_)
        if self.isFixedWidth is not None:
            isFixedWidth_ = self.isFixedWidth
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isFixedWidth').text = self.gds_format_boolean(isFixedWidth_)
        for lineTerminator_ in self.lineTerminator:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}lineTerminator').text = self.gds_format_string(lineTerminator_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.nullSequence is not None:
            nullSequence_ = self.nullSequence
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}nullSequence').text = self.gds_format_string(nullSequence_)
        if self.overview is not None:
            overview_ = self.overview
            overview_.to_etree(element, name_='overview', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.quoteCharacter is not None:
            quoteCharacter_ = self.quoteCharacter
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}quoteCharacter').text = self.gds_format_string(quoteCharacter_)
        if self.skipBlankRows is not None:
            skipBlankRows_ = self.skipBlankRows
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}skipBlankRows').text = self.gds_format_boolean(skipBlankRows_)
        if self.skipDataColumns is not None:
            skipDataColumns_ = self.skipDataColumns
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}skipDataColumns').text = self.gds_format_integer(skipDataColumns_)
        if self.skipInitialSpace is not None:
            skipInitialSpace_ = self.skipInitialSpace
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}skipInitialSpace').text = self.gds_format_boolean(skipInitialSpace_)
        if self.skipRows is not None:
            skipRows_ = self.skipRows
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}skipRows').text = self.gds_format_integer(skipRows_)
        if self.tableDirection is not None:
            tableDirection_ = self.tableDirection
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}tableDirection').text = self.gds_format_string(tableDirection_)
        if self.textDirection is not None:
            textDirection_ = self.textDirection
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}textDirection').text = self.gds_format_string(textDirection_)
        if self.treatConsecutiveDelimitersAsOne is not None:
            treatConsecutiveDelimitersAsOne_ = self.treatConsecutiveDelimitersAsOne
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}treatConsecutiveDelimitersAsOne').text = self.gds_format_boolean(treatConsecutiveDelimitersAsOne_)
        if self.trim is not None:
            trim_ = self.trim
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}trim').text = self.gds_format_string(trim_)
        for PhysicalSegmentLayout_isDefinedBy_Concept_ in self.PhysicalSegmentLayout_isDefinedBy_Concept:
            PhysicalSegmentLayout_isDefinedBy_Concept_.to_etree(element, name_='PhysicalSegmentLayout_isDefinedBy_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.PhysicalSegmentLayout_formats_LogicalRecord is not None:
            PhysicalSegmentLayout_formats_LogicalRecord_ = self.PhysicalSegmentLayout_formats_LogicalRecord
            PhysicalSegmentLayout_formats_LogicalRecord_.to_etree(element, name_='PhysicalSegmentLayout_formats_LogicalRecord', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalSegmentLayout_has_ValueMapping_ in self.PhysicalSegmentLayout_has_ValueMapping:
            PhysicalSegmentLayout_has_ValueMapping_.to_etree(element, name_='PhysicalSegmentLayout_has_ValueMapping', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PhysicalSegmentLayout_has_ValueMappingPosition_ in self.PhysicalSegmentLayout_has_ValueMappingPosition:
            PhysicalSegmentLayout_has_ValueMappingPosition_.to_etree(element, name_='PhysicalSegmentLayout_has_ValueMappingPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allowsDuplicates':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'allowsDuplicates')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowsDuplicates')
            self.allowsDuplicates = ival_
            self.allowsDuplicates_nsprefix_ = child_.prefix
        elif nodeName_ == 'arrayBase' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'arrayBase')
            ival_ = self.gds_validate_integer(ival_, node, 'arrayBase')
            self.arrayBase = ival_
            self.arrayBase_nsprefix_ = child_.prefix
        elif nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'commentPrefix':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'commentPrefix')
            value_ = self.gds_validate_string(value_, node, 'commentPrefix')
            self.commentPrefix = value_
            self.commentPrefix_nsprefix_ = child_.prefix
        elif nodeName_ == 'delimiter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'delimiter')
            value_ = self.gds_validate_string(value_, node, 'delimiter')
            self.delimiter = value_
            self.delimiter_nsprefix_ = child_.prefix
        elif nodeName_ == 'encoding':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encoding = obj_
            obj_.original_tagname_ = 'encoding'
        elif nodeName_ == 'escapeCharacter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'escapeCharacter')
            value_ = self.gds_validate_string(value_, node, 'escapeCharacter')
            self.escapeCharacter = value_
            self.escapeCharacter_nsprefix_ = child_.prefix
        elif nodeName_ == 'hasHeader':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'hasHeader')
            ival_ = self.gds_validate_boolean(ival_, node, 'hasHeader')
            self.hasHeader = ival_
            self.hasHeader_nsprefix_ = child_.prefix
        elif nodeName_ == 'headerIsCaseSensitive':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'headerIsCaseSensitive')
            ival_ = self.gds_validate_boolean(ival_, node, 'headerIsCaseSensitive')
            self.headerIsCaseSensitive = ival_
            self.headerIsCaseSensitive_nsprefix_ = child_.prefix
        elif nodeName_ == 'headerRowCount' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'headerRowCount')
            ival_ = self.gds_validate_integer(ival_, node, 'headerRowCount')
            self.headerRowCount = ival_
            self.headerRowCount_nsprefix_ = child_.prefix
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'isDelimited':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isDelimited')
            ival_ = self.gds_validate_boolean(ival_, node, 'isDelimited')
            self.isDelimited = ival_
            self.isDelimited_nsprefix_ = child_.prefix
        elif nodeName_ == 'isFixedWidth':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isFixedWidth')
            ival_ = self.gds_validate_boolean(ival_, node, 'isFixedWidth')
            self.isFixedWidth = ival_
            self.isFixedWidth_nsprefix_ = child_.prefix
        elif nodeName_ == 'lineTerminator':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lineTerminator')
            value_ = self.gds_validate_string(value_, node, 'lineTerminator')
            self.lineTerminator.append(value_)
            self.lineTerminator_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'nullSequence':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nullSequence')
            value_ = self.gds_validate_string(value_, node, 'nullSequence')
            self.nullSequence = value_
            self.nullSequence_nsprefix_ = child_.prefix
        elif nodeName_ == 'overview':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.overview = obj_
            obj_.original_tagname_ = 'overview'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'quoteCharacter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'quoteCharacter')
            value_ = self.gds_validate_string(value_, node, 'quoteCharacter')
            self.quoteCharacter = value_
            self.quoteCharacter_nsprefix_ = child_.prefix
        elif nodeName_ == 'skipBlankRows':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'skipBlankRows')
            ival_ = self.gds_validate_boolean(ival_, node, 'skipBlankRows')
            self.skipBlankRows = ival_
            self.skipBlankRows_nsprefix_ = child_.prefix
        elif nodeName_ == 'skipDataColumns' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'skipDataColumns')
            ival_ = self.gds_validate_integer(ival_, node, 'skipDataColumns')
            self.skipDataColumns = ival_
            self.skipDataColumns_nsprefix_ = child_.prefix
        elif nodeName_ == 'skipInitialSpace':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'skipInitialSpace')
            ival_ = self.gds_validate_boolean(ival_, node, 'skipInitialSpace')
            self.skipInitialSpace = ival_
            self.skipInitialSpace_nsprefix_ = child_.prefix
        elif nodeName_ == 'skipRows' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'skipRows')
            ival_ = self.gds_validate_integer(ival_, node, 'skipRows')
            self.skipRows = ival_
            self.skipRows_nsprefix_ = child_.prefix
        elif nodeName_ == 'tableDirection':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tableDirection')
            value_ = self.gds_validate_string(value_, node, 'tableDirection')
            self.tableDirection = value_
            self.tableDirection_nsprefix_ = child_.prefix
            # validate type TableDirectionValues
            self.validate_TableDirectionValues(self.tableDirection)
        elif nodeName_ == 'textDirection':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'textDirection')
            value_ = self.gds_validate_string(value_, node, 'textDirection')
            self.textDirection = value_
            self.textDirection_nsprefix_ = child_.prefix
            # validate type TextDirectionValues
            self.validate_TextDirectionValues(self.textDirection)
        elif nodeName_ == 'treatConsecutiveDelimitersAsOne':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'treatConsecutiveDelimitersAsOne')
            ival_ = self.gds_validate_boolean(ival_, node, 'treatConsecutiveDelimitersAsOne')
            self.treatConsecutiveDelimitersAsOne = ival_
            self.treatConsecutiveDelimitersAsOne_nsprefix_ = child_.prefix
        elif nodeName_ == 'trim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'trim')
            value_ = self.gds_validate_string(value_, node, 'trim')
            self.trim = value_
            self.trim_nsprefix_ = child_.prefix
            # validate type TrimValues
            self.validate_TrimValues(self.trim)
        elif nodeName_ == 'PhysicalSegmentLayout_isDefinedBy_Concept':
            obj_ = PhysicalSegmentLayout_isDefinedBy_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalSegmentLayout_isDefinedBy_Concept.append(obj_)
            obj_.original_tagname_ = 'PhysicalSegmentLayout_isDefinedBy_Concept'
        elif nodeName_ == 'PhysicalSegmentLayout_formats_LogicalRecord':
            obj_ = PhysicalSegmentLayout_formats_LogicalRecordType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalSegmentLayout_formats_LogicalRecord = obj_
            obj_.original_tagname_ = 'PhysicalSegmentLayout_formats_LogicalRecord'
        elif nodeName_ == 'PhysicalSegmentLayout_has_ValueMapping':
            obj_ = PhysicalSegmentLayout_has_ValueMappingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalSegmentLayout_has_ValueMapping.append(obj_)
            obj_.original_tagname_ = 'PhysicalSegmentLayout_has_ValueMapping'
        elif nodeName_ == 'PhysicalSegmentLayout_has_ValueMappingPosition':
            obj_ = PhysicalSegmentLayout_has_ValueMappingPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalSegmentLayout_has_ValueMappingPosition.append(obj_)
            obj_.original_tagname_ = 'PhysicalSegmentLayout_has_ValueMappingPosition'
# end class PhysicalSegmentLayout


class PhysicalSegmentLocation(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, identifier=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalSegmentLocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalSegmentLocation.subclass:
            return PhysicalSegmentLocation.subclass(*args_, **kwargs_)
        else:
            return PhysicalSegmentLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.identifier is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalSegmentLocation', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
# end class PhysicalSegmentLocation


class PrimaryKey(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, PrimaryKey_isComposedOf_PrimaryKeyComponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if PrimaryKey_isComposedOf_PrimaryKeyComponent is None:
            self.PrimaryKey_isComposedOf_PrimaryKeyComponent = []
        else:
            self.PrimaryKey_isComposedOf_PrimaryKeyComponent = PrimaryKey_isComposedOf_PrimaryKeyComponent
        self.PrimaryKey_isComposedOf_PrimaryKeyComponent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrimaryKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrimaryKey.subclass:
            return PrimaryKey.subclass(*args_, **kwargs_)
        else:
            return PrimaryKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_PrimaryKey_isComposedOf_PrimaryKeyComponent(self):
        return self.PrimaryKey_isComposedOf_PrimaryKeyComponent
    def set_PrimaryKey_isComposedOf_PrimaryKeyComponent(self, PrimaryKey_isComposedOf_PrimaryKeyComponent):
        self.PrimaryKey_isComposedOf_PrimaryKeyComponent = PrimaryKey_isComposedOf_PrimaryKeyComponent
    def add_PrimaryKey_isComposedOf_PrimaryKeyComponent(self, value):
        self.PrimaryKey_isComposedOf_PrimaryKeyComponent.append(value)
    def insert_PrimaryKey_isComposedOf_PrimaryKeyComponent_at(self, index, value):
        self.PrimaryKey_isComposedOf_PrimaryKeyComponent.insert(index, value)
    def replace_PrimaryKey_isComposedOf_PrimaryKeyComponent_at(self, index, value):
        self.PrimaryKey_isComposedOf_PrimaryKeyComponent[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.PrimaryKey_isComposedOf_PrimaryKeyComponent
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PrimaryKey', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for PrimaryKey_isComposedOf_PrimaryKeyComponent_ in self.PrimaryKey_isComposedOf_PrimaryKeyComponent:
            PrimaryKey_isComposedOf_PrimaryKeyComponent_.to_etree(element, name_='PrimaryKey_isComposedOf_PrimaryKeyComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'PrimaryKey_isComposedOf_PrimaryKeyComponent':
            obj_ = PrimaryKey_isComposedOf_PrimaryKeyComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrimaryKey_isComposedOf_PrimaryKeyComponent.append(obj_)
            obj_.original_tagname_ = 'PrimaryKey_isComposedOf_PrimaryKeyComponent'
# end class PrimaryKey


class PrimaryKeyComponent(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, PrimaryKeyComponent_correspondsTo_DataStructureComponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.PrimaryKeyComponent_correspondsTo_DataStructureComponent = PrimaryKeyComponent_correspondsTo_DataStructureComponent
        self.PrimaryKeyComponent_correspondsTo_DataStructureComponent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrimaryKeyComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrimaryKeyComponent.subclass:
            return PrimaryKeyComponent.subclass(*args_, **kwargs_)
        else:
            return PrimaryKeyComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_PrimaryKeyComponent_correspondsTo_DataStructureComponent(self):
        return self.PrimaryKeyComponent_correspondsTo_DataStructureComponent
    def set_PrimaryKeyComponent_correspondsTo_DataStructureComponent(self, PrimaryKeyComponent_correspondsTo_DataStructureComponent):
        self.PrimaryKeyComponent_correspondsTo_DataStructureComponent = PrimaryKeyComponent_correspondsTo_DataStructureComponent
    def has__content(self):
        if (
            self.identifier is not None or
            self.PrimaryKeyComponent_correspondsTo_DataStructureComponent is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PrimaryKeyComponent', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.PrimaryKeyComponent_correspondsTo_DataStructureComponent is not None:
            PrimaryKeyComponent_correspondsTo_DataStructureComponent_ = self.PrimaryKeyComponent_correspondsTo_DataStructureComponent
            PrimaryKeyComponent_correspondsTo_DataStructureComponent_.to_etree(element, name_='PrimaryKeyComponent_correspondsTo_DataStructureComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'PrimaryKeyComponent_correspondsTo_DataStructureComponent':
            obj_ = PrimaryKeyComponent_correspondsTo_DataStructureComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrimaryKeyComponent_correspondsTo_DataStructureComponent = obj_
            obj_.original_tagname_ = 'PrimaryKeyComponent_correspondsTo_DataStructureComponent'
# end class PrimaryKeyComponent


class ProcessingAgent(Agent):
    """ProcessingAgent_performs_Activity -- A processing agent performs an activity at the direction of control logic.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Agent
    def __init__(self, catalogDetails=None, identifier=None, image=None, purpose=None, ProcessingAgent_performs_Activity=None, ProcessingAgent_operatesOn_ProductionEnvironment=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ProcessingAgent"), self).__init__(catalogDetails, identifier, image, purpose, extensiontype_,  **kwargs_)
        if ProcessingAgent_performs_Activity is None:
            self.ProcessingAgent_performs_Activity = []
        else:
            self.ProcessingAgent_performs_Activity = ProcessingAgent_performs_Activity
        self.ProcessingAgent_performs_Activity_nsprefix_ = None
        if ProcessingAgent_operatesOn_ProductionEnvironment is None:
            self.ProcessingAgent_operatesOn_ProductionEnvironment = []
        else:
            self.ProcessingAgent_operatesOn_ProductionEnvironment = ProcessingAgent_operatesOn_ProductionEnvironment
        self.ProcessingAgent_operatesOn_ProductionEnvironment_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessingAgent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessingAgent.subclass:
            return ProcessingAgent.subclass(*args_, **kwargs_)
        else:
            return ProcessingAgent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ProcessingAgent_performs_Activity(self):
        return self.ProcessingAgent_performs_Activity
    def set_ProcessingAgent_performs_Activity(self, ProcessingAgent_performs_Activity):
        self.ProcessingAgent_performs_Activity = ProcessingAgent_performs_Activity
    def add_ProcessingAgent_performs_Activity(self, value):
        self.ProcessingAgent_performs_Activity.append(value)
    def insert_ProcessingAgent_performs_Activity_at(self, index, value):
        self.ProcessingAgent_performs_Activity.insert(index, value)
    def replace_ProcessingAgent_performs_Activity_at(self, index, value):
        self.ProcessingAgent_performs_Activity[index] = value
    def get_ProcessingAgent_operatesOn_ProductionEnvironment(self):
        return self.ProcessingAgent_operatesOn_ProductionEnvironment
    def set_ProcessingAgent_operatesOn_ProductionEnvironment(self, ProcessingAgent_operatesOn_ProductionEnvironment):
        self.ProcessingAgent_operatesOn_ProductionEnvironment = ProcessingAgent_operatesOn_ProductionEnvironment
    def add_ProcessingAgent_operatesOn_ProductionEnvironment(self, value):
        self.ProcessingAgent_operatesOn_ProductionEnvironment.append(value)
    def insert_ProcessingAgent_operatesOn_ProductionEnvironment_at(self, index, value):
        self.ProcessingAgent_operatesOn_ProductionEnvironment.insert(index, value)
    def replace_ProcessingAgent_operatesOn_ProductionEnvironment_at(self, index, value):
        self.ProcessingAgent_operatesOn_ProductionEnvironment[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.ProcessingAgent_performs_Activity or
            self.ProcessingAgent_operatesOn_ProductionEnvironment or
            super(ProcessingAgent, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ProcessingAgent', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(ProcessingAgent, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        for ProcessingAgent_performs_Activity_ in self.ProcessingAgent_performs_Activity:
            ProcessingAgent_performs_Activity_.to_etree(element, name_='ProcessingAgent_performs_Activity', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ProcessingAgent_operatesOn_ProductionEnvironment_ in self.ProcessingAgent_operatesOn_ProductionEnvironment:
            ProcessingAgent_operatesOn_ProductionEnvironment_.to_etree(element, name_='ProcessingAgent_operatesOn_ProductionEnvironment', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ProcessingAgent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ProcessingAgent_performs_Activity':
            obj_ = ProcessingAgent_performs_ActivityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ProcessingAgent_performs_Activity.append(obj_)
            obj_.original_tagname_ = 'ProcessingAgent_performs_Activity'
        elif nodeName_ == 'ProcessingAgent_operatesOn_ProductionEnvironment':
            obj_ = ProcessingAgent_operatesOn_ProductionEnvironmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ProcessingAgent_operatesOn_ProductionEnvironment.append(obj_)
            obj_.original_tagname_ = 'ProcessingAgent_operatesOn_ProductionEnvironment'
        super(ProcessingAgent, self)._buildChildren(child_, node, nodeName_, True)
# end class ProcessingAgent


class ProductionEnvironment(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductionEnvironment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductionEnvironment.subclass:
            return ProductionEnvironment.subclass(*args_, **kwargs_)
        else:
            return ProductionEnvironment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def has__content(self):
        if (
            self.identifier is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ProductionEnvironment', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
# end class ProductionEnvironment


class QualifiedMeasure(MeasureComponent):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MeasureComponent
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, name=None, QualifiedMeasure_refines_MeasureComponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QualifiedMeasure"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable, name,  **kwargs_)
        self.QualifiedMeasure_refines_MeasureComponent = QualifiedMeasure_refines_MeasureComponent
        self.QualifiedMeasure_refines_MeasureComponent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QualifiedMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QualifiedMeasure.subclass:
            return QualifiedMeasure.subclass(*args_, **kwargs_)
        else:
            return QualifiedMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_QualifiedMeasure_refines_MeasureComponent(self):
        return self.QualifiedMeasure_refines_MeasureComponent
    def set_QualifiedMeasure_refines_MeasureComponent(self, QualifiedMeasure_refines_MeasureComponent):
        self.QualifiedMeasure_refines_MeasureComponent = QualifiedMeasure_refines_MeasureComponent
    def has__content(self):
        if (
            self.QualifiedMeasure_refines_MeasureComponent is not None or
            super(QualifiedMeasure, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='QualifiedMeasure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(QualifiedMeasure, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.QualifiedMeasure_refines_MeasureComponent is not None:
            QualifiedMeasure_refines_MeasureComponent_ = self.QualifiedMeasure_refines_MeasureComponent
            QualifiedMeasure_refines_MeasureComponent_.to_etree(element, name_='QualifiedMeasure_refines_MeasureComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QualifiedMeasure, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'QualifiedMeasure_refines_MeasureComponent':
            obj_ = QualifiedMeasure_refines_MeasureComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.QualifiedMeasure_refines_MeasureComponent = obj_
            obj_.original_tagname_ = 'QualifiedMeasure_refines_MeasureComponent'
        super(QualifiedMeasure, self)._buildChildren(child_, node, nodeName_, True)
# end class QualifiedMeasure


class RecordRelation(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    displayLabel -- A human-readable display label for the object. Supports the use of multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    purpose -- Intent or reason for the object/the description of the object.
    usage -- Explanation of the ways in which the object is employed.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, displayLabel=None, identifier=None, purpose=None, usage=None, RecordRelation_maps_LogicalRecord=None, RecordRelation_has_InstanceVariableMap=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        if displayLabel is None:
            self.displayLabel = []
        else:
            self.displayLabel = displayLabel
        self.displayLabel_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.usage = usage
        self.usage_nsprefix_ = None
        if RecordRelation_maps_LogicalRecord is None:
            self.RecordRelation_maps_LogicalRecord = []
        else:
            self.RecordRelation_maps_LogicalRecord = RecordRelation_maps_LogicalRecord
        self.RecordRelation_maps_LogicalRecord_nsprefix_ = None
        if RecordRelation_has_InstanceVariableMap is None:
            self.RecordRelation_has_InstanceVariableMap = []
        else:
            self.RecordRelation_has_InstanceVariableMap = RecordRelation_has_InstanceVariableMap
        self.RecordRelation_has_InstanceVariableMap_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RecordRelation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RecordRelation.subclass:
            return RecordRelation.subclass(*args_, **kwargs_)
        else:
            return RecordRelation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def add_displayLabel(self, value):
        self.displayLabel.append(value)
    def insert_displayLabel_at(self, index, value):
        self.displayLabel.insert(index, value)
    def replace_displayLabel_at(self, index, value):
        self.displayLabel[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_RecordRelation_maps_LogicalRecord(self):
        return self.RecordRelation_maps_LogicalRecord
    def set_RecordRelation_maps_LogicalRecord(self, RecordRelation_maps_LogicalRecord):
        self.RecordRelation_maps_LogicalRecord = RecordRelation_maps_LogicalRecord
    def add_RecordRelation_maps_LogicalRecord(self, value):
        self.RecordRelation_maps_LogicalRecord.append(value)
    def insert_RecordRelation_maps_LogicalRecord_at(self, index, value):
        self.RecordRelation_maps_LogicalRecord.insert(index, value)
    def replace_RecordRelation_maps_LogicalRecord_at(self, index, value):
        self.RecordRelation_maps_LogicalRecord[index] = value
    def get_RecordRelation_has_InstanceVariableMap(self):
        return self.RecordRelation_has_InstanceVariableMap
    def set_RecordRelation_has_InstanceVariableMap(self, RecordRelation_has_InstanceVariableMap):
        self.RecordRelation_has_InstanceVariableMap = RecordRelation_has_InstanceVariableMap
    def add_RecordRelation_has_InstanceVariableMap(self, value):
        self.RecordRelation_has_InstanceVariableMap.append(value)
    def insert_RecordRelation_has_InstanceVariableMap_at(self, index, value):
        self.RecordRelation_has_InstanceVariableMap.insert(index, value)
    def replace_RecordRelation_has_InstanceVariableMap_at(self, index, value):
        self.RecordRelation_has_InstanceVariableMap[index] = value
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.displayLabel or
            self.identifier is not None or
            self.purpose is not None or
            self.usage is not None or
            self.RecordRelation_maps_LogicalRecord or
            self.RecordRelation_has_InstanceVariableMap
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RecordRelation', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for displayLabel_ in self.displayLabel:
            displayLabel_.to_etree(element, name_='displayLabel', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.usage is not None:
            usage_ = self.usage
            usage_.to_etree(element, name_='usage', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RecordRelation_maps_LogicalRecord_ in self.RecordRelation_maps_LogicalRecord:
            RecordRelation_maps_LogicalRecord_.to_etree(element, name_='RecordRelation_maps_LogicalRecord', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RecordRelation_has_InstanceVariableMap_ in self.RecordRelation_has_InstanceVariableMap:
            RecordRelation_has_InstanceVariableMap_.to_etree(element, name_='RecordRelation_has_InstanceVariableMap', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'displayLabel':
            obj_ = LabelForDisplay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayLabel.append(obj_)
            obj_.original_tagname_ = 'displayLabel'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'usage':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.usage = obj_
            obj_.original_tagname_ = 'usage'
        elif nodeName_ == 'RecordRelation_maps_LogicalRecord':
            obj_ = RecordRelation_maps_LogicalRecordType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RecordRelation_maps_LogicalRecord.append(obj_)
            obj_.original_tagname_ = 'RecordRelation_maps_LogicalRecord'
        elif nodeName_ == 'RecordRelation_has_InstanceVariableMap':
            obj_ = RecordRelation_has_InstanceVariableMapType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RecordRelation_has_InstanceVariableMap.append(obj_)
            obj_.original_tagname_ = 'RecordRelation_has_InstanceVariableMap'
# end class RecordRelation


class ReferenceValue(InstanceValue):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = InstanceValue
    def __init__(self, content=None, identifier=None, whiteSpace=None, InstanceValue_hasValueFrom_ValueDomain=None, InstanceValue_isStoredIn_DataPoint=None, InstanceValue_represents_ConceptualValue=None, ReferenceValue_correspondsTo_VariableValueComponent=None, ReferenceValue_hasValueFrom_ReferenceValueDomain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReferenceValue"), self).__init__(content, identifier, whiteSpace, InstanceValue_hasValueFrom_ValueDomain, InstanceValue_isStoredIn_DataPoint, InstanceValue_represents_ConceptualValue,  **kwargs_)
        self.ReferenceValue_correspondsTo_VariableValueComponent = ReferenceValue_correspondsTo_VariableValueComponent
        self.ReferenceValue_correspondsTo_VariableValueComponent_nsprefix_ = None
        self.ReferenceValue_hasValueFrom_ReferenceValueDomain = ReferenceValue_hasValueFrom_ReferenceValueDomain
        self.ReferenceValue_hasValueFrom_ReferenceValueDomain_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceValue.subclass:
            return ReferenceValue.subclass(*args_, **kwargs_)
        else:
            return ReferenceValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ReferenceValue_correspondsTo_VariableValueComponent(self):
        return self.ReferenceValue_correspondsTo_VariableValueComponent
    def set_ReferenceValue_correspondsTo_VariableValueComponent(self, ReferenceValue_correspondsTo_VariableValueComponent):
        self.ReferenceValue_correspondsTo_VariableValueComponent = ReferenceValue_correspondsTo_VariableValueComponent
    def get_ReferenceValue_hasValueFrom_ReferenceValueDomain(self):
        return self.ReferenceValue_hasValueFrom_ReferenceValueDomain
    def set_ReferenceValue_hasValueFrom_ReferenceValueDomain(self, ReferenceValue_hasValueFrom_ReferenceValueDomain):
        self.ReferenceValue_hasValueFrom_ReferenceValueDomain = ReferenceValue_hasValueFrom_ReferenceValueDomain
    def has__content(self):
        if (
            self.ReferenceValue_correspondsTo_VariableValueComponent is not None or
            self.ReferenceValue_hasValueFrom_ReferenceValueDomain is not None or
            super(ReferenceValue, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ReferenceValue', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(ReferenceValue, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.ReferenceValue_correspondsTo_VariableValueComponent is not None:
            ReferenceValue_correspondsTo_VariableValueComponent_ = self.ReferenceValue_correspondsTo_VariableValueComponent
            ReferenceValue_correspondsTo_VariableValueComponent_.to_etree(element, name_='ReferenceValue_correspondsTo_VariableValueComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ReferenceValue_hasValueFrom_ReferenceValueDomain is not None:
            ReferenceValue_hasValueFrom_ReferenceValueDomain_ = self.ReferenceValue_hasValueFrom_ReferenceValueDomain
            ReferenceValue_hasValueFrom_ReferenceValueDomain_.to_etree(element, name_='ReferenceValue_hasValueFrom_ReferenceValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReferenceValue, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ReferenceValue_correspondsTo_VariableValueComponent':
            obj_ = ReferenceValue_correspondsTo_VariableValueComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReferenceValue_correspondsTo_VariableValueComponent = obj_
            obj_.original_tagname_ = 'ReferenceValue_correspondsTo_VariableValueComponent'
        elif nodeName_ == 'ReferenceValue_hasValueFrom_ReferenceValueDomain':
            obj_ = ReferenceValue_hasValueFrom_ReferenceValueDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReferenceValue_hasValueFrom_ReferenceValueDomain = obj_
            obj_.original_tagname_ = 'ReferenceValue_hasValueFrom_ReferenceValueDomain'
        super(ReferenceValue, self)._buildChildren(child_, node, nodeName_, True)
# end class ReferenceValue


class RepresentedVariable(ConceptualVariable):
    """describedUnitOfMeasure -- The unit in which the data values are measured (kg, pound, euro), expressed as a value from a controlled system of entries (i.e., QDT). Supports the provision of an identifier for the entry in the authoritative source (a URI, etc.), and the specific vocabulary.
    hasIntendedDataType -- The data type intended to be used by this variable. Supports the optional use of an external controlled vocabulary.
    simpleUnitOfMeasure -- The unit in which the data values are measured (kg, pound, euro), expressed as a simple string, in cases where no additional information is available (in the legacy system) or needed (as in the case of broad agreement within the community of use [i.e., ISO country codes, currencies, etc. in SDMX])
    RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain -- A represented variable may have more than one sets of sentinel value domains, one for each type of software platform on which related instance variables might be instantiated. All of the sentinel value domains must have sentinel conceptual domains that correspond exactly. This allows codes for missing values to be explicitly matched across platforms.
    RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain -- The substantive representation (substantive value domain) of the variable. This is equivalent to the relationship "Measures" in the Generic Statistical Information Model (GSIM) although GSIM makes no distinction between substantive and sentinel values.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ConceptualVariable
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, externalDefinition=None, identifier=None, name=None, Concept_uses_Concept=None, descriptiveText=None, unitOfMeasureKind=None, ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain=None, ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain=None, ConceptualVariable_measures_UnitType=None, describedUnitOfMeasure=None, hasIntendedDataType=None, simpleUnitOfMeasure=None, RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain=None, RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RepresentedVariable"), self).__init__(catalogDetails, definition, displayLabel, externalDefinition, identifier, name, Concept_uses_Concept, descriptiveText, unitOfMeasureKind, ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain, ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain, ConceptualVariable_measures_UnitType, extensiontype_,  **kwargs_)
        self.describedUnitOfMeasure = describedUnitOfMeasure
        self.describedUnitOfMeasure_nsprefix_ = None
        self.hasIntendedDataType = hasIntendedDataType
        self.hasIntendedDataType_nsprefix_ = None
        self.simpleUnitOfMeasure = simpleUnitOfMeasure
        self.simpleUnitOfMeasure_nsprefix_ = None
        if RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain is None:
            self.RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain = []
        else:
            self.RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain = RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain
        self.RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_nsprefix_ = None
        self.RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain = RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain
        self.RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RepresentedVariable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RepresentedVariable.subclass:
            return RepresentedVariable.subclass(*args_, **kwargs_)
        else:
            return RepresentedVariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_describedUnitOfMeasure(self):
        return self.describedUnitOfMeasure
    def set_describedUnitOfMeasure(self, describedUnitOfMeasure):
        self.describedUnitOfMeasure = describedUnitOfMeasure
    def get_hasIntendedDataType(self):
        return self.hasIntendedDataType
    def set_hasIntendedDataType(self, hasIntendedDataType):
        self.hasIntendedDataType = hasIntendedDataType
    def get_simpleUnitOfMeasure(self):
        return self.simpleUnitOfMeasure
    def set_simpleUnitOfMeasure(self, simpleUnitOfMeasure):
        self.simpleUnitOfMeasure = simpleUnitOfMeasure
    def get_RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain(self):
        return self.RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain
    def set_RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain(self, RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain):
        self.RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain = RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain
    def add_RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain(self, value):
        self.RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain.append(value)
    def insert_RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_at(self, index, value):
        self.RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain.insert(index, value)
    def replace_RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_at(self, index, value):
        self.RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain[index] = value
    def get_RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain(self):
        return self.RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain
    def set_RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain(self, RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain):
        self.RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain = RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.describedUnitOfMeasure is not None or
            self.hasIntendedDataType is not None or
            self.simpleUnitOfMeasure is not None or
            self.RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain or
            self.RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain is not None or
            super(RepresentedVariable, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RepresentedVariable', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(RepresentedVariable, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.describedUnitOfMeasure is not None:
            describedUnitOfMeasure_ = self.describedUnitOfMeasure
            describedUnitOfMeasure_.to_etree(element, name_='describedUnitOfMeasure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.hasIntendedDataType is not None:
            hasIntendedDataType_ = self.hasIntendedDataType
            hasIntendedDataType_.to_etree(element, name_='hasIntendedDataType', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.simpleUnitOfMeasure is not None:
            simpleUnitOfMeasure_ = self.simpleUnitOfMeasure
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}simpleUnitOfMeasure').text = self.gds_format_string(simpleUnitOfMeasure_)
        for RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_ in self.RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain:
            RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain_.to_etree(element, name_='RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain is not None:
            RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_ = self.RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain
            RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain_.to_etree(element, name_='RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(RepresentedVariable, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'describedUnitOfMeasure':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.describedUnitOfMeasure = obj_
            obj_.original_tagname_ = 'describedUnitOfMeasure'
        elif nodeName_ == 'hasIntendedDataType':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.hasIntendedDataType = obj_
            obj_.original_tagname_ = 'hasIntendedDataType'
        elif nodeName_ == 'simpleUnitOfMeasure':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'simpleUnitOfMeasure')
            value_ = self.gds_validate_string(value_, node, 'simpleUnitOfMeasure')
            self.simpleUnitOfMeasure = value_
            self.simpleUnitOfMeasure_nsprefix_ = child_.prefix
        elif nodeName_ == 'RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain':
            obj_ = RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain.append(obj_)
            obj_.original_tagname_ = 'RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain'
        elif nodeName_ == 'RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain':
            obj_ = RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain = obj_
            obj_.original_tagname_ = 'RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain'
        super(RepresentedVariable, self)._buildChildren(child_, node, nodeName_, True)
# end class RepresentedVariable


class RevisableDatum(Datum):
    """vintage -- A revision sequence number for a datum.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Datum
    def __init__(self, catalogDetails=None, identifier=None, Datum_uses_Notation=None, Datum_denotes_ConceptualValue=None, Datum_uses_InstanceValue=None, Datum_isBoundedBy_InstanceVariable=None, vintage=None, RevisableDatum_correspondsTo_Revision=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RevisableDatum"), self).__init__(catalogDetails, identifier, Datum_uses_Notation, Datum_denotes_ConceptualValue, Datum_uses_InstanceValue, Datum_isBoundedBy_InstanceVariable,  **kwargs_)
        self.vintage = vintage
        self.vintage_nsprefix_ = None
        self.RevisableDatum_correspondsTo_Revision = RevisableDatum_correspondsTo_Revision
        self.RevisableDatum_correspondsTo_Revision_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RevisableDatum)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RevisableDatum.subclass:
            return RevisableDatum.subclass(*args_, **kwargs_)
        else:
            return RevisableDatum(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vintage(self):
        return self.vintage
    def set_vintage(self, vintage):
        self.vintage = vintage
    def get_RevisableDatum_correspondsTo_Revision(self):
        return self.RevisableDatum_correspondsTo_Revision
    def set_RevisableDatum_correspondsTo_Revision(self, RevisableDatum_correspondsTo_Revision):
        self.RevisableDatum_correspondsTo_Revision = RevisableDatum_correspondsTo_Revision
    def has__content(self):
        if (
            self.vintage is not None or
            self.RevisableDatum_correspondsTo_Revision is not None or
            super(RevisableDatum, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RevisableDatum', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(RevisableDatum, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.vintage is not None:
            vintage_ = self.vintage
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}vintage').text = self.gds_format_integer(vintage_)
        if self.RevisableDatum_correspondsTo_Revision is not None:
            RevisableDatum_correspondsTo_Revision_ = self.RevisableDatum_correspondsTo_Revision
            RevisableDatum_correspondsTo_Revision_.to_etree(element, name_='RevisableDatum_correspondsTo_Revision', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RevisableDatum, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vintage' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'vintage')
            ival_ = self.gds_validate_integer(ival_, node, 'vintage')
            self.vintage = ival_
            self.vintage_nsprefix_ = child_.prefix
        elif nodeName_ == 'RevisableDatum_correspondsTo_Revision':
            obj_ = RevisableDatum_correspondsTo_RevisionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RevisableDatum_correspondsTo_Revision = obj_
            obj_.original_tagname_ = 'RevisableDatum_correspondsTo_Revision'
        super(RevisableDatum, self)._buildChildren(child_, node, nodeName_, True)
# end class RevisableDatum


class Revision(GeneratedsSuper):
    """algorithm -- Actual code or reference to specific algorithm
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    overview -- Short natural language account of the information obtained from the combination of properties and relationships associated with an object.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, algorithm=None, identifier=None, overview=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.algorithm = algorithm
        self.algorithm_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.overview = overview
        self.overview_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Revision)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Revision.subclass:
            return Revision.subclass(*args_, **kwargs_)
        else:
            return Revision(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_algorithm(self):
        return self.algorithm
    def set_algorithm(self, algorithm):
        self.algorithm = algorithm
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_overview(self):
        return self.overview
    def set_overview(self, overview):
        self.overview = overview
    def has__content(self):
        if (
            self.algorithm is not None or
            self.identifier is not None or
            self.overview is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Revision', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.algorithm is not None:
            algorithm_ = self.algorithm
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}algorithm').text = self.gds_format_string(algorithm_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.overview is not None:
            overview_ = self.overview
            overview_.to_etree(element, name_='overview', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'algorithm':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'algorithm')
            value_ = self.gds_validate_string(value_, node, 'algorithm')
            self.algorithm = value_
            self.algorithm_nsprefix_ = child_.prefix
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'overview':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.overview = obj_
            obj_.original_tagname_ = 'overview'
# end class Revision


class Rule(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    Rule_hasPrecondition_ConditionalControlLogic -- The condition part of a rule is associated with conditonal control logic.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, Rule_hasPrecondition_ConditionalControlLogic=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if Rule_hasPrecondition_ConditionalControlLogic is None:
            self.Rule_hasPrecondition_ConditionalControlLogic = []
        else:
            self.Rule_hasPrecondition_ConditionalControlLogic = Rule_hasPrecondition_ConditionalControlLogic
        self.Rule_hasPrecondition_ConditionalControlLogic_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Rule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Rule.subclass:
            return Rule.subclass(*args_, **kwargs_)
        else:
            return Rule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_Rule_hasPrecondition_ConditionalControlLogic(self):
        return self.Rule_hasPrecondition_ConditionalControlLogic
    def set_Rule_hasPrecondition_ConditionalControlLogic(self, Rule_hasPrecondition_ConditionalControlLogic):
        self.Rule_hasPrecondition_ConditionalControlLogic = Rule_hasPrecondition_ConditionalControlLogic
    def add_Rule_hasPrecondition_ConditionalControlLogic(self, value):
        self.Rule_hasPrecondition_ConditionalControlLogic.append(value)
    def insert_Rule_hasPrecondition_ConditionalControlLogic_at(self, index, value):
        self.Rule_hasPrecondition_ConditionalControlLogic.insert(index, value)
    def replace_Rule_hasPrecondition_ConditionalControlLogic_at(self, index, value):
        self.Rule_hasPrecondition_ConditionalControlLogic[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.Rule_hasPrecondition_ConditionalControlLogic
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Rule', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Rule_hasPrecondition_ConditionalControlLogic_ in self.Rule_hasPrecondition_ConditionalControlLogic:
            Rule_hasPrecondition_ConditionalControlLogic_.to_etree(element, name_='Rule_hasPrecondition_ConditionalControlLogic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'Rule_hasPrecondition_ConditionalControlLogic':
            obj_ = Rule_hasPrecondition_ConditionalControlLogicType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Rule_hasPrecondition_ConditionalControlLogic.append(obj_)
            obj_.original_tagname_ = 'Rule_hasPrecondition_ConditionalControlLogic'
# end class Rule


class RuleBasedScheduling(NonDeterministicDeclarative):
    """schedulingType -- Indicated if rule-based scheduling is forward-chaining or backward-chaining.
    RuleBasedScheduling_has_RuleSet -- Rule sets are a component of rule based scheduling.
    RuleBasedScheduling_has_Curator -- Rule based scheduling has one or more curators. The curators may be commercial/off-the-shelf, open source and/or home grown. They are likely to be domain-specific which is why rule based scheduling might employ many.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NonDeterministicDeclarative
    def __init__(self, description=None, identifier=None, workflow=None, ControlLogic_informs_ProcessingAgent=None, ControlLogic_invokes_Activity=None, ControlLogic_hasSubControlLogic_ControlLogic=None, ControlLogic_has_InformationFlowDefinition=None, schedulingType=None, RuleBasedScheduling_has_RuleSet=None, RuleBasedScheduling_has_Curator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RuleBasedScheduling"), self).__init__(description, identifier, workflow, ControlLogic_informs_ProcessingAgent, ControlLogic_invokes_Activity, ControlLogic_hasSubControlLogic_ControlLogic, ControlLogic_has_InformationFlowDefinition,  **kwargs_)
        self.schedulingType = schedulingType
        self.validate_SchedulingStrategy(self.schedulingType)
        self.schedulingType_nsprefix_ = None
        if RuleBasedScheduling_has_RuleSet is None:
            self.RuleBasedScheduling_has_RuleSet = []
        else:
            self.RuleBasedScheduling_has_RuleSet = RuleBasedScheduling_has_RuleSet
        self.RuleBasedScheduling_has_RuleSet_nsprefix_ = None
        if RuleBasedScheduling_has_Curator is None:
            self.RuleBasedScheduling_has_Curator = []
        else:
            self.RuleBasedScheduling_has_Curator = RuleBasedScheduling_has_Curator
        self.RuleBasedScheduling_has_Curator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RuleBasedScheduling)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RuleBasedScheduling.subclass:
            return RuleBasedScheduling.subclass(*args_, **kwargs_)
        else:
            return RuleBasedScheduling(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_schedulingType(self):
        return self.schedulingType
    def set_schedulingType(self, schedulingType):
        self.schedulingType = schedulingType
    def get_RuleBasedScheduling_has_RuleSet(self):
        return self.RuleBasedScheduling_has_RuleSet
    def set_RuleBasedScheduling_has_RuleSet(self, RuleBasedScheduling_has_RuleSet):
        self.RuleBasedScheduling_has_RuleSet = RuleBasedScheduling_has_RuleSet
    def add_RuleBasedScheduling_has_RuleSet(self, value):
        self.RuleBasedScheduling_has_RuleSet.append(value)
    def insert_RuleBasedScheduling_has_RuleSet_at(self, index, value):
        self.RuleBasedScheduling_has_RuleSet.insert(index, value)
    def replace_RuleBasedScheduling_has_RuleSet_at(self, index, value):
        self.RuleBasedScheduling_has_RuleSet[index] = value
    def get_RuleBasedScheduling_has_Curator(self):
        return self.RuleBasedScheduling_has_Curator
    def set_RuleBasedScheduling_has_Curator(self, RuleBasedScheduling_has_Curator):
        self.RuleBasedScheduling_has_Curator = RuleBasedScheduling_has_Curator
    def add_RuleBasedScheduling_has_Curator(self, value):
        self.RuleBasedScheduling_has_Curator.append(value)
    def insert_RuleBasedScheduling_has_Curator_at(self, index, value):
        self.RuleBasedScheduling_has_Curator.insert(index, value)
    def replace_RuleBasedScheduling_has_Curator_at(self, index, value):
        self.RuleBasedScheduling_has_Curator[index] = value
    def validate_SchedulingStrategy(self, value):
        result = True
        # Validate type SchedulingStrategy, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['BackwardChaining', 'ForwardChaining']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SchedulingStrategy' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.schedulingType is not None or
            self.RuleBasedScheduling_has_RuleSet or
            self.RuleBasedScheduling_has_Curator or
            super(RuleBasedScheduling, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RuleBasedScheduling', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(RuleBasedScheduling, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.schedulingType is not None:
            schedulingType_ = self.schedulingType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}schedulingType').text = self.gds_format_string(schedulingType_)
        for RuleBasedScheduling_has_RuleSet_ in self.RuleBasedScheduling_has_RuleSet:
            RuleBasedScheduling_has_RuleSet_.to_etree(element, name_='RuleBasedScheduling_has_RuleSet', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RuleBasedScheduling_has_Curator_ in self.RuleBasedScheduling_has_Curator:
            RuleBasedScheduling_has_Curator_.to_etree(element, name_='RuleBasedScheduling_has_Curator', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RuleBasedScheduling, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'schedulingType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'schedulingType')
            value_ = self.gds_validate_string(value_, node, 'schedulingType')
            self.schedulingType = value_
            self.schedulingType_nsprefix_ = child_.prefix
            # validate type SchedulingStrategy
            self.validate_SchedulingStrategy(self.schedulingType)
        elif nodeName_ == 'RuleBasedScheduling_has_RuleSet':
            obj_ = RuleBasedScheduling_has_RuleSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RuleBasedScheduling_has_RuleSet.append(obj_)
            obj_.original_tagname_ = 'RuleBasedScheduling_has_RuleSet'
        elif nodeName_ == 'RuleBasedScheduling_has_Curator':
            obj_ = RuleBasedScheduling_has_CuratorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RuleBasedScheduling_has_Curator.append(obj_)
            obj_.original_tagname_ = 'RuleBasedScheduling_has_Curator'
        super(RuleBasedScheduling, self)._buildChildren(child_, node, nodeName_, True)
# end class RuleBasedScheduling


class RuleSet(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    RuleSet_has_Rule -- A rule is a member of a rule set.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, RuleSet_has_Rule=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if RuleSet_has_Rule is None:
            self.RuleSet_has_Rule = []
        else:
            self.RuleSet_has_Rule = RuleSet_has_Rule
        self.RuleSet_has_Rule_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RuleSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RuleSet.subclass:
            return RuleSet.subclass(*args_, **kwargs_)
        else:
            return RuleSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_RuleSet_has_Rule(self):
        return self.RuleSet_has_Rule
    def set_RuleSet_has_Rule(self, RuleSet_has_Rule):
        self.RuleSet_has_Rule = RuleSet_has_Rule
    def add_RuleSet_has_Rule(self, value):
        self.RuleSet_has_Rule.append(value)
    def insert_RuleSet_has_Rule_at(self, index, value):
        self.RuleSet_has_Rule.insert(index, value)
    def replace_RuleSet_has_Rule_at(self, index, value):
        self.RuleSet_has_Rule[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.RuleSet_has_Rule
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RuleSet', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for RuleSet_has_Rule_ in self.RuleSet_has_Rule:
            RuleSet_has_Rule_.to_etree(element, name_='RuleSet_has_Rule', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'RuleSet_has_Rule':
            obj_ = RuleSet_has_RuleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RuleSet_has_Rule.append(obj_)
            obj_.original_tagname_ = 'RuleSet_has_Rule'
# end class RuleSet


class ScopedMeasure(GeneratedsSuper):
    """frequency -- Time interval between successive measurements (i.e. applications) of a Scoped Measure.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    ScopedMeasure_circumscribes_DimensionalKeyDefinition -- A universe is specific to the specific cell associated with a scoped measure.
    ScopedMeasure_restricts_QualifiedMeasure -- A scoped measure resticts a qualified measure to a particular cell.
    ScopedMeasure_generates_RevisableDatum -- Scoped measure generates one revisable datum.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, frequency=None, identifier=None, ScopedMeasure_circumscribes_DimensionalKeyDefinition=None, ScopedMeasure_restricts_QualifiedMeasure=None, ScopedMeasure_generates_RevisableDatum=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.frequency = frequency
        self.frequency_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.ScopedMeasure_circumscribes_DimensionalKeyDefinition = ScopedMeasure_circumscribes_DimensionalKeyDefinition
        self.ScopedMeasure_circumscribes_DimensionalKeyDefinition_nsprefix_ = None
        self.ScopedMeasure_restricts_QualifiedMeasure = ScopedMeasure_restricts_QualifiedMeasure
        self.ScopedMeasure_restricts_QualifiedMeasure_nsprefix_ = None
        self.ScopedMeasure_generates_RevisableDatum = ScopedMeasure_generates_RevisableDatum
        self.ScopedMeasure_generates_RevisableDatum_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScopedMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScopedMeasure.subclass:
            return ScopedMeasure.subclass(*args_, **kwargs_)
        else:
            return ScopedMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_frequency(self):
        return self.frequency
    def set_frequency(self, frequency):
        self.frequency = frequency
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_ScopedMeasure_circumscribes_DimensionalKeyDefinition(self):
        return self.ScopedMeasure_circumscribes_DimensionalKeyDefinition
    def set_ScopedMeasure_circumscribes_DimensionalKeyDefinition(self, ScopedMeasure_circumscribes_DimensionalKeyDefinition):
        self.ScopedMeasure_circumscribes_DimensionalKeyDefinition = ScopedMeasure_circumscribes_DimensionalKeyDefinition
    def get_ScopedMeasure_restricts_QualifiedMeasure(self):
        return self.ScopedMeasure_restricts_QualifiedMeasure
    def set_ScopedMeasure_restricts_QualifiedMeasure(self, ScopedMeasure_restricts_QualifiedMeasure):
        self.ScopedMeasure_restricts_QualifiedMeasure = ScopedMeasure_restricts_QualifiedMeasure
    def get_ScopedMeasure_generates_RevisableDatum(self):
        return self.ScopedMeasure_generates_RevisableDatum
    def set_ScopedMeasure_generates_RevisableDatum(self, ScopedMeasure_generates_RevisableDatum):
        self.ScopedMeasure_generates_RevisableDatum = ScopedMeasure_generates_RevisableDatum
    def has__content(self):
        if (
            self.frequency is not None or
            self.identifier is not None or
            self.ScopedMeasure_circumscribes_DimensionalKeyDefinition is not None or
            self.ScopedMeasure_restricts_QualifiedMeasure is not None or
            self.ScopedMeasure_generates_RevisableDatum is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ScopedMeasure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.frequency is not None:
            frequency_ = self.frequency
            frequency_.to_etree(element, name_='frequency', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ScopedMeasure_circumscribes_DimensionalKeyDefinition is not None:
            ScopedMeasure_circumscribes_DimensionalKeyDefinition_ = self.ScopedMeasure_circumscribes_DimensionalKeyDefinition
            ScopedMeasure_circumscribes_DimensionalKeyDefinition_.to_etree(element, name_='ScopedMeasure_circumscribes_DimensionalKeyDefinition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ScopedMeasure_restricts_QualifiedMeasure is not None:
            ScopedMeasure_restricts_QualifiedMeasure_ = self.ScopedMeasure_restricts_QualifiedMeasure
            ScopedMeasure_restricts_QualifiedMeasure_.to_etree(element, name_='ScopedMeasure_restricts_QualifiedMeasure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ScopedMeasure_generates_RevisableDatum is not None:
            ScopedMeasure_generates_RevisableDatum_ = self.ScopedMeasure_generates_RevisableDatum
            ScopedMeasure_generates_RevisableDatum_.to_etree(element, name_='ScopedMeasure_generates_RevisableDatum', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'frequency':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.frequency = obj_
            obj_.original_tagname_ = 'frequency'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'ScopedMeasure_circumscribes_DimensionalKeyDefinition':
            obj_ = ScopedMeasure_circumscribes_DimensionalKeyDefinitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ScopedMeasure_circumscribes_DimensionalKeyDefinition = obj_
            obj_.original_tagname_ = 'ScopedMeasure_circumscribes_DimensionalKeyDefinition'
        elif nodeName_ == 'ScopedMeasure_restricts_QualifiedMeasure':
            obj_ = ScopedMeasure_restricts_QualifiedMeasureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ScopedMeasure_restricts_QualifiedMeasure = obj_
            obj_.original_tagname_ = 'ScopedMeasure_restricts_QualifiedMeasure'
        elif nodeName_ == 'ScopedMeasure_generates_RevisableDatum':
            obj_ = ScopedMeasure_generates_RevisableDatumType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ScopedMeasure_generates_RevisableDatum = obj_
            obj_.original_tagname_ = 'ScopedMeasure_generates_RevisableDatum'
# end class ScopedMeasure


class SegmentByText(PhysicalSegmentLocation):
    """characterLength -- The number of characters in the segment. The segment may include text from multiple lines of the resource. If it does, the length includes any line termination characters.
    endCharacterPosition -- The character position of the last character of the segment.  If endLine is specified, the count begins at character 1 of endLine. If startLine and endLine are not specified, the count begins at character 1 of the first line of the resource and the count includes any line termination characters. The resulting segment may include text from multiple lines of the resource.
    endLine -- The last line on which to count characters. If missing this defaults to startLine.
    startCharacterPosition -- The character position of the first character of the segment, with the count beginning at character 1 of startLine.
    startLine -- The line number, where 1 is the first line, on which to begin counting characters. If missing this defaults to 1 (the first line).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PhysicalSegmentLocation
    def __init__(self, catalogDetails=None, identifier=None, characterLength=None, endCharacterPosition=None, endLine=None, startCharacterPosition=None, startLine=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SegmentByText"), self).__init__(catalogDetails, identifier,  **kwargs_)
        self.characterLength = characterLength
        self.characterLength_nsprefix_ = None
        self.endCharacterPosition = endCharacterPosition
        self.endCharacterPosition_nsprefix_ = None
        self.endLine = endLine
        self.endLine_nsprefix_ = None
        self.startCharacterPosition = startCharacterPosition
        self.startCharacterPosition_nsprefix_ = None
        self.startLine = startLine
        self.startLine_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SegmentByText)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SegmentByText.subclass:
            return SegmentByText.subclass(*args_, **kwargs_)
        else:
            return SegmentByText(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_characterLength(self):
        return self.characterLength
    def set_characterLength(self, characterLength):
        self.characterLength = characterLength
    def get_endCharacterPosition(self):
        return self.endCharacterPosition
    def set_endCharacterPosition(self, endCharacterPosition):
        self.endCharacterPosition = endCharacterPosition
    def get_endLine(self):
        return self.endLine
    def set_endLine(self, endLine):
        self.endLine = endLine
    def get_startCharacterPosition(self):
        return self.startCharacterPosition
    def set_startCharacterPosition(self, startCharacterPosition):
        self.startCharacterPosition = startCharacterPosition
    def get_startLine(self):
        return self.startLine
    def set_startLine(self, startLine):
        self.startLine = startLine
    def has__content(self):
        if (
            self.characterLength is not None or
            self.endCharacterPosition is not None or
            self.endLine is not None or
            self.startCharacterPosition is not None or
            self.startLine is not None or
            super(SegmentByText, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SegmentByText', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(SegmentByText, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.characterLength is not None:
            characterLength_ = self.characterLength
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}characterLength').text = self.gds_format_integer(characterLength_)
        if self.endCharacterPosition is not None:
            endCharacterPosition_ = self.endCharacterPosition
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}endCharacterPosition').text = self.gds_format_integer(endCharacterPosition_)
        if self.endLine is not None:
            endLine_ = self.endLine
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}endLine').text = self.gds_format_integer(endLine_)
        if self.startCharacterPosition is not None:
            startCharacterPosition_ = self.startCharacterPosition
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}startCharacterPosition').text = self.gds_format_integer(startCharacterPosition_)
        if self.startLine is not None:
            startLine_ = self.startLine
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}startLine').text = self.gds_format_integer(startLine_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SegmentByText, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'characterLength' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'characterLength')
            ival_ = self.gds_validate_integer(ival_, node, 'characterLength')
            self.characterLength = ival_
            self.characterLength_nsprefix_ = child_.prefix
        elif nodeName_ == 'endCharacterPosition' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'endCharacterPosition')
            ival_ = self.gds_validate_integer(ival_, node, 'endCharacterPosition')
            self.endCharacterPosition = ival_
            self.endCharacterPosition_nsprefix_ = child_.prefix
        elif nodeName_ == 'endLine' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'endLine')
            ival_ = self.gds_validate_integer(ival_, node, 'endLine')
            self.endLine = ival_
            self.endLine_nsprefix_ = child_.prefix
        elif nodeName_ == 'startCharacterPosition' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'startCharacterPosition')
            ival_ = self.gds_validate_integer(ival_, node, 'startCharacterPosition')
            self.startCharacterPosition = ival_
            self.startCharacterPosition_nsprefix_ = child_.prefix
        elif nodeName_ == 'startLine' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'startLine')
            ival_ = self.gds_validate_integer(ival_, node, 'startLine')
            self.startLine = ival_
            self.startLine_nsprefix_ = child_.prefix
        super(SegmentByText, self)._buildChildren(child_, node, nodeName_, True)
# end class SegmentByText


class SentinelConceptualDomain(ConceptualDomain):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ConceptualDomain
    def __init__(self, catalogDetails=None, displayLabel=None, identifier=None, ConceptualDomain_isDescribedBy_ValueAndConceptDescription=None, ConceptualDomain_takesConceptsFrom_ConceptSystem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SentinelConceptualDomain"), self).__init__(catalogDetails, displayLabel, identifier, ConceptualDomain_isDescribedBy_ValueAndConceptDescription, ConceptualDomain_takesConceptsFrom_ConceptSystem,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SentinelConceptualDomain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SentinelConceptualDomain.subclass:
            return SentinelConceptualDomain.subclass(*args_, **kwargs_)
        else:
            return SentinelConceptualDomain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(SentinelConceptualDomain, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SentinelConceptualDomain', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(SentinelConceptualDomain, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SentinelConceptualDomain, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SentinelConceptualDomain, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SentinelConceptualDomain


class Sequence(DeterministicImperative):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DeterministicImperative
    def __init__(self, description=None, identifier=None, workflow=None, ControlLogic_informs_ProcessingAgent=None, ControlLogic_invokes_Activity=None, ControlLogic_hasSubControlLogic_ControlLogic=None, ControlLogic_has_InformationFlowDefinition=None, Sequence_has_SequencePosition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Sequence"), self).__init__(description, identifier, workflow, ControlLogic_informs_ProcessingAgent, ControlLogic_invokes_Activity, ControlLogic_hasSubControlLogic_ControlLogic, ControlLogic_has_InformationFlowDefinition,  **kwargs_)
        if Sequence_has_SequencePosition is None:
            self.Sequence_has_SequencePosition = []
        else:
            self.Sequence_has_SequencePosition = Sequence_has_SequencePosition
        self.Sequence_has_SequencePosition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Sequence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Sequence.subclass:
            return Sequence.subclass(*args_, **kwargs_)
        else:
            return Sequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Sequence_has_SequencePosition(self):
        return self.Sequence_has_SequencePosition
    def set_Sequence_has_SequencePosition(self, Sequence_has_SequencePosition):
        self.Sequence_has_SequencePosition = Sequence_has_SequencePosition
    def add_Sequence_has_SequencePosition(self, value):
        self.Sequence_has_SequencePosition.append(value)
    def insert_Sequence_has_SequencePosition_at(self, index, value):
        self.Sequence_has_SequencePosition.insert(index, value)
    def replace_Sequence_has_SequencePosition_at(self, index, value):
        self.Sequence_has_SequencePosition[index] = value
    def has__content(self):
        if (
            self.Sequence_has_SequencePosition or
            super(Sequence, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Sequence', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(Sequence, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        for Sequence_has_SequencePosition_ in self.Sequence_has_SequencePosition:
            Sequence_has_SequencePosition_.to_etree(element, name_='Sequence_has_SequencePosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Sequence, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Sequence_has_SequencePosition':
            obj_ = Sequence_has_SequencePositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Sequence_has_SequencePosition.append(obj_)
            obj_.original_tagname_ = 'Sequence_has_SequencePosition'
        super(Sequence, self)._buildChildren(child_, node, nodeName_, True)
# end class Sequence


class SequencePosition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    value -- Indexes the activities in a sequence using integers with a position indicated by incrementing upward from 0 or 1.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequencePosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequencePosition.subclass:
            return SequencePosition.subclass(*args_, **kwargs_)
        else:
            return SequencePosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SequencePosition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_integer(value_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
# end class SequencePosition


class Service(ProcessingAgent):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ProcessingAgent
    def __init__(self, catalogDetails=None, identifier=None, image=None, purpose=None, ProcessingAgent_performs_Activity=None, ProcessingAgent_operatesOn_ProductionEnvironment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Service"), self).__init__(catalogDetails, identifier, image, purpose, ProcessingAgent_performs_Activity, ProcessingAgent_operatesOn_ProductionEnvironment,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Service)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Service.subclass:
            return Service.subclass(*args_, **kwargs_)
        else:
            return Service(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(Service, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Service', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(Service, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Service, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(Service, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class Service


class StatisticalClassification(EnumerationDomain):
    """allowsDuplicates -- If value is False, the members are unique within the collection - if True, there may be duplicates. (Note that a mathematical
    “
    bag
    ”
    permits duplicates and is unordered - a
    “
    set
    ”
    does not have duplicates and may be ordered.)
    availableLanguage -- A list of languages in which the Statistical Classification is available. Supports the indication of multiple languages within a single property. Supports use of codes defined by the RFC 1766.
    catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    changeFromBase -- Describes the relationship between the variant and its base Statistical Classification, including regroupings, aggregations added and extensions. (Source: GSIM StatisticalClassification/Changes from base Statistical Classification).
    copyright -- Copyright of the statistical classification.
    displayLabel -- A human-readable display label for the object. Supports the use of multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.
    isCurrent -- Indicates if the statistical classification is currently valid.
    isFloating -- Indicates if the Statistical Classification is a floating classification. In a floating statistical classification, a validity period should be defined for all classification Items which will allow the display of the item structure and content at different points of time. (Source: GSIM StatisticalClassification/Floating).
    purposeOfVariant -- If the Statistical Classification is a variant, notes the specific purpose for which it was developed. (Source: GSIM StatisticalClassification/Purpose of variant).
    rationale -- Explanation of the reason(s) some decision was made or some object exists.
    releaseDate -- Date when the current version of the Statistical Classification was released.
    updateChanges -- Summary description of changes which have occurred since the most recent classification version or classification update came into force.
    usage -- Explanation of the ways in which the object is employed.
    validDates -- The dates describing the validity period of the object. The date from which the object became valid must be defined if the map belongs to a "floating" construct. The date at which the object became invalid must be defined if the map belongs to a "floating" construct and is no longer valid. Per the Generic Statistical Information Model, Statistical Classification: "The date the statistical classification enters production use and the date on which the Statistical Classification was superseded by a successor version or otherwise ceased to be valid."
    StatisticalClassification_isMaintainedBy_Organization -- Organization, agency, or group within an agency responsible for the maintenance and upkeep of the statistical classification.
    StatisticalClassification_isVariantOf_StatisticalClassification -- Statistical classification on which the current variant is based, and any subsequent versions of that statistical classification to which it is also applicable.
    StatisticalClassification_isSuccessorOf_StatisticalClassification -- Statistical classification preceded by the actual statistical classification (for those statistical classifications that are versions or updates).
    StatisticalClassification_isPredecessorOf_StatisticalClassification -- Statistical classification preceded by the actual statistical classification (for those statistical classifications that are versions or updates).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EnumerationDomain
    def __init__(self, identifier=None, name=None, purpose=None, EnumerationDomain_uses_LevelStructure=None, EnumerationDomain_references_CategorySet=None, EnumerationDomain_isDefinedBy_Concept=None, allowsDuplicates=None, availableLanguage=None, catalogDetails=None, changeFromBase=None, copyright=None, displayLabel=None, isCurrent=None, isFloating=None, purposeOfVariant=None, rationale=None, releaseDate=None, updateChanges=None, usage=None, validDates=None, StatisticalClassification_isMaintainedBy_Organization=None, StatisticalClassification_isIndexedBy_ClassificationIndex=None, StatisticalClassification_isVariantOf_StatisticalClassification=None, StatisticalClassification_isSuccessorOf_StatisticalClassification=None, StatisticalClassification_isPredecessorOf_StatisticalClassification=None, StatisticalClassification_has_ClassificationItemPosition=None, StatisticalClassification_has_ClassificationItem=None, StatisticalClassification_has_LevelStructure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("StatisticalClassification"), self).__init__(identifier, name, purpose, EnumerationDomain_uses_LevelStructure, EnumerationDomain_references_CategorySet, EnumerationDomain_isDefinedBy_Concept,  **kwargs_)
        self.allowsDuplicates = allowsDuplicates
        self.allowsDuplicates_nsprefix_ = None
        if availableLanguage is None:
            self.availableLanguage = []
        else:
            self.availableLanguage = availableLanguage
        self.availableLanguage_nsprefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.changeFromBase = changeFromBase
        self.changeFromBase_nsprefix_ = None
        if copyright is None:
            self.copyright = []
        else:
            self.copyright = copyright
        self.copyright_nsprefix_ = None
        if displayLabel is None:
            self.displayLabel = []
        else:
            self.displayLabel = displayLabel
        self.displayLabel_nsprefix_ = None
        self.isCurrent = isCurrent
        self.isCurrent_nsprefix_ = None
        self.isFloating = isFloating
        self.isFloating_nsprefix_ = None
        self.purposeOfVariant = purposeOfVariant
        self.purposeOfVariant_nsprefix_ = None
        self.rationale = rationale
        self.rationale_nsprefix_ = None
        self.releaseDate = releaseDate
        self.releaseDate_nsprefix_ = None
        if updateChanges is None:
            self.updateChanges = []
        else:
            self.updateChanges = updateChanges
        self.updateChanges_nsprefix_ = None
        self.usage = usage
        self.usage_nsprefix_ = None
        self.validDates = validDates
        self.validDates_nsprefix_ = None
        if StatisticalClassification_isMaintainedBy_Organization is None:
            self.StatisticalClassification_isMaintainedBy_Organization = []
        else:
            self.StatisticalClassification_isMaintainedBy_Organization = StatisticalClassification_isMaintainedBy_Organization
        self.StatisticalClassification_isMaintainedBy_Organization_nsprefix_ = None
        if StatisticalClassification_isIndexedBy_ClassificationIndex is None:
            self.StatisticalClassification_isIndexedBy_ClassificationIndex = []
        else:
            self.StatisticalClassification_isIndexedBy_ClassificationIndex = StatisticalClassification_isIndexedBy_ClassificationIndex
        self.StatisticalClassification_isIndexedBy_ClassificationIndex_nsprefix_ = None
        self.StatisticalClassification_isVariantOf_StatisticalClassification = StatisticalClassification_isVariantOf_StatisticalClassification
        self.StatisticalClassification_isVariantOf_StatisticalClassification_nsprefix_ = None
        if StatisticalClassification_isSuccessorOf_StatisticalClassification is None:
            self.StatisticalClassification_isSuccessorOf_StatisticalClassification = []
        else:
            self.StatisticalClassification_isSuccessorOf_StatisticalClassification = StatisticalClassification_isSuccessorOf_StatisticalClassification
        self.StatisticalClassification_isSuccessorOf_StatisticalClassification_nsprefix_ = None
        if StatisticalClassification_isPredecessorOf_StatisticalClassification is None:
            self.StatisticalClassification_isPredecessorOf_StatisticalClassification = []
        else:
            self.StatisticalClassification_isPredecessorOf_StatisticalClassification = StatisticalClassification_isPredecessorOf_StatisticalClassification
        self.StatisticalClassification_isPredecessorOf_StatisticalClassification_nsprefix_ = None
        if StatisticalClassification_has_ClassificationItemPosition is None:
            self.StatisticalClassification_has_ClassificationItemPosition = []
        else:
            self.StatisticalClassification_has_ClassificationItemPosition = StatisticalClassification_has_ClassificationItemPosition
        self.StatisticalClassification_has_ClassificationItemPosition_nsprefix_ = None
        if StatisticalClassification_has_ClassificationItem is None:
            self.StatisticalClassification_has_ClassificationItem = []
        else:
            self.StatisticalClassification_has_ClassificationItem = StatisticalClassification_has_ClassificationItem
        self.StatisticalClassification_has_ClassificationItem_nsprefix_ = None
        self.StatisticalClassification_has_LevelStructure = StatisticalClassification_has_LevelStructure
        self.StatisticalClassification_has_LevelStructure_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatisticalClassification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatisticalClassification.subclass:
            return StatisticalClassification.subclass(*args_, **kwargs_)
        else:
            return StatisticalClassification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_allowsDuplicates(self):
        return self.allowsDuplicates
    def set_allowsDuplicates(self, allowsDuplicates):
        self.allowsDuplicates = allowsDuplicates
    def get_availableLanguage(self):
        return self.availableLanguage
    def set_availableLanguage(self, availableLanguage):
        self.availableLanguage = availableLanguage
    def add_availableLanguage(self, value):
        self.availableLanguage.append(value)
    def insert_availableLanguage_at(self, index, value):
        self.availableLanguage.insert(index, value)
    def replace_availableLanguage_at(self, index, value):
        self.availableLanguage[index] = value
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_changeFromBase(self):
        return self.changeFromBase
    def set_changeFromBase(self, changeFromBase):
        self.changeFromBase = changeFromBase
    def get_copyright(self):
        return self.copyright
    def set_copyright(self, copyright):
        self.copyright = copyright
    def add_copyright(self, value):
        self.copyright.append(value)
    def insert_copyright_at(self, index, value):
        self.copyright.insert(index, value)
    def replace_copyright_at(self, index, value):
        self.copyright[index] = value
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def add_displayLabel(self, value):
        self.displayLabel.append(value)
    def insert_displayLabel_at(self, index, value):
        self.displayLabel.insert(index, value)
    def replace_displayLabel_at(self, index, value):
        self.displayLabel[index] = value
    def get_isCurrent(self):
        return self.isCurrent
    def set_isCurrent(self, isCurrent):
        self.isCurrent = isCurrent
    def get_isFloating(self):
        return self.isFloating
    def set_isFloating(self, isFloating):
        self.isFloating = isFloating
    def get_purposeOfVariant(self):
        return self.purposeOfVariant
    def set_purposeOfVariant(self, purposeOfVariant):
        self.purposeOfVariant = purposeOfVariant
    def get_rationale(self):
        return self.rationale
    def set_rationale(self, rationale):
        self.rationale = rationale
    def get_releaseDate(self):
        return self.releaseDate
    def set_releaseDate(self, releaseDate):
        self.releaseDate = releaseDate
    def get_updateChanges(self):
        return self.updateChanges
    def set_updateChanges(self, updateChanges):
        self.updateChanges = updateChanges
    def add_updateChanges(self, value):
        self.updateChanges.append(value)
    def insert_updateChanges_at(self, index, value):
        self.updateChanges.insert(index, value)
    def replace_updateChanges_at(self, index, value):
        self.updateChanges[index] = value
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_validDates(self):
        return self.validDates
    def set_validDates(self, validDates):
        self.validDates = validDates
    def get_StatisticalClassification_isMaintainedBy_Organization(self):
        return self.StatisticalClassification_isMaintainedBy_Organization
    def set_StatisticalClassification_isMaintainedBy_Organization(self, StatisticalClassification_isMaintainedBy_Organization):
        self.StatisticalClassification_isMaintainedBy_Organization = StatisticalClassification_isMaintainedBy_Organization
    def add_StatisticalClassification_isMaintainedBy_Organization(self, value):
        self.StatisticalClassification_isMaintainedBy_Organization.append(value)
    def insert_StatisticalClassification_isMaintainedBy_Organization_at(self, index, value):
        self.StatisticalClassification_isMaintainedBy_Organization.insert(index, value)
    def replace_StatisticalClassification_isMaintainedBy_Organization_at(self, index, value):
        self.StatisticalClassification_isMaintainedBy_Organization[index] = value
    def get_StatisticalClassification_isIndexedBy_ClassificationIndex(self):
        return self.StatisticalClassification_isIndexedBy_ClassificationIndex
    def set_StatisticalClassification_isIndexedBy_ClassificationIndex(self, StatisticalClassification_isIndexedBy_ClassificationIndex):
        self.StatisticalClassification_isIndexedBy_ClassificationIndex = StatisticalClassification_isIndexedBy_ClassificationIndex
    def add_StatisticalClassification_isIndexedBy_ClassificationIndex(self, value):
        self.StatisticalClassification_isIndexedBy_ClassificationIndex.append(value)
    def insert_StatisticalClassification_isIndexedBy_ClassificationIndex_at(self, index, value):
        self.StatisticalClassification_isIndexedBy_ClassificationIndex.insert(index, value)
    def replace_StatisticalClassification_isIndexedBy_ClassificationIndex_at(self, index, value):
        self.StatisticalClassification_isIndexedBy_ClassificationIndex[index] = value
    def get_StatisticalClassification_isVariantOf_StatisticalClassification(self):
        return self.StatisticalClassification_isVariantOf_StatisticalClassification
    def set_StatisticalClassification_isVariantOf_StatisticalClassification(self, StatisticalClassification_isVariantOf_StatisticalClassification):
        self.StatisticalClassification_isVariantOf_StatisticalClassification = StatisticalClassification_isVariantOf_StatisticalClassification
    def get_StatisticalClassification_isSuccessorOf_StatisticalClassification(self):
        return self.StatisticalClassification_isSuccessorOf_StatisticalClassification
    def set_StatisticalClassification_isSuccessorOf_StatisticalClassification(self, StatisticalClassification_isSuccessorOf_StatisticalClassification):
        self.StatisticalClassification_isSuccessorOf_StatisticalClassification = StatisticalClassification_isSuccessorOf_StatisticalClassification
    def add_StatisticalClassification_isSuccessorOf_StatisticalClassification(self, value):
        self.StatisticalClassification_isSuccessorOf_StatisticalClassification.append(value)
    def insert_StatisticalClassification_isSuccessorOf_StatisticalClassification_at(self, index, value):
        self.StatisticalClassification_isSuccessorOf_StatisticalClassification.insert(index, value)
    def replace_StatisticalClassification_isSuccessorOf_StatisticalClassification_at(self, index, value):
        self.StatisticalClassification_isSuccessorOf_StatisticalClassification[index] = value
    def get_StatisticalClassification_isPredecessorOf_StatisticalClassification(self):
        return self.StatisticalClassification_isPredecessorOf_StatisticalClassification
    def set_StatisticalClassification_isPredecessorOf_StatisticalClassification(self, StatisticalClassification_isPredecessorOf_StatisticalClassification):
        self.StatisticalClassification_isPredecessorOf_StatisticalClassification = StatisticalClassification_isPredecessorOf_StatisticalClassification
    def add_StatisticalClassification_isPredecessorOf_StatisticalClassification(self, value):
        self.StatisticalClassification_isPredecessorOf_StatisticalClassification.append(value)
    def insert_StatisticalClassification_isPredecessorOf_StatisticalClassification_at(self, index, value):
        self.StatisticalClassification_isPredecessorOf_StatisticalClassification.insert(index, value)
    def replace_StatisticalClassification_isPredecessorOf_StatisticalClassification_at(self, index, value):
        self.StatisticalClassification_isPredecessorOf_StatisticalClassification[index] = value
    def get_StatisticalClassification_has_ClassificationItemPosition(self):
        return self.StatisticalClassification_has_ClassificationItemPosition
    def set_StatisticalClassification_has_ClassificationItemPosition(self, StatisticalClassification_has_ClassificationItemPosition):
        self.StatisticalClassification_has_ClassificationItemPosition = StatisticalClassification_has_ClassificationItemPosition
    def add_StatisticalClassification_has_ClassificationItemPosition(self, value):
        self.StatisticalClassification_has_ClassificationItemPosition.append(value)
    def insert_StatisticalClassification_has_ClassificationItemPosition_at(self, index, value):
        self.StatisticalClassification_has_ClassificationItemPosition.insert(index, value)
    def replace_StatisticalClassification_has_ClassificationItemPosition_at(self, index, value):
        self.StatisticalClassification_has_ClassificationItemPosition[index] = value
    def get_StatisticalClassification_has_ClassificationItem(self):
        return self.StatisticalClassification_has_ClassificationItem
    def set_StatisticalClassification_has_ClassificationItem(self, StatisticalClassification_has_ClassificationItem):
        self.StatisticalClassification_has_ClassificationItem = StatisticalClassification_has_ClassificationItem
    def add_StatisticalClassification_has_ClassificationItem(self, value):
        self.StatisticalClassification_has_ClassificationItem.append(value)
    def insert_StatisticalClassification_has_ClassificationItem_at(self, index, value):
        self.StatisticalClassification_has_ClassificationItem.insert(index, value)
    def replace_StatisticalClassification_has_ClassificationItem_at(self, index, value):
        self.StatisticalClassification_has_ClassificationItem[index] = value
    def get_StatisticalClassification_has_LevelStructure(self):
        return self.StatisticalClassification_has_LevelStructure
    def set_StatisticalClassification_has_LevelStructure(self, StatisticalClassification_has_LevelStructure):
        self.StatisticalClassification_has_LevelStructure = StatisticalClassification_has_LevelStructure
    def has__content(self):
        if (
            self.allowsDuplicates is not None or
            self.availableLanguage or
            self.catalogDetails is not None or
            self.changeFromBase is not None or
            self.copyright or
            self.displayLabel or
            self.isCurrent is not None or
            self.isFloating is not None or
            self.purposeOfVariant is not None or
            self.rationale is not None or
            self.releaseDate is not None or
            self.updateChanges or
            self.usage is not None or
            self.validDates is not None or
            self.StatisticalClassification_isMaintainedBy_Organization or
            self.StatisticalClassification_isIndexedBy_ClassificationIndex or
            self.StatisticalClassification_isVariantOf_StatisticalClassification is not None or
            self.StatisticalClassification_isSuccessorOf_StatisticalClassification or
            self.StatisticalClassification_isPredecessorOf_StatisticalClassification or
            self.StatisticalClassification_has_ClassificationItemPosition or
            self.StatisticalClassification_has_ClassificationItem or
            self.StatisticalClassification_has_LevelStructure is not None or
            super(StatisticalClassification, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StatisticalClassification', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(StatisticalClassification, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.allowsDuplicates is not None:
            allowsDuplicates_ = self.allowsDuplicates
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}allowsDuplicates').text = self.gds_format_boolean(allowsDuplicates_)
        for availableLanguage_ in self.availableLanguage:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}availableLanguage').text = self.gds_format_string(availableLanguage_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.changeFromBase is not None:
            changeFromBase_ = self.changeFromBase
            changeFromBase_.to_etree(element, name_='changeFromBase', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for copyright_ in self.copyright:
            copyright_.to_etree(element, name_='copyright', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for displayLabel_ in self.displayLabel:
            displayLabel_.to_etree(element, name_='displayLabel', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isCurrent is not None:
            isCurrent_ = self.isCurrent
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isCurrent').text = self.gds_format_boolean(isCurrent_)
        if self.isFloating is not None:
            isFloating_ = self.isFloating
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isFloating').text = self.gds_format_boolean(isFloating_)
        if self.purposeOfVariant is not None:
            purposeOfVariant_ = self.purposeOfVariant
            purposeOfVariant_.to_etree(element, name_='purposeOfVariant', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.rationale is not None:
            rationale_ = self.rationale
            rationale_.to_etree(element, name_='rationale', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.releaseDate is not None:
            releaseDate_ = self.releaseDate
            releaseDate_.to_etree(element, name_='releaseDate', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for updateChanges_ in self.updateChanges:
            updateChanges_.to_etree(element, name_='updateChanges', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.usage is not None:
            usage_ = self.usage
            usage_.to_etree(element, name_='usage', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validDates is not None:
            validDates_ = self.validDates
            validDates_.to_etree(element, name_='validDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for StatisticalClassification_isMaintainedBy_Organization_ in self.StatisticalClassification_isMaintainedBy_Organization:
            StatisticalClassification_isMaintainedBy_Organization_.to_etree(element, name_='StatisticalClassification_isMaintainedBy_Organization', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for StatisticalClassification_isIndexedBy_ClassificationIndex_ in self.StatisticalClassification_isIndexedBy_ClassificationIndex:
            StatisticalClassification_isIndexedBy_ClassificationIndex_.to_etree(element, name_='StatisticalClassification_isIndexedBy_ClassificationIndex', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.StatisticalClassification_isVariantOf_StatisticalClassification is not None:
            StatisticalClassification_isVariantOf_StatisticalClassification_ = self.StatisticalClassification_isVariantOf_StatisticalClassification
            StatisticalClassification_isVariantOf_StatisticalClassification_.to_etree(element, name_='StatisticalClassification_isVariantOf_StatisticalClassification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for StatisticalClassification_isSuccessorOf_StatisticalClassification_ in self.StatisticalClassification_isSuccessorOf_StatisticalClassification:
            StatisticalClassification_isSuccessorOf_StatisticalClassification_.to_etree(element, name_='StatisticalClassification_isSuccessorOf_StatisticalClassification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for StatisticalClassification_isPredecessorOf_StatisticalClassification_ in self.StatisticalClassification_isPredecessorOf_StatisticalClassification:
            StatisticalClassification_isPredecessorOf_StatisticalClassification_.to_etree(element, name_='StatisticalClassification_isPredecessorOf_StatisticalClassification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for StatisticalClassification_has_ClassificationItemPosition_ in self.StatisticalClassification_has_ClassificationItemPosition:
            StatisticalClassification_has_ClassificationItemPosition_.to_etree(element, name_='StatisticalClassification_has_ClassificationItemPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for StatisticalClassification_has_ClassificationItem_ in self.StatisticalClassification_has_ClassificationItem:
            StatisticalClassification_has_ClassificationItem_.to_etree(element, name_='StatisticalClassification_has_ClassificationItem', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.StatisticalClassification_has_LevelStructure is not None:
            StatisticalClassification_has_LevelStructure_ = self.StatisticalClassification_has_LevelStructure
            StatisticalClassification_has_LevelStructure_.to_etree(element, name_='StatisticalClassification_has_LevelStructure', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StatisticalClassification, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allowsDuplicates':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'allowsDuplicates')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowsDuplicates')
            self.allowsDuplicates = ival_
            self.allowsDuplicates_nsprefix_ = child_.prefix
        elif nodeName_ == 'availableLanguage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'availableLanguage')
            value_ = self.gds_validate_string(value_, node, 'availableLanguage')
            self.availableLanguage.append(value_)
            self.availableLanguage_nsprefix_ = child_.prefix
        elif nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'changeFromBase':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.changeFromBase = obj_
            obj_.original_tagname_ = 'changeFromBase'
        elif nodeName_ == 'copyright':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.copyright.append(obj_)
            obj_.original_tagname_ = 'copyright'
        elif nodeName_ == 'displayLabel':
            obj_ = LabelForDisplay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayLabel.append(obj_)
            obj_.original_tagname_ = 'displayLabel'
        elif nodeName_ == 'isCurrent':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isCurrent')
            ival_ = self.gds_validate_boolean(ival_, node, 'isCurrent')
            self.isCurrent = ival_
            self.isCurrent_nsprefix_ = child_.prefix
        elif nodeName_ == 'isFloating':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isFloating')
            ival_ = self.gds_validate_boolean(ival_, node, 'isFloating')
            self.isFloating = ival_
            self.isFloating_nsprefix_ = child_.prefix
        elif nodeName_ == 'purposeOfVariant':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purposeOfVariant = obj_
            obj_.original_tagname_ = 'purposeOfVariant'
        elif nodeName_ == 'rationale':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rationale = obj_
            obj_.original_tagname_ = 'rationale'
        elif nodeName_ == 'releaseDate':
            obj_ = CombinedDate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.releaseDate = obj_
            obj_.original_tagname_ = 'releaseDate'
        elif nodeName_ == 'updateChanges':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.updateChanges.append(obj_)
            obj_.original_tagname_ = 'updateChanges'
        elif nodeName_ == 'usage':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.usage = obj_
            obj_.original_tagname_ = 'usage'
        elif nodeName_ == 'validDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validDates = obj_
            obj_.original_tagname_ = 'validDates'
        elif nodeName_ == 'StatisticalClassification_isMaintainedBy_Organization':
            obj_ = StatisticalClassification_isMaintainedBy_OrganizationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassification_isMaintainedBy_Organization.append(obj_)
            obj_.original_tagname_ = 'StatisticalClassification_isMaintainedBy_Organization'
        elif nodeName_ == 'StatisticalClassification_isIndexedBy_ClassificationIndex':
            obj_ = StatisticalClassification_isIndexedBy_ClassificationIndexType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassification_isIndexedBy_ClassificationIndex.append(obj_)
            obj_.original_tagname_ = 'StatisticalClassification_isIndexedBy_ClassificationIndex'
        elif nodeName_ == 'StatisticalClassification_isVariantOf_StatisticalClassification':
            obj_ = StatisticalClassification_isVariantOf_StatisticalClassificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassification_isVariantOf_StatisticalClassification = obj_
            obj_.original_tagname_ = 'StatisticalClassification_isVariantOf_StatisticalClassification'
        elif nodeName_ == 'StatisticalClassification_isSuccessorOf_StatisticalClassification':
            obj_ = StatisticalClassification_isSuccessorOf_StatisticalClassificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassification_isSuccessorOf_StatisticalClassification.append(obj_)
            obj_.original_tagname_ = 'StatisticalClassification_isSuccessorOf_StatisticalClassification'
        elif nodeName_ == 'StatisticalClassification_isPredecessorOf_StatisticalClassification':
            obj_ = StatisticalClassification_isPredecessorOf_StatisticalClassificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassification_isPredecessorOf_StatisticalClassification.append(obj_)
            obj_.original_tagname_ = 'StatisticalClassification_isPredecessorOf_StatisticalClassification'
        elif nodeName_ == 'StatisticalClassification_has_ClassificationItemPosition':
            obj_ = StatisticalClassification_has_ClassificationItemPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassification_has_ClassificationItemPosition.append(obj_)
            obj_.original_tagname_ = 'StatisticalClassification_has_ClassificationItemPosition'
        elif nodeName_ == 'StatisticalClassification_has_ClassificationItem':
            obj_ = StatisticalClassification_has_ClassificationItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassification_has_ClassificationItem.append(obj_)
            obj_.original_tagname_ = 'StatisticalClassification_has_ClassificationItem'
        elif nodeName_ == 'StatisticalClassification_has_LevelStructure':
            obj_ = StatisticalClassification_has_LevelStructureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassification_has_LevelStructure = obj_
            obj_.original_tagname_ = 'StatisticalClassification_has_LevelStructure'
        super(StatisticalClassification, self)._buildChildren(child_, node, nodeName_, True)
# end class StatisticalClassification


class StatisticalClassificationRelationship(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, semantics=None, StatisticalClassificationRelationship_hasTarget_StatisticalClassification=None, StatisticalClassificationRelationship_hasSource_StatisticalClassification=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        if StatisticalClassificationRelationship_hasTarget_StatisticalClassification is None:
            self.StatisticalClassificationRelationship_hasTarget_StatisticalClassification = []
        else:
            self.StatisticalClassificationRelationship_hasTarget_StatisticalClassification = StatisticalClassificationRelationship_hasTarget_StatisticalClassification
        self.StatisticalClassificationRelationship_hasTarget_StatisticalClassification_nsprefix_ = None
        if StatisticalClassificationRelationship_hasSource_StatisticalClassification is None:
            self.StatisticalClassificationRelationship_hasSource_StatisticalClassification = []
        else:
            self.StatisticalClassificationRelationship_hasSource_StatisticalClassification = StatisticalClassificationRelationship_hasSource_StatisticalClassification
        self.StatisticalClassificationRelationship_hasSource_StatisticalClassification_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatisticalClassificationRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatisticalClassificationRelationship.subclass:
            return StatisticalClassificationRelationship.subclass(*args_, **kwargs_)
        else:
            return StatisticalClassificationRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_StatisticalClassificationRelationship_hasTarget_StatisticalClassification(self):
        return self.StatisticalClassificationRelationship_hasTarget_StatisticalClassification
    def set_StatisticalClassificationRelationship_hasTarget_StatisticalClassification(self, StatisticalClassificationRelationship_hasTarget_StatisticalClassification):
        self.StatisticalClassificationRelationship_hasTarget_StatisticalClassification = StatisticalClassificationRelationship_hasTarget_StatisticalClassification
    def add_StatisticalClassificationRelationship_hasTarget_StatisticalClassification(self, value):
        self.StatisticalClassificationRelationship_hasTarget_StatisticalClassification.append(value)
    def insert_StatisticalClassificationRelationship_hasTarget_StatisticalClassification_at(self, index, value):
        self.StatisticalClassificationRelationship_hasTarget_StatisticalClassification.insert(index, value)
    def replace_StatisticalClassificationRelationship_hasTarget_StatisticalClassification_at(self, index, value):
        self.StatisticalClassificationRelationship_hasTarget_StatisticalClassification[index] = value
    def get_StatisticalClassificationRelationship_hasSource_StatisticalClassification(self):
        return self.StatisticalClassificationRelationship_hasSource_StatisticalClassification
    def set_StatisticalClassificationRelationship_hasSource_StatisticalClassification(self, StatisticalClassificationRelationship_hasSource_StatisticalClassification):
        self.StatisticalClassificationRelationship_hasSource_StatisticalClassification = StatisticalClassificationRelationship_hasSource_StatisticalClassification
    def add_StatisticalClassificationRelationship_hasSource_StatisticalClassification(self, value):
        self.StatisticalClassificationRelationship_hasSource_StatisticalClassification.append(value)
    def insert_StatisticalClassificationRelationship_hasSource_StatisticalClassification_at(self, index, value):
        self.StatisticalClassificationRelationship_hasSource_StatisticalClassification.insert(index, value)
    def replace_StatisticalClassificationRelationship_hasSource_StatisticalClassification_at(self, index, value):
        self.StatisticalClassificationRelationship_hasSource_StatisticalClassification[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.semantics is not None or
            self.StatisticalClassificationRelationship_hasTarget_StatisticalClassification or
            self.StatisticalClassificationRelationship_hasSource_StatisticalClassification
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StatisticalClassificationRelationship', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for StatisticalClassificationRelationship_hasTarget_StatisticalClassification_ in self.StatisticalClassificationRelationship_hasTarget_StatisticalClassification:
            StatisticalClassificationRelationship_hasTarget_StatisticalClassification_.to_etree(element, name_='StatisticalClassificationRelationship_hasTarget_StatisticalClassification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for StatisticalClassificationRelationship_hasSource_StatisticalClassification_ in self.StatisticalClassificationRelationship_hasSource_StatisticalClassification:
            StatisticalClassificationRelationship_hasSource_StatisticalClassification_.to_etree(element, name_='StatisticalClassificationRelationship_hasSource_StatisticalClassification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'StatisticalClassificationRelationship_hasTarget_StatisticalClassification':
            obj_ = StatisticalClassificationRelationship_hasTarget_StatisticalClassificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassificationRelationship_hasTarget_StatisticalClassification.append(obj_)
            obj_.original_tagname_ = 'StatisticalClassificationRelationship_hasTarget_StatisticalClassification'
        elif nodeName_ == 'StatisticalClassificationRelationship_hasSource_StatisticalClassification':
            obj_ = StatisticalClassificationRelationship_hasSource_StatisticalClassificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StatisticalClassificationRelationship_hasSource_StatisticalClassification.append(obj_)
            obj_.original_tagname_ = 'StatisticalClassificationRelationship_hasSource_StatisticalClassification'
# end class StatisticalClassificationRelationship


class Step(Activity):
    """script -- The executable code for performing a process step, expressed in a formal language.
    scriptingLanguage -- The formal language used by the script associated with the process step.
    Step_produces_Parameter -- The Step creates Parameter as an output.
    Step_receives_Parameter -- The Step uses Parameter as an input.
    Step_hasSubStep_Step -- A step can be broken out into steps ad infinitum.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Activity
    def __init__(self, definition=None, description=None, displayLabel=None, entityProduced=None, entityUsed=None, identifier=None, name=None, standardModelMapping=None, Activity_hasInternal_ControlLogic=None, Activity_hasSubActivity_Activity=None, Activity_has_Step=None, script=None, scriptingLanguage=None, Step_produces_Parameter=None, Step_receives_Parameter=None, Step_hasSubStep_Step=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Step"), self).__init__(definition, description, displayLabel, entityProduced, entityUsed, identifier, name, standardModelMapping, Activity_hasInternal_ControlLogic, Activity_hasSubActivity_Activity, Activity_has_Step,  **kwargs_)
        self.script = script
        self.script_nsprefix_ = None
        self.scriptingLanguage = scriptingLanguage
        self.scriptingLanguage_nsprefix_ = None
        if Step_produces_Parameter is None:
            self.Step_produces_Parameter = []
        else:
            self.Step_produces_Parameter = Step_produces_Parameter
        self.Step_produces_Parameter_nsprefix_ = None
        if Step_receives_Parameter is None:
            self.Step_receives_Parameter = []
        else:
            self.Step_receives_Parameter = Step_receives_Parameter
        self.Step_receives_Parameter_nsprefix_ = None
        if Step_hasSubStep_Step is None:
            self.Step_hasSubStep_Step = []
        else:
            self.Step_hasSubStep_Step = Step_hasSubStep_Step
        self.Step_hasSubStep_Step_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Step)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Step.subclass:
            return Step.subclass(*args_, **kwargs_)
        else:
            return Step(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_scriptingLanguage(self):
        return self.scriptingLanguage
    def set_scriptingLanguage(self, scriptingLanguage):
        self.scriptingLanguage = scriptingLanguage
    def get_Step_produces_Parameter(self):
        return self.Step_produces_Parameter
    def set_Step_produces_Parameter(self, Step_produces_Parameter):
        self.Step_produces_Parameter = Step_produces_Parameter
    def add_Step_produces_Parameter(self, value):
        self.Step_produces_Parameter.append(value)
    def insert_Step_produces_Parameter_at(self, index, value):
        self.Step_produces_Parameter.insert(index, value)
    def replace_Step_produces_Parameter_at(self, index, value):
        self.Step_produces_Parameter[index] = value
    def get_Step_receives_Parameter(self):
        return self.Step_receives_Parameter
    def set_Step_receives_Parameter(self, Step_receives_Parameter):
        self.Step_receives_Parameter = Step_receives_Parameter
    def add_Step_receives_Parameter(self, value):
        self.Step_receives_Parameter.append(value)
    def insert_Step_receives_Parameter_at(self, index, value):
        self.Step_receives_Parameter.insert(index, value)
    def replace_Step_receives_Parameter_at(self, index, value):
        self.Step_receives_Parameter[index] = value
    def get_Step_hasSubStep_Step(self):
        return self.Step_hasSubStep_Step
    def set_Step_hasSubStep_Step(self, Step_hasSubStep_Step):
        self.Step_hasSubStep_Step = Step_hasSubStep_Step
    def add_Step_hasSubStep_Step(self, value):
        self.Step_hasSubStep_Step.append(value)
    def insert_Step_hasSubStep_Step_at(self, index, value):
        self.Step_hasSubStep_Step.insert(index, value)
    def replace_Step_hasSubStep_Step_at(self, index, value):
        self.Step_hasSubStep_Step[index] = value
    def has__content(self):
        if (
            self.script is not None or
            self.scriptingLanguage is not None or
            self.Step_produces_Parameter or
            self.Step_receives_Parameter or
            self.Step_hasSubStep_Step or
            super(Step, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Step', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(Step, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.script is not None:
            script_ = self.script
            script_.to_etree(element, name_='script', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.scriptingLanguage is not None:
            scriptingLanguage_ = self.scriptingLanguage
            scriptingLanguage_.to_etree(element, name_='scriptingLanguage', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Step_produces_Parameter_ in self.Step_produces_Parameter:
            Step_produces_Parameter_.to_etree(element, name_='Step_produces_Parameter', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Step_receives_Parameter_ in self.Step_receives_Parameter:
            Step_receives_Parameter_.to_etree(element, name_='Step_receives_Parameter', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Step_hasSubStep_Step_ in self.Step_hasSubStep_Step:
            Step_hasSubStep_Step_.to_etree(element, name_='Step_hasSubStep_Step', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Step, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'script':
            obj_ = CommandCode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.script = obj_
            obj_.original_tagname_ = 'script'
        elif nodeName_ == 'scriptingLanguage':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scriptingLanguage = obj_
            obj_.original_tagname_ = 'scriptingLanguage'
        elif nodeName_ == 'Step_produces_Parameter':
            obj_ = Step_produces_ParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Step_produces_Parameter.append(obj_)
            obj_.original_tagname_ = 'Step_produces_Parameter'
        elif nodeName_ == 'Step_receives_Parameter':
            obj_ = Step_receives_ParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Step_receives_Parameter.append(obj_)
            obj_.original_tagname_ = 'Step_receives_Parameter'
        elif nodeName_ == 'Step_hasSubStep_Step':
            obj_ = Step_hasSubStep_StepType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Step_hasSubStep_Step.append(obj_)
            obj_.original_tagname_ = 'Step_hasSubStep_Step'
        super(Step, self)._buildChildren(child_, node, nodeName_, True)
# end class Step


class SubstantiveConceptualDomain(ConceptualDomain):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ConceptualDomain
    def __init__(self, catalogDetails=None, displayLabel=None, identifier=None, ConceptualDomain_isDescribedBy_ValueAndConceptDescription=None, ConceptualDomain_takesConceptsFrom_ConceptSystem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SubstantiveConceptualDomain"), self).__init__(catalogDetails, displayLabel, identifier, ConceptualDomain_isDescribedBy_ValueAndConceptDescription, ConceptualDomain_takesConceptsFrom_ConceptSystem,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubstantiveConceptualDomain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubstantiveConceptualDomain.subclass:
            return SubstantiveConceptualDomain.subclass(*args_, **kwargs_)
        else:
            return SubstantiveConceptualDomain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(SubstantiveConceptualDomain, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SubstantiveConceptualDomain', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(SubstantiveConceptualDomain, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SubstantiveConceptualDomain, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SubstantiveConceptualDomain, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SubstantiveConceptualDomain


class SyntheticIdComponent(DataStructureComponent):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataStructureComponent
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SyntheticIdComponent"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SyntheticIdComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SyntheticIdComponent.subclass:
            return SyntheticIdComponent.subclass(*args_, **kwargs_)
        else:
            return SyntheticIdComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(SyntheticIdComponent, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SyntheticIdComponent', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(SyntheticIdComponent, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SyntheticIdComponent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SyntheticIdComponent, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SyntheticIdComponent


class TemporalConstraints(NonDeterministicDeclarative):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NonDeterministicDeclarative
    def __init__(self, description=None, identifier=None, workflow=None, ControlLogic_informs_ProcessingAgent=None, ControlLogic_invokes_Activity=None, ControlLogic_hasSubControlLogic_ControlLogic=None, ControlLogic_has_InformationFlowDefinition=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TemporalConstraints"), self).__init__(description, identifier, workflow, ControlLogic_informs_ProcessingAgent, ControlLogic_invokes_Activity, ControlLogic_hasSubControlLogic_ControlLogic, ControlLogic_has_InformationFlowDefinition, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemporalConstraints)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemporalConstraints.subclass:
            return TemporalConstraints.subclass(*args_, **kwargs_)
        else:
            return TemporalConstraints(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            super(TemporalConstraints, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TemporalConstraints', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(TemporalConstraints, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(TemporalConstraints, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TemporalConstraints, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class TemporalConstraints


class TemporalControlConstruct(TemporalConstraints):
    """temporalControl -- TemporalControl is a property of type TemporalControlConstructType. There are four members of this enumeration: AND-split, XOR-split, AND-join and XOR-join.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TemporalConstraints
    def __init__(self, description=None, identifier=None, workflow=None, ControlLogic_informs_ProcessingAgent=None, ControlLogic_invokes_Activity=None, ControlLogic_hasSubControlLogic_ControlLogic=None, ControlLogic_has_InformationFlowDefinition=None, temporalControl=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TemporalControlConstruct"), self).__init__(description, identifier, workflow, ControlLogic_informs_ProcessingAgent, ControlLogic_invokes_Activity, ControlLogic_hasSubControlLogic_ControlLogic, ControlLogic_has_InformationFlowDefinition,  **kwargs_)
        self.temporalControl = temporalControl
        self.validate_TemporalOperator(self.temporalControl)
        self.temporalControl_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemporalControlConstruct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemporalControlConstruct.subclass:
            return TemporalControlConstruct.subclass(*args_, **kwargs_)
        else:
            return TemporalControlConstruct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_temporalControl(self):
        return self.temporalControl
    def set_temporalControl(self, temporalControl):
        self.temporalControl = temporalControl
    def validate_TemporalOperator(self, value):
        result = True
        # Validate type TemporalOperator, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AndJoin', 'AndSplit', 'XorJoin', 'XorSplit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TemporalOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.temporalControl is not None or
            super(TemporalControlConstruct, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TemporalControlConstruct', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(TemporalControlConstruct, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.temporalControl is not None:
            temporalControl_ = self.temporalControl
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}temporalControl').text = self.gds_format_string(temporalControl_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TemporalControlConstruct, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'temporalControl':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'temporalControl')
            value_ = self.gds_validate_string(value_, node, 'temporalControl')
            self.temporalControl = value_
            self.temporalControl_nsprefix_ = child_.prefix
            # validate type TemporalOperator
            self.validate_TemporalOperator(self.temporalControl)
        super(TemporalControlConstruct, self)._buildChildren(child_, node, nodeName_, True)
# end class TemporalControlConstruct


class Unit(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry. Examples would be creator, contributor, title, copyright, embargo, and license information. A set of information useful for attribution, data discovery, and access. This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    definition -- Natural language statement conveying the meaning of a concept, differentiating it from other concepts. Supports the use of multiple languages and structured text.
    displayLabel -- A human-readable display label for the object. Supports the use of multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    Unit_has_UnitType -- The unit type of the unit.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, identifier=None, name=None, Unit_has_UnitType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        self.definition = definition
        self.definition_nsprefix_ = None
        if displayLabel is None:
            self.displayLabel = []
        else:
            self.displayLabel = displayLabel
        self.displayLabel_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        if Unit_has_UnitType is None:
            self.Unit_has_UnitType = []
        else:
            self.Unit_has_UnitType = Unit_has_UnitType
        self.Unit_has_UnitType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Unit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Unit.subclass:
            return Unit.subclass(*args_, **kwargs_)
        else:
            return Unit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_definition(self):
        return self.definition
    def set_definition(self, definition):
        self.definition = definition
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def add_displayLabel(self, value):
        self.displayLabel.append(value)
    def insert_displayLabel_at(self, index, value):
        self.displayLabel.insert(index, value)
    def replace_displayLabel_at(self, index, value):
        self.displayLabel[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_Unit_has_UnitType(self):
        return self.Unit_has_UnitType
    def set_Unit_has_UnitType(self, Unit_has_UnitType):
        self.Unit_has_UnitType = Unit_has_UnitType
    def add_Unit_has_UnitType(self, value):
        self.Unit_has_UnitType.append(value)
    def insert_Unit_has_UnitType_at(self, index, value):
        self.Unit_has_UnitType.insert(index, value)
    def replace_Unit_has_UnitType_at(self, index, value):
        self.Unit_has_UnitType[index] = value
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.definition is not None or
            self.displayLabel or
            self.identifier is not None or
            self.name or
            self.Unit_has_UnitType
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Unit', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.definition is not None:
            definition_ = self.definition
            definition_.to_etree(element, name_='definition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for displayLabel_ in self.displayLabel:
            displayLabel_.to_etree(element, name_='displayLabel', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Unit_has_UnitType_ in self.Unit_has_UnitType:
            Unit_has_UnitType_.to_etree(element, name_='Unit_has_UnitType', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'definition':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.definition = obj_
            obj_.original_tagname_ = 'definition'
        elif nodeName_ == 'displayLabel':
            obj_ = LabelForDisplay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayLabel.append(obj_)
            obj_.original_tagname_ = 'displayLabel'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'Unit_has_UnitType':
            obj_ = Unit_has_UnitTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Unit_has_UnitType.append(obj_)
            obj_.original_tagname_ = 'Unit_has_UnitType'
# end class Unit


class UnitSegmentLayout(PhysicalSegmentLayout):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PhysicalSegmentLayout
    def __init__(self, allowsDuplicates=None, arrayBase=None, catalogDetails=None, commentPrefix=None, delimiter=None, encoding=None, escapeCharacter=None, hasHeader=None, headerIsCaseSensitive=None, headerRowCount=None, identifier=None, isDelimited=None, isFixedWidth=None, lineTerminator=None, name=None, nullSequence=None, overview=None, purpose=None, quoteCharacter=None, skipBlankRows=None, skipDataColumns=None, skipInitialSpace=None, skipRows=None, tableDirection=None, textDirection=None, treatConsecutiveDelimitersAsOne=None, trim=None, PhysicalSegmentLayout_isDefinedBy_Concept=None, PhysicalSegmentLayout_formats_LogicalRecord=None, PhysicalSegmentLayout_has_ValueMapping=None, PhysicalSegmentLayout_has_ValueMappingPosition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("UnitSegmentLayout"), self).__init__(allowsDuplicates, arrayBase, catalogDetails, commentPrefix, delimiter, encoding, escapeCharacter, hasHeader, headerIsCaseSensitive, headerRowCount, identifier, isDelimited, isFixedWidth, lineTerminator, name, nullSequence, overview, purpose, quoteCharacter, skipBlankRows, skipDataColumns, skipInitialSpace, skipRows, tableDirection, textDirection, treatConsecutiveDelimitersAsOne, trim, PhysicalSegmentLayout_isDefinedBy_Concept, PhysicalSegmentLayout_formats_LogicalRecord, PhysicalSegmentLayout_has_ValueMapping, PhysicalSegmentLayout_has_ValueMappingPosition,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitSegmentLayout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitSegmentLayout.subclass:
            return UnitSegmentLayout.subclass(*args_, **kwargs_)
        else:
            return UnitSegmentLayout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(UnitSegmentLayout, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UnitSegmentLayout', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(UnitSegmentLayout, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(UnitSegmentLayout, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(UnitSegmentLayout, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class UnitSegmentLayout


class UnitType(Concept):
    """descriptiveText -- A short natural language account of the characteristics of the object.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Concept
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, externalDefinition=None, identifier=None, name=None, Concept_uses_Concept=None, descriptiveText=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("UnitType"), self).__init__(catalogDetails, definition, displayLabel, externalDefinition, identifier, name, Concept_uses_Concept, extensiontype_,  **kwargs_)
        self.descriptiveText = descriptiveText
        self.descriptiveText_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitType.subclass:
            return UnitType.subclass(*args_, **kwargs_)
        else:
            return UnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_descriptiveText(self):
        return self.descriptiveText
    def set_descriptiveText(self, descriptiveText):
        self.descriptiveText = descriptiveText
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.descriptiveText is not None or
            super(UnitType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UnitType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(UnitType, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.descriptiveText is not None:
            descriptiveText_ = self.descriptiveText
            descriptiveText_.to_etree(element, name_='descriptiveText', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(UnitType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'descriptiveText':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.descriptiveText = obj_
            obj_.original_tagname_ = 'descriptiveText'
        super(UnitType, self)._buildChildren(child_, node, nodeName_, True)
# end class UnitType


class Universe(UnitType):
    """isInclusive -- Default value is True. The description statement of a universe is generally stated in inclusive terms such as "All persons with university degree". Occasionally a universe is defined by what it excludes, i.e., "All persons except those with university degree". In this case the value would be changed to False.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = UnitType
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, externalDefinition=None, identifier=None, name=None, Concept_uses_Concept=None, descriptiveText=None, isInclusive=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Universe"), self).__init__(catalogDetails, definition, displayLabel, externalDefinition, identifier, name, Concept_uses_Concept, descriptiveText, extensiontype_,  **kwargs_)
        self.isInclusive = isInclusive
        self.isInclusive_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Universe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Universe.subclass:
            return Universe.subclass(*args_, **kwargs_)
        else:
            return Universe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isInclusive(self):
        return self.isInclusive
    def set_isInclusive(self, isInclusive):
        self.isInclusive = isInclusive
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.isInclusive is not None or
            super(Universe, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Universe', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(Universe, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.isInclusive is not None:
            isInclusive_ = self.isInclusive
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isInclusive').text = self.gds_format_boolean(isInclusive_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Universe, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isInclusive':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isInclusive')
            ival_ = self.gds_validate_boolean(ival_, node, 'isInclusive')
            self.isInclusive = ival_
            self.isInclusive_nsprefix_ = child_.prefix
        super(Universe, self)._buildChildren(child_, node, nodeName_, True)
# end class Universe


class ValueAndConceptDescription(GeneratedsSuper):
    """classificationLevel -- Indicates the type of relationship, nominal, ordinal, interval, ratio, or continuous. Use where appropriate for the representation type.
    description -- A formal description of the set of values in human-readable language.
    formatPattern -- A pattern for a number as described in Unicode Locale Data Markup Language (LDML) (http://www.unicode.org/reports/tr35/tr35.html) Part 3: Numbers  (http://www.unicode.org/reports/tr35/tr35-numbers.html#Number_Format_Patterns) and Part 4. Dates (http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns) . Examples would be    #,##0.### to describe the pattern for a decimal number, or yyyy.MM.dd G 'at' HH:mm:ss zzz for a datetime pattern.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    logicalExpression -- A logical expression where the values of "x" making the expression true are the members of the set of valid values.  For example, "(all reals x such that  x
    >
    0)" describes the real numbers greater than 0.
    maximumValueExclusive -- A string denoting the maximum possible value (excluding this value). From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 5.11.2: "maxExclusive: An atomic property that contains a single number or string that is the maximum valid value (exclusive). The value of this property becomes the maximum exclusive annotation for the described datatype. See Value Constraints in [tabular-data-model] for details."
    maximumValueInclusive -- A string denoting the maximum possible value. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 5.11.2: "maximum: An atomic property that contains a single number or string that is the maximum valid value (inclusive); equivalent to maxInclusive. The value of this property becomes the maximum annotation for the described datatype. See Value Constraints in [tabular-data-model] for details."
    minimumValueExclusive -- A string denoting the minimum possible value (excluding this value). From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 5.11.2: "minExclusive: An atomic property that contains a single number or string that is the minimum valid value (exclusive). The value of this property becomes the minimum exclusive annotation for the described datatype. See Value Constraints in [tabular-data-model] for details."
    minimumValueInclusive -- A string denoting the minimum possible value. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 5.11.2: "minimum: An atomic property that contains a single number or string that is the minimum valid value (inclusive); equivalent to minInclusive. The value of this property becomes the minimum annotation for the described datatype. See Value Constraints in [tabular-data-model] for details."
    regularExpression -- A regular expression where strings matching the expression belong to the set of valid values. Use typeOfContent to specify the syntax of the regularExpression found in content.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, classificationLevel=None, description=None, formatPattern=None, identifier=None, logicalExpression=None, maximumValueExclusive=None, maximumValueInclusive=None, minimumValueExclusive=None, minimumValueInclusive=None, regularExpression=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.classificationLevel = classificationLevel
        self.validate_CategoryRelationCode(self.classificationLevel)
        self.classificationLevel_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.formatPattern = formatPattern
        self.formatPattern_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.logicalExpression = logicalExpression
        self.logicalExpression_nsprefix_ = None
        self.maximumValueExclusive = maximumValueExclusive
        self.maximumValueExclusive_nsprefix_ = None
        self.maximumValueInclusive = maximumValueInclusive
        self.maximumValueInclusive_nsprefix_ = None
        self.minimumValueExclusive = minimumValueExclusive
        self.minimumValueExclusive_nsprefix_ = None
        self.minimumValueInclusive = minimumValueInclusive
        self.minimumValueInclusive_nsprefix_ = None
        self.regularExpression = regularExpression
        self.regularExpression_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueAndConceptDescription)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueAndConceptDescription.subclass:
            return ValueAndConceptDescription.subclass(*args_, **kwargs_)
        else:
            return ValueAndConceptDescription(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_classificationLevel(self):
        return self.classificationLevel
    def set_classificationLevel(self, classificationLevel):
        self.classificationLevel = classificationLevel
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_formatPattern(self):
        return self.formatPattern
    def set_formatPattern(self, formatPattern):
        self.formatPattern = formatPattern
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_logicalExpression(self):
        return self.logicalExpression
    def set_logicalExpression(self, logicalExpression):
        self.logicalExpression = logicalExpression
    def get_maximumValueExclusive(self):
        return self.maximumValueExclusive
    def set_maximumValueExclusive(self, maximumValueExclusive):
        self.maximumValueExclusive = maximumValueExclusive
    def get_maximumValueInclusive(self):
        return self.maximumValueInclusive
    def set_maximumValueInclusive(self, maximumValueInclusive):
        self.maximumValueInclusive = maximumValueInclusive
    def get_minimumValueExclusive(self):
        return self.minimumValueExclusive
    def set_minimumValueExclusive(self, minimumValueExclusive):
        self.minimumValueExclusive = minimumValueExclusive
    def get_minimumValueInclusive(self):
        return self.minimumValueInclusive
    def set_minimumValueInclusive(self, minimumValueInclusive):
        self.minimumValueInclusive = minimumValueInclusive
    def get_regularExpression(self):
        return self.regularExpression
    def set_regularExpression(self, regularExpression):
        self.regularExpression = regularExpression
    def validate_CategoryRelationCode(self, value):
        result = True
        # Validate type CategoryRelationCode, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Continuous', 'Interval', 'Nominal', 'Ordinal', 'Ratio']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CategoryRelationCode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.classificationLevel is not None or
            self.description is not None or
            self.formatPattern is not None or
            self.identifier is not None or
            self.logicalExpression is not None or
            self.maximumValueExclusive is not None or
            self.maximumValueInclusive is not None or
            self.minimumValueExclusive is not None or
            self.minimumValueInclusive is not None or
            self.regularExpression is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ValueAndConceptDescription', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.classificationLevel is not None:
            classificationLevel_ = self.classificationLevel
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}classificationLevel').text = self.gds_format_string(classificationLevel_)
        if self.description is not None:
            description_ = self.description
            description_.to_etree(element, name_='description', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.formatPattern is not None:
            formatPattern_ = self.formatPattern
            formatPattern_.to_etree(element, name_='formatPattern', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.logicalExpression is not None:
            logicalExpression_ = self.logicalExpression
            logicalExpression_.to_etree(element, name_='logicalExpression', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.maximumValueExclusive is not None:
            maximumValueExclusive_ = self.maximumValueExclusive
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}maximumValueExclusive').text = self.gds_format_string(maximumValueExclusive_)
        if self.maximumValueInclusive is not None:
            maximumValueInclusive_ = self.maximumValueInclusive
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}maximumValueInclusive').text = self.gds_format_string(maximumValueInclusive_)
        if self.minimumValueExclusive is not None:
            minimumValueExclusive_ = self.minimumValueExclusive
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}minimumValueExclusive').text = self.gds_format_string(minimumValueExclusive_)
        if self.minimumValueInclusive is not None:
            minimumValueInclusive_ = self.minimumValueInclusive
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}minimumValueInclusive').text = self.gds_format_string(minimumValueInclusive_)
        if self.regularExpression is not None:
            regularExpression_ = self.regularExpression
            regularExpression_.to_etree(element, name_='regularExpression', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'classificationLevel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'classificationLevel')
            value_ = self.gds_validate_string(value_, node, 'classificationLevel')
            self.classificationLevel = value_
            self.classificationLevel_nsprefix_ = child_.prefix
            # validate type CategoryRelationCode
            self.validate_CategoryRelationCode(self.classificationLevel)
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'formatPattern':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.formatPattern = obj_
            obj_.original_tagname_ = 'formatPattern'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'logicalExpression':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.logicalExpression = obj_
            obj_.original_tagname_ = 'logicalExpression'
        elif nodeName_ == 'maximumValueExclusive':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'maximumValueExclusive')
            value_ = self.gds_validate_string(value_, node, 'maximumValueExclusive')
            self.maximumValueExclusive = value_
            self.maximumValueExclusive_nsprefix_ = child_.prefix
        elif nodeName_ == 'maximumValueInclusive':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'maximumValueInclusive')
            value_ = self.gds_validate_string(value_, node, 'maximumValueInclusive')
            self.maximumValueInclusive = value_
            self.maximumValueInclusive_nsprefix_ = child_.prefix
        elif nodeName_ == 'minimumValueExclusive':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'minimumValueExclusive')
            value_ = self.gds_validate_string(value_, node, 'minimumValueExclusive')
            self.minimumValueExclusive = value_
            self.minimumValueExclusive_nsprefix_ = child_.prefix
        elif nodeName_ == 'minimumValueInclusive':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'minimumValueInclusive')
            value_ = self.gds_validate_string(value_, node, 'minimumValueInclusive')
            self.minimumValueInclusive = value_
            self.minimumValueInclusive_nsprefix_ = child_.prefix
        elif nodeName_ == 'regularExpression':
            obj_ = TypedString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regularExpression = obj_
            obj_.original_tagname_ = 'regularExpression'
# end class ValueAndConceptDescription


class ValueDomain(GeneratedsSuper):
    """catalogDetails -- Bundles the information useful for a data catalog entry.
    Examples would be creator, contributor, title, copyright, embargo, and license information
    A set of information useful for attribution, data discovery, and access.
    This is information that is tied to the identity of the object. If this information changes the version of the associated object changes.
    displayLabel -- A human-readable display label for the object. Supports the use of multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    recommendedDataType -- The data types that are recommended for use with this domain.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalogDetails=None, displayLabel=None, identifier=None, recommendedDataType=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.catalogDetails = catalogDetails
        self.catalogDetails_nsprefix_ = None
        if displayLabel is None:
            self.displayLabel = []
        else:
            self.displayLabel = displayLabel
        self.displayLabel_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if recommendedDataType is None:
            self.recommendedDataType = []
        else:
            self.recommendedDataType = recommendedDataType
        self.recommendedDataType_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueDomain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueDomain.subclass:
            return ValueDomain.subclass(*args_, **kwargs_)
        else:
            return ValueDomain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalogDetails(self):
        return self.catalogDetails
    def set_catalogDetails(self, catalogDetails):
        self.catalogDetails = catalogDetails
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def add_displayLabel(self, value):
        self.displayLabel.append(value)
    def insert_displayLabel_at(self, index, value):
        self.displayLabel.insert(index, value)
    def replace_displayLabel_at(self, index, value):
        self.displayLabel[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_recommendedDataType(self):
        return self.recommendedDataType
    def set_recommendedDataType(self, recommendedDataType):
        self.recommendedDataType = recommendedDataType
    def add_recommendedDataType(self, value):
        self.recommendedDataType.append(value)
    def insert_recommendedDataType_at(self, index, value):
        self.recommendedDataType.insert(index, value)
    def replace_recommendedDataType_at(self, index, value):
        self.recommendedDataType[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.catalogDetails is not None or
            self.displayLabel or
            self.identifier is not None or
            self.recommendedDataType
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ValueDomain', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.catalogDetails is not None:
            catalogDetails_ = self.catalogDetails
            catalogDetails_.to_etree(element, name_='catalogDetails', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for displayLabel_ in self.displayLabel:
            displayLabel_.to_etree(element, name_='displayLabel', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for recommendedDataType_ in self.recommendedDataType:
            recommendedDataType_.to_etree(element, name_='recommendedDataType', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalogDetails':
            obj_ = CatalogDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogDetails = obj_
            obj_.original_tagname_ = 'catalogDetails'
        elif nodeName_ == 'displayLabel':
            obj_ = LabelForDisplay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayLabel.append(obj_)
            obj_.original_tagname_ = 'displayLabel'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'recommendedDataType':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recommendedDataType.append(obj_)
            obj_.original_tagname_ = 'recommendedDataType'
# end class ValueDomain


class ValueMapping(GeneratedsSuper):
    """decimalPositions -- The number of decimal positions expressed as an integer. Used when the decimal position is implied (no decimal separator is present) See DDI 3.2 ManagedNumericRepresentation_decimalPositions
    defaultDecimalSeparator -- Default value is "." (period). The character separating the integer part from the fractional part of a decimal or real number. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 6.4.2: "decimalChar: A string whose value is used to represent a decimal point within the number. If the supplied value is not a string, implementations MUST issue a warning and proceed as if the property had not been specified."
    defaultDigitGroupSeparator -- Default value is null. A character separating groups of digits (for readability). In W3C part of the datatype format From https://www.w3.org/TR/tabular-metadata/ tabular 6.4.2 groupChar: "A string whose value is used to group digits within the number. If the supplied value is not a string, implementations MUST issue a warning and proceed as if the property had not been specified."
    defaultValue -- A default string indicating the value to substitute for an empty string. From https://www.w3.org/TR/tabular-metadata/ Inherited 5.7  "default - An atomic property holding a single string that is used to create a default value for the cell in cases where the original string value is an empty string. See Parsing Cells in [tabular-data-model] for more details. If not specified, the default for the default property is the empty string, "". The value of this property becomes the default annotation for the described column."
    format -- This defines the format of the physical representation of the value. From https://www.w3.org/TR/tabular-metadata/ 5.11.2 format: "An atomic property that contains either a single string or an object that defines the format of a value of this type, used when parsing a string value as described in Parsing Cells in [tabular-data-model]. The value of this property becomes the format annotation for the described datatype." See https://www.w3.org/TR/tabular-metadata/ Tabular 6.4.2 "Formats for numeric datatypes" this may include decimalChar, groupChar, pattern "By default, numeric values must be in the formats defined in [xmlschema11-2]. It is not uncommon for numbers within tabular data to be formatted for human consumption, which may involve using commas for decimal points, grouping digits in the number using commas, or adding percent signs to the number." See https://www.w3.org/TR/tabular-metadata/ Tabular 6.4. Formats for Booleans " Boolean values may be represented in many ways aside from the standard 1 and 0 or true and false." See https://www.w3.org/TR/tabular-metadata/ 6.4.4. Formats for dates and times "By default, dates and times are assumed to be in the format defined in [xmlschema11-2]. However dates and times are commonly represented in tabular data in other formats." See https://www.w3.org/TR/tabular-metadata/ 6.4.5 Formats for durations "Durations MUST be formatted and interpreted as defined in [xmlschema11-2], using the [ISO8601] format -?PnYnMnDTnHnMnS. For example, the duration P1Y1D is used for a year and a day; the duration PT2H30M for 2 hours and 30 minutes." See https://www.w3.org/TR/tabular-metadata/ 6.4.6 Formats for other types "If the datatype base is not numeric, boolean, a date/time type, or a duration type, the datatype format annotation provides a regular expression for the string values, with syntax and processing defined by [ECMASCRIPT]. If the supplied value is not a valid regular expression, implementations MUST issue a warning and proceed as if no format had been provided." From DDI3.2 ManagedNumericRepresentation@format "A format for number expressed as a string." From DDI3.2 ManagedDateTimeRepresentation_DateFieldFormat "Describes the format of the date field, in formats such as YYYY/MM or MM-DD-YY, etc. If this element is omitted, then the format is assumed to be the XML Schema format corresponding to the type attribute value."
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    isRequired -- If the value of this property is True indicates that a value is required for the referenced instance variable. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 5.7 Inherited Properties: "required: A boolean atomic property taking a single value which indicates whether the cell value can be null. See Parsing Cells in [tabular-data-model] for more details. The default is false, which means cells can have null values. The value of this property becomes the required annotation for the
    described column."
    length -- The length in characters of the physical representation of the value. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/)  5.11.2 "length: A numeric atomic property that contains a single integer that is the exact length of the value. The value of this property becomes the length annotation for the described datatype. See Length Constraints in [tabular-data-model] for details." Corresponds to DDI2.5 var/location/width and DDI 3.2 PhysicalLocation/Width.
    maximumLength -- The largest possible value of the length of the physical representation of the value. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 5.11.2: "maxLength: A numeric atomic property that contains a single integer that is the maximum length of the value. The value of this property becomes the maximum length annotation for the described datatype. See Length Constraints in [tabular-data-model] for details."
    minimumLength -- The smallest possible value for the length of the physical representation of the value. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/)  5.11.2: "minLength: An atomic property that contains a single integer that is the minimum length of the value. The value of this property becomes the minimum length annotation for the described datatype. See Length Constraints in [tabular-data-model] for details."
    nullSequence -- A string indicating a null value. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) 4.3: "null: the string or strings which cause the value of cells having string value matching any of these values to be null." From the same source, Inherited 5.7: "null: An atomic property giving the string or strings used for null values within the data. If the string value of the cell is equal to any one of these values, the cell value is null. See Parsing Cells in [tabular-data-model] for more details. If not specified, the default for the null property is the empty string ''. The value of this property becomes the null annotation for the described column."
    numberPattern -- A pattern description of the format of a numeric value. In W3C part of the datatype format From https://www.w3.org/TR/tabular-metadata/ tabular 6.4.2 pattern: "A number format pattern as defined in [UAX35] http://www.unicode.org/reports/tr35/tr35-31/tr35-numbers.html#Number_Format_Patterns. Implementations MUST recognise number format patterns containing the symbols 0, #, the specified decimalChar (or "." if unspecified), the specified groupChar (or "," if unspecified), E, +, % and
    ‰
    . Implementations MAY additionally recognise number format patterns containing other special pattern characters defined in [UAX35]. If the supplied value is not a string, or if it contains an invalid number format pattern or uses special pattern characters that the implementation does not recognise, implementations MUST issue a warning and proceed as if the property had not been specified. If the datatype format annotation is a single string, this is interpreted in the same way as if it were an object with a pattern property whose value is that string. If the groupChar is specified, but no pattern is supplied, when parsing the string value of a cell against this format specification, implementations MUST recognise and parse numbers that consist of: an optional + or - sign,
    …
    Implementations MAY also recognise numeric values that are in any of the standard-decimal, standard-percent or standard-scientific formats listed in the Unicode Common Locale Data Repository.
    …
    "
    physicalDataType -- The base datatype of the physical representation. An integer InstanceVariable might, for example, be stored as a floating point number. From the W3C Recommendation "Metadata Vocabulary for Tabular Data" (https://www.w3.org/TR/tabular-metadata/) Inherited 5.7: "datatype: An atomic property that contains either a single string that is the main datatype of the values of the cell or a datatype description object. If the value of this property is a string, it MUST be the name of one of the built-in datatypes defined in section 5.11.1 Built-in Datatypes and this value is normalized to an object whose base property is the original string value. If it is an object then it describes a more specialized datatype. If a cell contains a sequence (i.e. the separator property is specified and not null) then this property specifies the datatype of each value within that sequence. See 5.11 Datatypes and Parsing Cells in [tabular-data-model] for more details.  The normalized value of this property becomes the datatype annotation for the described column."
    scale -- The scale of the number expressed as an integer. A multiplier to be used in combination with the value to determine the measurement. (E.g., a number expressed in 100's with a value of 5 and a scale of 100 would be 500).
    ValueMapping_uses_PhysicalSegmentLocation -- Uses a physical segment location to describe where in the physical record a segment representing the data point is. This could be, for example, described as a start position and end position value for characters in a text record via the segment by text extension of physical segment location.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, decimalPositions=None, defaultDecimalSeparator=None, defaultDigitGroupSeparator=None, defaultValue=None, format=None, identifier=None, isRequired=None, length=None, maximumLength=None, minimumLength=None, nullSequence=None, numberPattern=None, physicalDataType=None, scale=None, ValueMapping_formats_DataPoint=None, ValueMapping_uses_PhysicalSegmentLocation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.decimalPositions = decimalPositions
        self.decimalPositions_nsprefix_ = None
        self.defaultDecimalSeparator = defaultDecimalSeparator
        self.defaultDecimalSeparator_nsprefix_ = None
        self.defaultDigitGroupSeparator = defaultDigitGroupSeparator
        self.defaultDigitGroupSeparator_nsprefix_ = None
        self.defaultValue = defaultValue
        self.defaultValue_nsprefix_ = None
        self.format = format
        self.format_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.isRequired = isRequired
        self.isRequired_nsprefix_ = None
        self.length = length
        self.length_nsprefix_ = None
        self.maximumLength = maximumLength
        self.maximumLength_nsprefix_ = None
        self.minimumLength = minimumLength
        self.minimumLength_nsprefix_ = None
        self.nullSequence = nullSequence
        self.nullSequence_nsprefix_ = None
        self.numberPattern = numberPattern
        self.numberPattern_nsprefix_ = None
        self.physicalDataType = physicalDataType
        self.physicalDataType_nsprefix_ = None
        self.scale = scale
        self.scale_nsprefix_ = None
        if ValueMapping_formats_DataPoint is None:
            self.ValueMapping_formats_DataPoint = []
        else:
            self.ValueMapping_formats_DataPoint = ValueMapping_formats_DataPoint
        self.ValueMapping_formats_DataPoint_nsprefix_ = None
        self.ValueMapping_uses_PhysicalSegmentLocation = ValueMapping_uses_PhysicalSegmentLocation
        self.ValueMapping_uses_PhysicalSegmentLocation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueMapping)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueMapping.subclass:
            return ValueMapping.subclass(*args_, **kwargs_)
        else:
            return ValueMapping(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_decimalPositions(self):
        return self.decimalPositions
    def set_decimalPositions(self, decimalPositions):
        self.decimalPositions = decimalPositions
    def get_defaultDecimalSeparator(self):
        return self.defaultDecimalSeparator
    def set_defaultDecimalSeparator(self, defaultDecimalSeparator):
        self.defaultDecimalSeparator = defaultDecimalSeparator
    def get_defaultDigitGroupSeparator(self):
        return self.defaultDigitGroupSeparator
    def set_defaultDigitGroupSeparator(self, defaultDigitGroupSeparator):
        self.defaultDigitGroupSeparator = defaultDigitGroupSeparator
    def get_defaultValue(self):
        return self.defaultValue
    def set_defaultValue(self, defaultValue):
        self.defaultValue = defaultValue
    def get_format(self):
        return self.format
    def set_format(self, format):
        self.format = format
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_isRequired(self):
        return self.isRequired
    def set_isRequired(self, isRequired):
        self.isRequired = isRequired
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_maximumLength(self):
        return self.maximumLength
    def set_maximumLength(self, maximumLength):
        self.maximumLength = maximumLength
    def get_minimumLength(self):
        return self.minimumLength
    def set_minimumLength(self, minimumLength):
        self.minimumLength = minimumLength
    def get_nullSequence(self):
        return self.nullSequence
    def set_nullSequence(self, nullSequence):
        self.nullSequence = nullSequence
    def get_numberPattern(self):
        return self.numberPattern
    def set_numberPattern(self, numberPattern):
        self.numberPattern = numberPattern
    def get_physicalDataType(self):
        return self.physicalDataType
    def set_physicalDataType(self, physicalDataType):
        self.physicalDataType = physicalDataType
    def get_scale(self):
        return self.scale
    def set_scale(self, scale):
        self.scale = scale
    def get_ValueMapping_formats_DataPoint(self):
        return self.ValueMapping_formats_DataPoint
    def set_ValueMapping_formats_DataPoint(self, ValueMapping_formats_DataPoint):
        self.ValueMapping_formats_DataPoint = ValueMapping_formats_DataPoint
    def add_ValueMapping_formats_DataPoint(self, value):
        self.ValueMapping_formats_DataPoint.append(value)
    def insert_ValueMapping_formats_DataPoint_at(self, index, value):
        self.ValueMapping_formats_DataPoint.insert(index, value)
    def replace_ValueMapping_formats_DataPoint_at(self, index, value):
        self.ValueMapping_formats_DataPoint[index] = value
    def get_ValueMapping_uses_PhysicalSegmentLocation(self):
        return self.ValueMapping_uses_PhysicalSegmentLocation
    def set_ValueMapping_uses_PhysicalSegmentLocation(self, ValueMapping_uses_PhysicalSegmentLocation):
        self.ValueMapping_uses_PhysicalSegmentLocation = ValueMapping_uses_PhysicalSegmentLocation
    def has__content(self):
        if (
            self.decimalPositions is not None or
            self.defaultDecimalSeparator is not None or
            self.defaultDigitGroupSeparator is not None or
            self.defaultValue is not None or
            self.format is not None or
            self.identifier is not None or
            self.isRequired is not None or
            self.length is not None or
            self.maximumLength is not None or
            self.minimumLength is not None or
            self.nullSequence is not None or
            self.numberPattern is not None or
            self.physicalDataType is not None or
            self.scale is not None or
            self.ValueMapping_formats_DataPoint or
            self.ValueMapping_uses_PhysicalSegmentLocation is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ValueMapping', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.decimalPositions is not None:
            decimalPositions_ = self.decimalPositions
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}decimalPositions').text = self.gds_format_integer(decimalPositions_)
        if self.defaultDecimalSeparator is not None:
            defaultDecimalSeparator_ = self.defaultDecimalSeparator
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}defaultDecimalSeparator').text = self.gds_format_string(defaultDecimalSeparator_)
        if self.defaultDigitGroupSeparator is not None:
            defaultDigitGroupSeparator_ = self.defaultDigitGroupSeparator
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}defaultDigitGroupSeparator').text = self.gds_format_string(defaultDigitGroupSeparator_)
        if self.defaultValue is not None:
            defaultValue_ = self.defaultValue
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}defaultValue').text = self.gds_format_string(defaultValue_)
        if self.format is not None:
            format_ = self.format
            format_.to_etree(element, name_='format', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isRequired is not None:
            isRequired_ = self.isRequired
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isRequired').text = self.gds_format_boolean(isRequired_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}length').text = self.gds_format_integer(length_)
        if self.maximumLength is not None:
            maximumLength_ = self.maximumLength
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}maximumLength').text = self.gds_format_integer(maximumLength_)
        if self.minimumLength is not None:
            minimumLength_ = self.minimumLength
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}minimumLength').text = self.gds_format_integer(minimumLength_)
        if self.nullSequence is not None:
            nullSequence_ = self.nullSequence
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}nullSequence').text = self.gds_format_string(nullSequence_)
        if self.numberPattern is not None:
            numberPattern_ = self.numberPattern
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}numberPattern').text = self.gds_format_string(numberPattern_)
        if self.physicalDataType is not None:
            physicalDataType_ = self.physicalDataType
            physicalDataType_.to_etree(element, name_='physicalDataType', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.scale is not None:
            scale_ = self.scale
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}scale').text = self.gds_format_integer(scale_)
        for ValueMapping_formats_DataPoint_ in self.ValueMapping_formats_DataPoint:
            ValueMapping_formats_DataPoint_.to_etree(element, name_='ValueMapping_formats_DataPoint', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ValueMapping_uses_PhysicalSegmentLocation is not None:
            ValueMapping_uses_PhysicalSegmentLocation_ = self.ValueMapping_uses_PhysicalSegmentLocation
            ValueMapping_uses_PhysicalSegmentLocation_.to_etree(element, name_='ValueMapping_uses_PhysicalSegmentLocation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'decimalPositions' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'decimalPositions')
            ival_ = self.gds_validate_integer(ival_, node, 'decimalPositions')
            self.decimalPositions = ival_
            self.decimalPositions_nsprefix_ = child_.prefix
        elif nodeName_ == 'defaultDecimalSeparator':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'defaultDecimalSeparator')
            value_ = self.gds_validate_string(value_, node, 'defaultDecimalSeparator')
            self.defaultDecimalSeparator = value_
            self.defaultDecimalSeparator_nsprefix_ = child_.prefix
        elif nodeName_ == 'defaultDigitGroupSeparator':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'defaultDigitGroupSeparator')
            value_ = self.gds_validate_string(value_, node, 'defaultDigitGroupSeparator')
            self.defaultDigitGroupSeparator = value_
            self.defaultDigitGroupSeparator_nsprefix_ = child_.prefix
        elif nodeName_ == 'defaultValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'defaultValue')
            value_ = self.gds_validate_string(value_, node, 'defaultValue')
            self.defaultValue = value_
            self.defaultValue_nsprefix_ = child_.prefix
        elif nodeName_ == 'format':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.format = obj_
            obj_.original_tagname_ = 'format'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'isRequired':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isRequired')
            ival_ = self.gds_validate_boolean(ival_, node, 'isRequired')
            self.isRequired = ival_
            self.isRequired_nsprefix_ = child_.prefix
        elif nodeName_ == 'length' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'length')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
            self.length_nsprefix_ = child_.prefix
        elif nodeName_ == 'maximumLength' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'maximumLength')
            ival_ = self.gds_validate_integer(ival_, node, 'maximumLength')
            self.maximumLength = ival_
            self.maximumLength_nsprefix_ = child_.prefix
        elif nodeName_ == 'minimumLength' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'minimumLength')
            ival_ = self.gds_validate_integer(ival_, node, 'minimumLength')
            self.minimumLength = ival_
            self.minimumLength_nsprefix_ = child_.prefix
        elif nodeName_ == 'nullSequence':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nullSequence')
            value_ = self.gds_validate_string(value_, node, 'nullSequence')
            self.nullSequence = value_
            self.nullSequence_nsprefix_ = child_.prefix
        elif nodeName_ == 'numberPattern':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'numberPattern')
            value_ = self.gds_validate_string(value_, node, 'numberPattern')
            self.numberPattern = value_
            self.numberPattern_nsprefix_ = child_.prefix
        elif nodeName_ == 'physicalDataType':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physicalDataType = obj_
            obj_.original_tagname_ = 'physicalDataType'
        elif nodeName_ == 'scale' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'scale')
            ival_ = self.gds_validate_integer(ival_, node, 'scale')
            self.scale = ival_
            self.scale_nsprefix_ = child_.prefix
        elif nodeName_ == 'ValueMapping_formats_DataPoint':
            obj_ = ValueMapping_formats_DataPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueMapping_formats_DataPoint.append(obj_)
            obj_.original_tagname_ = 'ValueMapping_formats_DataPoint'
        elif nodeName_ == 'ValueMapping_uses_PhysicalSegmentLocation':
            obj_ = ValueMapping_uses_PhysicalSegmentLocationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueMapping_uses_PhysicalSegmentLocation = obj_
            obj_.original_tagname_ = 'ValueMapping_uses_PhysicalSegmentLocation'
# end class ValueMapping


class ValueMappingPosition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    value -- Index value of the member in an ordered array.
    ValueMappingPosition_indexes_ValueMapping -- Assigns a position to a value mapping within a physical segment.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, value=None, ValueMappingPosition_indexes_ValueMapping=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.ValueMappingPosition_indexes_ValueMapping = ValueMappingPosition_indexes_ValueMapping
        self.ValueMappingPosition_indexes_ValueMapping_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueMappingPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueMappingPosition.subclass:
            return ValueMappingPosition.subclass(*args_, **kwargs_)
        else:
            return ValueMappingPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_ValueMappingPosition_indexes_ValueMapping(self):
        return self.ValueMappingPosition_indexes_ValueMapping
    def set_ValueMappingPosition_indexes_ValueMapping(self, ValueMappingPosition_indexes_ValueMapping):
        self.ValueMappingPosition_indexes_ValueMapping = ValueMappingPosition_indexes_ValueMapping
    def has__content(self):
        if (
            self.identifier is not None or
            self.value is not None or
            self.ValueMappingPosition_indexes_ValueMapping is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ValueMappingPosition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_integer(value_)
        if self.ValueMappingPosition_indexes_ValueMapping is not None:
            ValueMappingPosition_indexes_ValueMapping_ = self.ValueMappingPosition_indexes_ValueMapping
            ValueMappingPosition_indexes_ValueMapping_.to_etree(element, name_='ValueMappingPosition_indexes_ValueMapping', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
        elif nodeName_ == 'ValueMappingPosition_indexes_ValueMapping':
            obj_ = ValueMappingPosition_indexes_ValueMappingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueMappingPosition_indexes_ValueMapping = obj_
            obj_.original_tagname_ = 'ValueMappingPosition_indexes_ValueMapping'
# end class ValueMappingPosition


class ValueMappingRelationship(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    ValueMappingRelationship_hasTarget_ValueMapping -- Specialization of target to variable mapping. Restricts cardinality.
    ValueMappingRelationship_hasSource_ValueMapping -- Specialization of source to variable mapping.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, semantics=None, ValueMappingRelationship_hasTarget_ValueMapping=None, ValueMappingRelationship_hasSource_ValueMapping=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        if ValueMappingRelationship_hasTarget_ValueMapping is None:
            self.ValueMappingRelationship_hasTarget_ValueMapping = []
        else:
            self.ValueMappingRelationship_hasTarget_ValueMapping = ValueMappingRelationship_hasTarget_ValueMapping
        self.ValueMappingRelationship_hasTarget_ValueMapping_nsprefix_ = None
        if ValueMappingRelationship_hasSource_ValueMapping is None:
            self.ValueMappingRelationship_hasSource_ValueMapping = []
        else:
            self.ValueMappingRelationship_hasSource_ValueMapping = ValueMappingRelationship_hasSource_ValueMapping
        self.ValueMappingRelationship_hasSource_ValueMapping_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueMappingRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueMappingRelationship.subclass:
            return ValueMappingRelationship.subclass(*args_, **kwargs_)
        else:
            return ValueMappingRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_ValueMappingRelationship_hasTarget_ValueMapping(self):
        return self.ValueMappingRelationship_hasTarget_ValueMapping
    def set_ValueMappingRelationship_hasTarget_ValueMapping(self, ValueMappingRelationship_hasTarget_ValueMapping):
        self.ValueMappingRelationship_hasTarget_ValueMapping = ValueMappingRelationship_hasTarget_ValueMapping
    def add_ValueMappingRelationship_hasTarget_ValueMapping(self, value):
        self.ValueMappingRelationship_hasTarget_ValueMapping.append(value)
    def insert_ValueMappingRelationship_hasTarget_ValueMapping_at(self, index, value):
        self.ValueMappingRelationship_hasTarget_ValueMapping.insert(index, value)
    def replace_ValueMappingRelationship_hasTarget_ValueMapping_at(self, index, value):
        self.ValueMappingRelationship_hasTarget_ValueMapping[index] = value
    def get_ValueMappingRelationship_hasSource_ValueMapping(self):
        return self.ValueMappingRelationship_hasSource_ValueMapping
    def set_ValueMappingRelationship_hasSource_ValueMapping(self, ValueMappingRelationship_hasSource_ValueMapping):
        self.ValueMappingRelationship_hasSource_ValueMapping = ValueMappingRelationship_hasSource_ValueMapping
    def add_ValueMappingRelationship_hasSource_ValueMapping(self, value):
        self.ValueMappingRelationship_hasSource_ValueMapping.append(value)
    def insert_ValueMappingRelationship_hasSource_ValueMapping_at(self, index, value):
        self.ValueMappingRelationship_hasSource_ValueMapping.insert(index, value)
    def replace_ValueMappingRelationship_hasSource_ValueMapping_at(self, index, value):
        self.ValueMappingRelationship_hasSource_ValueMapping[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.semantics is not None or
            self.ValueMappingRelationship_hasTarget_ValueMapping or
            self.ValueMappingRelationship_hasSource_ValueMapping
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ValueMappingRelationship', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ValueMappingRelationship_hasTarget_ValueMapping_ in self.ValueMappingRelationship_hasTarget_ValueMapping:
            ValueMappingRelationship_hasTarget_ValueMapping_.to_etree(element, name_='ValueMappingRelationship_hasTarget_ValueMapping', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for ValueMappingRelationship_hasSource_ValueMapping_ in self.ValueMappingRelationship_hasSource_ValueMapping:
            ValueMappingRelationship_hasSource_ValueMapping_.to_etree(element, name_='ValueMappingRelationship_hasSource_ValueMapping', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'ValueMappingRelationship_hasTarget_ValueMapping':
            obj_ = ValueMappingRelationship_hasTarget_ValueMappingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueMappingRelationship_hasTarget_ValueMapping.append(obj_)
            obj_.original_tagname_ = 'ValueMappingRelationship_hasTarget_ValueMapping'
        elif nodeName_ == 'ValueMappingRelationship_hasSource_ValueMapping':
            obj_ = ValueMappingRelationship_hasSource_ValueMappingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValueMappingRelationship_hasSource_ValueMapping.append(obj_)
            obj_.original_tagname_ = 'ValueMappingRelationship_hasSource_ValueMapping'
# end class ValueMappingRelationship


class VariableCollection(GeneratedsSuper):
    """allowsDuplicates -- If value is False, the members are unique within the collection - if True, there may be duplicates. (Note that a mathematical
    “
    bag
    ”
    permits duplicates and is unordered - a
    “
    set
    ”
    does not have duplicates and may be ordered.)
    displayLabel -- A human-readable display label for the object. Supports the use of multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.
    groupingSemantic -- A semantic term defining the factor used for defining this group.
    identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    usage -- Explanation of the ways in which the object is employed.
    VariableCollection_isDefinedBy_Concept -- The conceptual basis for the collection of members.
    VariableCollection_has_ConceptualVariable -- Variable collection has zero to many conceptual variables.
    VariableCollection_has_VariablePosition -- Variable collection has zero to many variable positions.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, allowsDuplicates=None, displayLabel=None, groupingSemantic=None, identifier=None, name=None, purpose=None, usage=None, VariableCollection_isDefinedBy_Concept=None, VariableCollection_has_ConceptualVariable=None, VariableCollection_has_VariablePosition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.allowsDuplicates = allowsDuplicates
        self.allowsDuplicates_nsprefix_ = None
        if displayLabel is None:
            self.displayLabel = []
        else:
            self.displayLabel = displayLabel
        self.displayLabel_nsprefix_ = None
        self.groupingSemantic = groupingSemantic
        self.groupingSemantic_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.usage = usage
        self.usage_nsprefix_ = None
        if VariableCollection_isDefinedBy_Concept is None:
            self.VariableCollection_isDefinedBy_Concept = []
        else:
            self.VariableCollection_isDefinedBy_Concept = VariableCollection_isDefinedBy_Concept
        self.VariableCollection_isDefinedBy_Concept_nsprefix_ = None
        if VariableCollection_has_ConceptualVariable is None:
            self.VariableCollection_has_ConceptualVariable = []
        else:
            self.VariableCollection_has_ConceptualVariable = VariableCollection_has_ConceptualVariable
        self.VariableCollection_has_ConceptualVariable_nsprefix_ = None
        if VariableCollection_has_VariablePosition is None:
            self.VariableCollection_has_VariablePosition = []
        else:
            self.VariableCollection_has_VariablePosition = VariableCollection_has_VariablePosition
        self.VariableCollection_has_VariablePosition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableCollection.subclass:
            return VariableCollection.subclass(*args_, **kwargs_)
        else:
            return VariableCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_allowsDuplicates(self):
        return self.allowsDuplicates
    def set_allowsDuplicates(self, allowsDuplicates):
        self.allowsDuplicates = allowsDuplicates
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def add_displayLabel(self, value):
        self.displayLabel.append(value)
    def insert_displayLabel_at(self, index, value):
        self.displayLabel.insert(index, value)
    def replace_displayLabel_at(self, index, value):
        self.displayLabel[index] = value
    def get_groupingSemantic(self):
        return self.groupingSemantic
    def set_groupingSemantic(self, groupingSemantic):
        self.groupingSemantic = groupingSemantic
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_VariableCollection_isDefinedBy_Concept(self):
        return self.VariableCollection_isDefinedBy_Concept
    def set_VariableCollection_isDefinedBy_Concept(self, VariableCollection_isDefinedBy_Concept):
        self.VariableCollection_isDefinedBy_Concept = VariableCollection_isDefinedBy_Concept
    def add_VariableCollection_isDefinedBy_Concept(self, value):
        self.VariableCollection_isDefinedBy_Concept.append(value)
    def insert_VariableCollection_isDefinedBy_Concept_at(self, index, value):
        self.VariableCollection_isDefinedBy_Concept.insert(index, value)
    def replace_VariableCollection_isDefinedBy_Concept_at(self, index, value):
        self.VariableCollection_isDefinedBy_Concept[index] = value
    def get_VariableCollection_has_ConceptualVariable(self):
        return self.VariableCollection_has_ConceptualVariable
    def set_VariableCollection_has_ConceptualVariable(self, VariableCollection_has_ConceptualVariable):
        self.VariableCollection_has_ConceptualVariable = VariableCollection_has_ConceptualVariable
    def add_VariableCollection_has_ConceptualVariable(self, value):
        self.VariableCollection_has_ConceptualVariable.append(value)
    def insert_VariableCollection_has_ConceptualVariable_at(self, index, value):
        self.VariableCollection_has_ConceptualVariable.insert(index, value)
    def replace_VariableCollection_has_ConceptualVariable_at(self, index, value):
        self.VariableCollection_has_ConceptualVariable[index] = value
    def get_VariableCollection_has_VariablePosition(self):
        return self.VariableCollection_has_VariablePosition
    def set_VariableCollection_has_VariablePosition(self, VariableCollection_has_VariablePosition):
        self.VariableCollection_has_VariablePosition = VariableCollection_has_VariablePosition
    def add_VariableCollection_has_VariablePosition(self, value):
        self.VariableCollection_has_VariablePosition.append(value)
    def insert_VariableCollection_has_VariablePosition_at(self, index, value):
        self.VariableCollection_has_VariablePosition.insert(index, value)
    def replace_VariableCollection_has_VariablePosition_at(self, index, value):
        self.VariableCollection_has_VariablePosition[index] = value
    def has__content(self):
        if (
            self.allowsDuplicates is not None or
            self.displayLabel or
            self.groupingSemantic is not None or
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.usage is not None or
            self.VariableCollection_isDefinedBy_Concept or
            self.VariableCollection_has_ConceptualVariable or
            self.VariableCollection_has_VariablePosition
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableCollection', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.allowsDuplicates is not None:
            allowsDuplicates_ = self.allowsDuplicates
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}allowsDuplicates').text = self.gds_format_boolean(allowsDuplicates_)
        for displayLabel_ in self.displayLabel:
            displayLabel_.to_etree(element, name_='displayLabel', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.groupingSemantic is not None:
            groupingSemantic_ = self.groupingSemantic
            groupingSemantic_.to_etree(element, name_='groupingSemantic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.usage is not None:
            usage_ = self.usage
            usage_.to_etree(element, name_='usage', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableCollection_isDefinedBy_Concept_ in self.VariableCollection_isDefinedBy_Concept:
            VariableCollection_isDefinedBy_Concept_.to_etree(element, name_='VariableCollection_isDefinedBy_Concept', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableCollection_has_ConceptualVariable_ in self.VariableCollection_has_ConceptualVariable:
            VariableCollection_has_ConceptualVariable_.to_etree(element, name_='VariableCollection_has_ConceptualVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableCollection_has_VariablePosition_ in self.VariableCollection_has_VariablePosition:
            VariableCollection_has_VariablePosition_.to_etree(element, name_='VariableCollection_has_VariablePosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allowsDuplicates':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'allowsDuplicates')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowsDuplicates')
            self.allowsDuplicates = ival_
            self.allowsDuplicates_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayLabel':
            obj_ = LabelForDisplay.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayLabel.append(obj_)
            obj_.original_tagname_ = 'displayLabel'
        elif nodeName_ == 'groupingSemantic':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.groupingSemantic = obj_
            obj_.original_tagname_ = 'groupingSemantic'
        elif nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'usage':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.usage = obj_
            obj_.original_tagname_ = 'usage'
        elif nodeName_ == 'VariableCollection_isDefinedBy_Concept':
            obj_ = VariableCollection_isDefinedBy_ConceptType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableCollection_isDefinedBy_Concept.append(obj_)
            obj_.original_tagname_ = 'VariableCollection_isDefinedBy_Concept'
        elif nodeName_ == 'VariableCollection_has_ConceptualVariable':
            obj_ = VariableCollection_has_ConceptualVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableCollection_has_ConceptualVariable.append(obj_)
            obj_.original_tagname_ = 'VariableCollection_has_ConceptualVariable'
        elif nodeName_ == 'VariableCollection_has_VariablePosition':
            obj_ = VariableCollection_has_VariablePositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableCollection_has_VariablePosition.append(obj_)
            obj_.original_tagname_ = 'VariableCollection_has_VariablePosition'
# end class VariableCollection


class VariableDescriptorComponent(DataStructureComponent):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataStructureComponent
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, VariableDescriptorComponent_isDefinedBy_DescriptorVariable=None, VariableDescriptorComponent_refersTo_VariableValueComponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("VariableDescriptorComponent"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable,  **kwargs_)
        self.VariableDescriptorComponent_isDefinedBy_DescriptorVariable = VariableDescriptorComponent_isDefinedBy_DescriptorVariable
        self.VariableDescriptorComponent_isDefinedBy_DescriptorVariable_nsprefix_ = None
        self.VariableDescriptorComponent_refersTo_VariableValueComponent = VariableDescriptorComponent_refersTo_VariableValueComponent
        self.VariableDescriptorComponent_refersTo_VariableValueComponent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableDescriptorComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableDescriptorComponent.subclass:
            return VariableDescriptorComponent.subclass(*args_, **kwargs_)
        else:
            return VariableDescriptorComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VariableDescriptorComponent_isDefinedBy_DescriptorVariable(self):
        return self.VariableDescriptorComponent_isDefinedBy_DescriptorVariable
    def set_VariableDescriptorComponent_isDefinedBy_DescriptorVariable(self, VariableDescriptorComponent_isDefinedBy_DescriptorVariable):
        self.VariableDescriptorComponent_isDefinedBy_DescriptorVariable = VariableDescriptorComponent_isDefinedBy_DescriptorVariable
    def get_VariableDescriptorComponent_refersTo_VariableValueComponent(self):
        return self.VariableDescriptorComponent_refersTo_VariableValueComponent
    def set_VariableDescriptorComponent_refersTo_VariableValueComponent(self, VariableDescriptorComponent_refersTo_VariableValueComponent):
        self.VariableDescriptorComponent_refersTo_VariableValueComponent = VariableDescriptorComponent_refersTo_VariableValueComponent
    def has__content(self):
        if (
            self.VariableDescriptorComponent_isDefinedBy_DescriptorVariable is not None or
            self.VariableDescriptorComponent_refersTo_VariableValueComponent is not None or
            super(VariableDescriptorComponent, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableDescriptorComponent', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(VariableDescriptorComponent, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.VariableDescriptorComponent_isDefinedBy_DescriptorVariable is not None:
            VariableDescriptorComponent_isDefinedBy_DescriptorVariable_ = self.VariableDescriptorComponent_isDefinedBy_DescriptorVariable
            VariableDescriptorComponent_isDefinedBy_DescriptorVariable_.to_etree(element, name_='VariableDescriptorComponent_isDefinedBy_DescriptorVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.VariableDescriptorComponent_refersTo_VariableValueComponent is not None:
            VariableDescriptorComponent_refersTo_VariableValueComponent_ = self.VariableDescriptorComponent_refersTo_VariableValueComponent
            VariableDescriptorComponent_refersTo_VariableValueComponent_.to_etree(element, name_='VariableDescriptorComponent_refersTo_VariableValueComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(VariableDescriptorComponent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VariableDescriptorComponent_isDefinedBy_DescriptorVariable':
            obj_ = VariableDescriptorComponent_isDefinedBy_DescriptorVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableDescriptorComponent_isDefinedBy_DescriptorVariable = obj_
            obj_.original_tagname_ = 'VariableDescriptorComponent_isDefinedBy_DescriptorVariable'
        elif nodeName_ == 'VariableDescriptorComponent_refersTo_VariableValueComponent':
            obj_ = VariableDescriptorComponent_refersTo_VariableValueComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableDescriptorComponent_refersTo_VariableValueComponent = obj_
            obj_.original_tagname_ = 'VariableDescriptorComponent_refersTo_VariableValueComponent'
        super(VariableDescriptorComponent, self)._buildChildren(child_, node, nodeName_, True)
# end class VariableDescriptorComponent


class VariablePosition(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    value -- Index value of the member in an ordered array.
    VariablePosition_indexes_ConceptualVariable -- Variable position indexes a conceptual variable.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, value=None, VariablePosition_indexes_ConceptualVariable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.VariablePosition_indexes_ConceptualVariable = VariablePosition_indexes_ConceptualVariable
        self.VariablePosition_indexes_ConceptualVariable_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariablePosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariablePosition.subclass:
            return VariablePosition.subclass(*args_, **kwargs_)
        else:
            return VariablePosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_VariablePosition_indexes_ConceptualVariable(self):
        return self.VariablePosition_indexes_ConceptualVariable
    def set_VariablePosition_indexes_ConceptualVariable(self, VariablePosition_indexes_ConceptualVariable):
        self.VariablePosition_indexes_ConceptualVariable = VariablePosition_indexes_ConceptualVariable
    def has__content(self):
        if (
            self.identifier is not None or
            self.value is not None or
            self.VariablePosition_indexes_ConceptualVariable is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariablePosition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_integer(value_)
        if self.VariablePosition_indexes_ConceptualVariable is not None:
            VariablePosition_indexes_ConceptualVariable_ = self.VariablePosition_indexes_ConceptualVariable
            VariablePosition_indexes_ConceptualVariable_.to_etree(element, name_='VariablePosition_indexes_ConceptualVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
        elif nodeName_ == 'VariablePosition_indexes_ConceptualVariable':
            obj_ = VariablePosition_indexes_ConceptualVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariablePosition_indexes_ConceptualVariable = obj_
            obj_.original_tagname_ = 'VariablePosition_indexes_ConceptualVariable'
# end class VariablePosition


class VariableRelationship(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    VariableRelationship_hasTarget_ConceptualVariable -- Note that this can be realized as a collection to support tuples.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, semantics=None, VariableRelationship_hasTarget_ConceptualVariable=None, VariableRelationship_hasSource_ConceptualVariable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        if VariableRelationship_hasTarget_ConceptualVariable is None:
            self.VariableRelationship_hasTarget_ConceptualVariable = []
        else:
            self.VariableRelationship_hasTarget_ConceptualVariable = VariableRelationship_hasTarget_ConceptualVariable
        self.VariableRelationship_hasTarget_ConceptualVariable_nsprefix_ = None
        if VariableRelationship_hasSource_ConceptualVariable is None:
            self.VariableRelationship_hasSource_ConceptualVariable = []
        else:
            self.VariableRelationship_hasSource_ConceptualVariable = VariableRelationship_hasSource_ConceptualVariable
        self.VariableRelationship_hasSource_ConceptualVariable_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableRelationship.subclass:
            return VariableRelationship.subclass(*args_, **kwargs_)
        else:
            return VariableRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_VariableRelationship_hasTarget_ConceptualVariable(self):
        return self.VariableRelationship_hasTarget_ConceptualVariable
    def set_VariableRelationship_hasTarget_ConceptualVariable(self, VariableRelationship_hasTarget_ConceptualVariable):
        self.VariableRelationship_hasTarget_ConceptualVariable = VariableRelationship_hasTarget_ConceptualVariable
    def add_VariableRelationship_hasTarget_ConceptualVariable(self, value):
        self.VariableRelationship_hasTarget_ConceptualVariable.append(value)
    def insert_VariableRelationship_hasTarget_ConceptualVariable_at(self, index, value):
        self.VariableRelationship_hasTarget_ConceptualVariable.insert(index, value)
    def replace_VariableRelationship_hasTarget_ConceptualVariable_at(self, index, value):
        self.VariableRelationship_hasTarget_ConceptualVariable[index] = value
    def get_VariableRelationship_hasSource_ConceptualVariable(self):
        return self.VariableRelationship_hasSource_ConceptualVariable
    def set_VariableRelationship_hasSource_ConceptualVariable(self, VariableRelationship_hasSource_ConceptualVariable):
        self.VariableRelationship_hasSource_ConceptualVariable = VariableRelationship_hasSource_ConceptualVariable
    def add_VariableRelationship_hasSource_ConceptualVariable(self, value):
        self.VariableRelationship_hasSource_ConceptualVariable.append(value)
    def insert_VariableRelationship_hasSource_ConceptualVariable_at(self, index, value):
        self.VariableRelationship_hasSource_ConceptualVariable.insert(index, value)
    def replace_VariableRelationship_hasSource_ConceptualVariable_at(self, index, value):
        self.VariableRelationship_hasSource_ConceptualVariable[index] = value
    def has__content(self):
        if (
            self.identifier is not None or
            self.semantics is not None or
            self.VariableRelationship_hasTarget_ConceptualVariable or
            self.VariableRelationship_hasSource_ConceptualVariable
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableRelationship', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableRelationship_hasTarget_ConceptualVariable_ in self.VariableRelationship_hasTarget_ConceptualVariable:
            VariableRelationship_hasTarget_ConceptualVariable_.to_etree(element, name_='VariableRelationship_hasTarget_ConceptualVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableRelationship_hasSource_ConceptualVariable_ in self.VariableRelationship_hasSource_ConceptualVariable:
            VariableRelationship_hasSource_ConceptualVariable_.to_etree(element, name_='VariableRelationship_hasSource_ConceptualVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'VariableRelationship_hasTarget_ConceptualVariable':
            obj_ = VariableRelationship_hasTarget_ConceptualVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableRelationship_hasTarget_ConceptualVariable.append(obj_)
            obj_.original_tagname_ = 'VariableRelationship_hasTarget_ConceptualVariable'
        elif nodeName_ == 'VariableRelationship_hasSource_ConceptualVariable':
            obj_ = VariableRelationship_hasSource_ConceptualVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableRelationship_hasSource_ConceptualVariable.append(obj_)
            obj_.original_tagname_ = 'VariableRelationship_hasSource_ConceptualVariable'
# end class VariableRelationship


class VariableStructure(GeneratedsSuper):
    """identifier -- Identifier for objects requiring short- or long-lasting referencing and management.
    name -- Human understandable name (liguistic signifier, word, phrase, or mnemonic). May follow ISO/IEC 11179-5 naming principles, and have context provided to specify usage.
    purpose -- Intent or reason for the object/the description of the object.
    semantics -- Specifies the semantics of the object in reference to a vocabulary, ontology, etc.
    specification -- Provides information on reflexivity, transitivity, and symmetry of relationship using a descriptive term from an enumerated list. Use if all relations within this relation structure are of the same specification.
    topology -- Indicates the form of the associations among members of the collection. Specifies the way in which constituent parts are interrelated or arranged.
    totality -- Indicates whether the related collections are comprehensive in terms of their coverage.
    VariableStructure_structures_VariableCollection -- Variable structure structures zero to one variable collection.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifier=None, name=None, purpose=None, semantics=None, specification=None, topology=None, totality=None, VariableStructure_structures_VariableCollection=None, VariableStructure_has_VariableRelationship=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.purpose = purpose
        self.purpose_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
        self.specification = specification
        self.specification_nsprefix_ = None
        self.topology = topology
        self.topology_nsprefix_ = None
        self.totality = totality
        self.validate_StructureExtent(self.totality)
        self.totality_nsprefix_ = None
        self.VariableStructure_structures_VariableCollection = VariableStructure_structures_VariableCollection
        self.VariableStructure_structures_VariableCollection_nsprefix_ = None
        if VariableStructure_has_VariableRelationship is None:
            self.VariableStructure_has_VariableRelationship = []
        else:
            self.VariableStructure_has_VariableRelationship = VariableStructure_has_VariableRelationship
        self.VariableStructure_has_VariableRelationship_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableStructure.subclass:
            return VariableStructure.subclass(*args_, **kwargs_)
        else:
            return VariableStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def get_specification(self):
        return self.specification
    def set_specification(self, specification):
        self.specification = specification
    def get_topology(self):
        return self.topology
    def set_topology(self, topology):
        self.topology = topology
    def get_totality(self):
        return self.totality
    def set_totality(self, totality):
        self.totality = totality
    def get_VariableStructure_structures_VariableCollection(self):
        return self.VariableStructure_structures_VariableCollection
    def set_VariableStructure_structures_VariableCollection(self, VariableStructure_structures_VariableCollection):
        self.VariableStructure_structures_VariableCollection = VariableStructure_structures_VariableCollection
    def get_VariableStructure_has_VariableRelationship(self):
        return self.VariableStructure_has_VariableRelationship
    def set_VariableStructure_has_VariableRelationship(self, VariableStructure_has_VariableRelationship):
        self.VariableStructure_has_VariableRelationship = VariableStructure_has_VariableRelationship
    def add_VariableStructure_has_VariableRelationship(self, value):
        self.VariableStructure_has_VariableRelationship.append(value)
    def insert_VariableStructure_has_VariableRelationship_at(self, index, value):
        self.VariableStructure_has_VariableRelationship.insert(index, value)
    def replace_VariableStructure_has_VariableRelationship_at(self, index, value):
        self.VariableStructure_has_VariableRelationship[index] = value
    def validate_StructureExtent(self, value):
        result = True
        # Validate type StructureExtent, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Partial', 'Total']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StructureExtent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.identifier is not None or
            self.name or
            self.purpose is not None or
            self.semantics is not None or
            self.specification is not None or
            self.topology is not None or
            self.totality is not None or
            self.VariableStructure_structures_VariableCollection is not None or
            self.VariableStructure_has_VariableRelationship
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for name_ in self.name:
            name_.to_etree(element, name_='name', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.purpose is not None:
            purpose_ = self.purpose
            purpose_.to_etree(element, name_='purpose', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.specification is not None:
            specification_ = self.specification
            specification_.to_etree(element, name_='specification', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.topology is not None:
            topology_ = self.topology
            topology_.to_etree(element, name_='topology', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.totality is not None:
            totality_ = self.totality
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}totality').text = self.gds_format_string(totality_)
        if self.VariableStructure_structures_VariableCollection is not None:
            VariableStructure_structures_VariableCollection_ = self.VariableStructure_structures_VariableCollection
            VariableStructure_structures_VariableCollection_.to_etree(element, name_='VariableStructure_structures_VariableCollection', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for VariableStructure_has_VariableRelationship_ in self.VariableStructure_has_VariableRelationship:
            VariableStructure_has_VariableRelationship_.to_etree(element, name_='VariableStructure_has_VariableRelationship', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifier':
            obj_ = Identifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'name':
            obj_ = OrganizationName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purpose = obj_
            obj_.original_tagname_ = 'purpose'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
        elif nodeName_ == 'specification':
            obj_ = StructureSpecification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specification = obj_
            obj_.original_tagname_ = 'specification'
        elif nodeName_ == 'topology':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.topology = obj_
            obj_.original_tagname_ = 'topology'
        elif nodeName_ == 'totality':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'totality')
            value_ = self.gds_validate_string(value_, node, 'totality')
            self.totality = value_
            self.totality_nsprefix_ = child_.prefix
            # validate type StructureExtent
            self.validate_StructureExtent(self.totality)
        elif nodeName_ == 'VariableStructure_structures_VariableCollection':
            obj_ = VariableStructure_structures_VariableCollectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableStructure_structures_VariableCollection = obj_
            obj_.original_tagname_ = 'VariableStructure_structures_VariableCollection'
        elif nodeName_ == 'VariableStructure_has_VariableRelationship':
            obj_ = VariableStructure_has_VariableRelationshipType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableStructure_has_VariableRelationship.append(obj_)
            obj_.original_tagname_ = 'VariableStructure_has_VariableRelationship'
# end class VariableStructure


class VariableValueComponent(DataStructureComponent):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataStructureComponent
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("VariableValueComponent"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableValueComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableValueComponent.subclass:
            return VariableValueComponent.subclass(*args_, **kwargs_)
        else:
            return VariableValueComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(VariableValueComponent, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableValueComponent', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(VariableValueComponent, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(VariableValueComponent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(VariableValueComponent, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class VariableValueComponent


class WideDataSet(DataSet):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataSet
    def __init__(self, catalogDetails=None, identifier=None, DataSet_isStructuredBy_DataStructure=None, DataSet_has_DataPoint=None, DataSet_has_Key=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("WideDataSet"), self).__init__(catalogDetails, identifier, DataSet_isStructuredBy_DataStructure, DataSet_has_DataPoint, DataSet_has_Key,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WideDataSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WideDataSet.subclass:
            return WideDataSet.subclass(*args_, **kwargs_)
        else:
            return WideDataSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(WideDataSet, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='WideDataSet', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(WideDataSet, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(WideDataSet, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(WideDataSet, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class WideDataSet


class WideKey(Key):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Key
    def __init__(self, identifier=None, Key_correspondsTo_Unit=None, Key_represents_KeyDefinition=None, Key_identifies_DataPoint=None, Key_correspondsTo_Universe=None, Key_has_KeyMember=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("WideKey"), self).__init__(identifier, Key_correspondsTo_Unit, Key_represents_KeyDefinition, Key_identifies_DataPoint, Key_correspondsTo_Universe, Key_has_KeyMember,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WideKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WideKey.subclass:
            return WideKey.subclass(*args_, **kwargs_)
        else:
            return WideKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(WideKey, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='WideKey', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(WideKey, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(WideKey, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(WideKey, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class WideKey


class WideKeyMember(KeyMember):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = KeyMember
    def __init__(self, content=None, identifier=None, whiteSpace=None, InstanceValue_hasValueFrom_ValueDomain=None, InstanceValue_isStoredIn_DataPoint=None, InstanceValue_represents_ConceptualValue=None, KeyMember_isBasedOn_DataStructureComponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("WideKeyMember"), self).__init__(content, identifier, whiteSpace, InstanceValue_hasValueFrom_ValueDomain, InstanceValue_isStoredIn_DataPoint, InstanceValue_represents_ConceptualValue, KeyMember_isBasedOn_DataStructureComponent,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WideKeyMember)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WideKeyMember.subclass:
            return WideKeyMember.subclass(*args_, **kwargs_)
        else:
            return WideKeyMember(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(WideKeyMember, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='WideKeyMember', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(WideKeyMember, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(WideKeyMember, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(WideKeyMember, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class WideKeyMember


class AccessInformation(GeneratedsSuper):
    """copyright -- The copyright statement.
    embargo -- Specific information about any relevant embargo
    license -- Information about any relevant license
    rights -- Information about rights held in and over the resource. Typically, rights information includes a statement about various property rights associated with the resource, including intellectual property rights.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, copyright=None, embargo=None, license=None, rights=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if copyright is None:
            self.copyright = []
        else:
            self.copyright = copyright
        self.copyright_nsprefix_ = None
        if embargo is None:
            self.embargo = []
        else:
            self.embargo = embargo
        self.embargo_nsprefix_ = None
        if license is None:
            self.license = []
        else:
            self.license = license
        self.license_nsprefix_ = None
        if rights is None:
            self.rights = []
        else:
            self.rights = rights
        self.rights_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccessInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccessInformation.subclass:
            return AccessInformation.subclass(*args_, **kwargs_)
        else:
            return AccessInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_copyright(self):
        return self.copyright
    def set_copyright(self, copyright):
        self.copyright = copyright
    def add_copyright(self, value):
        self.copyright.append(value)
    def insert_copyright_at(self, index, value):
        self.copyright.insert(index, value)
    def replace_copyright_at(self, index, value):
        self.copyright[index] = value
    def get_embargo(self):
        return self.embargo
    def set_embargo(self, embargo):
        self.embargo = embargo
    def add_embargo(self, value):
        self.embargo.append(value)
    def insert_embargo_at(self, index, value):
        self.embargo.insert(index, value)
    def replace_embargo_at(self, index, value):
        self.embargo[index] = value
    def get_license(self):
        return self.license
    def set_license(self, license):
        self.license = license
    def add_license(self, value):
        self.license.append(value)
    def insert_license_at(self, index, value):
        self.license.insert(index, value)
    def replace_license_at(self, index, value):
        self.license[index] = value
    def get_rights(self):
        return self.rights
    def set_rights(self, rights):
        self.rights = rights
    def add_rights(self, value):
        self.rights.append(value)
    def insert_rights_at(self, index, value):
        self.rights.insert(index, value)
    def replace_rights_at(self, index, value):
        self.rights[index] = value
    def has__content(self):
        if (
            self.copyright or
            self.embargo or
            self.license or
            self.rights
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AccessInformation', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        for copyright_ in self.copyright:
            copyright_.to_etree(element, name_='copyright', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for embargo_ in self.embargo:
            embargo_.to_etree(element, name_='embargo', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for license_ in self.license:
            license_.to_etree(element, name_='license', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for rights_ in self.rights:
            rights_.to_etree(element, name_='rights', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'copyright':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.copyright.append(obj_)
            obj_.original_tagname_ = 'copyright'
        elif nodeName_ == 'embargo':
            obj_ = EmbargoInformation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.embargo.append(obj_)
            obj_.original_tagname_ = 'embargo'
        elif nodeName_ == 'license':
            obj_ = LicenseInformation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.license.append(obj_)
            obj_.original_tagname_ = 'license'
        elif nodeName_ == 'rights':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rights.append(obj_)
            obj_.original_tagname_ = 'rights'
# end class AccessInformation


class AccessLocation(GeneratedsSuper):
    """mimeType -- The MIME type. MIME stands for "Multipurpose Internet Mail Extensions. It's a way of identifying files on the Internet according to their nature and format. Supports the use of an controlled vocabulary.
    physicalLocation -- The physical location of the machine.
    uri -- A Uniform Resource Identifier (URI) is a string of characters that unambiguously identifies a particular resource. A URI is normally expressed as a URL.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, mimeType=None, physicalLocation=None, uri=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mimeType = mimeType
        self.mimeType_nsprefix_ = None
        if physicalLocation is None:
            self.physicalLocation = []
        else:
            self.physicalLocation = physicalLocation
        self.physicalLocation_nsprefix_ = None
        if uri is None:
            self.uri = []
        else:
            self.uri = uri
        self.uri_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccessLocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccessLocation.subclass:
            return AccessLocation.subclass(*args_, **kwargs_)
        else:
            return AccessLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mimeType(self):
        return self.mimeType
    def set_mimeType(self, mimeType):
        self.mimeType = mimeType
    def get_physicalLocation(self):
        return self.physicalLocation
    def set_physicalLocation(self, physicalLocation):
        self.physicalLocation = physicalLocation
    def add_physicalLocation(self, value):
        self.physicalLocation.append(value)
    def insert_physicalLocation_at(self, index, value):
        self.physicalLocation.insert(index, value)
    def replace_physicalLocation_at(self, index, value):
        self.physicalLocation[index] = value
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def add_uri(self, value):
        self.uri.append(value)
    def insert_uri_at(self, index, value):
        self.uri.insert(index, value)
    def replace_uri_at(self, index, value):
        self.uri[index] = value
    def has__content(self):
        if (
            self.mimeType is not None or
            self.physicalLocation or
            self.uri
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AccessLocation', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.mimeType is not None:
            mimeType_ = self.mimeType
            mimeType_.to_etree(element, name_='mimeType', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for physicalLocation_ in self.physicalLocation:
            physicalLocation_.to_etree(element, name_='physicalLocation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for uri_ in self.uri:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}uri').text = self.gds_format_string(uri_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mimeType':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mimeType = obj_
            obj_.original_tagname_ = 'mimeType'
        elif nodeName_ == 'physicalLocation':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physicalLocation.append(obj_)
            obj_.original_tagname_ = 'physicalLocation'
        elif nodeName_ == 'uri':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'uri')
            value_ = self.gds_validate_string(value_, node, 'uri')
            self.uri.append(value_)
            self.uri_nsprefix_ = child_.prefix
# end class AccessLocation


class Address(GeneratedsSuper):
    """cityPlaceLocal -- City, place, or local area used as part of an address.
    countryCode -- Country of the location.
    effectiveDates -- Clarifies when the identification information is accurate.
    geographicPoint -- Geographic coordinates corresponding to the address.
    isPreferred -- Set to True if this is the preferred location for contacting the organization or individual.
    line -- Number and street including office or suite number. May use multiple lines.
    locationName -- Name of the location if applicable.
    postalCode -- Postal or ZIP Code.
    privacy -- Specify the level privacy for the address as public, restricted, or private. Supports the use of an external controlled vocabulary.
    regionalCoverage -- The region covered by the agent at this address.
    stateProvince -- A major sub-national division such as a state or province used to identify a major region within an address.
    timeZone -- Time zone of the location expressed as code.
    typeOfAddress -- Indicates address type (i.e. home, office, mailing, etc.).
    typeOfLocation -- The type or purpose of the location (i.e. regional office, distribution center, home).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cityPlaceLocal=None, countryCode=None, effectiveDates=None, geographicPoint=None, isPreferred=None, line=None, locationName=None, postalCode=None, privacy=None, regionalCoverage=None, stateProvince=None, timeZone=None, typeOfAddress=None, typeOfLocation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cityPlaceLocal = cityPlaceLocal
        self.cityPlaceLocal_nsprefix_ = None
        self.countryCode = countryCode
        self.countryCode_nsprefix_ = None
        self.effectiveDates = effectiveDates
        self.effectiveDates_nsprefix_ = None
        self.geographicPoint = geographicPoint
        self.geographicPoint_nsprefix_ = None
        self.isPreferred = isPreferred
        self.isPreferred_nsprefix_ = None
        if line is None:
            self.line = []
        else:
            self.line = line
        self.line_nsprefix_ = None
        self.locationName = locationName
        self.locationName_nsprefix_ = None
        self.postalCode = postalCode
        self.postalCode_nsprefix_ = None
        self.privacy = privacy
        self.privacy_nsprefix_ = None
        self.regionalCoverage = regionalCoverage
        self.regionalCoverage_nsprefix_ = None
        self.stateProvince = stateProvince
        self.stateProvince_nsprefix_ = None
        self.timeZone = timeZone
        self.timeZone_nsprefix_ = None
        self.typeOfAddress = typeOfAddress
        self.typeOfAddress_nsprefix_ = None
        self.typeOfLocation = typeOfLocation
        self.typeOfLocation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Address)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Address.subclass:
            return Address.subclass(*args_, **kwargs_)
        else:
            return Address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cityPlaceLocal(self):
        return self.cityPlaceLocal
    def set_cityPlaceLocal(self, cityPlaceLocal):
        self.cityPlaceLocal = cityPlaceLocal
    def get_countryCode(self):
        return self.countryCode
    def set_countryCode(self, countryCode):
        self.countryCode = countryCode
    def get_effectiveDates(self):
        return self.effectiveDates
    def set_effectiveDates(self, effectiveDates):
        self.effectiveDates = effectiveDates
    def get_geographicPoint(self):
        return self.geographicPoint
    def set_geographicPoint(self, geographicPoint):
        self.geographicPoint = geographicPoint
    def get_isPreferred(self):
        return self.isPreferred
    def set_isPreferred(self, isPreferred):
        self.isPreferred = isPreferred
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def add_line(self, value):
        self.line.append(value)
    def insert_line_at(self, index, value):
        self.line.insert(index, value)
    def replace_line_at(self, index, value):
        self.line[index] = value
    def get_locationName(self):
        return self.locationName
    def set_locationName(self, locationName):
        self.locationName = locationName
    def get_postalCode(self):
        return self.postalCode
    def set_postalCode(self, postalCode):
        self.postalCode = postalCode
    def get_privacy(self):
        return self.privacy
    def set_privacy(self, privacy):
        self.privacy = privacy
    def get_regionalCoverage(self):
        return self.regionalCoverage
    def set_regionalCoverage(self, regionalCoverage):
        self.regionalCoverage = regionalCoverage
    def get_stateProvince(self):
        return self.stateProvince
    def set_stateProvince(self, stateProvince):
        self.stateProvince = stateProvince
    def get_timeZone(self):
        return self.timeZone
    def set_timeZone(self, timeZone):
        self.timeZone = timeZone
    def get_typeOfAddress(self):
        return self.typeOfAddress
    def set_typeOfAddress(self, typeOfAddress):
        self.typeOfAddress = typeOfAddress
    def get_typeOfLocation(self):
        return self.typeOfLocation
    def set_typeOfLocation(self, typeOfLocation):
        self.typeOfLocation = typeOfLocation
    def has__content(self):
        if (
            self.cityPlaceLocal is not None or
            self.countryCode is not None or
            self.effectiveDates is not None or
            self.geographicPoint is not None or
            self.isPreferred is not None or
            self.line or
            self.locationName is not None or
            self.postalCode is not None or
            self.privacy is not None or
            self.regionalCoverage is not None or
            self.stateProvince is not None or
            self.timeZone is not None or
            self.typeOfAddress is not None or
            self.typeOfLocation is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Address', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.cityPlaceLocal is not None:
            cityPlaceLocal_ = self.cityPlaceLocal
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}cityPlaceLocal').text = self.gds_format_string(cityPlaceLocal_)
        if self.countryCode is not None:
            countryCode_ = self.countryCode
            countryCode_.to_etree(element, name_='countryCode', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.effectiveDates is not None:
            effectiveDates_ = self.effectiveDates
            effectiveDates_.to_etree(element, name_='effectiveDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.geographicPoint is not None:
            geographicPoint_ = self.geographicPoint
            geographicPoint_.to_etree(element, name_='geographicPoint', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isPreferred is not None:
            isPreferred_ = self.isPreferred
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isPreferred').text = self.gds_format_boolean(isPreferred_)
        for line_ in self.line:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}line').text = self.gds_format_string(line_)
        if self.locationName is not None:
            locationName_ = self.locationName
            locationName_.to_etree(element, name_='locationName', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.postalCode is not None:
            postalCode_ = self.postalCode
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}postalCode').text = self.gds_format_string(postalCode_)
        if self.privacy is not None:
            privacy_ = self.privacy
            privacy_.to_etree(element, name_='privacy', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.regionalCoverage is not None:
            regionalCoverage_ = self.regionalCoverage
            regionalCoverage_.to_etree(element, name_='regionalCoverage', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.stateProvince is not None:
            stateProvince_ = self.stateProvince
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}stateProvince').text = self.gds_format_string(stateProvince_)
        if self.timeZone is not None:
            timeZone_ = self.timeZone
            timeZone_.to_etree(element, name_='timeZone', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.typeOfAddress is not None:
            typeOfAddress_ = self.typeOfAddress
            typeOfAddress_.to_etree(element, name_='typeOfAddress', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.typeOfLocation is not None:
            typeOfLocation_ = self.typeOfLocation
            typeOfLocation_.to_etree(element, name_='typeOfLocation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cityPlaceLocal':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cityPlaceLocal')
            value_ = self.gds_validate_string(value_, node, 'cityPlaceLocal')
            self.cityPlaceLocal = value_
            self.cityPlaceLocal_nsprefix_ = child_.prefix
        elif nodeName_ == 'countryCode':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.countryCode = obj_
            obj_.original_tagname_ = 'countryCode'
        elif nodeName_ == 'effectiveDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveDates = obj_
            obj_.original_tagname_ = 'effectiveDates'
        elif nodeName_ == 'geographicPoint':
            obj_ = SpatialPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geographicPoint = obj_
            obj_.original_tagname_ = 'geographicPoint'
        elif nodeName_ == 'isPreferred':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isPreferred')
            ival_ = self.gds_validate_boolean(ival_, node, 'isPreferred')
            self.isPreferred = ival_
            self.isPreferred_nsprefix_ = child_.prefix
        elif nodeName_ == 'line':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'line')
            value_ = self.gds_validate_string(value_, node, 'line')
            self.line.append(value_)
            self.line_nsprefix_ = child_.prefix
        elif nodeName_ == 'locationName':
            class_obj_ = self.get_class_obj_(child_, ObjectName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.locationName = obj_
            obj_.original_tagname_ = 'locationName'
        elif nodeName_ == 'postalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalCode')
            value_ = self.gds_validate_string(value_, node, 'postalCode')
            self.postalCode = value_
            self.postalCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'privacy':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.privacy = obj_
            obj_.original_tagname_ = 'privacy'
        elif nodeName_ == 'regionalCoverage':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regionalCoverage = obj_
            obj_.original_tagname_ = 'regionalCoverage'
        elif nodeName_ == 'stateProvince':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'stateProvince')
            value_ = self.gds_validate_string(value_, node, 'stateProvince')
            self.stateProvince = value_
            self.stateProvince_nsprefix_ = child_.prefix
        elif nodeName_ == 'timeZone':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeZone = obj_
            obj_.original_tagname_ = 'timeZone'
        elif nodeName_ == 'typeOfAddress':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfAddress = obj_
            obj_.original_tagname_ = 'typeOfAddress'
        elif nodeName_ == 'typeOfLocation':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfLocation = obj_
            obj_.original_tagname_ = 'typeOfLocation'
# end class Address


class AgentInRole(GeneratedsSuper):
    """agentName -- Full name of the contributor. Language equivalents should be expressed within the international string structure.
    reference -- Reference to an agent described in DDI or some other platform.
    role -- Role of the of the agent within the context of the parent property name.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, agentName=None, reference=None, role=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.agentName = agentName
        self.agentName_nsprefix_ = None
        self.reference = reference
        self.reference_nsprefix_ = None
        if role is None:
            self.role = []
        else:
            self.role = role
        self.role_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentInRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentInRole.subclass:
            return AgentInRole.subclass(*args_, **kwargs_)
        else:
            return AgentInRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_agentName(self):
        return self.agentName
    def set_agentName(self, agentName):
        self.agentName = agentName
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def add_role(self, value):
        self.role.append(value)
    def insert_role_at(self, index, value):
        self.role.insert(index, value)
    def replace_role_at(self, index, value):
        self.role[index] = value
    def has__content(self):
        if (
            self.agentName is not None or
            self.reference is not None or
            self.role
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentInRole', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.agentName is not None:
            agentName_ = self.agentName
            agentName_.to_etree(element, name_='agentName', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.reference is not None:
            reference_ = self.reference
            reference_.to_etree(element, name_='reference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for role_ in self.role:
            role_.to_etree(element, name_='role', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'agentName':
            obj_ = BibliographicName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.agentName = obj_
            obj_.original_tagname_ = 'agentName'
        elif nodeName_ == 'reference':
            class_obj_ = self.get_class_obj_(child_, Reference)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference = obj_
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'role':
            obj_ = PairedControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.role.append(obj_)
            obj_.original_tagname_ = 'role'
# end class AgentInRole


class CatalogDetails(GeneratedsSuper):
    """access -- Information important for understanding access conditions.
    alternativeTitle -- An alternative title by which a data collection is commonly referred, or an abbreviation for the title.
    contributor -- The name of a contributing author or creator, who worked in support of the primary creator given above.
    creator -- Person, corporate body, or agency responsible for the substantive and intellectual content of the described object.
    date -- A date associated with the annotated object (not the coverage period). Use typeOfDate to specify the type of date such as Version, Publication, Submitted, Copyrighted, Accepted, etc.
    identifier -- An identifier or locator. Contains identifier and Managing agency (ISBN, ISSN, DOI, local archive). Indicates if it is a URI.
    informationSource -- The name or identifier of source information for the annotated object.
    languageOfObject -- Language of the intellectual content of the described object. Multiple languages are supported by the structure itself as defined in the transformation to specific bindings. Use language codes supported by xs:language which include the 2 and 3 character and extended structures defined by RFC4646 or its successors. Supports multiple language codes.
    provenance -- Information about the origins of the object.
    publisher -- Person or organization responsible for making the resource available in its present form.
    relatedResource -- Provide the identifier, managing agency, and type of resource related to this object. Use to specify related resources similar to Dublin Core isPartOf and hasPart to indicate collection/series membership for objects where there is an identifiable record. If not an identified object use the relationship to ExternalMaterial using a type that indicates a series description.
    subTitle -- Secondary or explanatory title.
    summary -- A summary description (abstract) of the annotated object.
    title -- Full authoritative title. List any additional titles for this item as alternativeTitle.
    typeOfResource -- Provide the type of the resource. This supports the use of a controlled vocabulary. It should be appropriate to the level of the annotation.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, access=None, alternativeTitle=None, contributor=None, creator=None, date=None, identifier=None, informationSource=None, languageOfObject=None, provenance=None, publisher=None, relatedResource=None, subTitle=None, summary=None, title=None, typeOfResource=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if access is None:
            self.access = []
        else:
            self.access = access
        self.access_nsprefix_ = None
        if alternativeTitle is None:
            self.alternativeTitle = []
        else:
            self.alternativeTitle = alternativeTitle
        self.alternativeTitle_nsprefix_ = None
        if contributor is None:
            self.contributor = []
        else:
            self.contributor = contributor
        self.contributor_nsprefix_ = None
        if creator is None:
            self.creator = []
        else:
            self.creator = creator
        self.creator_nsprefix_ = None
        if date is None:
            self.date = []
        else:
            self.date = date
        self.date_nsprefix_ = None
        self.identifier = identifier
        self.identifier_nsprefix_ = None
        if informationSource is None:
            self.informationSource = []
        else:
            self.informationSource = informationSource
        self.informationSource_nsprefix_ = None
        if languageOfObject is None:
            self.languageOfObject = []
        else:
            self.languageOfObject = languageOfObject
        self.languageOfObject_nsprefix_ = None
        self.provenance = provenance
        self.provenance_nsprefix_ = None
        if publisher is None:
            self.publisher = []
        else:
            self.publisher = publisher
        self.publisher_nsprefix_ = None
        if relatedResource is None:
            self.relatedResource = []
        else:
            self.relatedResource = relatedResource
        self.relatedResource_nsprefix_ = None
        if subTitle is None:
            self.subTitle = []
        else:
            self.subTitle = subTitle
        self.subTitle_nsprefix_ = None
        self.summary = summary
        self.summary_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        if typeOfResource is None:
            self.typeOfResource = []
        else:
            self.typeOfResource = typeOfResource
        self.typeOfResource_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CatalogDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CatalogDetails.subclass:
            return CatalogDetails.subclass(*args_, **kwargs_)
        else:
            return CatalogDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def add_access(self, value):
        self.access.append(value)
    def insert_access_at(self, index, value):
        self.access.insert(index, value)
    def replace_access_at(self, index, value):
        self.access[index] = value
    def get_alternativeTitle(self):
        return self.alternativeTitle
    def set_alternativeTitle(self, alternativeTitle):
        self.alternativeTitle = alternativeTitle
    def add_alternativeTitle(self, value):
        self.alternativeTitle.append(value)
    def insert_alternativeTitle_at(self, index, value):
        self.alternativeTitle.insert(index, value)
    def replace_alternativeTitle_at(self, index, value):
        self.alternativeTitle[index] = value
    def get_contributor(self):
        return self.contributor
    def set_contributor(self, contributor):
        self.contributor = contributor
    def add_contributor(self, value):
        self.contributor.append(value)
    def insert_contributor_at(self, index, value):
        self.contributor.insert(index, value)
    def replace_contributor_at(self, index, value):
        self.contributor[index] = value
    def get_creator(self):
        return self.creator
    def set_creator(self, creator):
        self.creator = creator
    def add_creator(self, value):
        self.creator.append(value)
    def insert_creator_at(self, index, value):
        self.creator.insert(index, value)
    def replace_creator_at(self, index, value):
        self.creator[index] = value
    def get_date(self):
        return self.date
    def set_date(self, date):
        self.date = date
    def add_date(self, value):
        self.date.append(value)
    def insert_date_at(self, index, value):
        self.date.insert(index, value)
    def replace_date_at(self, index, value):
        self.date[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_informationSource(self):
        return self.informationSource
    def set_informationSource(self, informationSource):
        self.informationSource = informationSource
    def add_informationSource(self, value):
        self.informationSource.append(value)
    def insert_informationSource_at(self, index, value):
        self.informationSource.insert(index, value)
    def replace_informationSource_at(self, index, value):
        self.informationSource[index] = value
    def get_languageOfObject(self):
        return self.languageOfObject
    def set_languageOfObject(self, languageOfObject):
        self.languageOfObject = languageOfObject
    def add_languageOfObject(self, value):
        self.languageOfObject.append(value)
    def insert_languageOfObject_at(self, index, value):
        self.languageOfObject.insert(index, value)
    def replace_languageOfObject_at(self, index, value):
        self.languageOfObject[index] = value
    def get_provenance(self):
        return self.provenance
    def set_provenance(self, provenance):
        self.provenance = provenance
    def get_publisher(self):
        return self.publisher
    def set_publisher(self, publisher):
        self.publisher = publisher
    def add_publisher(self, value):
        self.publisher.append(value)
    def insert_publisher_at(self, index, value):
        self.publisher.insert(index, value)
    def replace_publisher_at(self, index, value):
        self.publisher[index] = value
    def get_relatedResource(self):
        return self.relatedResource
    def set_relatedResource(self, relatedResource):
        self.relatedResource = relatedResource
    def add_relatedResource(self, value):
        self.relatedResource.append(value)
    def insert_relatedResource_at(self, index, value):
        self.relatedResource.insert(index, value)
    def replace_relatedResource_at(self, index, value):
        self.relatedResource[index] = value
    def get_subTitle(self):
        return self.subTitle
    def set_subTitle(self, subTitle):
        self.subTitle = subTitle
    def add_subTitle(self, value):
        self.subTitle.append(value)
    def insert_subTitle_at(self, index, value):
        self.subTitle.insert(index, value)
    def replace_subTitle_at(self, index, value):
        self.subTitle[index] = value
    def get_summary(self):
        return self.summary
    def set_summary(self, summary):
        self.summary = summary
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_typeOfResource(self):
        return self.typeOfResource
    def set_typeOfResource(self, typeOfResource):
        self.typeOfResource = typeOfResource
    def add_typeOfResource(self, value):
        self.typeOfResource.append(value)
    def insert_typeOfResource_at(self, index, value):
        self.typeOfResource.insert(index, value)
    def replace_typeOfResource_at(self, index, value):
        self.typeOfResource[index] = value
    def has__content(self):
        if (
            self.access or
            self.alternativeTitle or
            self.contributor or
            self.creator or
            self.date or
            self.identifier is not None or
            self.informationSource or
            self.languageOfObject or
            self.provenance is not None or
            self.publisher or
            self.relatedResource or
            self.subTitle or
            self.summary is not None or
            self.title is not None or
            self.typeOfResource
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CatalogDetails', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        for access_ in self.access:
            access_.to_etree(element, name_='access', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for alternativeTitle_ in self.alternativeTitle:
            alternativeTitle_.to_etree(element, name_='alternativeTitle', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for contributor_ in self.contributor:
            contributor_.to_etree(element, name_='contributor', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for creator_ in self.creator:
            creator_.to_etree(element, name_='creator', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for date_ in self.date:
            date_.to_etree(element, name_='date', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.identifier is not None:
            identifier_ = self.identifier
            identifier_.to_etree(element, name_='identifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for informationSource_ in self.informationSource:
            informationSource_.to_etree(element, name_='informationSource', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for languageOfObject_ in self.languageOfObject:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}languageOfObject').text = self.gds_format_string(languageOfObject_)
        if self.provenance is not None:
            provenance_ = self.provenance
            provenance_.to_etree(element, name_='provenance', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for publisher_ in self.publisher:
            publisher_.to_etree(element, name_='publisher', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relatedResource_ in self.relatedResource:
            relatedResource_.to_etree(element, name_='relatedResource', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for subTitle_ in self.subTitle:
            subTitle_.to_etree(element, name_='subTitle', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.summary is not None:
            summary_ = self.summary
            summary_.to_etree(element, name_='summary', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.title is not None:
            title_ = self.title
            title_.to_etree(element, name_='title', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for typeOfResource_ in self.typeOfResource:
            typeOfResource_.to_etree(element, name_='typeOfResource', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'access':
            obj_ = AccessInformation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access.append(obj_)
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'alternativeTitle':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternativeTitle.append(obj_)
            obj_.original_tagname_ = 'alternativeTitle'
        elif nodeName_ == 'contributor':
            obj_ = AgentInRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contributor.append(obj_)
            obj_.original_tagname_ = 'contributor'
        elif nodeName_ == 'creator':
            obj_ = AgentInRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creator.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'date':
            obj_ = CombinedDate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'identifier':
            obj_ = InternationalIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'informationSource':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informationSource.append(obj_)
            obj_.original_tagname_ = 'informationSource'
        elif nodeName_ == 'languageOfObject':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'languageOfObject')
            value_ = self.gds_validate_string(value_, node, 'languageOfObject')
            self.languageOfObject.append(value_)
            self.languageOfObject_nsprefix_ = child_.prefix
        elif nodeName_ == 'provenance':
            obj_ = ProvenanceInformation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.provenance = obj_
            obj_.original_tagname_ = 'provenance'
        elif nodeName_ == 'publisher':
            obj_ = AgentInRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.publisher.append(obj_)
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'relatedResource':
            class_obj_ = self.get_class_obj_(child_, Reference)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedResource.append(obj_)
            obj_.original_tagname_ = 'relatedResource'
        elif nodeName_ == 'subTitle':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subTitle.append(obj_)
            obj_.original_tagname_ = 'subTitle'
        elif nodeName_ == 'summary':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.summary = obj_
            obj_.original_tagname_ = 'summary'
        elif nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'typeOfResource':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfResource.append(obj_)
            obj_.original_tagname_ = 'typeOfResource'
# end class CatalogDetails


class CombinedDate(GeneratedsSuper):
    """isoDate -- Strongly recommend that ALL dates be expressed in an ISO format at a minimum. A single point in time expressed in an ISO standard structure. Note that while it supports an ISO date range structure this should be used in Date only when the single date is unclear i.e. occurring at some time between two dates.
    nonIsoDate -- A simple date expressed in a non-ISO date format, including a specification of the date format and calendar used.
    semantics -- Use to specify the type of date. This may reflect the refinements of dc:date such as dateAccepted, dateCopyrighted, dateSubmitted, etc.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, isoDate=None, nonIsoDate=None, semantics=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(isoDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(isoDate, '%Y-%m-%d').date()
        else:
            initvalue_ = isoDate
        self.isoDate = initvalue_
        self.isoDate_nsprefix_ = None
        if nonIsoDate is None:
            self.nonIsoDate = []
        else:
            self.nonIsoDate = nonIsoDate
        self.nonIsoDate_nsprefix_ = None
        self.semantics = semantics
        self.semantics_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CombinedDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CombinedDate.subclass:
            return CombinedDate.subclass(*args_, **kwargs_)
        else:
            return CombinedDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isoDate(self):
        return self.isoDate
    def set_isoDate(self, isoDate):
        self.isoDate = isoDate
    def get_nonIsoDate(self):
        return self.nonIsoDate
    def set_nonIsoDate(self, nonIsoDate):
        self.nonIsoDate = nonIsoDate
    def add_nonIsoDate(self, value):
        self.nonIsoDate.append(value)
    def insert_nonIsoDate_at(self, index, value):
        self.nonIsoDate.insert(index, value)
    def replace_nonIsoDate_at(self, index, value):
        self.nonIsoDate[index] = value
    def get_semantics(self):
        return self.semantics
    def set_semantics(self, semantics):
        self.semantics = semantics
    def has__content(self):
        if (
            self.isoDate is not None or
            self.nonIsoDate or
            self.semantics is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CombinedDate', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.isoDate is not None:
            isoDate_ = self.isoDate
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isoDate').text = self.gds_format_date(isoDate_)
        for nonIsoDate_ in self.nonIsoDate:
            nonIsoDate_.to_etree(element, name_='nonIsoDate', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantics is not None:
            semantics_ = self.semantics
            semantics_.to_etree(element, name_='semantics', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isoDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.isoDate = dval_
            self.isoDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'nonIsoDate':
            obj_ = NonIsoDate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nonIsoDate.append(obj_)
            obj_.original_tagname_ = 'nonIsoDate'
        elif nodeName_ == 'semantics':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantics = obj_
            obj_.original_tagname_ = 'semantics'
# end class CombinedDate


class Command(GeneratedsSuper):
    """commandContent -- Content of the command itself expressed in the language designated in programming language.
    programLanguage -- Designates the programming language used for the command. Supports the use of a controlled vocabulary.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, commandContent=None, programLanguage=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.commandContent = commandContent
        self.commandContent_nsprefix_ = None
        self.programLanguage = programLanguage
        self.programLanguage_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Command)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Command.subclass:
            return Command.subclass(*args_, **kwargs_)
        else:
            return Command(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_commandContent(self):
        return self.commandContent
    def set_commandContent(self, commandContent):
        self.commandContent = commandContent
    def get_programLanguage(self):
        return self.programLanguage
    def set_programLanguage(self, programLanguage):
        self.programLanguage = programLanguage
    def has__content(self):
        if (
            self.commandContent is not None or
            self.programLanguage is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Command', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.commandContent is not None:
            commandContent_ = self.commandContent
            commandContent_.to_etree(element, name_='commandContent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.programLanguage is not None:
            programLanguage_ = self.programLanguage
            programLanguage_.to_etree(element, name_='programLanguage', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'commandContent':
            obj_ = TypedString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.commandContent = obj_
            obj_.original_tagname_ = 'commandContent'
        elif nodeName_ == 'programLanguage':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.programLanguage = obj_
            obj_.original_tagname_ = 'programLanguage'
# end class Command


class CommandCode(GeneratedsSuper):
    """command -- This is an in-line provision of the command itself. It provides the programming language used as well as the command.
    commandFile -- Identifies and provides a link to an external copy of the command, for example, a SAS Command Code script. Designates the programming language of the command file as well as the URI for the file.
    description -- A description of the purpose and use of the command code provided. Supports multiple languages.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, command=None, commandFile=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if command is None:
            self.command = []
        else:
            self.command = command
        self.command_nsprefix_ = None
        if commandFile is None:
            self.commandFile = []
        else:
            self.commandFile = commandFile
        self.commandFile_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommandCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommandCode.subclass:
            return CommandCode.subclass(*args_, **kwargs_)
        else:
            return CommandCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_command(self):
        return self.command
    def set_command(self, command):
        self.command = command
    def add_command(self, value):
        self.command.append(value)
    def insert_command_at(self, index, value):
        self.command.insert(index, value)
    def replace_command_at(self, index, value):
        self.command[index] = value
    def get_commandFile(self):
        return self.commandFile
    def set_commandFile(self, commandFile):
        self.commandFile = commandFile
    def add_commandFile(self, value):
        self.commandFile.append(value)
    def insert_commandFile_at(self, index, value):
        self.commandFile.insert(index, value)
    def replace_commandFile_at(self, index, value):
        self.commandFile[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def has__content(self):
        if (
            self.command or
            self.commandFile or
            self.description is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CommandCode', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        for command_ in self.command:
            command_.to_etree(element, name_='command', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for commandFile_ in self.commandFile:
            commandFile_.to_etree(element, name_='commandFile', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.description is not None:
            description_ = self.description
            description_.to_etree(element, name_='description', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'command':
            obj_ = Command.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.command.append(obj_)
            obj_.original_tagname_ = 'command'
        elif nodeName_ == 'commandFile':
            obj_ = CommandFile.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.commandFile.append(obj_)
            obj_.original_tagname_ = 'commandFile'
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
# end class CommandCode


class CommandFile(GeneratedsSuper):
    """location -- A description of the location of the file. This may not be machine actionable. It supports a description expressed in multiple languages.
    uri -- The URL or URN of the command file.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, location=None, uri=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.location = location
        self.location_nsprefix_ = None
        self.uri = uri
        self.uri_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommandFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommandFile.subclass:
            return CommandFile.subclass(*args_, **kwargs_)
        else:
            return CommandFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def has__content(self):
        if (
            self.location is not None or
            self.uri is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CommandFile', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.location is not None:
            location_ = self.location
            location_.to_etree(element, name_='location', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.uri is not None:
            uri_ = self.uri
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}uri').text = self.gds_format_string(uri_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'location':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'uri':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'uri')
            value_ = self.gds_validate_string(value_, node, 'uri')
            self.uri = value_
            self.uri_nsprefix_ = child_.prefix
# end class CommandFile


class ContactInformation(GeneratedsSuper):
    """address -- The address for contact.
    email -- Email contact information.
    emessaging -- Electronic messaging other than email.
    telephone -- Telephone for contact.
    website -- The URL of the Agent's website.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, address=None, email=None, emessaging=None, telephone=None, website=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if address is None:
            self.address = []
        else:
            self.address = address
        self.address_nsprefix_ = None
        if email is None:
            self.email = []
        else:
            self.email = email
        self.email_nsprefix_ = None
        if emessaging is None:
            self.emessaging = []
        else:
            self.emessaging = emessaging
        self.emessaging_nsprefix_ = None
        if telephone is None:
            self.telephone = []
        else:
            self.telephone = telephone
        self.telephone_nsprefix_ = None
        if website is None:
            self.website = []
        else:
            self.website = website
        self.website_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactInformation.subclass:
            return ContactInformation.subclass(*args_, **kwargs_)
        else:
            return ContactInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    def add_address(self, value):
        self.address.append(value)
    def insert_address_at(self, index, value):
        self.address.insert(index, value)
    def replace_address_at(self, index, value):
        self.address[index] = value
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def add_email(self, value):
        self.email.append(value)
    def insert_email_at(self, index, value):
        self.email.insert(index, value)
    def replace_email_at(self, index, value):
        self.email[index] = value
    def get_emessaging(self):
        return self.emessaging
    def set_emessaging(self, emessaging):
        self.emessaging = emessaging
    def add_emessaging(self, value):
        self.emessaging.append(value)
    def insert_emessaging_at(self, index, value):
        self.emessaging.insert(index, value)
    def replace_emessaging_at(self, index, value):
        self.emessaging[index] = value
    def get_telephone(self):
        return self.telephone
    def set_telephone(self, telephone):
        self.telephone = telephone
    def add_telephone(self, value):
        self.telephone.append(value)
    def insert_telephone_at(self, index, value):
        self.telephone.insert(index, value)
    def replace_telephone_at(self, index, value):
        self.telephone[index] = value
    def get_website(self):
        return self.website
    def set_website(self, website):
        self.website = website
    def add_website(self, value):
        self.website.append(value)
    def insert_website_at(self, index, value):
        self.website.insert(index, value)
    def replace_website_at(self, index, value):
        self.website[index] = value
    def has__content(self):
        if (
            self.address or
            self.email or
            self.emessaging or
            self.telephone or
            self.website
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ContactInformation', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        for address_ in self.address:
            address_.to_etree(element, name_='address', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for email_ in self.email:
            email_.to_etree(element, name_='email', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for emessaging_ in self.emessaging:
            emessaging_.to_etree(element, name_='emessaging', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for telephone_ in self.telephone:
            telephone_.to_etree(element, name_='telephone', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for website_ in self.website:
            website_.to_etree(element, name_='website', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'address':
            obj_ = Address.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.address.append(obj_)
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'email':
            obj_ = Email.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.email.append(obj_)
            obj_.original_tagname_ = 'email'
        elif nodeName_ == 'emessaging':
            obj_ = ElectronicMessageSystem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.emessaging.append(obj_)
            obj_.original_tagname_ = 'emessaging'
        elif nodeName_ == 'telephone':
            obj_ = Telephone.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telephone.append(obj_)
            obj_.original_tagname_ = 'telephone'
        elif nodeName_ == 'website':
            obj_ = WebLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.website.append(obj_)
            obj_.original_tagname_ = 'website'
# end class ContactInformation


class ControlledVocabularyEntry(GeneratedsSuper):
    """entryReference -- A reference to the specific item in the vocabulary referenced in the vocabulary attribute, using a URI or other resolvable identifier.
    entryValue -- The value of the entry of the controlled vocabulary. If no controlled vocabulary is used the term is entered here and none of the properties defining the controlled vocabulary location are used.
    name -- The name of the code list (controlled vocabulary).
    valueForOther -- If the value of the string is "Other" or the equivalent from the codelist, this attribute can provide a more specific value not found in the codelist.
    vocabulary -- A reference to the external controlled vocabulary, using a URI or other resolvable identifier.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, entryReference=None, entryValue=None, name=None, valueForOther=None, vocabulary=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if entryReference is None:
            self.entryReference = []
        else:
            self.entryReference = entryReference
        self.entryReference_nsprefix_ = None
        if entryValue is None:
            self.entryValue = []
        else:
            self.entryValue = entryValue
        self.entryValue_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.valueForOther = valueForOther
        self.valueForOther_nsprefix_ = None
        self.vocabulary = vocabulary
        self.vocabulary_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ControlledVocabularyEntry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ControlledVocabularyEntry.subclass:
            return ControlledVocabularyEntry.subclass(*args_, **kwargs_)
        else:
            return ControlledVocabularyEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_entryReference(self):
        return self.entryReference
    def set_entryReference(self, entryReference):
        self.entryReference = entryReference
    def add_entryReference(self, value):
        self.entryReference.append(value)
    def insert_entryReference_at(self, index, value):
        self.entryReference.insert(index, value)
    def replace_entryReference_at(self, index, value):
        self.entryReference[index] = value
    def get_entryValue(self):
        return self.entryValue
    def set_entryValue(self, entryValue):
        self.entryValue = entryValue
    def add_entryValue(self, value):
        self.entryValue.append(value)
    def insert_entryValue_at(self, index, value):
        self.entryValue.insert(index, value)
    def replace_entryValue_at(self, index, value):
        self.entryValue[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_valueForOther(self):
        return self.valueForOther
    def set_valueForOther(self, valueForOther):
        self.valueForOther = valueForOther
    def get_vocabulary(self):
        return self.vocabulary
    def set_vocabulary(self, vocabulary):
        self.vocabulary = vocabulary
    def has__content(self):
        if (
            self.entryReference or
            self.entryValue or
            self.name is not None or
            self.valueForOther is not None or
            self.vocabulary is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ControlledVocabularyEntry', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        for entryReference_ in self.entryReference:
            entryReference_.to_etree(element, name_='entryReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for entryValue_ in self.entryValue:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}entryValue').text = self.gds_format_string(entryValue_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}name').text = self.gds_format_string(name_)
        if self.valueForOther is not None:
            valueForOther_ = self.valueForOther
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}valueForOther').text = self.gds_format_string(valueForOther_)
        if self.vocabulary is not None:
            vocabulary_ = self.vocabulary
            vocabulary_.to_etree(element, name_='vocabulary', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'entryReference':
            class_obj_ = self.get_class_obj_(child_, Reference)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryReference.append(obj_)
            obj_.original_tagname_ = 'entryReference'
        elif nodeName_ == 'entryValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entryValue')
            value_ = self.gds_validate_string(value_, node, 'entryValue')
            self.entryValue.append(value_)
            self.entryValue_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'valueForOther':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'valueForOther')
            value_ = self.gds_validate_string(value_, node, 'valueForOther')
            self.valueForOther = value_
            self.valueForOther_nsprefix_ = child_.prefix
        elif nodeName_ == 'vocabulary':
            class_obj_ = self.get_class_obj_(child_, Reference)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vocabulary = obj_
            obj_.original_tagname_ = 'vocabulary'
# end class ControlledVocabularyEntry


class CorrespondenceDefinition(GeneratedsSuper):
    """commonality -- A description of the common features of the two items. Supports multiple language versions of the same content as well as optional formatting of the content.
    commonalityCode -- Commonality expressed as a term or code. Supports the use of an external controlled vocabulary. If repeated, clarify each external controlled vocabulary used.
    difference -- A description of the differences between the two items. Supports multiple language versions of the same content as well as optional formatting of the content.
    matching -- Allows specification of exact match, close match, or disjoint. These relationships can be further defined by describing commonalities or differences or providing additional controlled vocabulary descriptions of relationships.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, commonality=None, commonalityCode=None, difference=None, matching=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.commonality = commonality
        self.commonality_nsprefix_ = None
        if commonalityCode is None:
            self.commonalityCode = []
        else:
            self.commonalityCode = commonalityCode
        self.commonalityCode_nsprefix_ = None
        self.difference = difference
        self.difference_nsprefix_ = None
        self.matching = matching
        self.validate_MatchingCriterion(self.matching)
        self.matching_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrespondenceDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrespondenceDefinition.subclass:
            return CorrespondenceDefinition.subclass(*args_, **kwargs_)
        else:
            return CorrespondenceDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_commonality(self):
        return self.commonality
    def set_commonality(self, commonality):
        self.commonality = commonality
    def get_commonalityCode(self):
        return self.commonalityCode
    def set_commonalityCode(self, commonalityCode):
        self.commonalityCode = commonalityCode
    def add_commonalityCode(self, value):
        self.commonalityCode.append(value)
    def insert_commonalityCode_at(self, index, value):
        self.commonalityCode.insert(index, value)
    def replace_commonalityCode_at(self, index, value):
        self.commonalityCode[index] = value
    def get_difference(self):
        return self.difference
    def set_difference(self, difference):
        self.difference = difference
    def get_matching(self):
        return self.matching
    def set_matching(self, matching):
        self.matching = matching
    def validate_MatchingCriterion(self, value):
        result = True
        # Validate type MatchingCriterion, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CloseMatch', 'Disjoint', 'ExactMatch']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MatchingCriterion' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.commonality is not None or
            self.commonalityCode or
            self.difference is not None or
            self.matching is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CorrespondenceDefinition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.commonality is not None:
            commonality_ = self.commonality
            commonality_.to_etree(element, name_='commonality', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for commonalityCode_ in self.commonalityCode:
            commonalityCode_.to_etree(element, name_='commonalityCode', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.difference is not None:
            difference_ = self.difference
            difference_.to_etree(element, name_='difference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.matching is not None:
            matching_ = self.matching
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}matching').text = self.gds_format_string(matching_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'commonality':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.commonality = obj_
            obj_.original_tagname_ = 'commonality'
        elif nodeName_ == 'commonalityCode':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.commonalityCode.append(obj_)
            obj_.original_tagname_ = 'commonalityCode'
        elif nodeName_ == 'difference':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.difference = obj_
            obj_.original_tagname_ = 'difference'
        elif nodeName_ == 'matching':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'matching')
            value_ = self.gds_validate_string(value_, node, 'matching')
            self.matching = value_
            self.matching_nsprefix_ = child_.prefix
            # validate type MatchingCriterion
            self.validate_MatchingCriterion(self.matching)
# end class CorrespondenceDefinition


class DateRange(GeneratedsSuper):
    """endDate -- The date (time) designating the end of the period or range.
    startDate -- The date (time) designating the beginning of the period or range.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, endDate=None, startDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.endDate = endDate
        self.endDate_nsprefix_ = None
        self.startDate = startDate
        self.startDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateRange.subclass:
            return DateRange.subclass(*args_, **kwargs_)
        else:
            return DateRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_endDate(self):
        return self.endDate
    def set_endDate(self, endDate):
        self.endDate = endDate
    def get_startDate(self):
        return self.startDate
    def set_startDate(self, startDate):
        self.startDate = startDate
    def has__content(self):
        if (
            self.endDate is not None or
            self.startDate is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DateRange', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.endDate is not None:
            endDate_ = self.endDate
            endDate_.to_etree(element, name_='endDate', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.startDate is not None:
            startDate_ = self.startDate
            startDate_.to_etree(element, name_='startDate', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'endDate':
            obj_ = CombinedDate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.endDate = obj_
            obj_.original_tagname_ = 'endDate'
        elif nodeName_ == 'startDate':
            obj_ = CombinedDate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.startDate = obj_
            obj_.original_tagname_ = 'startDate'
# end class DateRange


class ElectronicMessageSystem(GeneratedsSuper):
    """contactAddress -- Account identification for contacting.
    effectiveDates -- Time period during which the account is valid.
    isPreferred -- Set to True if this is the preferred address.
    privacy -- Specify the level privacy for the address as public, restricted, or private. Supports the use of an external controlled vocabulary.
    typeOfService -- Indicates the type of service used. Supports the use of a controlled vocabulary.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, contactAddress=None, effectiveDates=None, isPreferred=None, privacy=None, typeOfService=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.contactAddress = contactAddress
        self.contactAddress_nsprefix_ = None
        self.effectiveDates = effectiveDates
        self.effectiveDates_nsprefix_ = None
        self.isPreferred = isPreferred
        self.isPreferred_nsprefix_ = None
        self.privacy = privacy
        self.privacy_nsprefix_ = None
        self.typeOfService = typeOfService
        self.typeOfService_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectronicMessageSystem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectronicMessageSystem.subclass:
            return ElectronicMessageSystem.subclass(*args_, **kwargs_)
        else:
            return ElectronicMessageSystem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_contactAddress(self):
        return self.contactAddress
    def set_contactAddress(self, contactAddress):
        self.contactAddress = contactAddress
    def get_effectiveDates(self):
        return self.effectiveDates
    def set_effectiveDates(self, effectiveDates):
        self.effectiveDates = effectiveDates
    def get_isPreferred(self):
        return self.isPreferred
    def set_isPreferred(self, isPreferred):
        self.isPreferred = isPreferred
    def get_privacy(self):
        return self.privacy
    def set_privacy(self, privacy):
        self.privacy = privacy
    def get_typeOfService(self):
        return self.typeOfService
    def set_typeOfService(self, typeOfService):
        self.typeOfService = typeOfService
    def has__content(self):
        if (
            self.contactAddress is not None or
            self.effectiveDates is not None or
            self.isPreferred is not None or
            self.privacy is not None or
            self.typeOfService is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ElectronicMessageSystem', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.contactAddress is not None:
            contactAddress_ = self.contactAddress
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}contactAddress').text = self.gds_format_string(contactAddress_)
        if self.effectiveDates is not None:
            effectiveDates_ = self.effectiveDates
            effectiveDates_.to_etree(element, name_='effectiveDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isPreferred is not None:
            isPreferred_ = self.isPreferred
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isPreferred').text = self.gds_format_boolean(isPreferred_)
        if self.privacy is not None:
            privacy_ = self.privacy
            privacy_.to_etree(element, name_='privacy', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.typeOfService is not None:
            typeOfService_ = self.typeOfService
            typeOfService_.to_etree(element, name_='typeOfService', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contactAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contactAddress')
            value_ = self.gds_validate_string(value_, node, 'contactAddress')
            self.contactAddress = value_
            self.contactAddress_nsprefix_ = child_.prefix
        elif nodeName_ == 'effectiveDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveDates = obj_
            obj_.original_tagname_ = 'effectiveDates'
        elif nodeName_ == 'isPreferred':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isPreferred')
            ival_ = self.gds_validate_boolean(ival_, node, 'isPreferred')
            self.isPreferred = ival_
            self.isPreferred_nsprefix_ = child_.prefix
        elif nodeName_ == 'privacy':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.privacy = obj_
            obj_.original_tagname_ = 'privacy'
        elif nodeName_ == 'typeOfService':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfService = obj_
            obj_.original_tagname_ = 'typeOfService'
# end class ElectronicMessageSystem


class Email(GeneratedsSuper):
    """effectiveDates -- Time period for which the e-mail address is valid.
    internetEmail -- The email address expressed as a string (should follow the Internet format specification - RFC 5322) e.g. user@server.ext, more complex and flexible examples are also supported by the format.
    isPreferred -- Set to True if this is the preferred email.
    privacy -- Indicates the level of privacy.
    typeOfEmail -- Code indicating the type of e-mail address. Supports the use of an external controlled vocabulary. (e.g. home, office).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, effectiveDates=None, internetEmail=None, isPreferred=None, privacy=None, typeOfEmail=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.effectiveDates = effectiveDates
        self.effectiveDates_nsprefix_ = None
        self.internetEmail = internetEmail
        self.internetEmail_nsprefix_ = None
        self.isPreferred = isPreferred
        self.isPreferred_nsprefix_ = None
        self.privacy = privacy
        self.privacy_nsprefix_ = None
        self.typeOfEmail = typeOfEmail
        self.typeOfEmail_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Email)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Email.subclass:
            return Email.subclass(*args_, **kwargs_)
        else:
            return Email(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_effectiveDates(self):
        return self.effectiveDates
    def set_effectiveDates(self, effectiveDates):
        self.effectiveDates = effectiveDates
    def get_internetEmail(self):
        return self.internetEmail
    def set_internetEmail(self, internetEmail):
        self.internetEmail = internetEmail
    def get_isPreferred(self):
        return self.isPreferred
    def set_isPreferred(self, isPreferred):
        self.isPreferred = isPreferred
    def get_privacy(self):
        return self.privacy
    def set_privacy(self, privacy):
        self.privacy = privacy
    def get_typeOfEmail(self):
        return self.typeOfEmail
    def set_typeOfEmail(self, typeOfEmail):
        self.typeOfEmail = typeOfEmail
    def has__content(self):
        if (
            self.effectiveDates is not None or
            self.internetEmail is not None or
            self.isPreferred is not None or
            self.privacy is not None or
            self.typeOfEmail is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Email', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.effectiveDates is not None:
            effectiveDates_ = self.effectiveDates
            effectiveDates_.to_etree(element, name_='effectiveDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.internetEmail is not None:
            internetEmail_ = self.internetEmail
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}internetEmail').text = self.gds_format_string(internetEmail_)
        if self.isPreferred is not None:
            isPreferred_ = self.isPreferred
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isPreferred').text = self.gds_format_boolean(isPreferred_)
        if self.privacy is not None:
            privacy_ = self.privacy
            privacy_.to_etree(element, name_='privacy', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.typeOfEmail is not None:
            typeOfEmail_ = self.typeOfEmail
            typeOfEmail_.to_etree(element, name_='typeOfEmail', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'effectiveDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveDates = obj_
            obj_.original_tagname_ = 'effectiveDates'
        elif nodeName_ == 'internetEmail':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'internetEmail')
            value_ = self.gds_validate_string(value_, node, 'internetEmail')
            self.internetEmail = value_
            self.internetEmail_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPreferred':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isPreferred')
            ival_ = self.gds_validate_boolean(ival_, node, 'isPreferred')
            self.isPreferred = ival_
            self.isPreferred_nsprefix_ = child_.prefix
        elif nodeName_ == 'privacy':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.privacy = obj_
            obj_.original_tagname_ = 'privacy'
        elif nodeName_ == 'typeOfEmail':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfEmail = obj_
            obj_.original_tagname_ = 'typeOfEmail'
# end class Email


class EmbargoInformation(GeneratedsSuper):
    """description -- A text desription of the terms of an embarog on the object.
    period -- The time range(s) for embargo of the object
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, description=None, period=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        if period is None:
            self.period = []
        else:
            self.period = period
        self.period_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmbargoInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmbargoInformation.subclass:
            return EmbargoInformation.subclass(*args_, **kwargs_)
        else:
            return EmbargoInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def add_period(self, value):
        self.period.append(value)
    def insert_period_at(self, index, value):
        self.period.insert(index, value)
    def replace_period_at(self, index, value):
        self.period[index] = value
    def has__content(self):
        if (
            self.description is not None or
            self.period
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='EmbargoInformation', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.description is not None:
            description_ = self.description
            description_.to_etree(element, name_='description', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for period_ in self.period:
            period_.to_etree(element, name_='period', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'period':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.period.append(obj_)
            obj_.original_tagname_ = 'period'
# end class EmbargoInformation


class FundingInformation(GeneratedsSuper):
    """fundingAgent -- A reference to the agent (e.g. organization) that provided funding for a grant.
    grantNumber -- The identification number for the grant at least partly provided by the funding agent.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, fundingAgent=None, grantNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if fundingAgent is None:
            self.fundingAgent = []
        else:
            self.fundingAgent = fundingAgent
        self.fundingAgent_nsprefix_ = None
        self.grantNumber = grantNumber
        self.grantNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FundingInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FundingInformation.subclass:
            return FundingInformation.subclass(*args_, **kwargs_)
        else:
            return FundingInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fundingAgent(self):
        return self.fundingAgent
    def set_fundingAgent(self, fundingAgent):
        self.fundingAgent = fundingAgent
    def add_fundingAgent(self, value):
        self.fundingAgent.append(value)
    def insert_fundingAgent_at(self, index, value):
        self.fundingAgent.insert(index, value)
    def replace_fundingAgent_at(self, index, value):
        self.fundingAgent[index] = value
    def get_grantNumber(self):
        return self.grantNumber
    def set_grantNumber(self, grantNumber):
        self.grantNumber = grantNumber
    def has__content(self):
        if (
            self.fundingAgent or
            self.grantNumber is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FundingInformation', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        for fundingAgent_ in self.fundingAgent:
            fundingAgent_.to_etree(element, name_='fundingAgent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.grantNumber is not None:
            grantNumber_ = self.grantNumber
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}grantNumber').text = self.gds_format_string(grantNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fundingAgent':
            obj_ = AgentInRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fundingAgent.append(obj_)
            obj_.original_tagname_ = 'fundingAgent'
        elif nodeName_ == 'grantNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'grantNumber')
            value_ = self.gds_validate_string(value_, node, 'grantNumber')
            self.grantNumber = value_
            self.grantNumber_nsprefix_ = child_.prefix
# end class FundingInformation


class Identifier(GeneratedsSuper):
    """ddiIdentifier -- A globally unique identifier. The values of the three attributes can be used to create a DDI URN.
    isDdiIdentifierPersistent -- Default value is False indicating that the content of the current version may change (may be in development mode). Set to True when the content of this version will no longer change.
    isDdiIdentifierUniversallyUnique -- Default value is False. If the id of the object was created as a Universally Unique ID (UUID) set to True.
    nonDdiIdentifier -- Any identifier other than a DDI identifier.
    uri -- A Universal Resource Identifier, valid according to the W3C XML Schema specification.
    versionDate -- Date and time the object was changed expressed in standard ISO formats.
    versionRationale -- Reason for making a new version of the object.
    versionResponsibility -- Contributor who has the ownership and responsibility for the current version.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ddiIdentifier=None, isDdiIdentifierPersistent=None, isDdiIdentifierUniversallyUnique=None, nonDdiIdentifier=None, uri=None, versionDate=None, versionRationale=None, versionResponsibility=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ddiIdentifier = ddiIdentifier
        self.ddiIdentifier_nsprefix_ = None
        self.isDdiIdentifierPersistent = isDdiIdentifierPersistent
        self.isDdiIdentifierPersistent_nsprefix_ = None
        self.isDdiIdentifierUniversallyUnique = isDdiIdentifierUniversallyUnique
        self.isDdiIdentifierUniversallyUnique_nsprefix_ = None
        if nonDdiIdentifier is None:
            self.nonDdiIdentifier = []
        else:
            self.nonDdiIdentifier = nonDdiIdentifier
        self.nonDdiIdentifier_nsprefix_ = None
        self.uri = uri
        self.uri_nsprefix_ = None
        if isinstance(versionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(versionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = versionDate
        self.versionDate = initvalue_
        self.versionDate_nsprefix_ = None
        self.versionRationale = versionRationale
        self.versionRationale_nsprefix_ = None
        self.versionResponsibility = versionResponsibility
        self.versionResponsibility_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Identifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Identifier.subclass:
            return Identifier.subclass(*args_, **kwargs_)
        else:
            return Identifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiIdentifier(self):
        return self.ddiIdentifier
    def set_ddiIdentifier(self, ddiIdentifier):
        self.ddiIdentifier = ddiIdentifier
    def get_isDdiIdentifierPersistent(self):
        return self.isDdiIdentifierPersistent
    def set_isDdiIdentifierPersistent(self, isDdiIdentifierPersistent):
        self.isDdiIdentifierPersistent = isDdiIdentifierPersistent
    def get_isDdiIdentifierUniversallyUnique(self):
        return self.isDdiIdentifierUniversallyUnique
    def set_isDdiIdentifierUniversallyUnique(self, isDdiIdentifierUniversallyUnique):
        self.isDdiIdentifierUniversallyUnique = isDdiIdentifierUniversallyUnique
    def get_nonDdiIdentifier(self):
        return self.nonDdiIdentifier
    def set_nonDdiIdentifier(self, nonDdiIdentifier):
        self.nonDdiIdentifier = nonDdiIdentifier
    def add_nonDdiIdentifier(self, value):
        self.nonDdiIdentifier.append(value)
    def insert_nonDdiIdentifier_at(self, index, value):
        self.nonDdiIdentifier.insert(index, value)
    def replace_nonDdiIdentifier_at(self, index, value):
        self.nonDdiIdentifier[index] = value
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def get_versionDate(self):
        return self.versionDate
    def set_versionDate(self, versionDate):
        self.versionDate = versionDate
    def get_versionRationale(self):
        return self.versionRationale
    def set_versionRationale(self, versionRationale):
        self.versionRationale = versionRationale
    def get_versionResponsibility(self):
        return self.versionResponsibility
    def set_versionResponsibility(self, versionResponsibility):
        self.versionResponsibility = versionResponsibility
    def has__content(self):
        if (
            self.ddiIdentifier is not None or
            self.isDdiIdentifierPersistent is not None or
            self.isDdiIdentifierUniversallyUnique is not None or
            self.nonDdiIdentifier or
            self.uri is not None or
            self.versionDate is not None or
            self.versionRationale is not None or
            self.versionResponsibility is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Identifier', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiIdentifier is not None:
            ddiIdentifier_ = self.ddiIdentifier
            ddiIdentifier_.to_etree(element, name_='ddiIdentifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isDdiIdentifierPersistent is not None:
            isDdiIdentifierPersistent_ = self.isDdiIdentifierPersistent
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isDdiIdentifierPersistent').text = self.gds_format_boolean(isDdiIdentifierPersistent_)
        if self.isDdiIdentifierUniversallyUnique is not None:
            isDdiIdentifierUniversallyUnique_ = self.isDdiIdentifierUniversallyUnique
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isDdiIdentifierUniversallyUnique').text = self.gds_format_boolean(isDdiIdentifierUniversallyUnique_)
        for nonDdiIdentifier_ in self.nonDdiIdentifier:
            nonDdiIdentifier_.to_etree(element, name_='nonDdiIdentifier', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.uri is not None:
            uri_ = self.uri
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}uri').text = self.gds_format_string(uri_)
        if self.versionDate is not None:
            versionDate_ = self.versionDate
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}versionDate').text = self.gds_format_date(versionDate_)
        if self.versionRationale is not None:
            versionRationale_ = self.versionRationale
            versionRationale_.to_etree(element, name_='versionRationale', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.versionResponsibility is not None:
            versionResponsibility_ = self.versionResponsibility
            versionResponsibility_.to_etree(element, name_='versionResponsibility', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiIdentifier':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiIdentifier = obj_
            obj_.original_tagname_ = 'ddiIdentifier'
        elif nodeName_ == 'isDdiIdentifierPersistent':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isDdiIdentifierPersistent')
            ival_ = self.gds_validate_boolean(ival_, node, 'isDdiIdentifierPersistent')
            self.isDdiIdentifierPersistent = ival_
            self.isDdiIdentifierPersistent_nsprefix_ = child_.prefix
        elif nodeName_ == 'isDdiIdentifierUniversallyUnique':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isDdiIdentifierUniversallyUnique')
            ival_ = self.gds_validate_boolean(ival_, node, 'isDdiIdentifierUniversallyUnique')
            self.isDdiIdentifierUniversallyUnique = ival_
            self.isDdiIdentifierUniversallyUnique_nsprefix_ = child_.prefix
        elif nodeName_ == 'nonDdiIdentifier':
            obj_ = NonDdiIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nonDdiIdentifier.append(obj_)
            obj_.original_tagname_ = 'nonDdiIdentifier'
        elif nodeName_ == 'uri':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'uri')
            value_ = self.gds_validate_string(value_, node, 'uri')
            self.uri = value_
            self.uri_nsprefix_ = child_.prefix
        elif nodeName_ == 'versionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.versionDate = dval_
            self.versionDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'versionRationale':
            obj_ = RationaleDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.versionRationale = obj_
            obj_.original_tagname_ = 'versionRationale'
        elif nodeName_ == 'versionResponsibility':
            obj_ = AgentInRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.versionResponsibility = obj_
            obj_.original_tagname_ = 'versionResponsibility'
# end class Identifier


class IndividualName(GeneratedsSuper):
    """abbreviation -- An abbreviation or acronym for the name. This may be expressed in multiple languages. It is assumed that if only a single language is provided that it may be used in any of the other languages within which the name itself is expressed.
    context -- A name may be specific to a particular context, i.e. common usage, business, social, etc.. Identify the context related to the specified name. Supports the use of an external controlled vocabulary.
    effectiveDates -- Clarifies when the name information is accurate.
    firstGiven -- First (given) name of the individual.
    fullName -- This provides a means of providing a full name as a single object for display or print such as identification badges etc. For example a person with the name of William Grace for official use may prefer a display name of Bill Grace on a name tag or other informal publication.
    isFormal -- The legal or formal name of the individual should have the isFormal attribute set to True. To avoid confusion only one individual name should have the isFormal attribute set to True. Use the TypeOfIndividualName to further differentiate the type and applied usage when multiple names are provided.
    isPreferred -- If more than one name for the object is provided, use the isPreferred attribute to indicate which is the preferred name content. All other names should be set to isPreferred=False.
    lastFamily -- Last (family) name /surname of the individual.
    middle -- Middle name or initial of the individual.
    prefix -- Title that precedes the name of the individual, such as Ms., or Dr.
    sex -- Sex allows for the specification of male, female or neutral. The purpose of providing this information is to assist others in the appropriate use of pronouns when addressing the individual. Note that many countries/languages may offer a neutral pronoun form.
    suffix -- Title that follows the name of the individual, such as Esq. (abbreviation for Esquire. This is usually a courtesy title).
    typeOfIndividualName -- The type of individual name provided. the use of a controlled vocabulary is strongly recommended. At minimum his should include, e.g. PreviousFormalName, Nickname (or CommonName), Other.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, abbreviation=None, context=None, effectiveDates=None, firstGiven=None, fullName=None, isFormal=None, isPreferred=None, lastFamily=None, middle=None, prefix=None, sex=None, suffix=None, typeOfIndividualName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.abbreviation = abbreviation
        self.abbreviation_nsprefix_ = None
        self.context = context
        self.context_nsprefix_ = None
        self.effectiveDates = effectiveDates
        self.effectiveDates_nsprefix_ = None
        self.firstGiven = firstGiven
        self.firstGiven_nsprefix_ = None
        self.fullName = fullName
        self.fullName_nsprefix_ = None
        self.isFormal = isFormal
        self.isFormal_nsprefix_ = None
        self.isPreferred = isPreferred
        self.isPreferred_nsprefix_ = None
        self.lastFamily = lastFamily
        self.lastFamily_nsprefix_ = None
        if middle is None:
            self.middle = []
        else:
            self.middle = middle
        self.middle_nsprefix_ = None
        self.prefix = prefix
        self.prefix_nsprefix_ = None
        self.sex = sex
        self.validate_SexSpecification(self.sex)
        self.sex_nsprefix_ = None
        self.suffix = suffix
        self.suffix_nsprefix_ = None
        self.typeOfIndividualName = typeOfIndividualName
        self.typeOfIndividualName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndividualName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndividualName.subclass:
            return IndividualName.subclass(*args_, **kwargs_)
        else:
            return IndividualName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_abbreviation(self):
        return self.abbreviation
    def set_abbreviation(self, abbreviation):
        self.abbreviation = abbreviation
    def get_context(self):
        return self.context
    def set_context(self, context):
        self.context = context
    def get_effectiveDates(self):
        return self.effectiveDates
    def set_effectiveDates(self, effectiveDates):
        self.effectiveDates = effectiveDates
    def get_firstGiven(self):
        return self.firstGiven
    def set_firstGiven(self, firstGiven):
        self.firstGiven = firstGiven
    def get_fullName(self):
        return self.fullName
    def set_fullName(self, fullName):
        self.fullName = fullName
    def get_isFormal(self):
        return self.isFormal
    def set_isFormal(self, isFormal):
        self.isFormal = isFormal
    def get_isPreferred(self):
        return self.isPreferred
    def set_isPreferred(self, isPreferred):
        self.isPreferred = isPreferred
    def get_lastFamily(self):
        return self.lastFamily
    def set_lastFamily(self, lastFamily):
        self.lastFamily = lastFamily
    def get_middle(self):
        return self.middle
    def set_middle(self, middle):
        self.middle = middle
    def add_middle(self, value):
        self.middle.append(value)
    def insert_middle_at(self, index, value):
        self.middle.insert(index, value)
    def replace_middle_at(self, index, value):
        self.middle[index] = value
    def get_prefix(self):
        return self.prefix
    def set_prefix(self, prefix):
        self.prefix = prefix
    def get_sex(self):
        return self.sex
    def set_sex(self, sex):
        self.sex = sex
    def get_suffix(self):
        return self.suffix
    def set_suffix(self, suffix):
        self.suffix = suffix
    def get_typeOfIndividualName(self):
        return self.typeOfIndividualName
    def set_typeOfIndividualName(self, typeOfIndividualName):
        self.typeOfIndividualName = typeOfIndividualName
    def validate_SexSpecification(self, value):
        result = True
        # Validate type SexSpecification, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Feminine', 'GenderNeutral', 'Masculine']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SexSpecification' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.abbreviation is not None or
            self.context is not None or
            self.effectiveDates is not None or
            self.firstGiven is not None or
            self.fullName is not None or
            self.isFormal is not None or
            self.isPreferred is not None or
            self.lastFamily is not None or
            self.middle or
            self.prefix is not None or
            self.sex is not None or
            self.suffix is not None or
            self.typeOfIndividualName is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='IndividualName', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.abbreviation is not None:
            abbreviation_ = self.abbreviation
            abbreviation_.to_etree(element, name_='abbreviation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.context is not None:
            context_ = self.context
            context_.to_etree(element, name_='context', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.effectiveDates is not None:
            effectiveDates_ = self.effectiveDates
            effectiveDates_.to_etree(element, name_='effectiveDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.firstGiven is not None:
            firstGiven_ = self.firstGiven
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}firstGiven').text = self.gds_format_string(firstGiven_)
        if self.fullName is not None:
            fullName_ = self.fullName
            fullName_.to_etree(element, name_='fullName', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isFormal is not None:
            isFormal_ = self.isFormal
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isFormal').text = self.gds_format_boolean(isFormal_)
        if self.isPreferred is not None:
            isPreferred_ = self.isPreferred
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isPreferred').text = self.gds_format_boolean(isPreferred_)
        if self.lastFamily is not None:
            lastFamily_ = self.lastFamily
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}lastFamily').text = self.gds_format_string(lastFamily_)
        for middle_ in self.middle:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}middle').text = self.gds_format_string(middle_)
        if self.prefix is not None:
            prefix_ = self.prefix
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}prefix').text = self.gds_format_string(prefix_)
        if self.sex is not None:
            sex_ = self.sex
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}sex').text = self.gds_format_string(sex_)
        if self.suffix is not None:
            suffix_ = self.suffix
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}suffix').text = self.gds_format_string(suffix_)
        if self.typeOfIndividualName is not None:
            typeOfIndividualName_ = self.typeOfIndividualName
            typeOfIndividualName_.to_etree(element, name_='typeOfIndividualName', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'abbreviation':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abbreviation = obj_
            obj_.original_tagname_ = 'abbreviation'
        elif nodeName_ == 'context':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.context = obj_
            obj_.original_tagname_ = 'context'
        elif nodeName_ == 'effectiveDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveDates = obj_
            obj_.original_tagname_ = 'effectiveDates'
        elif nodeName_ == 'firstGiven':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'firstGiven')
            value_ = self.gds_validate_string(value_, node, 'firstGiven')
            self.firstGiven = value_
            self.firstGiven_nsprefix_ = child_.prefix
        elif nodeName_ == 'fullName':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fullName = obj_
            obj_.original_tagname_ = 'fullName'
        elif nodeName_ == 'isFormal':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isFormal')
            ival_ = self.gds_validate_boolean(ival_, node, 'isFormal')
            self.isFormal = ival_
            self.isFormal_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPreferred':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isPreferred')
            ival_ = self.gds_validate_boolean(ival_, node, 'isPreferred')
            self.isPreferred = ival_
            self.isPreferred_nsprefix_ = child_.prefix
        elif nodeName_ == 'lastFamily':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lastFamily')
            value_ = self.gds_validate_string(value_, node, 'lastFamily')
            self.lastFamily = value_
            self.lastFamily_nsprefix_ = child_.prefix
        elif nodeName_ == 'middle':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'middle')
            value_ = self.gds_validate_string(value_, node, 'middle')
            self.middle.append(value_)
            self.middle_nsprefix_ = child_.prefix
        elif nodeName_ == 'prefix':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'prefix')
            value_ = self.gds_validate_string(value_, node, 'prefix')
            self.prefix = value_
            self.prefix_nsprefix_ = child_.prefix
        elif nodeName_ == 'sex':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sex')
            value_ = self.gds_validate_string(value_, node, 'sex')
            self.sex = value_
            self.sex_nsprefix_ = child_.prefix
            # validate type SexSpecification
            self.validate_SexSpecification(self.sex)
        elif nodeName_ == 'suffix':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'suffix')
            value_ = self.gds_validate_string(value_, node, 'suffix')
            self.suffix = value_
            self.suffix_nsprefix_ = child_.prefix
        elif nodeName_ == 'typeOfIndividualName':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfIndividualName = obj_
            obj_.original_tagname_ = 'typeOfIndividualName'
# end class IndividualName


class InternationalIdentifier(GeneratedsSuper):
    """identifierContent -- An identifier as it should be listed for identification purposes.
    isURI -- Set to True if Identifier is a URI.
    managingAgency -- The identification of the Agency which assigns and manages the identifier, i.e., ISBN, ISSN, DOI, etc.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, identifierContent=None, isURI=None, managingAgency=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.identifierContent = identifierContent
        self.identifierContent_nsprefix_ = None
        self.isURI = isURI
        self.isURI_nsprefix_ = None
        self.managingAgency = managingAgency
        self.managingAgency_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InternationalIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InternationalIdentifier.subclass:
            return InternationalIdentifier.subclass(*args_, **kwargs_)
        else:
            return InternationalIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identifierContent(self):
        return self.identifierContent
    def set_identifierContent(self, identifierContent):
        self.identifierContent = identifierContent
    def get_isURI(self):
        return self.isURI
    def set_isURI(self, isURI):
        self.isURI = isURI
    def get_managingAgency(self):
        return self.managingAgency
    def set_managingAgency(self, managingAgency):
        self.managingAgency = managingAgency
    def has__content(self):
        if (
            self.identifierContent is not None or
            self.isURI is not None or
            self.managingAgency is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InternationalIdentifier', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.identifierContent is not None:
            identifierContent_ = self.identifierContent
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}identifierContent').text = self.gds_format_string(identifierContent_)
        if self.isURI is not None:
            isURI_ = self.isURI
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isURI').text = self.gds_format_boolean(isURI_)
        if self.managingAgency is not None:
            managingAgency_ = self.managingAgency
            managingAgency_.to_etree(element, name_='managingAgency', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identifierContent':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'identifierContent')
            value_ = self.gds_validate_string(value_, node, 'identifierContent')
            self.identifierContent = value_
            self.identifierContent_nsprefix_ = child_.prefix
        elif nodeName_ == 'isURI':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isURI')
            ival_ = self.gds_validate_boolean(ival_, node, 'isURI')
            self.isURI = ival_
            self.isURI_nsprefix_ = child_.prefix
        elif nodeName_ == 'managingAgency':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.managingAgency = obj_
            obj_.original_tagname_ = 'managingAgency'
# end class InternationalIdentifier


class InternationalRegistrationDataIdentifier(GeneratedsSuper):
    """dataIdentifier -- Identifier assigned to an Administered Item within a Registration Authority, hereafter called Data Identifier (DI). The DI is called 'id' in DDI-Codebook and DDI-Lifecycle.
    registrationAuthorityIdentifier -- Identifier assigned to a Registration Authority, hereafter called Registration Authority Identifier (RAI). The RAI is called 'agency' in DDI-Codebook and DDI-Lifecycle.
    versionIdentifier -- Identifier assigned to a version under which an Administered Item registration is submitted or updated hereafter called Version Identifier (VI). The VI is called "version" in DDI-Codebook and DDI-Lifecycle.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dataIdentifier=None, registrationAuthorityIdentifier=None, versionIdentifier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dataIdentifier = dataIdentifier
        self.dataIdentifier_nsprefix_ = None
        self.registrationAuthorityIdentifier = registrationAuthorityIdentifier
        self.registrationAuthorityIdentifier_nsprefix_ = None
        self.versionIdentifier = versionIdentifier
        self.versionIdentifier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InternationalRegistrationDataIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InternationalRegistrationDataIdentifier.subclass:
            return InternationalRegistrationDataIdentifier.subclass(*args_, **kwargs_)
        else:
            return InternationalRegistrationDataIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dataIdentifier(self):
        return self.dataIdentifier
    def set_dataIdentifier(self, dataIdentifier):
        self.dataIdentifier = dataIdentifier
    def get_registrationAuthorityIdentifier(self):
        return self.registrationAuthorityIdentifier
    def set_registrationAuthorityIdentifier(self, registrationAuthorityIdentifier):
        self.registrationAuthorityIdentifier = registrationAuthorityIdentifier
    def get_versionIdentifier(self):
        return self.versionIdentifier
    def set_versionIdentifier(self, versionIdentifier):
        self.versionIdentifier = versionIdentifier
    def has__content(self):
        if (
            self.dataIdentifier is not None or
            self.registrationAuthorityIdentifier is not None or
            self.versionIdentifier is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InternationalRegistrationDataIdentifier', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.dataIdentifier is not None:
            dataIdentifier_ = self.dataIdentifier
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}dataIdentifier').text = self.gds_format_string(dataIdentifier_)
        if self.registrationAuthorityIdentifier is not None:
            registrationAuthorityIdentifier_ = self.registrationAuthorityIdentifier
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}registrationAuthorityIdentifier').text = self.gds_format_string(registrationAuthorityIdentifier_)
        if self.versionIdentifier is not None:
            versionIdentifier_ = self.versionIdentifier
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}versionIdentifier').text = self.gds_format_string(versionIdentifier_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dataIdentifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dataIdentifier')
            value_ = self.gds_validate_string(value_, node, 'dataIdentifier')
            self.dataIdentifier = value_
            self.dataIdentifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'registrationAuthorityIdentifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'registrationAuthorityIdentifier')
            value_ = self.gds_validate_string(value_, node, 'registrationAuthorityIdentifier')
            self.registrationAuthorityIdentifier = value_
            self.registrationAuthorityIdentifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'versionIdentifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'versionIdentifier')
            value_ = self.gds_validate_string(value_, node, 'versionIdentifier')
            self.versionIdentifier = value_
            self.versionIdentifier_nsprefix_ = child_.prefix
# end class InternationalRegistrationDataIdentifier


class InternationalString(GeneratedsSuper):
    """languageSpecificString -- A non-formatted string of text with an attribute that designates the language of the text. Repeat this object to express the same content in another language.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, languageSpecificString=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if languageSpecificString is None:
            self.languageSpecificString = []
        else:
            self.languageSpecificString = languageSpecificString
        self.languageSpecificString_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InternationalString)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InternationalString.subclass:
            return InternationalString.subclass(*args_, **kwargs_)
        else:
            return InternationalString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_languageSpecificString(self):
        return self.languageSpecificString
    def set_languageSpecificString(self, languageSpecificString):
        self.languageSpecificString = languageSpecificString
    def add_languageSpecificString(self, value):
        self.languageSpecificString.append(value)
    def insert_languageSpecificString_at(self, index, value):
        self.languageSpecificString.insert(index, value)
    def replace_languageSpecificString_at(self, index, value):
        self.languageSpecificString[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.languageSpecificString
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InternationalString', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        for languageSpecificString_ in self.languageSpecificString:
            languageSpecificString_.to_etree(element, name_='languageSpecificString', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'languageSpecificString':
            obj_ = LanguageString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageSpecificString.append(obj_)
            obj_.original_tagname_ = 'languageSpecificString'
# end class InternationalString


class LabelForDisplay(InternationalString):
    """locationVariant -- Indicate the locality specification for content that is specific to a geographic area. May be a country code, sub-country code, or area name.
    maxLength -- A positive integer indicating the maximum number of characters in the label.
    validDates -- Allows for the specification of a starting date and ending date for the period that this label is valid.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = InternationalString
    def __init__(self, languageSpecificString=None, locationVariant=None, maxLength=None, validDates=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LabelForDisplay"), self).__init__(languageSpecificString,  **kwargs_)
        self.locationVariant = locationVariant
        self.locationVariant_nsprefix_ = None
        self.maxLength = maxLength
        self.maxLength_nsprefix_ = None
        self.validDates = validDates
        self.validDates_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LabelForDisplay)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LabelForDisplay.subclass:
            return LabelForDisplay.subclass(*args_, **kwargs_)
        else:
            return LabelForDisplay(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_locationVariant(self):
        return self.locationVariant
    def set_locationVariant(self, locationVariant):
        self.locationVariant = locationVariant
    def get_maxLength(self):
        return self.maxLength
    def set_maxLength(self, maxLength):
        self.maxLength = maxLength
    def get_validDates(self):
        return self.validDates
    def set_validDates(self, validDates):
        self.validDates = validDates
    def has__content(self):
        if (
            self.locationVariant is not None or
            self.maxLength is not None or
            self.validDates is not None or
            super(LabelForDisplay, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LabelForDisplay', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(LabelForDisplay, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.locationVariant is not None:
            locationVariant_ = self.locationVariant
            locationVariant_.to_etree(element, name_='locationVariant', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.maxLength is not None:
            maxLength_ = self.maxLength
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}maxLength').text = self.gds_format_integer(maxLength_)
        if self.validDates is not None:
            validDates_ = self.validDates
            validDates_.to_etree(element, name_='validDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LabelForDisplay, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'locationVariant':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.locationVariant = obj_
            obj_.original_tagname_ = 'locationVariant'
        elif nodeName_ == 'maxLength' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'maxLength')
            ival_ = self.gds_validate_integer(ival_, node, 'maxLength')
            self.maxLength = ival_
            self.maxLength_nsprefix_ = child_.prefix
        elif nodeName_ == 'validDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validDates = obj_
            obj_.original_tagname_ = 'validDates'
        super(LabelForDisplay, self)._buildChildren(child_, node, nodeName_, True)
# end class LabelForDisplay


class LanguageString(GeneratedsSuper):
    """content -- The content of the string.
    isTranslatable -- Indicates whether content is translatable (True) or not (False). An example of something that is not translatable would be a MNEMONIC of an object or a number.
    isTranslated -- Indicates whether content is a translation (True) or an original (False).
    scope -- Supports specification of scope for the contained content. Use with the language specification to filter application of content.
    structureUsed -- The structure type used. Examples are HTML or restructured text.
    translationDate -- The date the content was translated. Provision of translation date allows user to verify if translation was available during data collection or other time linked activity.
    translationSourceLanguage -- List the language code of the source. Repeat of multiple language sources are used.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, content=None, isTranslatable=None, isTranslated=None, scope=None, structureUsed=None, translationDate=None, translationSourceLanguage=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.content = content
        self.content_nsprefix_ = None
        self.isTranslatable = isTranslatable
        self.isTranslatable_nsprefix_ = None
        self.isTranslated = isTranslated
        self.isTranslated_nsprefix_ = None
        self.scope = scope
        self.scope_nsprefix_ = None
        self.structureUsed = structureUsed
        self.structureUsed_nsprefix_ = None
        if isinstance(translationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(translationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = translationDate
        self.translationDate = initvalue_
        self.translationDate_nsprefix_ = None
        if translationSourceLanguage is None:
            self.translationSourceLanguage = []
        else:
            self.translationSourceLanguage = translationSourceLanguage
        self.translationSourceLanguage_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LanguageString)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LanguageString.subclass:
            return LanguageString.subclass(*args_, **kwargs_)
        else:
            return LanguageString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def get_isTranslatable(self):
        return self.isTranslatable
    def set_isTranslatable(self, isTranslatable):
        self.isTranslatable = isTranslatable
    def get_isTranslated(self):
        return self.isTranslated
    def set_isTranslated(self, isTranslated):
        self.isTranslated = isTranslated
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_structureUsed(self):
        return self.structureUsed
    def set_structureUsed(self, structureUsed):
        self.structureUsed = structureUsed
    def get_translationDate(self):
        return self.translationDate
    def set_translationDate(self, translationDate):
        self.translationDate = translationDate
    def get_translationSourceLanguage(self):
        return self.translationSourceLanguage
    def set_translationSourceLanguage(self, translationSourceLanguage):
        self.translationSourceLanguage = translationSourceLanguage
    def add_translationSourceLanguage(self, value):
        self.translationSourceLanguage.append(value)
    def insert_translationSourceLanguage_at(self, index, value):
        self.translationSourceLanguage.insert(index, value)
    def replace_translationSourceLanguage_at(self, index, value):
        self.translationSourceLanguage[index] = value
    def has__content(self):
        if (
            self.content is not None or
            self.isTranslatable is not None or
            self.isTranslated is not None or
            self.scope is not None or
            self.structureUsed is not None or
            self.translationDate is not None or
            self.translationSourceLanguage
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LanguageString', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.content is not None:
            content_ = self.content
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}content').text = self.gds_format_string(content_)
        if self.isTranslatable is not None:
            isTranslatable_ = self.isTranslatable
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isTranslatable').text = self.gds_format_boolean(isTranslatable_)
        if self.isTranslated is not None:
            isTranslated_ = self.isTranslated
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isTranslated').text = self.gds_format_boolean(isTranslated_)
        if self.scope is not None:
            scope_ = self.scope
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}scope').text = self.gds_format_string(scope_)
        if self.structureUsed is not None:
            structureUsed_ = self.structureUsed
            structureUsed_.to_etree(element, name_='structureUsed', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.translationDate is not None:
            translationDate_ = self.translationDate
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}translationDate').text = self.gds_format_date(translationDate_)
        for translationSourceLanguage_ in self.translationSourceLanguage:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}translationSourceLanguage').text = self.gds_format_string(translationSourceLanguage_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'content')
            value_ = self.gds_validate_string(value_, node, 'content')
            self.content = value_
            self.content_nsprefix_ = child_.prefix
        elif nodeName_ == 'isTranslatable':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isTranslatable')
            ival_ = self.gds_validate_boolean(ival_, node, 'isTranslatable')
            self.isTranslatable = ival_
            self.isTranslatable_nsprefix_ = child_.prefix
        elif nodeName_ == 'isTranslated':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isTranslated')
            ival_ = self.gds_validate_boolean(ival_, node, 'isTranslated')
            self.isTranslated = ival_
            self.isTranslated_nsprefix_ = child_.prefix
        elif nodeName_ == 'scope':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'scope')
            value_ = self.gds_validate_string(value_, node, 'scope')
            self.scope = value_
            self.scope_nsprefix_ = child_.prefix
        elif nodeName_ == 'structureUsed':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.structureUsed = obj_
            obj_.original_tagname_ = 'structureUsed'
        elif nodeName_ == 'translationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.translationDate = dval_
            self.translationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'translationSourceLanguage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'translationSourceLanguage')
            value_ = self.gds_validate_string(value_, node, 'translationSourceLanguage')
            self.translationSourceLanguage.append(value_)
            self.translationSourceLanguage_nsprefix_ = child_.prefix
# end class LanguageString


class LicenseInformation(GeneratedsSuper):
    """contact -- Information on whom to contact for details on licensing.
    description -- A description of licensing terms.
    licenseAgent -- Points to a description of an agent with information about, or responsible for licensing of the object.
    licenseReference -- Points to published license terms, such as to a specific Creative Commons license.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, contact=None, description=None, licenseAgent=None, licenseReference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if contact is None:
            self.contact = []
        else:
            self.contact = contact
        self.contact_nsprefix_ = None
        if description is None:
            self.description = []
        else:
            self.description = description
        self.description_nsprefix_ = None
        if licenseAgent is None:
            self.licenseAgent = []
        else:
            self.licenseAgent = licenseAgent
        self.licenseAgent_nsprefix_ = None
        if licenseReference is None:
            self.licenseReference = []
        else:
            self.licenseReference = licenseReference
        self.licenseReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LicenseInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LicenseInformation.subclass:
            return LicenseInformation.subclass(*args_, **kwargs_)
        else:
            return LicenseInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_contact(self):
        return self.contact
    def set_contact(self, contact):
        self.contact = contact
    def add_contact(self, value):
        self.contact.append(value)
    def insert_contact_at(self, index, value):
        self.contact.insert(index, value)
    def replace_contact_at(self, index, value):
        self.contact[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def add_description(self, value):
        self.description.append(value)
    def insert_description_at(self, index, value):
        self.description.insert(index, value)
    def replace_description_at(self, index, value):
        self.description[index] = value
    def get_licenseAgent(self):
        return self.licenseAgent
    def set_licenseAgent(self, licenseAgent):
        self.licenseAgent = licenseAgent
    def add_licenseAgent(self, value):
        self.licenseAgent.append(value)
    def insert_licenseAgent_at(self, index, value):
        self.licenseAgent.insert(index, value)
    def replace_licenseAgent_at(self, index, value):
        self.licenseAgent[index] = value
    def get_licenseReference(self):
        return self.licenseReference
    def set_licenseReference(self, licenseReference):
        self.licenseReference = licenseReference
    def add_licenseReference(self, value):
        self.licenseReference.append(value)
    def insert_licenseReference_at(self, index, value):
        self.licenseReference.insert(index, value)
    def replace_licenseReference_at(self, index, value):
        self.licenseReference[index] = value
    def has__content(self):
        if (
            self.contact or
            self.description or
            self.licenseAgent or
            self.licenseReference
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LicenseInformation', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        for contact_ in self.contact:
            contact_.to_etree(element, name_='contact', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for description_ in self.description:
            description_.to_etree(element, name_='description', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for licenseAgent_ in self.licenseAgent:
            licenseAgent_.to_etree(element, name_='licenseAgent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for licenseReference_ in self.licenseReference:
            licenseReference_.to_etree(element, name_='licenseReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contact':
            obj_ = ContactInformation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contact.append(obj_)
            obj_.original_tagname_ = 'contact'
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'licenseAgent':
            obj_ = AgentInRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.licenseAgent.append(obj_)
            obj_.original_tagname_ = 'licenseAgent'
        elif nodeName_ == 'licenseReference':
            class_obj_ = self.get_class_obj_(child_, Reference)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.licenseReference.append(obj_)
            obj_.original_tagname_ = 'licenseReference'
# end class LicenseInformation


class ModelIdentification(GeneratedsSuper):
    """acronym -- Acronym of the model.
    language -- Language of the model.
    majorVersion -- Major version number of the model.
    minorVersion -- Minor version number of the model.
    subtitle -- Subtitle of the model.
    title -- Title of the model.
    uri -- URI of the specification.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, acronym=None, language=None, majorVersion=None, minorVersion=None, subtitle=None, title=None, uri=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.acronym = acronym
        self.acronym_nsprefix_ = None
        self.language = language
        self.language_nsprefix_ = None
        self.majorVersion = majorVersion
        self.majorVersion_nsprefix_ = None
        self.minorVersion = minorVersion
        self.minorVersion_nsprefix_ = None
        self.subtitle = subtitle
        self.subtitle_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        self.uri = uri
        self.uri_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModelIdentification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModelIdentification.subclass:
            return ModelIdentification.subclass(*args_, **kwargs_)
        else:
            return ModelIdentification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_acronym(self):
        return self.acronym
    def set_acronym(self, acronym):
        self.acronym = acronym
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_majorVersion(self):
        return self.majorVersion
    def set_majorVersion(self, majorVersion):
        self.majorVersion = majorVersion
    def get_minorVersion(self):
        return self.minorVersion
    def set_minorVersion(self, minorVersion):
        self.minorVersion = minorVersion
    def get_subtitle(self):
        return self.subtitle
    def set_subtitle(self, subtitle):
        self.subtitle = subtitle
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def has__content(self):
        if (
            self.acronym is not None or
            self.language is not None or
            self.majorVersion is not None or
            self.minorVersion is not None or
            self.subtitle is not None or
            self.title is not None or
            self.uri is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ModelIdentification', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.acronym is not None:
            acronym_ = self.acronym
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}acronym').text = self.gds_format_string(acronym_)
        if self.language is not None:
            language_ = self.language
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}language').text = self.gds_format_string(language_)
        if self.majorVersion is not None:
            majorVersion_ = self.majorVersion
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}majorVersion').text = self.gds_format_integer(majorVersion_)
        if self.minorVersion is not None:
            minorVersion_ = self.minorVersion
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}minorVersion').text = self.gds_format_integer(minorVersion_)
        if self.subtitle is not None:
            subtitle_ = self.subtitle
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}subtitle').text = self.gds_format_string(subtitle_)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}title').text = self.gds_format_string(title_)
        if self.uri is not None:
            uri_ = self.uri
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}uri').text = self.gds_format_string(uri_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'acronym':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'acronym')
            value_ = self.gds_validate_string(value_, node, 'acronym')
            self.acronym = value_
            self.acronym_nsprefix_ = child_.prefix
        elif nodeName_ == 'language':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'language')
            value_ = self.gds_validate_string(value_, node, 'language')
            self.language = value_
            self.language_nsprefix_ = child_.prefix
        elif nodeName_ == 'majorVersion' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'majorVersion')
            ival_ = self.gds_validate_integer(ival_, node, 'majorVersion')
            self.majorVersion = ival_
            self.majorVersion_nsprefix_ = child_.prefix
        elif nodeName_ == 'minorVersion' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'minorVersion')
            ival_ = self.gds_validate_integer(ival_, node, 'minorVersion')
            self.minorVersion = ival_
            self.minorVersion_nsprefix_ = child_.prefix
        elif nodeName_ == 'subtitle':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subtitle')
            value_ = self.gds_validate_string(value_, node, 'subtitle')
            self.subtitle = value_
            self.subtitle_nsprefix_ = child_.prefix
        elif nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'uri':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'uri')
            value_ = self.gds_validate_string(value_, node, 'uri')
            self.uri = value_
            self.uri_nsprefix_ = child_.prefix
# end class ModelIdentification


class NonDdiIdentifier(GeneratedsSuper):
    """managingAgency -- The authority which maintains the identification scheme.
    type -- The scheme of identifier, as distinct from a URI or a DDI-conforming identifier.
    value -- The identifier, structured according to the specified type.
    version -- The version of the object being identified, according to the versioning system provided by the identified scheme.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, managingAgency=None, type_=None, value=None, version=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.managingAgency = managingAgency
        self.managingAgency_nsprefix_ = None
        self.type_ = type_
        self.type__nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.version = version
        self.version_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonDdiIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonDdiIdentifier.subclass:
            return NonDdiIdentifier.subclass(*args_, **kwargs_)
        else:
            return NonDdiIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_managingAgency(self):
        return self.managingAgency
    def set_managingAgency(self, managingAgency):
        self.managingAgency = managingAgency
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def has__content(self):
        if (
            self.managingAgency is not None or
            self.type_ is not None or
            self.value is not None or
            self.version is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='NonDdiIdentifier', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.managingAgency is not None:
            managingAgency_ = self.managingAgency
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}managingAgency').text = self.gds_format_string(managingAgency_)
        if self.type_ is not None:
            type__ = self.type_
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}type').text = self.gds_format_string(type__)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_string(value_)
        if self.version is not None:
            version_ = self.version
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}version').text = self.gds_format_string(version_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'managingAgency':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'managingAgency')
            value_ = self.gds_validate_string(value_, node, 'managingAgency')
            self.managingAgency = value_
            self.managingAgency_nsprefix_ = child_.prefix
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'value')
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
            self.value_nsprefix_ = child_.prefix
        elif nodeName_ == 'version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'version')
            value_ = self.gds_validate_string(value_, node, 'version')
            self.version = value_
            self.version_nsprefix_ = child_.prefix
# end class NonDdiIdentifier


class NonIsoDate(GeneratedsSuper):
    """calendar -- Specifies the type of calendar used (e.g., Gregorian, Julian, Jewish).
    dateContent -- This is the date expressed in a non-ISO compliant structure. Primarily used to retain legacy content or to express non-Gregorian calendar dates.
    nonIsoDateFormat -- Indicate the structure of the date provided in NonISODate. For example if the NonISODate contained 4/1/2000 the Historical Date Format would be mm/dd/yyyy. The use of a controlled vocabulary is strongly recommended to support interoperability.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, calendar=None, dateContent=None, nonIsoDateFormat=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.calendar = calendar
        self.calendar_nsprefix_ = None
        self.dateContent = dateContent
        self.dateContent_nsprefix_ = None
        self.nonIsoDateFormat = nonIsoDateFormat
        self.nonIsoDateFormat_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonIsoDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonIsoDate.subclass:
            return NonIsoDate.subclass(*args_, **kwargs_)
        else:
            return NonIsoDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_calendar(self):
        return self.calendar
    def set_calendar(self, calendar):
        self.calendar = calendar
    def get_dateContent(self):
        return self.dateContent
    def set_dateContent(self, dateContent):
        self.dateContent = dateContent
    def get_nonIsoDateFormat(self):
        return self.nonIsoDateFormat
    def set_nonIsoDateFormat(self, nonIsoDateFormat):
        self.nonIsoDateFormat = nonIsoDateFormat
    def has__content(self):
        if (
            self.calendar is not None or
            self.dateContent is not None or
            self.nonIsoDateFormat is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='NonIsoDate', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.calendar is not None:
            calendar_ = self.calendar
            calendar_.to_etree(element, name_='calendar', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.dateContent is not None:
            dateContent_ = self.dateContent
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}dateContent').text = self.gds_format_string(dateContent_)
        if self.nonIsoDateFormat is not None:
            nonIsoDateFormat_ = self.nonIsoDateFormat
            nonIsoDateFormat_.to_etree(element, name_='nonIsoDateFormat', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'calendar':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.calendar = obj_
            obj_.original_tagname_ = 'calendar'
        elif nodeName_ == 'dateContent':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dateContent')
            value_ = self.gds_validate_string(value_, node, 'dateContent')
            self.dateContent = value_
            self.dateContent_nsprefix_ = child_.prefix
        elif nodeName_ == 'nonIsoDateFormat':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nonIsoDateFormat = obj_
            obj_.original_tagname_ = 'nonIsoDateFormat'
# end class NonIsoDate


class ObjectName(GeneratedsSuper):
    """context -- A name may be specific to a particular context, i.e., a type of software, or a section of a registry. Identify the context related to the specified name.
    name -- The expressed name of the object.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, context=None, name=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.context = context
        self.context_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectName.subclass:
            return ObjectName.subclass(*args_, **kwargs_)
        else:
            return ObjectName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_context(self):
        return self.context
    def set_context(self, context):
        self.context = context
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.context is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ObjectName', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.context is not None:
            context_ = self.context
            context_.to_etree(element, name_='context', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}name').text = self.gds_format_string(name_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'context':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.context = obj_
            obj_.original_tagname_ = 'context'
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class ObjectName


class OrganizationName(ObjectName):
    """abbreviation -- An abbreviation or acronym for the name. This may be expressed in multiple languages. It is assumed that if only a single language is provided that it may be used in any of the other languages within which the name itself is expressed.
    effectiveDates -- The time period for which this name is accurate and in use.
    isFormal -- The legal or formal name of the organization should have the isFormal attribute set to True. To avoid confusion only one organization name should have the isFormal attribute set to True. Use the typeOfOrganizationName to further differentiate the type and applied usage when multiple names are provided.
    typeOfOrganizationName -- The type of organization name provided. the use of a controlled vocabulary is strongly recommended. At minimum this should include, e.g. PreviousFormalName, Nickname (or CommonName), Other.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectName
    def __init__(self, context=None, name=None, abbreviation=None, effectiveDates=None, isFormal=None, typeOfOrganizationName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("OrganizationName"), self).__init__(context, name,  **kwargs_)
        self.abbreviation = abbreviation
        self.abbreviation_nsprefix_ = None
        self.effectiveDates = effectiveDates
        self.effectiveDates_nsprefix_ = None
        self.isFormal = isFormal
        self.isFormal_nsprefix_ = None
        self.typeOfOrganizationName = typeOfOrganizationName
        self.typeOfOrganizationName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganizationName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganizationName.subclass:
            return OrganizationName.subclass(*args_, **kwargs_)
        else:
            return OrganizationName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_abbreviation(self):
        return self.abbreviation
    def set_abbreviation(self, abbreviation):
        self.abbreviation = abbreviation
    def get_effectiveDates(self):
        return self.effectiveDates
    def set_effectiveDates(self, effectiveDates):
        self.effectiveDates = effectiveDates
    def get_isFormal(self):
        return self.isFormal
    def set_isFormal(self, isFormal):
        self.isFormal = isFormal
    def get_typeOfOrganizationName(self):
        return self.typeOfOrganizationName
    def set_typeOfOrganizationName(self, typeOfOrganizationName):
        self.typeOfOrganizationName = typeOfOrganizationName
    def has__content(self):
        if (
            self.abbreviation is not None or
            self.effectiveDates is not None or
            self.isFormal is not None or
            self.typeOfOrganizationName is not None or
            super(OrganizationName, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='OrganizationName', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(OrganizationName, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.abbreviation is not None:
            abbreviation_ = self.abbreviation
            abbreviation_.to_etree(element, name_='abbreviation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.effectiveDates is not None:
            effectiveDates_ = self.effectiveDates
            effectiveDates_.to_etree(element, name_='effectiveDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isFormal is not None:
            isFormal_ = self.isFormal
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isFormal').text = self.gds_format_boolean(isFormal_)
        if self.typeOfOrganizationName is not None:
            typeOfOrganizationName_ = self.typeOfOrganizationName
            typeOfOrganizationName_.to_etree(element, name_='typeOfOrganizationName', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(OrganizationName, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'abbreviation':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abbreviation = obj_
            obj_.original_tagname_ = 'abbreviation'
        elif nodeName_ == 'effectiveDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveDates = obj_
            obj_.original_tagname_ = 'effectiveDates'
        elif nodeName_ == 'isFormal':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isFormal')
            ival_ = self.gds_validate_boolean(ival_, node, 'isFormal')
            self.isFormal = ival_
            self.isFormal_nsprefix_ = child_.prefix
        elif nodeName_ == 'typeOfOrganizationName':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfOrganizationName = obj_
            obj_.original_tagname_ = 'typeOfOrganizationName'
        super(OrganizationName, self)._buildChildren(child_, node, nodeName_, True)
# end class OrganizationName


class PairedControlledVocabularyEntry(GeneratedsSuper):
    """extent -- Describes the extent to which the parent term applies for the specific case using an external controlled vocabulary. When associated with a role from the CASRAI Contributor Roles Taxonomy an appropriate vocabulary should be specified as either "lead", "equal", or "supporting".
    term -- The term attributed to the parent class, for example the role of a contributor.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, extent=None, term=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extent = extent
        self.extent_nsprefix_ = None
        self.term = term
        self.term_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PairedControlledVocabularyEntry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PairedControlledVocabularyEntry.subclass:
            return PairedControlledVocabularyEntry.subclass(*args_, **kwargs_)
        else:
            return PairedControlledVocabularyEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extent(self):
        return self.extent
    def set_extent(self, extent):
        self.extent = extent
    def get_term(self):
        return self.term
    def set_term(self, term):
        self.term = term
    def has__content(self):
        if (
            self.extent is not None or
            self.term is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PairedControlledVocabularyEntry', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extent is not None:
            extent_ = self.extent
            extent_.to_etree(element, name_='extent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.term is not None:
            term_ = self.term
            term_.to_etree(element, name_='term', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'extent':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extent = obj_
            obj_.original_tagname_ = 'extent'
        elif nodeName_ == 'term':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
# end class PairedControlledVocabularyEntry


class PrivateImage(GeneratedsSuper):
    """effectiveDates -- The period for which this image is effective/valid.
    privacy -- Specify the level privacy for the image as public, restricted, or private. Supports the use of an external controlled vocabulary.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, effectiveDates=None, privacy=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.effectiveDates = effectiveDates
        self.effectiveDates_nsprefix_ = None
        self.privacy = privacy
        self.privacy_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrivateImage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrivateImage.subclass:
            return PrivateImage.subclass(*args_, **kwargs_)
        else:
            return PrivateImage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_effectiveDates(self):
        return self.effectiveDates
    def set_effectiveDates(self, effectiveDates):
        self.effectiveDates = effectiveDates
    def get_privacy(self):
        return self.privacy
    def set_privacy(self, privacy):
        self.privacy = privacy
    def has__content(self):
        if (
            self.effectiveDates is not None or
            self.privacy is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PrivateImage', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.effectiveDates is not None:
            effectiveDates_ = self.effectiveDates
            effectiveDates_.to_etree(element, name_='effectiveDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.privacy is not None:
            privacy_ = self.privacy
            privacy_.to_etree(element, name_='privacy', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'effectiveDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveDates = obj_
            obj_.original_tagname_ = 'effectiveDates'
        elif nodeName_ == 'privacy':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.privacy = obj_
            obj_.original_tagname_ = 'privacy'
# end class PrivateImage


class ProvenanceInformation(GeneratedsSuper):
    """funding -- Information about a funding source.
    provenanceStatement -- A statement of any changes in ownership and custody of the resource since its creation that are significant for its authenticity, integrity, and interpretation.
    recordCreationDate -- Date the record was created.
    recordLastRevisionDate -- Date the record was last revised.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, funding=None, provenanceStatement=None, recordCreationDate=None, recordLastRevisionDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if funding is None:
            self.funding = []
        else:
            self.funding = funding
        self.funding_nsprefix_ = None
        if provenanceStatement is None:
            self.provenanceStatement = []
        else:
            self.provenanceStatement = provenanceStatement
        self.provenanceStatement_nsprefix_ = None
        if isinstance(recordCreationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(recordCreationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = recordCreationDate
        self.recordCreationDate = initvalue_
        self.recordCreationDate_nsprefix_ = None
        if isinstance(recordLastRevisionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(recordLastRevisionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = recordLastRevisionDate
        self.recordLastRevisionDate = initvalue_
        self.recordLastRevisionDate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProvenanceInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProvenanceInformation.subclass:
            return ProvenanceInformation.subclass(*args_, **kwargs_)
        else:
            return ProvenanceInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_funding(self):
        return self.funding
    def set_funding(self, funding):
        self.funding = funding
    def add_funding(self, value):
        self.funding.append(value)
    def insert_funding_at(self, index, value):
        self.funding.insert(index, value)
    def replace_funding_at(self, index, value):
        self.funding[index] = value
    def get_provenanceStatement(self):
        return self.provenanceStatement
    def set_provenanceStatement(self, provenanceStatement):
        self.provenanceStatement = provenanceStatement
    def add_provenanceStatement(self, value):
        self.provenanceStatement.append(value)
    def insert_provenanceStatement_at(self, index, value):
        self.provenanceStatement.insert(index, value)
    def replace_provenanceStatement_at(self, index, value):
        self.provenanceStatement[index] = value
    def get_recordCreationDate(self):
        return self.recordCreationDate
    def set_recordCreationDate(self, recordCreationDate):
        self.recordCreationDate = recordCreationDate
    def get_recordLastRevisionDate(self):
        return self.recordLastRevisionDate
    def set_recordLastRevisionDate(self, recordLastRevisionDate):
        self.recordLastRevisionDate = recordLastRevisionDate
    def has__content(self):
        if (
            self.funding or
            self.provenanceStatement or
            self.recordCreationDate is not None or
            self.recordLastRevisionDate is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ProvenanceInformation', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        for funding_ in self.funding:
            funding_.to_etree(element, name_='funding', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for provenanceStatement_ in self.provenanceStatement:
            provenanceStatement_.to_etree(element, name_='provenanceStatement', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.recordCreationDate is not None:
            recordCreationDate_ = self.recordCreationDate
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}recordCreationDate').text = self.gds_format_date(recordCreationDate_)
        if self.recordLastRevisionDate is not None:
            recordLastRevisionDate_ = self.recordLastRevisionDate
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}recordLastRevisionDate').text = self.gds_format_date(recordLastRevisionDate_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'funding':
            obj_ = FundingInformation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.funding.append(obj_)
            obj_.original_tagname_ = 'funding'
        elif nodeName_ == 'provenanceStatement':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.provenanceStatement.append(obj_)
            obj_.original_tagname_ = 'provenanceStatement'
        elif nodeName_ == 'recordCreationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.recordCreationDate = dval_
            self.recordCreationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'recordLastRevisionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.recordLastRevisionDate = dval_
            self.recordLastRevisionDate_nsprefix_ = child_.prefix
# end class ProvenanceInformation


class RationaleDefinition(GeneratedsSuper):
    """rationaleCode -- Rationale  ode is primarily for internal processing flags within an organization or system. Supports the use of an external controlled vocabulary.
    rationaleDescription -- Textual description of the rationale/purpose for the version change to inform users as to the extent and implication of the version change. May be expressed in multiple languages.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, rationaleCode=None, rationaleDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.rationaleCode = rationaleCode
        self.rationaleCode_nsprefix_ = None
        self.rationaleDescription = rationaleDescription
        self.rationaleDescription_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RationaleDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RationaleDefinition.subclass:
            return RationaleDefinition.subclass(*args_, **kwargs_)
        else:
            return RationaleDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rationaleCode(self):
        return self.rationaleCode
    def set_rationaleCode(self, rationaleCode):
        self.rationaleCode = rationaleCode
    def get_rationaleDescription(self):
        return self.rationaleDescription
    def set_rationaleDescription(self, rationaleDescription):
        self.rationaleDescription = rationaleDescription
    def has__content(self):
        if (
            self.rationaleCode is not None or
            self.rationaleDescription is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RationaleDefinition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.rationaleCode is not None:
            rationaleCode_ = self.rationaleCode
            rationaleCode_.to_etree(element, name_='rationaleCode', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.rationaleDescription is not None:
            rationaleDescription_ = self.rationaleDescription
            rationaleDescription_.to_etree(element, name_='rationaleDescription', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'rationaleCode':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rationaleCode = obj_
            obj_.original_tagname_ = 'rationaleCode'
        elif nodeName_ == 'rationaleDescription':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rationaleDescription = obj_
            obj_.original_tagname_ = 'rationaleDescription'
# end class RationaleDefinition


class Reference(GeneratedsSuper):
    """ddiReference -- A DDI type reference to a DDI object.
    deepLink -- The selector refers to the object identifier by the ddiReference and has deep linking purposes.
    description -- Human-readable description of the reference.
    location -- The location of the referenced resource, as appropriate to support retrieval.
    nonDdiReference -- A non-DDI reference to any object using a system of identification which is not supported by a URI.
    semantic -- External qualifier to describe the purpose or meaning of the reference.
    uri -- A URI to any object.
    validType -- The expected type of the reference (e.g., the class or element according to the schema of the referenced resource).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.deepLink = deepLink
        self.deepLink_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.location = location
        self.location_nsprefix_ = None
        if nonDdiReference is None:
            self.nonDdiReference = []
        else:
            self.nonDdiReference = nonDdiReference
        self.nonDdiReference_nsprefix_ = None
        self.semantic = semantic
        self.semantic_nsprefix_ = None
        self.uri = uri
        self.uri_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Reference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Reference.subclass:
            return Reference.subclass(*args_, **kwargs_)
        else:
            return Reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_deepLink(self):
        return self.deepLink
    def set_deepLink(self, deepLink):
        self.deepLink = deepLink
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_nonDdiReference(self):
        return self.nonDdiReference
    def set_nonDdiReference(self, nonDdiReference):
        self.nonDdiReference = nonDdiReference
    def add_nonDdiReference(self, value):
        self.nonDdiReference.append(value)
    def insert_nonDdiReference_at(self, index, value):
        self.nonDdiReference.insert(index, value)
    def replace_nonDdiReference_at(self, index, value):
        self.nonDdiReference[index] = value
    def get_semantic(self):
        return self.semantic
    def set_semantic(self, semantic):
        self.semantic = semantic
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.deepLink is not None or
            self.description is not None or
            self.location is not None or
            self.nonDdiReference or
            self.semantic is not None or
            self.uri is not None or
            self.validType
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Reference', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.deepLink is not None:
            deepLink_ = self.deepLink
            deepLink_.to_etree(element, name_='deepLink', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.description is not None:
            description_ = self.description
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}description').text = self.gds_format_string(description_)
        if self.location is not None:
            location_ = self.location
            location_.to_etree(element, name_='location', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for nonDdiReference_ in self.nonDdiReference:
            nonDdiReference_.to_etree(element, name_='nonDdiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.semantic is not None:
            semantic_ = self.semantic
            semantic_.to_etree(element, name_='semantic', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.uri is not None:
            uri_ = self.uri
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}uri').text = self.gds_format_string(uri_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'deepLink':
            class_obj_ = self.get_class_obj_(child_, Selector)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deepLink = obj_
            obj_.original_tagname_ = 'deepLink'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'location':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'nonDdiReference':
            obj_ = NonDdiIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nonDdiReference.append(obj_)
            obj_.original_tagname_ = 'nonDdiReference'
        elif nodeName_ == 'semantic':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semantic = obj_
            obj_.original_tagname_ = 'semantic'
        elif nodeName_ == 'uri':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'uri')
            value_ = self.gds_validate_string(value_, node, 'uri')
            self.uri = value_
            self.uri_nsprefix_ = child_.prefix
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
# end class Reference


class AssociationReference(Reference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Reference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AssociationReference"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType,  **kwargs_)
        self.isAssociationReference = _cast(bool, isAssociationReference)
        self.isAssociationReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssociationReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssociationReference.subclass:
            return AssociationReference.subclass(*args_, **kwargs_)
        else:
            return AssociationReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isAssociationReference(self):
        return self.isAssociationReference
    def set_isAssociationReference(self, isAssociationReference):
        self.isAssociationReference = isAssociationReference
    def has__content(self):
        if (
            super(AssociationReference, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AssociationReference', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(AssociationReference, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.isAssociationReference is not None:
            element.set('isAssociationReference', self.gds_format_boolean(self.isAssociationReference))
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isAssociationReference', node)
        if value is not None and 'isAssociationReference' not in already_processed:
            already_processed.add('isAssociationReference')
            if value in ('true', '1'):
                self.isAssociationReference = True
            elif value in ('false', '0'):
                self.isAssociationReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(AssociationReference, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AssociationReference, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class AssociationReference


class Selector(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Selector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Selector.subclass:
            return Selector.subclass(*args_, **kwargs_)
        else:
            return Selector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Selector', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Selector


class SpatialCoordinate(GeneratedsSuper):
    """content -- The value of the coordinate expressed as a string.
    coordinateType -- Identifies the type of point coordinate system using a controlled vocabulary. Point formats include decimal degree, degrees minutes seconds, decimal minutes, meters, and feet.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, content=None, coordinateType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.content = content
        self.content_nsprefix_ = None
        self.coordinateType = coordinateType
        self.validate_PointFormat(self.coordinateType)
        self.coordinateType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpatialCoordinate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpatialCoordinate.subclass:
            return SpatialCoordinate.subclass(*args_, **kwargs_)
        else:
            return SpatialCoordinate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def get_coordinateType(self):
        return self.coordinateType
    def set_coordinateType(self, coordinateType):
        self.coordinateType = coordinateType
    def validate_PointFormat(self, value):
        result = True
        # Validate type PointFormat, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DecimalDegree', 'DecimalMinutes', 'DegreesMinutesSeconds', 'Feet', 'Meters']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PointFormat' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.content is not None or
            self.coordinateType is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SpatialCoordinate', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.content is not None:
            content_ = self.content
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}content').text = self.gds_format_string(content_)
        if self.coordinateType is not None:
            coordinateType_ = self.coordinateType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}coordinateType').text = self.gds_format_string(coordinateType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'content')
            value_ = self.gds_validate_string(value_, node, 'content')
            self.content = value_
            self.content_nsprefix_ = child_.prefix
        elif nodeName_ == 'coordinateType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'coordinateType')
            value_ = self.gds_validate_string(value_, node, 'coordinateType')
            self.coordinateType = value_
            self.coordinateType_nsprefix_ = child_.prefix
            # validate type PointFormat
            self.validate_PointFormat(self.coordinateType)
# end class SpatialCoordinate


class SpatialPoint(GeneratedsSuper):
    """xCoordinate -- An X coordinate (latitudinal equivalent) value and format expressed using the Spatial Coordinate structure.
    yCoordinate -- A Y coordinate (longitudinal equivalent) value and format expressed using the Spatial Coordinate structure.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xCoordinate=None, yCoordinate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xCoordinate = xCoordinate
        self.xCoordinate_nsprefix_ = None
        self.yCoordinate = yCoordinate
        self.yCoordinate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpatialPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpatialPoint.subclass:
            return SpatialPoint.subclass(*args_, **kwargs_)
        else:
            return SpatialPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xCoordinate(self):
        return self.xCoordinate
    def set_xCoordinate(self, xCoordinate):
        self.xCoordinate = xCoordinate
    def get_yCoordinate(self):
        return self.yCoordinate
    def set_yCoordinate(self, yCoordinate):
        self.yCoordinate = yCoordinate
    def has__content(self):
        if (
            self.xCoordinate is not None or
            self.yCoordinate is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SpatialPoint', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.xCoordinate is not None:
            xCoordinate_ = self.xCoordinate
            xCoordinate_.to_etree(element, name_='xCoordinate', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.yCoordinate is not None:
            yCoordinate_ = self.yCoordinate
            yCoordinate_.to_etree(element, name_='yCoordinate', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xCoordinate':
            obj_ = SpatialCoordinate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.xCoordinate = obj_
            obj_.original_tagname_ = 'xCoordinate'
        elif nodeName_ == 'yCoordinate':
            obj_ = SpatialCoordinate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.yCoordinate = obj_
            obj_.original_tagname_ = 'yCoordinate'
# end class SpatialPoint


class SpecializationRole(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpecializationRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpecializationRole.subclass:
            return SpecializationRole.subclass(*args_, **kwargs_)
        else:
            return SpecializationRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SpecializationRole', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SpecializationRole


class Statistic(GeneratedsSuper):
    """computationBase -- Defines the cases included in determining the statistic. The options are total = all cases, valid and missing (invalid); validOnly = Only valid values, missing (invalid) are not included in the calculation; missingOnly = Only missing (invalid) cases included in the calculation.
    content -- The value of the statistic expressed as a real number.
    isWeighted -- Set to True if the statistic is weighted.
    typeOfNumericValue -- Indicate the type of numeric value as decimal, float, double.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, computationBase=None, content=None, isWeighted=None, typeOfNumericValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.computationBase = computationBase
        self.validate_ComputationBaseList(self.computationBase)
        self.computationBase_nsprefix_ = None
        self.content = content
        self.content_nsprefix_ = None
        self.isWeighted = isWeighted
        self.isWeighted_nsprefix_ = None
        self.typeOfNumericValue = typeOfNumericValue
        self.typeOfNumericValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Statistic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Statistic.subclass:
            return Statistic.subclass(*args_, **kwargs_)
        else:
            return Statistic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_computationBase(self):
        return self.computationBase
    def set_computationBase(self, computationBase):
        self.computationBase = computationBase
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def get_isWeighted(self):
        return self.isWeighted
    def set_isWeighted(self, isWeighted):
        self.isWeighted = isWeighted
    def get_typeOfNumericValue(self):
        return self.typeOfNumericValue
    def set_typeOfNumericValue(self, typeOfNumericValue):
        self.typeOfNumericValue = typeOfNumericValue
    def validate_ComputationBaseList(self, value):
        result = True
        # Validate type ComputationBaseList, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MissingOnly', 'Total', 'ValidOnly']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ComputationBaseList' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.computationBase is not None or
            self.content is not None or
            self.isWeighted is not None or
            self.typeOfNumericValue is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Statistic', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.computationBase is not None:
            computationBase_ = self.computationBase
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}computationBase').text = self.gds_format_string(computationBase_)
        if self.content is not None:
            content_ = self.content
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}content').text = self.gds_format_double(content_)
        if self.isWeighted is not None:
            isWeighted_ = self.isWeighted
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isWeighted').text = self.gds_format_boolean(isWeighted_)
        if self.typeOfNumericValue is not None:
            typeOfNumericValue_ = self.typeOfNumericValue
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}typeOfNumericValue').text = self.gds_format_string(typeOfNumericValue_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'computationBase':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'computationBase')
            value_ = self.gds_validate_string(value_, node, 'computationBase')
            self.computationBase = value_
            self.computationBase_nsprefix_ = child_.prefix
            # validate type ComputationBaseList
            self.validate_ComputationBaseList(self.computationBase)
        elif nodeName_ == 'content' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'content')
            fval_ = self.gds_validate_double(fval_, node, 'content')
            self.content = fval_
            self.content_nsprefix_ = child_.prefix
        elif nodeName_ == 'isWeighted':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isWeighted')
            ival_ = self.gds_validate_boolean(ival_, node, 'isWeighted')
            self.isWeighted = ival_
            self.isWeighted_nsprefix_ = child_.prefix
        elif nodeName_ == 'typeOfNumericValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeOfNumericValue')
            value_ = self.gds_validate_string(value_, node, 'typeOfNumericValue')
            self.typeOfNumericValue = value_
            self.typeOfNumericValue_nsprefix_ = child_.prefix
# end class Statistic


class StructureSpecification(GeneratedsSuper):
    """reflexive -- Members of the selected scope of the collection are related to themselves.
    symmetric -- For pairs of members, a, b in the indicated scope of the associated collection, whenever a is related to b then also b is related to a.
    transitive -- For members a, b, c in the indicated scope of the associated collection, whenever a is related to b and b is related to c then a is also related to c.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, reflexive=None, symmetric=None, transitive=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.reflexive = reflexive
        self.validate_MemberRelationshipScope(self.reflexive)
        self.reflexive_nsprefix_ = None
        self.symmetric = symmetric
        self.validate_MemberRelationshipScope(self.symmetric)
        self.symmetric_nsprefix_ = None
        self.transitive = transitive
        self.validate_MemberRelationshipScope(self.transitive)
        self.transitive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StructureSpecification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StructureSpecification.subclass:
            return StructureSpecification.subclass(*args_, **kwargs_)
        else:
            return StructureSpecification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reflexive(self):
        return self.reflexive
    def set_reflexive(self, reflexive):
        self.reflexive = reflexive
    def get_symmetric(self):
        return self.symmetric
    def set_symmetric(self, symmetric):
        self.symmetric = symmetric
    def get_transitive(self):
        return self.transitive
    def set_transitive(self, transitive):
        self.transitive = transitive
    def validate_MemberRelationshipScope(self, value):
        result = True
        # Validate type MemberRelationshipScope, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['All', 'None', 'Some']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MemberRelationshipScope' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.reflexive is not None or
            self.symmetric is not None or
            self.transitive is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StructureSpecification', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.reflexive is not None:
            reflexive_ = self.reflexive
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}reflexive').text = self.gds_format_string(reflexive_)
        if self.symmetric is not None:
            symmetric_ = self.symmetric
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}symmetric').text = self.gds_format_string(symmetric_)
        if self.transitive is not None:
            transitive_ = self.transitive
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}transitive').text = self.gds_format_string(transitive_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reflexive':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reflexive')
            value_ = self.gds_validate_string(value_, node, 'reflexive')
            self.reflexive = value_
            self.reflexive_nsprefix_ = child_.prefix
            # validate type MemberRelationshipScope
            self.validate_MemberRelationshipScope(self.reflexive)
        elif nodeName_ == 'symmetric':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'symmetric')
            value_ = self.gds_validate_string(value_, node, 'symmetric')
            self.symmetric = value_
            self.symmetric_nsprefix_ = child_.prefix
            # validate type MemberRelationshipScope
            self.validate_MemberRelationshipScope(self.symmetric)
        elif nodeName_ == 'transitive':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'transitive')
            value_ = self.gds_validate_string(value_, node, 'transitive')
            self.transitive = value_
            self.transitive_nsprefix_ = child_.prefix
            # validate type MemberRelationshipScope
            self.validate_MemberRelationshipScope(self.transitive)
# end class StructureSpecification


class Telephone(GeneratedsSuper):
    """effectiveDates -- Time period during which the telephone number is valid.
    isPreferred -- Set to True if this is the preferred telephone number for contact.
    privacy -- Specify the level privacy for the telephone number as public, restricted, or private. Supports the use of an external controlled vocabulary.
    telephoneNumber -- The telephone number including country code if appropriate.
    typeOfTelephone -- Indicates type of telephone number provided (home, fax, office, cell, etc.). Supports the use of a controlled vocabulary.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, effectiveDates=None, isPreferred=None, privacy=None, telephoneNumber=None, typeOfTelephone=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.effectiveDates = effectiveDates
        self.effectiveDates_nsprefix_ = None
        self.isPreferred = isPreferred
        self.isPreferred_nsprefix_ = None
        self.privacy = privacy
        self.privacy_nsprefix_ = None
        self.telephoneNumber = telephoneNumber
        self.telephoneNumber_nsprefix_ = None
        self.typeOfTelephone = typeOfTelephone
        self.typeOfTelephone_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Telephone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Telephone.subclass:
            return Telephone.subclass(*args_, **kwargs_)
        else:
            return Telephone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_effectiveDates(self):
        return self.effectiveDates
    def set_effectiveDates(self, effectiveDates):
        self.effectiveDates = effectiveDates
    def get_isPreferred(self):
        return self.isPreferred
    def set_isPreferred(self, isPreferred):
        self.isPreferred = isPreferred
    def get_privacy(self):
        return self.privacy
    def set_privacy(self, privacy):
        self.privacy = privacy
    def get_telephoneNumber(self):
        return self.telephoneNumber
    def set_telephoneNumber(self, telephoneNumber):
        self.telephoneNumber = telephoneNumber
    def get_typeOfTelephone(self):
        return self.typeOfTelephone
    def set_typeOfTelephone(self, typeOfTelephone):
        self.typeOfTelephone = typeOfTelephone
    def has__content(self):
        if (
            self.effectiveDates is not None or
            self.isPreferred is not None or
            self.privacy is not None or
            self.telephoneNumber is not None or
            self.typeOfTelephone is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Telephone', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.effectiveDates is not None:
            effectiveDates_ = self.effectiveDates
            effectiveDates_.to_etree(element, name_='effectiveDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isPreferred is not None:
            isPreferred_ = self.isPreferred
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isPreferred').text = self.gds_format_boolean(isPreferred_)
        if self.privacy is not None:
            privacy_ = self.privacy
            privacy_.to_etree(element, name_='privacy', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.telephoneNumber is not None:
            telephoneNumber_ = self.telephoneNumber
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}telephoneNumber').text = self.gds_format_string(telephoneNumber_)
        if self.typeOfTelephone is not None:
            typeOfTelephone_ = self.typeOfTelephone
            typeOfTelephone_.to_etree(element, name_='typeOfTelephone', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'effectiveDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveDates = obj_
            obj_.original_tagname_ = 'effectiveDates'
        elif nodeName_ == 'isPreferred':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isPreferred')
            ival_ = self.gds_validate_boolean(ival_, node, 'isPreferred')
            self.isPreferred = ival_
            self.isPreferred_nsprefix_ = child_.prefix
        elif nodeName_ == 'privacy':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.privacy = obj_
            obj_.original_tagname_ = 'privacy'
        elif nodeName_ == 'telephoneNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'telephoneNumber')
            value_ = self.gds_validate_string(value_, node, 'telephoneNumber')
            self.telephoneNumber = value_
            self.telephoneNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'typeOfTelephone':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfTelephone = obj_
            obj_.original_tagname_ = 'typeOfTelephone'
# end class Telephone


class TextPositionSelector(Selector):
    """end -- Position of the last character of the selection. Position 8 would be the end of the word "Position" of the previous sentence.
    start -- Position of the first character of the selection. Position 0 would be the start of the word "Position" of the previous sentence.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Selector
    def __init__(self, end=None, start=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TextPositionSelector"), self).__init__( **kwargs_)
        self.end = end
        self.end_nsprefix_ = None
        self.start = start
        self.start_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextPositionSelector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextPositionSelector.subclass:
            return TextPositionSelector.subclass(*args_, **kwargs_)
        else:
            return TextPositionSelector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def get_start(self):
        return self.start
    def set_start(self, start):
        self.start = start
    def has__content(self):
        if (
            self.end is not None or
            self.start is not None or
            super(TextPositionSelector, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TextPositionSelector', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(TextPositionSelector, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.end is not None:
            end_ = self.end
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}end').text = self.gds_format_integer(end_)
        if self.start is not None:
            start_ = self.start
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}start').text = self.gds_format_integer(start_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TextPositionSelector, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'end' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'end')
            ival_ = self.gds_validate_integer(ival_, node, 'end')
            self.end = ival_
            self.end_nsprefix_ = child_.prefix
        elif nodeName_ == 'start' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'start')
            ival_ = self.gds_validate_integer(ival_, node, 'start')
            self.start = ival_
            self.start_nsprefix_ = child_.prefix
        super(TextPositionSelector, self)._buildChildren(child_, node, nodeName_, True)
# end class TextPositionSelector


class TimeRole(SpecializationRole):
    """time -- Holds a value from an external controlled vocabulary defining the time role.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SpecializationRole
    def __init__(self, time=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TimeRole"), self).__init__( **kwargs_)
        self.time = time
        self.time_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeRole.subclass:
            return TimeRole.subclass(*args_, **kwargs_)
        else:
            return TimeRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def has__content(self):
        if (
            self.time is not None or
            super(TimeRole, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TimeRole', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(TimeRole, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.time is not None:
            time_ = self.time
            time_.to_etree(element, name_='time', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TimeRole, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'time':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        super(TimeRole, self)._buildChildren(child_, node, nodeName_, True)
# end class TimeRole


class TypedString(GeneratedsSuper):
    """content -- Content of the property expressed as a simple string.
    typeOfContent -- Optional use of a controlled vocabulary to specifically type the associated content.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, content=None, typeOfContent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.content = content
        self.content_nsprefix_ = None
        self.typeOfContent = typeOfContent
        self.typeOfContent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TypedString)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TypedString.subclass:
            return TypedString.subclass(*args_, **kwargs_)
        else:
            return TypedString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def get_typeOfContent(self):
        return self.typeOfContent
    def set_typeOfContent(self, typeOfContent):
        self.typeOfContent = typeOfContent
    def has__content(self):
        if (
            self.content is not None or
            self.typeOfContent is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TypedString', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.content is not None:
            content_ = self.content
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}content').text = self.gds_format_string(content_)
        if self.typeOfContent is not None:
            typeOfContent_ = self.typeOfContent
            typeOfContent_.to_etree(element, name_='typeOfContent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'content')
            value_ = self.gds_validate_string(value_, node, 'content')
            self.content = value_
            self.content_nsprefix_ = child_.prefix
        elif nodeName_ == 'typeOfContent':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfContent = obj_
            obj_.original_tagname_ = 'typeOfContent'
# end class TypedString


class WebLink(GeneratedsSuper):
    """effectiveDates -- The period for which this URL is valid.
    isPreferred -- Set to True if this is the preferred URL.
    privacy -- Indicates the privacy level of this URL.
    typeOfWebsite -- The type of Website URL, for example personal, project, organization, division, etc.
    uri -- A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource. Normally a URL.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, effectiveDates=None, isPreferred=None, privacy=None, typeOfWebsite=None, uri=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.effectiveDates = effectiveDates
        self.effectiveDates_nsprefix_ = None
        self.isPreferred = isPreferred
        self.isPreferred_nsprefix_ = None
        self.privacy = privacy
        self.privacy_nsprefix_ = None
        self.typeOfWebsite = typeOfWebsite
        self.typeOfWebsite_nsprefix_ = None
        self.uri = uri
        self.uri_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebLink.subclass:
            return WebLink.subclass(*args_, **kwargs_)
        else:
            return WebLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_effectiveDates(self):
        return self.effectiveDates
    def set_effectiveDates(self, effectiveDates):
        self.effectiveDates = effectiveDates
    def get_isPreferred(self):
        return self.isPreferred
    def set_isPreferred(self, isPreferred):
        self.isPreferred = isPreferred
    def get_privacy(self):
        return self.privacy
    def set_privacy(self, privacy):
        self.privacy = privacy
    def get_typeOfWebsite(self):
        return self.typeOfWebsite
    def set_typeOfWebsite(self, typeOfWebsite):
        self.typeOfWebsite = typeOfWebsite
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def has__content(self):
        if (
            self.effectiveDates is not None or
            self.isPreferred is not None or
            self.privacy is not None or
            self.typeOfWebsite is not None or
            self.uri is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='WebLink', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.effectiveDates is not None:
            effectiveDates_ = self.effectiveDates
            effectiveDates_.to_etree(element, name_='effectiveDates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isPreferred is not None:
            isPreferred_ = self.isPreferred
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}isPreferred').text = self.gds_format_boolean(isPreferred_)
        if self.privacy is not None:
            privacy_ = self.privacy
            privacy_.to_etree(element, name_='privacy', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.typeOfWebsite is not None:
            typeOfWebsite_ = self.typeOfWebsite
            typeOfWebsite_.to_etree(element, name_='typeOfWebsite', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.uri is not None:
            uri_ = self.uri
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}uri').text = self.gds_format_string(uri_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'effectiveDates':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveDates = obj_
            obj_.original_tagname_ = 'effectiveDates'
        elif nodeName_ == 'isPreferred':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isPreferred')
            ival_ = self.gds_validate_boolean(ival_, node, 'isPreferred')
            self.isPreferred = ival_
            self.isPreferred_nsprefix_ = child_.prefix
        elif nodeName_ == 'privacy':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.privacy = obj_
            obj_.original_tagname_ = 'privacy'
        elif nodeName_ == 'typeOfWebsite':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfWebsite = obj_
            obj_.original_tagname_ = 'typeOfWebsite'
        elif nodeName_ == 'uri':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'uri')
            value_ = self.gds_validate_string(value_, node, 'uri')
            self.uri = value_
            self.uri_nsprefix_ = child_.prefix
# end class WebLink


class Activity_hasInternal_ControlLogicType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Activity_hasInternal_ControlLogicType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Activity_hasInternal_ControlLogicType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Activity_hasInternal_ControlLogicType.subclass:
            return Activity_hasInternal_ControlLogicType.subclass(*args_, **kwargs_)
        else:
            return Activity_hasInternal_ControlLogicType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType(self, value):
        result = True
        # Validate type validTypeType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AllenIntervalAlgebra', 'ConditionalControlLogic', 'ControlLogic', 'DeterministicImperative', 'NonDeterministicDeclarative', 'RuleBasedScheduling', 'Sequence', 'TemporalConstraints', 'TemporalControlConstruct']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Activity_hasInternal_ControlLogicType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Activity_hasInternal_ControlLogicType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Activity_hasInternal_ControlLogicType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType
            self.validate_validTypeType(self.validType[-1])
# end class Activity_hasInternal_ControlLogicType


class Activity_hasSubActivity_ActivityType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Activity_hasSubActivity_ActivityType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType1(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Activity_hasSubActivity_ActivityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Activity_hasSubActivity_ActivityType.subclass:
            return Activity_hasSubActivity_ActivityType.subclass(*args_, **kwargs_)
        else:
            return Activity_hasSubActivity_ActivityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType1(self, value):
        result = True
        # Validate type validTypeType1, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Activity', 'Step']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType1' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(Activity_hasSubActivity_ActivityType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Activity_hasSubActivity_ActivityType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Activity_hasSubActivity_ActivityType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType1
            self.validate_validTypeType1(self.validType)
# end class Activity_hasSubActivity_ActivityType


class Activity_has_StepType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Activity_has_StepType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Activity_has_StepType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Activity_has_StepType.subclass:
            return Activity_has_StepType.subclass(*args_, **kwargs_)
        else:
            return Activity_has_StepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType2(self, value):
        result = True
        # Validate type validTypeType2, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Step']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType2' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Activity_has_StepType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Activity_has_StepType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Activity_has_StepType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType2
            self.validate_validTypeType2(self.validType[-1])
# end class Activity_has_StepType


class AgentListing_isDefinedBy_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AgentListing_isDefinedBy_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentListing_isDefinedBy_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentListing_isDefinedBy_ConceptType.subclass:
            return AgentListing_isDefinedBy_ConceptType.subclass(*args_, **kwargs_)
        else:
            return AgentListing_isDefinedBy_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType3(self, value):
        result = True
        # Validate type validTypeType3, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType3' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(AgentListing_isDefinedBy_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentListing_isDefinedBy_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AgentListing_isDefinedBy_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType3
            self.validate_validTypeType3(self.validType[-1])
# end class AgentListing_isDefinedBy_ConceptType


class AgentListing_isMaintainedBy_AgentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AgentListing_isMaintainedBy_AgentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentListing_isMaintainedBy_AgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentListing_isMaintainedBy_AgentType.subclass:
            return AgentListing_isMaintainedBy_AgentType.subclass(*args_, **kwargs_)
        else:
            return AgentListing_isMaintainedBy_AgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType4(self, value):
        result = True
        # Validate type validTypeType4, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Agent', 'Curator', 'Individual', 'Machine', 'Organization', 'ProcessingAgent', 'Service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType4' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(AgentListing_isMaintainedBy_AgentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentListing_isMaintainedBy_AgentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AgentListing_isMaintainedBy_AgentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType4
            self.validate_validTypeType4(self.validType[-1])
# end class AgentListing_isMaintainedBy_AgentType


class AgentListing_has_AgentPositionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AgentListing_has_AgentPositionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType5(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentListing_has_AgentPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentListing_has_AgentPositionType.subclass:
            return AgentListing_has_AgentPositionType.subclass(*args_, **kwargs_)
        else:
            return AgentListing_has_AgentPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType5(self, value):
        result = True
        # Validate type validTypeType5, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AgentPosition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType5' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(AgentListing_has_AgentPositionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentListing_has_AgentPositionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AgentListing_has_AgentPositionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType5
            self.validate_validTypeType5(self.validType)
# end class AgentListing_has_AgentPositionType


class AgentListing_has_AgentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AgentListing_has_AgentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentListing_has_AgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentListing_has_AgentType.subclass:
            return AgentListing_has_AgentType.subclass(*args_, **kwargs_)
        else:
            return AgentListing_has_AgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType6(self, value):
        result = True
        # Validate type validTypeType6, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Agent', 'Curator', 'Individual', 'Machine', 'Organization', 'ProcessingAgent', 'Service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType6' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(AgentListing_has_AgentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentListing_has_AgentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AgentListing_has_AgentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType6
            self.validate_validTypeType6(self.validType[-1])
# end class AgentListing_has_AgentType


class AgentPosition_indexes_AgentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AgentPosition_indexes_AgentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentPosition_indexes_AgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentPosition_indexes_AgentType.subclass:
            return AgentPosition_indexes_AgentType.subclass(*args_, **kwargs_)
        else:
            return AgentPosition_indexes_AgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType7(self, value):
        result = True
        # Validate type validTypeType7, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Agent', 'Curator', 'Individual', 'Machine', 'Organization', 'ProcessingAgent', 'Service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType7' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(AgentPosition_indexes_AgentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentPosition_indexes_AgentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AgentPosition_indexes_AgentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType7
            self.validate_validTypeType7(self.validType[-1])
# end class AgentPosition_indexes_AgentType


class AgentRelationship_hasSource_AgentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AgentRelationship_hasSource_AgentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentRelationship_hasSource_AgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentRelationship_hasSource_AgentType.subclass:
            return AgentRelationship_hasSource_AgentType.subclass(*args_, **kwargs_)
        else:
            return AgentRelationship_hasSource_AgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType8(self, value):
        result = True
        # Validate type validTypeType8, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Agent', 'Curator', 'Individual', 'Machine', 'Organization', 'ProcessingAgent', 'Service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType8' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(AgentRelationship_hasSource_AgentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentRelationship_hasSource_AgentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AgentRelationship_hasSource_AgentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType8
            self.validate_validTypeType8(self.validType[-1])
# end class AgentRelationship_hasSource_AgentType


class AgentRelationship_hasTarget_AgentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AgentRelationship_hasTarget_AgentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentRelationship_hasTarget_AgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentRelationship_hasTarget_AgentType.subclass:
            return AgentRelationship_hasTarget_AgentType.subclass(*args_, **kwargs_)
        else:
            return AgentRelationship_hasTarget_AgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType9(self, value):
        result = True
        # Validate type validTypeType9, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Agent', 'Curator', 'Individual', 'Machine', 'Organization', 'ProcessingAgent', 'Service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType9' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(AgentRelationship_hasTarget_AgentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentRelationship_hasTarget_AgentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AgentRelationship_hasTarget_AgentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType9
            self.validate_validTypeType9(self.validType[-1])
# end class AgentRelationship_hasTarget_AgentType


class AgentStructure_structures_AgentListingType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AgentStructure_structures_AgentListingType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentStructure_structures_AgentListingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentStructure_structures_AgentListingType.subclass:
            return AgentStructure_structures_AgentListingType.subclass(*args_, **kwargs_)
        else:
            return AgentStructure_structures_AgentListingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType10(self, value):
        result = True
        # Validate type validTypeType10, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AgentListing']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType10' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(AgentStructure_structures_AgentListingType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentStructure_structures_AgentListingType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AgentStructure_structures_AgentListingType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType10
            self.validate_validTypeType10(self.validType[-1])
# end class AgentStructure_structures_AgentListingType


class AgentStructure_has_AgentRelationshipType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AgentStructure_has_AgentRelationshipType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType11(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentStructure_has_AgentRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentStructure_has_AgentRelationshipType.subclass:
            return AgentStructure_has_AgentRelationshipType.subclass(*args_, **kwargs_)
        else:
            return AgentStructure_has_AgentRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType11(self, value):
        result = True
        # Validate type validTypeType11, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AgentRelationship']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType11' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(AgentStructure_has_AgentRelationshipType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AgentStructure_has_AgentRelationshipType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AgentStructure_has_AgentRelationshipType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType11
            self.validate_validTypeType11(self.validType)
# end class AgentStructure_has_AgentRelationshipType


class AttributeComponent_qualifies_DataStructureComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AttributeComponent_qualifies_DataStructureComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeComponent_qualifies_DataStructureComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeComponent_qualifies_DataStructureComponentType.subclass:
            return AttributeComponent_qualifies_DataStructureComponentType.subclass(*args_, **kwargs_)
        else:
            return AttributeComponent_qualifies_DataStructureComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType12(self, value):
        result = True
        # Validate type validTypeType12, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AttributeComponent', 'ContextualComponent', 'DataStructure', 'DataStructureComponent', 'DimensionComponent', 'DimensionalDataStructure', 'IdentifierComponent', 'KeyValueStructure', 'LongDataStructure', 'MeasureComponent', 'QualifiedMeasure', 'SyntheticIdComponent', 'VariableDescriptorComponent', 'VariableValueComponent', 'WideDataStructure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType12' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(AttributeComponent_qualifies_DataStructureComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AttributeComponent_qualifies_DataStructureComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AttributeComponent_qualifies_DataStructureComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType12
            self.validate_validTypeType12(self.validType[-1])
# end class AttributeComponent_qualifies_DataStructureComponentType


class AuthorizationSource_has_AgentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AuthorizationSource_has_AgentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuthorizationSource_has_AgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuthorizationSource_has_AgentType.subclass:
            return AuthorizationSource_has_AgentType.subclass(*args_, **kwargs_)
        else:
            return AuthorizationSource_has_AgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType13(self, value):
        result = True
        # Validate type validTypeType13, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Agent', 'Curator', 'Individual', 'Machine', 'Organization', 'ProcessingAgent', 'Service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType13' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(AuthorizationSource_has_AgentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AuthorizationSource_has_AgentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AuthorizationSource_has_AgentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType13
            self.validate_validTypeType13(self.validType[-1])
# end class AuthorizationSource_has_AgentType


class CategoryPosition_indexes_CategoryType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CategoryPosition_indexes_CategoryType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryPosition_indexes_CategoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryPosition_indexes_CategoryType.subclass:
            return CategoryPosition_indexes_CategoryType.subclass(*args_, **kwargs_)
        else:
            return CategoryPosition_indexes_CategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType14(self, value):
        result = True
        # Validate type validTypeType14, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType14' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CategoryPosition_indexes_CategoryType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategoryPosition_indexes_CategoryType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CategoryPosition_indexes_CategoryType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType14
            self.validate_validTypeType14(self.validType[-1])
# end class CategoryPosition_indexes_CategoryType


class CategoryRelationStructure_structures_CategorySetType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CategoryRelationStructure_structures_CategorySetType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryRelationStructure_structures_CategorySetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryRelationStructure_structures_CategorySetType.subclass:
            return CategoryRelationStructure_structures_CategorySetType.subclass(*args_, **kwargs_)
        else:
            return CategoryRelationStructure_structures_CategorySetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType15(self, value):
        result = True
        # Validate type validTypeType15, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CategorySet']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType15' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CategoryRelationStructure_structures_CategorySetType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategoryRelationStructure_structures_CategorySetType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CategoryRelationStructure_structures_CategorySetType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType15
            self.validate_validTypeType15(self.validType[-1])
# end class CategoryRelationStructure_structures_CategorySetType


class CategoryRelationStructure_has_CategoryRelationshipType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CategoryRelationStructure_has_CategoryRelationshipType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType16(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryRelationStructure_has_CategoryRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryRelationStructure_has_CategoryRelationshipType.subclass:
            return CategoryRelationStructure_has_CategoryRelationshipType.subclass(*args_, **kwargs_)
        else:
            return CategoryRelationStructure_has_CategoryRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType16(self, value):
        result = True
        # Validate type validTypeType16, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CategoryRelationship']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType16' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(CategoryRelationStructure_has_CategoryRelationshipType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategoryRelationStructure_has_CategoryRelationshipType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CategoryRelationStructure_has_CategoryRelationshipType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType16
            self.validate_validTypeType16(self.validType)
# end class CategoryRelationStructure_has_CategoryRelationshipType


class CategoryRelationship_hasSource_CategoryType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CategoryRelationship_hasSource_CategoryType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryRelationship_hasSource_CategoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryRelationship_hasSource_CategoryType.subclass:
            return CategoryRelationship_hasSource_CategoryType.subclass(*args_, **kwargs_)
        else:
            return CategoryRelationship_hasSource_CategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType17(self, value):
        result = True
        # Validate type validTypeType17, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType17' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CategoryRelationship_hasSource_CategoryType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategoryRelationship_hasSource_CategoryType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CategoryRelationship_hasSource_CategoryType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType17
            self.validate_validTypeType17(self.validType[-1])
# end class CategoryRelationship_hasSource_CategoryType


class CategoryRelationship_hasTarget_CategoryType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CategoryRelationship_hasTarget_CategoryType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryRelationship_hasTarget_CategoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryRelationship_hasTarget_CategoryType.subclass:
            return CategoryRelationship_hasTarget_CategoryType.subclass(*args_, **kwargs_)
        else:
            return CategoryRelationship_hasTarget_CategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType18(self, value):
        result = True
        # Validate type validTypeType18, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType18' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CategoryRelationship_hasTarget_CategoryType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategoryRelationship_hasTarget_CategoryType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CategoryRelationship_hasTarget_CategoryType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType18
            self.validate_validTypeType18(self.validType[-1])
# end class CategoryRelationship_hasTarget_CategoryType


class CategorySet_has_CategoryType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CategorySet_has_CategoryType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategorySet_has_CategoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategorySet_has_CategoryType.subclass:
            return CategorySet_has_CategoryType.subclass(*args_, **kwargs_)
        else:
            return CategorySet_has_CategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType19(self, value):
        result = True
        # Validate type validTypeType19, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType19' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CategorySet_has_CategoryType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategorySet_has_CategoryType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CategorySet_has_CategoryType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType19
            self.validate_validTypeType19(self.validType[-1])
# end class CategorySet_has_CategoryType


class CategorySet_has_CategoryPositionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CategorySet_has_CategoryPositionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType20(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategorySet_has_CategoryPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategorySet_has_CategoryPositionType.subclass:
            return CategorySet_has_CategoryPositionType.subclass(*args_, **kwargs_)
        else:
            return CategorySet_has_CategoryPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType20(self, value):
        result = True
        # Validate type validTypeType20, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CategoryPosition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType20' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(CategorySet_has_CategoryPositionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategorySet_has_CategoryPositionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CategorySet_has_CategoryPositionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType20
            self.validate_validTypeType20(self.validType)
# end class CategorySet_has_CategoryPositionType


class CategoryStatistic_appliesTo_InstanceVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CategoryStatistic_appliesTo_InstanceVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryStatistic_appliesTo_InstanceVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryStatistic_appliesTo_InstanceVariableType.subclass:
            return CategoryStatistic_appliesTo_InstanceVariableType.subclass(*args_, **kwargs_)
        else:
            return CategoryStatistic_appliesTo_InstanceVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType21(self, value):
        result = True
        # Validate type validTypeType21, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['InstanceVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType21' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CategoryStatistic_appliesTo_InstanceVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategoryStatistic_appliesTo_InstanceVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CategoryStatistic_appliesTo_InstanceVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType21
            self.validate_validTypeType21(self.validType[-1])
# end class CategoryStatistic_appliesTo_InstanceVariableType


class CategoryStatistic_for_CategoryType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CategoryStatistic_for_CategoryType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoryStatistic_for_CategoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoryStatistic_for_CategoryType.subclass:
            return CategoryStatistic_for_CategoryType.subclass(*args_, **kwargs_)
        else:
            return CategoryStatistic_for_CategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType22(self, value):
        result = True
        # Validate type validTypeType22, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType22' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CategoryStatistic_for_CategoryType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategoryStatistic_for_CategoryType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CategoryStatistic_for_CategoryType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType22
            self.validate_validTypeType22(self.validType[-1])
# end class CategoryStatistic_for_CategoryType


class ClassificationFamily_uses_ClassificationIndexType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationFamily_uses_ClassificationIndexType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationFamily_uses_ClassificationIndexType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationFamily_uses_ClassificationIndexType.subclass:
            return ClassificationFamily_uses_ClassificationIndexType.subclass(*args_, **kwargs_)
        else:
            return ClassificationFamily_uses_ClassificationIndexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType23(self, value):
        result = True
        # Validate type validTypeType23, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationIndex']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType23' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationFamily_uses_ClassificationIndexType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationFamily_uses_ClassificationIndexType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationFamily_uses_ClassificationIndexType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType23
            self.validate_validTypeType23(self.validType[-1])
# end class ClassificationFamily_uses_ClassificationIndexType


class ClassificationFamily_isDefinedBy_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationFamily_isDefinedBy_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationFamily_isDefinedBy_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationFamily_isDefinedBy_ConceptType.subclass:
            return ClassificationFamily_isDefinedBy_ConceptType.subclass(*args_, **kwargs_)
        else:
            return ClassificationFamily_isDefinedBy_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType24(self, value):
        result = True
        # Validate type validTypeType24, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType24' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationFamily_isDefinedBy_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationFamily_isDefinedBy_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationFamily_isDefinedBy_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType24
            self.validate_validTypeType24(self.validType[-1])
# end class ClassificationFamily_isDefinedBy_ConceptType


class ClassificationFamily_groups_ClassificationSeriesType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationFamily_groups_ClassificationSeriesType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType25(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationFamily_groups_ClassificationSeriesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationFamily_groups_ClassificationSeriesType.subclass:
            return ClassificationFamily_groups_ClassificationSeriesType.subclass(*args_, **kwargs_)
        else:
            return ClassificationFamily_groups_ClassificationSeriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType25(self, value):
        result = True
        # Validate type validTypeType25, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType25' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ClassificationFamily_groups_ClassificationSeriesType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationFamily_groups_ClassificationSeriesType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationFamily_groups_ClassificationSeriesType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType25
            self.validate_validTypeType25(self.validType)
# end class ClassificationFamily_groups_ClassificationSeriesType


class ClassificationIndex_isMaintainedBy_AgentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationIndex_isMaintainedBy_AgentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationIndex_isMaintainedBy_AgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationIndex_isMaintainedBy_AgentType.subclass:
            return ClassificationIndex_isMaintainedBy_AgentType.subclass(*args_, **kwargs_)
        else:
            return ClassificationIndex_isMaintainedBy_AgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType26(self, value):
        result = True
        # Validate type validTypeType26, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Agent', 'Curator', 'Individual', 'Machine', 'Organization', 'ProcessingAgent', 'Service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType26' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationIndex_isMaintainedBy_AgentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationIndex_isMaintainedBy_AgentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationIndex_isMaintainedBy_AgentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType26
            self.validate_validTypeType26(self.validType[-1])
# end class ClassificationIndex_isMaintainedBy_AgentType


class ClassificationIndex_hasContact_AgentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationIndex_hasContact_AgentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationIndex_hasContact_AgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationIndex_hasContact_AgentType.subclass:
            return ClassificationIndex_hasContact_AgentType.subclass(*args_, **kwargs_)
        else:
            return ClassificationIndex_hasContact_AgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType27(self, value):
        result = True
        # Validate type validTypeType27, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Agent', 'Curator', 'Individual', 'Machine', 'Organization', 'ProcessingAgent', 'Service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType27' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationIndex_hasContact_AgentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationIndex_hasContact_AgentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationIndex_hasContact_AgentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType27
            self.validate_validTypeType27(self.validType[-1])
# end class ClassificationIndex_hasContact_AgentType


class ClassificationIndex_isDefinedBy_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationIndex_isDefinedBy_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationIndex_isDefinedBy_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationIndex_isDefinedBy_ConceptType.subclass:
            return ClassificationIndex_isDefinedBy_ConceptType.subclass(*args_, **kwargs_)
        else:
            return ClassificationIndex_isDefinedBy_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType28(self, value):
        result = True
        # Validate type validTypeType28, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType28' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationIndex_isDefinedBy_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationIndex_isDefinedBy_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationIndex_isDefinedBy_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType28
            self.validate_validTypeType28(self.validType[-1])
# end class ClassificationIndex_isDefinedBy_ConceptType


class ClassificationIndex_has_ClassificationIndexEntryPositionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationIndex_has_ClassificationIndexEntryPositionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType29(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationIndex_has_ClassificationIndexEntryPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationIndex_has_ClassificationIndexEntryPositionType.subclass:
            return ClassificationIndex_has_ClassificationIndexEntryPositionType.subclass(*args_, **kwargs_)
        else:
            return ClassificationIndex_has_ClassificationIndexEntryPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType29(self, value):
        result = True
        # Validate type validTypeType29, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationIndexEntryPosition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType29' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ClassificationIndex_has_ClassificationIndexEntryPositionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationIndex_has_ClassificationIndexEntryPositionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationIndex_has_ClassificationIndexEntryPositionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType29
            self.validate_validTypeType29(self.validType)
# end class ClassificationIndex_has_ClassificationIndexEntryPositionType


class ClassificationIndex_has_ClassificationIndexEntryType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationIndex_has_ClassificationIndexEntryType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationIndex_has_ClassificationIndexEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationIndex_has_ClassificationIndexEntryType.subclass:
            return ClassificationIndex_has_ClassificationIndexEntryType.subclass(*args_, **kwargs_)
        else:
            return ClassificationIndex_has_ClassificationIndexEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType30(self, value):
        result = True
        # Validate type validTypeType30, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationIndexEntry']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType30' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationIndex_has_ClassificationIndexEntryType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationIndex_has_ClassificationIndexEntryType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationIndex_has_ClassificationIndexEntryType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType30
            self.validate_validTypeType30(self.validType[-1])
# end class ClassificationIndex_has_ClassificationIndexEntryType


class ClassificationIndexEntryPosition_indexes_ClassificationIndexEntryType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationIndexEntryPosition_indexes_ClassificationIndexEntryType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationIndexEntryPosition_indexes_ClassificationIndexEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationIndexEntryPosition_indexes_ClassificationIndexEntryType.subclass:
            return ClassificationIndexEntryPosition_indexes_ClassificationIndexEntryType.subclass(*args_, **kwargs_)
        else:
            return ClassificationIndexEntryPosition_indexes_ClassificationIndexEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType31(self, value):
        result = True
        # Validate type validTypeType31, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationIndexEntry']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType31' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationIndexEntryPosition_indexes_ClassificationIndexEntryType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationIndexEntryPosition_indexes_ClassificationIndexEntryType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationIndexEntryPosition_indexes_ClassificationIndexEntryType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType31
            self.validate_validTypeType31(self.validType[-1])
# end class ClassificationIndexEntryPosition_indexes_ClassificationIndexEntryType


class ClassificationItem_excludes_ClassificationItemType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationItem_excludes_ClassificationItemType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationItem_excludes_ClassificationItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationItem_excludes_ClassificationItemType.subclass:
            return ClassificationItem_excludes_ClassificationItemType.subclass(*args_, **kwargs_)
        else:
            return ClassificationItem_excludes_ClassificationItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType32(self, value):
        result = True
        # Validate type validTypeType32, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationItem']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationItem_excludes_ClassificationItemType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationItem_excludes_ClassificationItemType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationItem_excludes_ClassificationItemType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType32
            self.validate_validTypeType32(self.validType[-1])
# end class ClassificationItem_excludes_ClassificationItemType


class ClassificationItem_denotes_CategoryType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationItem_denotes_CategoryType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationItem_denotes_CategoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationItem_denotes_CategoryType.subclass:
            return ClassificationItem_denotes_CategoryType.subclass(*args_, **kwargs_)
        else:
            return ClassificationItem_denotes_CategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType33(self, value):
        result = True
        # Validate type validTypeType33, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType33' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationItem_denotes_CategoryType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationItem_denotes_CategoryType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationItem_denotes_CategoryType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType33
            self.validate_validTypeType33(self.validType[-1])
# end class ClassificationItem_denotes_CategoryType


class ClassificationItem_uses_NotationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationItem_uses_NotationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationItem_uses_NotationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationItem_uses_NotationType.subclass:
            return ClassificationItem_uses_NotationType.subclass(*args_, **kwargs_)
        else:
            return ClassificationItem_uses_NotationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType34(self, value):
        result = True
        # Validate type validTypeType34, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Notation']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType34' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationItem_uses_NotationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationItem_uses_NotationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationItem_uses_NotationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType34
            self.validate_validTypeType34(self.validType[-1])
# end class ClassificationItem_uses_NotationType


class ClassificationItem_hasRulingBy_AuthorizationSourceType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationItem_hasRulingBy_AuthorizationSourceType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationItem_hasRulingBy_AuthorizationSourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationItem_hasRulingBy_AuthorizationSourceType.subclass:
            return ClassificationItem_hasRulingBy_AuthorizationSourceType.subclass(*args_, **kwargs_)
        else:
            return ClassificationItem_hasRulingBy_AuthorizationSourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType35(self, value):
        result = True
        # Validate type validTypeType35, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AuthorizationSource']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType35' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationItem_hasRulingBy_AuthorizationSourceType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationItem_hasRulingBy_AuthorizationSourceType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationItem_hasRulingBy_AuthorizationSourceType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType35
            self.validate_validTypeType35(self.validType[-1])
# end class ClassificationItem_hasRulingBy_AuthorizationSourceType


class ClassificationItemPosition_indexes_ClassificationItemType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationItemPosition_indexes_ClassificationItemType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationItemPosition_indexes_ClassificationItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationItemPosition_indexes_ClassificationItemType.subclass:
            return ClassificationItemPosition_indexes_ClassificationItemType.subclass(*args_, **kwargs_)
        else:
            return ClassificationItemPosition_indexes_ClassificationItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType36(self, value):
        result = True
        # Validate type validTypeType36, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationItem']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType36' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationItemPosition_indexes_ClassificationItemType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationItemPosition_indexes_ClassificationItemType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationItemPosition_indexes_ClassificationItemType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType36
            self.validate_validTypeType36(self.validType[-1])
# end class ClassificationItemPosition_indexes_ClassificationItemType


class ClassificationItemRelationship_hasSource_ClassificationItemType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationItemRelationship_hasSource_ClassificationItemType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationItemRelationship_hasSource_ClassificationItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationItemRelationship_hasSource_ClassificationItemType.subclass:
            return ClassificationItemRelationship_hasSource_ClassificationItemType.subclass(*args_, **kwargs_)
        else:
            return ClassificationItemRelationship_hasSource_ClassificationItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType37(self, value):
        result = True
        # Validate type validTypeType37, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationItem']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType37' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationItemRelationship_hasSource_ClassificationItemType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationItemRelationship_hasSource_ClassificationItemType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationItemRelationship_hasSource_ClassificationItemType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType37
            self.validate_validTypeType37(self.validType[-1])
# end class ClassificationItemRelationship_hasSource_ClassificationItemType


class ClassificationItemRelationship_hasTarget_ClassificationItemType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationItemRelationship_hasTarget_ClassificationItemType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationItemRelationship_hasTarget_ClassificationItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationItemRelationship_hasTarget_ClassificationItemType.subclass:
            return ClassificationItemRelationship_hasTarget_ClassificationItemType.subclass(*args_, **kwargs_)
        else:
            return ClassificationItemRelationship_hasTarget_ClassificationItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType38(self, value):
        result = True
        # Validate type validTypeType38, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationItem']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType38' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationItemRelationship_hasTarget_ClassificationItemType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationItemRelationship_hasTarget_ClassificationItemType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationItemRelationship_hasTarget_ClassificationItemType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType38
            self.validate_validTypeType38(self.validType[-1])
# end class ClassificationItemRelationship_hasTarget_ClassificationItemType


class ClassificationItemStructure_structures_StatisticalClassificationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationItemStructure_structures_StatisticalClassificationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationItemStructure_structures_StatisticalClassificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationItemStructure_structures_StatisticalClassificationType.subclass:
            return ClassificationItemStructure_structures_StatisticalClassificationType.subclass(*args_, **kwargs_)
        else:
            return ClassificationItemStructure_structures_StatisticalClassificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType39(self, value):
        result = True
        # Validate type validTypeType39, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['StatisticalClassification']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType39' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationItemStructure_structures_StatisticalClassificationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationItemStructure_structures_StatisticalClassificationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationItemStructure_structures_StatisticalClassificationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType39
            self.validate_validTypeType39(self.validType[-1])
# end class ClassificationItemStructure_structures_StatisticalClassificationType


class ClassificationItemStructure_has_ClassificationItemRelationshipType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationItemStructure_has_ClassificationItemRelationshipType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType40(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationItemStructure_has_ClassificationItemRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationItemStructure_has_ClassificationItemRelationshipType.subclass:
            return ClassificationItemStructure_has_ClassificationItemRelationshipType.subclass(*args_, **kwargs_)
        else:
            return ClassificationItemStructure_has_ClassificationItemRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType40(self, value):
        result = True
        # Validate type validTypeType40, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationItemRelationship']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType40' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ClassificationItemStructure_has_ClassificationItemRelationshipType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationItemStructure_has_ClassificationItemRelationshipType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationItemStructure_has_ClassificationItemRelationshipType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType40
            self.validate_validTypeType40(self.validType)
# end class ClassificationItemStructure_has_ClassificationItemRelationshipType


class ClassificationPosition_indexes_StatisticalClassificationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationPosition_indexes_StatisticalClassificationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationPosition_indexes_StatisticalClassificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationPosition_indexes_StatisticalClassificationType.subclass:
            return ClassificationPosition_indexes_StatisticalClassificationType.subclass(*args_, **kwargs_)
        else:
            return ClassificationPosition_indexes_StatisticalClassificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType41(self, value):
        result = True
        # Validate type validTypeType41, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['StatisticalClassification']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType41' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationPosition_indexes_StatisticalClassificationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationPosition_indexes_StatisticalClassificationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationPosition_indexes_StatisticalClassificationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType41
            self.validate_validTypeType41(self.validType[-1])
# end class ClassificationPosition_indexes_StatisticalClassificationType


class ClassificationSeries_isOwnedBy_AgentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationSeries_isOwnedBy_AgentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationSeries_isOwnedBy_AgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationSeries_isOwnedBy_AgentType.subclass:
            return ClassificationSeries_isOwnedBy_AgentType.subclass(*args_, **kwargs_)
        else:
            return ClassificationSeries_isOwnedBy_AgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType42(self, value):
        result = True
        # Validate type validTypeType42, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Agent', 'Curator', 'Individual', 'Machine', 'Organization', 'ProcessingAgent', 'Service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType42' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationSeries_isOwnedBy_AgentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationSeries_isOwnedBy_AgentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationSeries_isOwnedBy_AgentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType42
            self.validate_validTypeType42(self.validType[-1])
# end class ClassificationSeries_isOwnedBy_AgentType


class ClassificationSeries_isDefinedBy_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationSeries_isDefinedBy_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationSeries_isDefinedBy_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationSeries_isDefinedBy_ConceptType.subclass:
            return ClassificationSeries_isDefinedBy_ConceptType.subclass(*args_, **kwargs_)
        else:
            return ClassificationSeries_isDefinedBy_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType43(self, value):
        result = True
        # Validate type validTypeType43, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType43' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationSeries_isDefinedBy_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationSeries_isDefinedBy_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationSeries_isDefinedBy_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType43
            self.validate_validTypeType43(self.validType[-1])
# end class ClassificationSeries_isDefinedBy_ConceptType


class ClassificationSeries_has_StatisticalClassificationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationSeries_has_StatisticalClassificationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType44(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationSeries_has_StatisticalClassificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationSeries_has_StatisticalClassificationType.subclass:
            return ClassificationSeries_has_StatisticalClassificationType.subclass(*args_, **kwargs_)
        else:
            return ClassificationSeries_has_StatisticalClassificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType44(self, value):
        result = True
        # Validate type validTypeType44, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['StatisticalClassification']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType44' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ClassificationSeries_has_StatisticalClassificationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationSeries_has_StatisticalClassificationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationSeries_has_StatisticalClassificationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType44
            self.validate_validTypeType44(self.validType)
# end class ClassificationSeries_has_StatisticalClassificationType


class ClassificationSeries_has_ClassificationPositionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationSeries_has_ClassificationPositionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType45(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationSeries_has_ClassificationPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationSeries_has_ClassificationPositionType.subclass:
            return ClassificationSeries_has_ClassificationPositionType.subclass(*args_, **kwargs_)
        else:
            return ClassificationSeries_has_ClassificationPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType45(self, value):
        result = True
        # Validate type validTypeType45, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationPosition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType45' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ClassificationSeries_has_ClassificationPositionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationSeries_has_ClassificationPositionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationSeries_has_ClassificationPositionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType45
            self.validate_validTypeType45(self.validType)
# end class ClassificationSeries_has_ClassificationPositionType


class ClassificationSeriesStructure_structures_ClassificationSeriesType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationSeriesStructure_structures_ClassificationSeriesType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationSeriesStructure_structures_ClassificationSeriesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationSeriesStructure_structures_ClassificationSeriesType.subclass:
            return ClassificationSeriesStructure_structures_ClassificationSeriesType.subclass(*args_, **kwargs_)
        else:
            return ClassificationSeriesStructure_structures_ClassificationSeriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType46(self, value):
        result = True
        # Validate type validTypeType46, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType46' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ClassificationSeriesStructure_structures_ClassificationSeriesType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationSeriesStructure_structures_ClassificationSeriesType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationSeriesStructure_structures_ClassificationSeriesType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType46
            self.validate_validTypeType46(self.validType[-1])
# end class ClassificationSeriesStructure_structures_ClassificationSeriesType


class ClassificationSeriesStructure_has_StatisticalClassificationRelationshipType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ClassificationSeriesStructure_has_StatisticalClassificationRelationshipType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType47(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassificationSeriesStructure_has_StatisticalClassificationRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassificationSeriesStructure_has_StatisticalClassificationRelationshipType.subclass:
            return ClassificationSeriesStructure_has_StatisticalClassificationRelationshipType.subclass(*args_, **kwargs_)
        else:
            return ClassificationSeriesStructure_has_StatisticalClassificationRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType47(self, value):
        result = True
        # Validate type validTypeType47, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['StatisticalClassificationRelationship']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType47' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ClassificationSeriesStructure_has_StatisticalClassificationRelationshipType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ClassificationSeriesStructure_has_StatisticalClassificationRelationshipType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ClassificationSeriesStructure_has_StatisticalClassificationRelationshipType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType47
            self.validate_validTypeType47(self.validType)
# end class ClassificationSeriesStructure_has_StatisticalClassificationRelationshipType


class Code_denotes_CategoryType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Code_denotes_CategoryType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Code_denotes_CategoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Code_denotes_CategoryType.subclass:
            return Code_denotes_CategoryType.subclass(*args_, **kwargs_)
        else:
            return Code_denotes_CategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType48(self, value):
        result = True
        # Validate type validTypeType48, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType48' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Code_denotes_CategoryType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Code_denotes_CategoryType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Code_denotes_CategoryType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType48
            self.validate_validTypeType48(self.validType[-1])
# end class Code_denotes_CategoryType


class Code_uses_NotationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Code_uses_NotationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Code_uses_NotationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Code_uses_NotationType.subclass:
            return Code_uses_NotationType.subclass(*args_, **kwargs_)
        else:
            return Code_uses_NotationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType49(self, value):
        result = True
        # Validate type validTypeType49, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Notation']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType49' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Code_uses_NotationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Code_uses_NotationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Code_uses_NotationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType49
            self.validate_validTypeType49(self.validType[-1])
# end class Code_uses_NotationType


class CodeList_has_CodePositionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CodeList_has_CodePositionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType50(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeList_has_CodePositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeList_has_CodePositionType.subclass:
            return CodeList_has_CodePositionType.subclass(*args_, **kwargs_)
        else:
            return CodeList_has_CodePositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType50(self, value):
        result = True
        # Validate type validTypeType50, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CodePosition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType50' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(CodeList_has_CodePositionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CodeList_has_CodePositionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CodeList_has_CodePositionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType50
            self.validate_validTypeType50(self.validType)
# end class CodeList_has_CodePositionType


class CodeList_has_CodeType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CodeList_has_CodeType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeList_has_CodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeList_has_CodeType.subclass:
            return CodeList_has_CodeType.subclass(*args_, **kwargs_)
        else:
            return CodeList_has_CodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType51(self, value):
        result = True
        # Validate type validTypeType51, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Code']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType51' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CodeList_has_CodeType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CodeList_has_CodeType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CodeList_has_CodeType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType51
            self.validate_validTypeType51(self.validType[-1])
# end class CodeList_has_CodeType


class CodeListStructure_structures_CodeListType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CodeListStructure_structures_CodeListType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType52(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeListStructure_structures_CodeListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeListStructure_structures_CodeListType.subclass:
            return CodeListStructure_structures_CodeListType.subclass(*args_, **kwargs_)
        else:
            return CodeListStructure_structures_CodeListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType52(self, value):
        result = True
        # Validate type validTypeType52, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CodeList']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType52' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(CodeListStructure_structures_CodeListType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CodeListStructure_structures_CodeListType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CodeListStructure_structures_CodeListType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType52
            self.validate_validTypeType52(self.validType)
# end class CodeListStructure_structures_CodeListType


class CodeListStructure_has_CodeRelationshipType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CodeListStructure_has_CodeRelationshipType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType53(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeListStructure_has_CodeRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeListStructure_has_CodeRelationshipType.subclass:
            return CodeListStructure_has_CodeRelationshipType.subclass(*args_, **kwargs_)
        else:
            return CodeListStructure_has_CodeRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType53(self, value):
        result = True
        # Validate type validTypeType53, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CodeRelationship']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType53' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(CodeListStructure_has_CodeRelationshipType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CodeListStructure_has_CodeRelationshipType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CodeListStructure_has_CodeRelationshipType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType53
            self.validate_validTypeType53(self.validType)
# end class CodeListStructure_has_CodeRelationshipType


class CodePosition_indexes_CodeType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CodePosition_indexes_CodeType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodePosition_indexes_CodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodePosition_indexes_CodeType.subclass:
            return CodePosition_indexes_CodeType.subclass(*args_, **kwargs_)
        else:
            return CodePosition_indexes_CodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType54(self, value):
        result = True
        # Validate type validTypeType54, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Code']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType54' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CodePosition_indexes_CodeType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CodePosition_indexes_CodeType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CodePosition_indexes_CodeType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType54
            self.validate_validTypeType54(self.validType[-1])
# end class CodePosition_indexes_CodeType


class CodeRelationship_hasTarget_CodeType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CodeRelationship_hasTarget_CodeType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeRelationship_hasTarget_CodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeRelationship_hasTarget_CodeType.subclass:
            return CodeRelationship_hasTarget_CodeType.subclass(*args_, **kwargs_)
        else:
            return CodeRelationship_hasTarget_CodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType55(self, value):
        result = True
        # Validate type validTypeType55, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Code']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType55' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CodeRelationship_hasTarget_CodeType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CodeRelationship_hasTarget_CodeType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CodeRelationship_hasTarget_CodeType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType55
            self.validate_validTypeType55(self.validType[-1])
# end class CodeRelationship_hasTarget_CodeType


class CodeRelationship_hasSource_CodeType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CodeRelationship_hasSource_CodeType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeRelationship_hasSource_CodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeRelationship_hasSource_CodeType.subclass:
            return CodeRelationship_hasSource_CodeType.subclass(*args_, **kwargs_)
        else:
            return CodeRelationship_hasSource_CodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType56(self, value):
        result = True
        # Validate type validTypeType56, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Code']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType56' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CodeRelationship_hasSource_CodeType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CodeRelationship_hasSource_CodeType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CodeRelationship_hasSource_CodeType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType56
            self.validate_validTypeType56(self.validType[-1])
# end class CodeRelationship_hasSource_CodeType


class ComponentPosition_indexes_DataStructureComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ComponentPosition_indexes_DataStructureComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComponentPosition_indexes_DataStructureComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComponentPosition_indexes_DataStructureComponentType.subclass:
            return ComponentPosition_indexes_DataStructureComponentType.subclass(*args_, **kwargs_)
        else:
            return ComponentPosition_indexes_DataStructureComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType57(self, value):
        result = True
        # Validate type validTypeType57, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AttributeComponent', 'ContextualComponent', 'DataStructure', 'DataStructureComponent', 'DimensionComponent', 'DimensionalDataStructure', 'IdentifierComponent', 'KeyValueStructure', 'LongDataStructure', 'MeasureComponent', 'QualifiedMeasure', 'SyntheticIdComponent', 'VariableDescriptorComponent', 'VariableValueComponent', 'WideDataStructure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType57' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ComponentPosition_indexes_DataStructureComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ComponentPosition_indexes_DataStructureComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ComponentPosition_indexes_DataStructureComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType57
            self.validate_validTypeType57(self.validType[-1])
# end class ComponentPosition_indexes_DataStructureComponentType


class Concept_uses_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Concept_uses_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Concept_uses_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Concept_uses_ConceptType.subclass:
            return Concept_uses_ConceptType.subclass(*args_, **kwargs_)
        else:
            return Concept_uses_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType58(self, value):
        result = True
        # Validate type validTypeType58, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType58' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Concept_uses_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Concept_uses_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Concept_uses_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType58
            self.validate_validTypeType58(self.validType[-1])
# end class Concept_uses_ConceptType


class ConceptMap_hasSource_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptMap_hasSource_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptMap_hasSource_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptMap_hasSource_ConceptType.subclass:
            return ConceptMap_hasSource_ConceptType.subclass(*args_, **kwargs_)
        else:
            return ConceptMap_hasSource_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType59(self, value):
        result = True
        # Validate type validTypeType59, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType59' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptMap_hasSource_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptMap_hasSource_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptMap_hasSource_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType59
            self.validate_validTypeType59(self.validType[-1])
# end class ConceptMap_hasSource_ConceptType


class ConceptMap_hasTarget_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptMap_hasTarget_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptMap_hasTarget_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptMap_hasTarget_ConceptType.subclass:
            return ConceptMap_hasTarget_ConceptType.subclass(*args_, **kwargs_)
        else:
            return ConceptMap_hasTarget_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType60(self, value):
        result = True
        # Validate type validTypeType60, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType60' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptMap_hasTarget_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptMap_hasTarget_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptMap_hasTarget_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType60
            self.validate_validTypeType60(self.validType[-1])
# end class ConceptMap_hasTarget_ConceptType


class ConceptRelationship_hasSource_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptRelationship_hasSource_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptRelationship_hasSource_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptRelationship_hasSource_ConceptType.subclass:
            return ConceptRelationship_hasSource_ConceptType.subclass(*args_, **kwargs_)
        else:
            return ConceptRelationship_hasSource_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType61(self, value):
        result = True
        # Validate type validTypeType61, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType61' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptRelationship_hasSource_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptRelationship_hasSource_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptRelationship_hasSource_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType61
            self.validate_validTypeType61(self.validType[-1])
# end class ConceptRelationship_hasSource_ConceptType


class ConceptRelationship_hasTarget_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptRelationship_hasTarget_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptRelationship_hasTarget_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptRelationship_hasTarget_ConceptType.subclass:
            return ConceptRelationship_hasTarget_ConceptType.subclass(*args_, **kwargs_)
        else:
            return ConceptRelationship_hasTarget_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType62(self, value):
        result = True
        # Validate type validTypeType62, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType62' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptRelationship_hasTarget_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptRelationship_hasTarget_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptRelationship_hasTarget_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType62
            self.validate_validTypeType62(self.validType[-1])
# end class ConceptRelationship_hasTarget_ConceptType


class ConceptStructure_structures_ConceptSystemType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptStructure_structures_ConceptSystemType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptStructure_structures_ConceptSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptStructure_structures_ConceptSystemType.subclass:
            return ConceptStructure_structures_ConceptSystemType.subclass(*args_, **kwargs_)
        else:
            return ConceptStructure_structures_ConceptSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType63(self, value):
        result = True
        # Validate type validTypeType63, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CategorySet', 'ConceptSystem']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType63' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptStructure_structures_ConceptSystemType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptStructure_structures_ConceptSystemType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptStructure_structures_ConceptSystemType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType63
            self.validate_validTypeType63(self.validType[-1])
# end class ConceptStructure_structures_ConceptSystemType


class ConceptStructure_has_ConceptRelationshipType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptStructure_has_ConceptRelationshipType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType64(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptStructure_has_ConceptRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptStructure_has_ConceptRelationshipType.subclass:
            return ConceptStructure_has_ConceptRelationshipType.subclass(*args_, **kwargs_)
        else:
            return ConceptStructure_has_ConceptRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType64(self, value):
        result = True
        # Validate type validTypeType64, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ConceptRelationship']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType64' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ConceptStructure_has_ConceptRelationshipType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptStructure_has_ConceptRelationshipType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptStructure_has_ConceptRelationshipType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType64
            self.validate_validTypeType64(self.validType)
# end class ConceptStructure_has_ConceptRelationshipType


class ConceptSystem_isDefinedBy_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptSystem_isDefinedBy_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptSystem_isDefinedBy_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptSystem_isDefinedBy_ConceptType.subclass:
            return ConceptSystem_isDefinedBy_ConceptType.subclass(*args_, **kwargs_)
        else:
            return ConceptSystem_isDefinedBy_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType65(self, value):
        result = True
        # Validate type validTypeType65, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType65' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptSystem_isDefinedBy_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptSystem_isDefinedBy_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptSystem_isDefinedBy_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType65
            self.validate_validTypeType65(self.validType[-1])
# end class ConceptSystem_isDefinedBy_ConceptType


class ConceptSystem_has_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptSystem_has_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptSystem_has_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptSystem_has_ConceptType.subclass:
            return ConceptSystem_has_ConceptType.subclass(*args_, **kwargs_)
        else:
            return ConceptSystem_has_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType66(self, value):
        result = True
        # Validate type validTypeType66, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType66' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptSystem_has_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptSystem_has_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptSystem_has_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType66
            self.validate_validTypeType66(self.validType[-1])
# end class ConceptSystem_has_ConceptType


class ConceptSystemCorrespondence_maps_ConceptSystemType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptSystemCorrespondence_maps_ConceptSystemType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptSystemCorrespondence_maps_ConceptSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptSystemCorrespondence_maps_ConceptSystemType.subclass:
            return ConceptSystemCorrespondence_maps_ConceptSystemType.subclass(*args_, **kwargs_)
        else:
            return ConceptSystemCorrespondence_maps_ConceptSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType67(self, value):
        result = True
        # Validate type validTypeType67, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CategorySet', 'ConceptSystem']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType67' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptSystemCorrespondence_maps_ConceptSystemType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptSystemCorrespondence_maps_ConceptSystemType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptSystemCorrespondence_maps_ConceptSystemType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType67
            self.validate_validTypeType67(self.validType[-1])
# end class ConceptSystemCorrespondence_maps_ConceptSystemType


class ConceptSystemCorrespondence_has_ConceptMapType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptSystemCorrespondence_has_ConceptMapType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType68(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptSystemCorrespondence_has_ConceptMapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptSystemCorrespondence_has_ConceptMapType.subclass:
            return ConceptSystemCorrespondence_has_ConceptMapType.subclass(*args_, **kwargs_)
        else:
            return ConceptSystemCorrespondence_has_ConceptMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType68(self, value):
        result = True
        # Validate type validTypeType68, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ConceptMap']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType68' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ConceptSystemCorrespondence_has_ConceptMapType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptSystemCorrespondence_has_ConceptMapType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptSystemCorrespondence_has_ConceptMapType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType68
            self.validate_validTypeType68(self.validType)
# end class ConceptSystemCorrespondence_has_ConceptMapType


class ConceptualDomain_isDescribedBy_ValueAndConceptDescriptionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptualDomain_isDescribedBy_ValueAndConceptDescriptionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptualDomain_isDescribedBy_ValueAndConceptDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptualDomain_isDescribedBy_ValueAndConceptDescriptionType.subclass:
            return ConceptualDomain_isDescribedBy_ValueAndConceptDescriptionType.subclass(*args_, **kwargs_)
        else:
            return ConceptualDomain_isDescribedBy_ValueAndConceptDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType69(self, value):
        result = True
        # Validate type validTypeType69, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ValueAndConceptDescription']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType69' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptualDomain_isDescribedBy_ValueAndConceptDescriptionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptualDomain_isDescribedBy_ValueAndConceptDescriptionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptualDomain_isDescribedBy_ValueAndConceptDescriptionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType69
            self.validate_validTypeType69(self.validType[-1])
# end class ConceptualDomain_isDescribedBy_ValueAndConceptDescriptionType


class ConceptualDomain_takesConceptsFrom_ConceptSystemType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptualDomain_takesConceptsFrom_ConceptSystemType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptualDomain_takesConceptsFrom_ConceptSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptualDomain_takesConceptsFrom_ConceptSystemType.subclass:
            return ConceptualDomain_takesConceptsFrom_ConceptSystemType.subclass(*args_, **kwargs_)
        else:
            return ConceptualDomain_takesConceptsFrom_ConceptSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType70(self, value):
        result = True
        # Validate type validTypeType70, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CategorySet', 'ConceptSystem']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType70' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptualDomain_takesConceptsFrom_ConceptSystemType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptualDomain_takesConceptsFrom_ConceptSystemType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptualDomain_takesConceptsFrom_ConceptSystemType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType70
            self.validate_validTypeType70(self.validType[-1])
# end class ConceptualDomain_takesConceptsFrom_ConceptSystemType


class ConceptualValue_hasConceptFrom_ConceptualDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptualValue_hasConceptFrom_ConceptualDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptualValue_hasConceptFrom_ConceptualDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptualValue_hasConceptFrom_ConceptualDomainType.subclass:
            return ConceptualValue_hasConceptFrom_ConceptualDomainType.subclass(*args_, **kwargs_)
        else:
            return ConceptualValue_hasConceptFrom_ConceptualDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType71(self, value):
        result = True
        # Validate type validTypeType71, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ConceptualDomain', 'SentinelConceptualDomain', 'SubstantiveConceptualDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType71' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptualValue_hasConceptFrom_ConceptualDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptualValue_hasConceptFrom_ConceptualDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptualValue_hasConceptFrom_ConceptualDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType71
            self.validate_validTypeType71(self.validType[-1])
# end class ConceptualValue_hasConceptFrom_ConceptualDomainType


class ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomainType.subclass:
            return ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomainType.subclass(*args_, **kwargs_)
        else:
            return ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType72(self, value):
        result = True
        # Validate type validTypeType72, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SentinelConceptualDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType72' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType72
            self.validate_validTypeType72(self.validType[-1])
# end class ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomainType


class ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomainType.subclass:
            return ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomainType.subclass(*args_, **kwargs_)
        else:
            return ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType73(self, value):
        result = True
        # Validate type validTypeType73, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SubstantiveConceptualDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType73' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType73
            self.validate_validTypeType73(self.validType[-1])
# end class ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomainType


class ConceptualVariable_measures_UnitTypeType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConceptualVariable_measures_UnitTypeType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptualVariable_measures_UnitTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptualVariable_measures_UnitTypeType.subclass:
            return ConceptualVariable_measures_UnitTypeType.subclass(*args_, **kwargs_)
        else:
            return ConceptualVariable_measures_UnitTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType74(self, value):
        result = True
        # Validate type validTypeType74, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Population', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType74' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ConceptualVariable_measures_UnitTypeType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConceptualVariable_measures_UnitTypeType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConceptualVariable_measures_UnitTypeType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType74
            self.validate_validTypeType74(self.validType[-1])
# end class ConceptualVariable_measures_UnitTypeType


class ControlLogic_informs_ProcessingAgentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ControlLogic_informs_ProcessingAgentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ControlLogic_informs_ProcessingAgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ControlLogic_informs_ProcessingAgentType.subclass:
            return ControlLogic_informs_ProcessingAgentType.subclass(*args_, **kwargs_)
        else:
            return ControlLogic_informs_ProcessingAgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType75(self, value):
        result = True
        # Validate type validTypeType75, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Curator', 'ProcessingAgent', 'Service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType75' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ControlLogic_informs_ProcessingAgentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ControlLogic_informs_ProcessingAgentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ControlLogic_informs_ProcessingAgentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType75
            self.validate_validTypeType75(self.validType[-1])
# end class ControlLogic_informs_ProcessingAgentType


class ControlLogic_invokes_ActivityType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ControlLogic_invokes_ActivityType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ControlLogic_invokes_ActivityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ControlLogic_invokes_ActivityType.subclass:
            return ControlLogic_invokes_ActivityType.subclass(*args_, **kwargs_)
        else:
            return ControlLogic_invokes_ActivityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType76(self, value):
        result = True
        # Validate type validTypeType76, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Activity', 'Step']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType76' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ControlLogic_invokes_ActivityType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ControlLogic_invokes_ActivityType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ControlLogic_invokes_ActivityType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType76
            self.validate_validTypeType76(self.validType[-1])
# end class ControlLogic_invokes_ActivityType


class ControlLogic_hasSubControlLogic_ControlLogicType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ControlLogic_hasSubControlLogic_ControlLogicType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType77(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ControlLogic_hasSubControlLogic_ControlLogicType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ControlLogic_hasSubControlLogic_ControlLogicType.subclass:
            return ControlLogic_hasSubControlLogic_ControlLogicType.subclass(*args_, **kwargs_)
        else:
            return ControlLogic_hasSubControlLogic_ControlLogicType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType77(self, value):
        result = True
        # Validate type validTypeType77, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AllenIntervalAlgebra', 'ConditionalControlLogic', 'ControlLogic', 'DeterministicImperative', 'NonDeterministicDeclarative', 'RuleBasedScheduling', 'Sequence', 'TemporalConstraints', 'TemporalControlConstruct']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType77' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ControlLogic_hasSubControlLogic_ControlLogicType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ControlLogic_hasSubControlLogic_ControlLogicType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ControlLogic_hasSubControlLogic_ControlLogicType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType77
            self.validate_validTypeType77(self.validType)
# end class ControlLogic_hasSubControlLogic_ControlLogicType


class ControlLogic_has_InformationFlowDefinitionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ControlLogic_has_InformationFlowDefinitionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ControlLogic_has_InformationFlowDefinitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ControlLogic_has_InformationFlowDefinitionType.subclass:
            return ControlLogic_has_InformationFlowDefinitionType.subclass(*args_, **kwargs_)
        else:
            return ControlLogic_has_InformationFlowDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType78(self, value):
        result = True
        # Validate type validTypeType78, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['InformationFlowDefinition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType78' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ControlLogic_has_InformationFlowDefinitionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ControlLogic_has_InformationFlowDefinitionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ControlLogic_has_InformationFlowDefinitionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType78
            self.validate_validTypeType78(self.validType[-1])
# end class ControlLogic_has_InformationFlowDefinitionType


class CorrespondenceTable_hasSource_LevelType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CorrespondenceTable_hasSource_LevelType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrespondenceTable_hasSource_LevelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrespondenceTable_hasSource_LevelType.subclass:
            return CorrespondenceTable_hasSource_LevelType.subclass(*args_, **kwargs_)
        else:
            return CorrespondenceTable_hasSource_LevelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType79(self, value):
        result = True
        # Validate type validTypeType79, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Level']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType79' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CorrespondenceTable_hasSource_LevelType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CorrespondenceTable_hasSource_LevelType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CorrespondenceTable_hasSource_LevelType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType79
            self.validate_validTypeType79(self.validType[-1])
# end class CorrespondenceTable_hasSource_LevelType


class CorrespondenceTable_hasTarget_LevelType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CorrespondenceTable_hasTarget_LevelType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrespondenceTable_hasTarget_LevelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrespondenceTable_hasTarget_LevelType.subclass:
            return CorrespondenceTable_hasTarget_LevelType.subclass(*args_, **kwargs_)
        else:
            return CorrespondenceTable_hasTarget_LevelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType80(self, value):
        result = True
        # Validate type validTypeType80, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Level']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType80' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CorrespondenceTable_hasTarget_LevelType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CorrespondenceTable_hasTarget_LevelType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CorrespondenceTable_hasTarget_LevelType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType80
            self.validate_validTypeType80(self.validType[-1])
# end class CorrespondenceTable_hasTarget_LevelType


class CorrespondenceTable_isOwnedBy_AgentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CorrespondenceTable_isOwnedBy_AgentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrespondenceTable_isOwnedBy_AgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrespondenceTable_isOwnedBy_AgentType.subclass:
            return CorrespondenceTable_isOwnedBy_AgentType.subclass(*args_, **kwargs_)
        else:
            return CorrespondenceTable_isOwnedBy_AgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType81(self, value):
        result = True
        # Validate type validTypeType81, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Agent', 'Curator', 'Individual', 'Machine', 'Organization', 'ProcessingAgent', 'Service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType81' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CorrespondenceTable_isOwnedBy_AgentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CorrespondenceTable_isOwnedBy_AgentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CorrespondenceTable_isOwnedBy_AgentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType81
            self.validate_validTypeType81(self.validType[-1])
# end class CorrespondenceTable_isOwnedBy_AgentType


class CorrespondenceTable_mapsTo_StatisticalClassificationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CorrespondenceTable_mapsTo_StatisticalClassificationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrespondenceTable_mapsTo_StatisticalClassificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrespondenceTable_mapsTo_StatisticalClassificationType.subclass:
            return CorrespondenceTable_mapsTo_StatisticalClassificationType.subclass(*args_, **kwargs_)
        else:
            return CorrespondenceTable_mapsTo_StatisticalClassificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType82(self, value):
        result = True
        # Validate type validTypeType82, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['StatisticalClassification']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType82' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CorrespondenceTable_mapsTo_StatisticalClassificationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CorrespondenceTable_mapsTo_StatisticalClassificationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CorrespondenceTable_mapsTo_StatisticalClassificationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType82
            self.validate_validTypeType82(self.validType[-1])
# end class CorrespondenceTable_mapsTo_StatisticalClassificationType


class CorrespondenceTable_hasContact_AgentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CorrespondenceTable_hasContact_AgentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrespondenceTable_hasContact_AgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrespondenceTable_hasContact_AgentType.subclass:
            return CorrespondenceTable_hasContact_AgentType.subclass(*args_, **kwargs_)
        else:
            return CorrespondenceTable_hasContact_AgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType83(self, value):
        result = True
        # Validate type validTypeType83, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Agent', 'Curator', 'Individual', 'Machine', 'Organization', 'ProcessingAgent', 'Service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType83' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CorrespondenceTable_hasContact_AgentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CorrespondenceTable_hasContact_AgentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CorrespondenceTable_hasContact_AgentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType83
            self.validate_validTypeType83(self.validType[-1])
# end class CorrespondenceTable_hasContact_AgentType


class CorrespondenceTable_isMaintainedBy_AgentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CorrespondenceTable_isMaintainedBy_AgentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrespondenceTable_isMaintainedBy_AgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrespondenceTable_isMaintainedBy_AgentType.subclass:
            return CorrespondenceTable_isMaintainedBy_AgentType.subclass(*args_, **kwargs_)
        else:
            return CorrespondenceTable_isMaintainedBy_AgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType84(self, value):
        result = True
        # Validate type validTypeType84, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Agent', 'Curator', 'Individual', 'Machine', 'Organization', 'ProcessingAgent', 'Service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType84' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(CorrespondenceTable_isMaintainedBy_AgentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CorrespondenceTable_isMaintainedBy_AgentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CorrespondenceTable_isMaintainedBy_AgentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType84
            self.validate_validTypeType84(self.validType[-1])
# end class CorrespondenceTable_isMaintainedBy_AgentType


class CorrespondenceTable_has_ConceptMapType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CorrespondenceTable_has_ConceptMapType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType85(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrespondenceTable_has_ConceptMapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrespondenceTable_has_ConceptMapType.subclass:
            return CorrespondenceTable_has_ConceptMapType.subclass(*args_, **kwargs_)
        else:
            return CorrespondenceTable_has_ConceptMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType85(self, value):
        result = True
        # Validate type validTypeType85, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ConceptMap']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType85' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(CorrespondenceTable_has_ConceptMapType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CorrespondenceTable_has_ConceptMapType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CorrespondenceTable_has_ConceptMapType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType85
            self.validate_validTypeType85(self.validType)
# end class CorrespondenceTable_has_ConceptMapType


class DataPoint_correspondsTo_DataStructureComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataPoint_correspondsTo_DataStructureComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataPoint_correspondsTo_DataStructureComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataPoint_correspondsTo_DataStructureComponentType.subclass:
            return DataPoint_correspondsTo_DataStructureComponentType.subclass(*args_, **kwargs_)
        else:
            return DataPoint_correspondsTo_DataStructureComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType86(self, value):
        result = True
        # Validate type validTypeType86, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AttributeComponent', 'ContextualComponent', 'DataStructure', 'DataStructureComponent', 'DimensionComponent', 'DimensionalDataStructure', 'IdentifierComponent', 'KeyValueStructure', 'LongDataStructure', 'MeasureComponent', 'QualifiedMeasure', 'SyntheticIdComponent', 'VariableDescriptorComponent', 'VariableValueComponent', 'WideDataStructure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType86' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DataPoint_correspondsTo_DataStructureComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataPoint_correspondsTo_DataStructureComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataPoint_correspondsTo_DataStructureComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType86
            self.validate_validTypeType86(self.validType[-1])
# end class DataPoint_correspondsTo_DataStructureComponentType


class DataPoint_isDescribedBy_InstanceVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataPoint_isDescribedBy_InstanceVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataPoint_isDescribedBy_InstanceVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataPoint_isDescribedBy_InstanceVariableType.subclass:
            return DataPoint_isDescribedBy_InstanceVariableType.subclass(*args_, **kwargs_)
        else:
            return DataPoint_isDescribedBy_InstanceVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType87(self, value):
        result = True
        # Validate type validTypeType87, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['InstanceVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType87' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DataPoint_isDescribedBy_InstanceVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataPoint_isDescribedBy_InstanceVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataPoint_isDescribedBy_InstanceVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType87
            self.validate_validTypeType87(self.validType[-1])
# end class DataPoint_isDescribedBy_InstanceVariableType


class DataPointPosition_indexes_DataPointType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataPointPosition_indexes_DataPointType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataPointPosition_indexes_DataPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataPointPosition_indexes_DataPointType.subclass:
            return DataPointPosition_indexes_DataPointType.subclass(*args_, **kwargs_)
        else:
            return DataPointPosition_indexes_DataPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType88(self, value):
        result = True
        # Validate type validTypeType88, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataPoint']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType88' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DataPointPosition_indexes_DataPointType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataPointPosition_indexes_DataPointType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataPointPosition_indexes_DataPointType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType88
            self.validate_validTypeType88(self.validType[-1])
# end class DataPointPosition_indexes_DataPointType


class DataPointRelationship_hasTarget_DataPointType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataPointRelationship_hasTarget_DataPointType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataPointRelationship_hasTarget_DataPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataPointRelationship_hasTarget_DataPointType.subclass:
            return DataPointRelationship_hasTarget_DataPointType.subclass(*args_, **kwargs_)
        else:
            return DataPointRelationship_hasTarget_DataPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType89(self, value):
        result = True
        # Validate type validTypeType89, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataPoint']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType89' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DataPointRelationship_hasTarget_DataPointType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataPointRelationship_hasTarget_DataPointType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataPointRelationship_hasTarget_DataPointType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType89
            self.validate_validTypeType89(self.validType[-1])
# end class DataPointRelationship_hasTarget_DataPointType


class DataPointRelationship_hasSource_DataPointType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataPointRelationship_hasSource_DataPointType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataPointRelationship_hasSource_DataPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataPointRelationship_hasSource_DataPointType.subclass:
            return DataPointRelationship_hasSource_DataPointType.subclass(*args_, **kwargs_)
        else:
            return DataPointRelationship_hasSource_DataPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType90(self, value):
        result = True
        # Validate type validTypeType90, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataPoint']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType90' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DataPointRelationship_hasSource_DataPointType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataPointRelationship_hasSource_DataPointType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataPointRelationship_hasSource_DataPointType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType90
            self.validate_validTypeType90(self.validType[-1])
# end class DataPointRelationship_hasSource_DataPointType


class DataSet_isStructuredBy_DataStructureType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataSet_isStructuredBy_DataStructureType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataSet_isStructuredBy_DataStructureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataSet_isStructuredBy_DataStructureType.subclass:
            return DataSet_isStructuredBy_DataStructureType.subclass(*args_, **kwargs_)
        else:
            return DataSet_isStructuredBy_DataStructureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType91(self, value):
        result = True
        # Validate type validTypeType91, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataStructure', 'DimensionalDataStructure', 'KeyValueStructure', 'LongDataStructure', 'WideDataStructure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType91' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DataSet_isStructuredBy_DataStructureType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataSet_isStructuredBy_DataStructureType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataSet_isStructuredBy_DataStructureType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType91
            self.validate_validTypeType91(self.validType[-1])
# end class DataSet_isStructuredBy_DataStructureType


class DataSet_has_DataPointType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataSet_has_DataPointType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType92(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataSet_has_DataPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataSet_has_DataPointType.subclass:
            return DataSet_has_DataPointType.subclass(*args_, **kwargs_)
        else:
            return DataSet_has_DataPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType92(self, value):
        result = True
        # Validate type validTypeType92, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataPoint']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType92' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(DataSet_has_DataPointType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataSet_has_DataPointType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataSet_has_DataPointType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType92
            self.validate_validTypeType92(self.validType)
# end class DataSet_has_DataPointType


class DataSet_has_KeyType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataSet_has_KeyType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType93(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataSet_has_KeyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataSet_has_KeyType.subclass:
            return DataSet_has_KeyType.subclass(*args_, **kwargs_)
        else:
            return DataSet_has_KeyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType93(self, value):
        result = True
        # Validate type validTypeType93, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DimensionalKey', 'InstanceKey', 'Key', 'LongKey', 'WideKey']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType93' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(DataSet_has_KeyType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataSet_has_KeyType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataSet_has_KeyType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType93
            self.validate_validTypeType93(self.validType)
# end class DataSet_has_KeyType


class DataStore_isDefinedBy_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataStore_isDefinedBy_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataStore_isDefinedBy_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataStore_isDefinedBy_ConceptType.subclass:
            return DataStore_isDefinedBy_ConceptType.subclass(*args_, **kwargs_)
        else:
            return DataStore_isDefinedBy_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType94(self, value):
        result = True
        # Validate type validTypeType94, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType94' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DataStore_isDefinedBy_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataStore_isDefinedBy_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataStore_isDefinedBy_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType94
            self.validate_validTypeType94(self.validType[-1])
# end class DataStore_isDefinedBy_ConceptType


class DataStore_has_LogicalRecordPositionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataStore_has_LogicalRecordPositionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType95(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataStore_has_LogicalRecordPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataStore_has_LogicalRecordPositionType.subclass:
            return DataStore_has_LogicalRecordPositionType.subclass(*args_, **kwargs_)
        else:
            return DataStore_has_LogicalRecordPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType95(self, value):
        result = True
        # Validate type validTypeType95, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LogicalRecordPosition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType95' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(DataStore_has_LogicalRecordPositionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataStore_has_LogicalRecordPositionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataStore_has_LogicalRecordPositionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType95
            self.validate_validTypeType95(self.validType)
# end class DataStore_has_LogicalRecordPositionType


class DataStore_has_LogicalRecordType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataStore_has_LogicalRecordType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataStore_has_LogicalRecordType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataStore_has_LogicalRecordType.subclass:
            return DataStore_has_LogicalRecordType.subclass(*args_, **kwargs_)
        else:
            return DataStore_has_LogicalRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType96(self, value):
        result = True
        # Validate type validTypeType96, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LogicalRecord']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType96' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DataStore_has_LogicalRecordType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataStore_has_LogicalRecordType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataStore_has_LogicalRecordType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType96
            self.validate_validTypeType96(self.validType[-1])
# end class DataStore_has_LogicalRecordType


class DataStore_has_RecordRelationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataStore_has_RecordRelationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataStore_has_RecordRelationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataStore_has_RecordRelationType.subclass:
            return DataStore_has_RecordRelationType.subclass(*args_, **kwargs_)
        else:
            return DataStore_has_RecordRelationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType97(self, value):
        result = True
        # Validate type validTypeType97, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RecordRelation']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType97' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DataStore_has_RecordRelationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataStore_has_RecordRelationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataStore_has_RecordRelationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType97
            self.validate_validTypeType97(self.validType[-1])
# end class DataStore_has_RecordRelationType


class DataStructure_has_ForeignKeyType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataStructure_has_ForeignKeyType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType98(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataStructure_has_ForeignKeyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataStructure_has_ForeignKeyType.subclass:
            return DataStructure_has_ForeignKeyType.subclass(*args_, **kwargs_)
        else:
            return DataStructure_has_ForeignKeyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType98(self, value):
        result = True
        # Validate type validTypeType98, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ForeignKey']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType98' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(DataStructure_has_ForeignKeyType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataStructure_has_ForeignKeyType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataStructure_has_ForeignKeyType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType98
            self.validate_validTypeType98(self.validType)
# end class DataStructure_has_ForeignKeyType


class DataStructure_has_DataStructureComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataStructure_has_DataStructureComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType99(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataStructure_has_DataStructureComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataStructure_has_DataStructureComponentType.subclass:
            return DataStructure_has_DataStructureComponentType.subclass(*args_, **kwargs_)
        else:
            return DataStructure_has_DataStructureComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType99(self, value):
        result = True
        # Validate type validTypeType99, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AttributeComponent', 'ContextualComponent', 'DataStructure', 'DataStructureComponent', 'DimensionComponent', 'DimensionalDataStructure', 'IdentifierComponent', 'KeyValueStructure', 'LongDataStructure', 'MeasureComponent', 'QualifiedMeasure', 'SyntheticIdComponent', 'VariableDescriptorComponent', 'VariableValueComponent', 'WideDataStructure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType99' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(DataStructure_has_DataStructureComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataStructure_has_DataStructureComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataStructure_has_DataStructureComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType99
            self.validate_validTypeType99(self.validType)
# end class DataStructure_has_DataStructureComponentType


class DataStructure_has_ComponentPositionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataStructure_has_ComponentPositionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType100(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataStructure_has_ComponentPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataStructure_has_ComponentPositionType.subclass:
            return DataStructure_has_ComponentPositionType.subclass(*args_, **kwargs_)
        else:
            return DataStructure_has_ComponentPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType100(self, value):
        result = True
        # Validate type validTypeType100, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ComponentPosition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType100' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(DataStructure_has_ComponentPositionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataStructure_has_ComponentPositionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataStructure_has_ComponentPositionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType100
            self.validate_validTypeType100(self.validType)
# end class DataStructure_has_ComponentPositionType


class DataStructure_has_PrimaryKeyType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataStructure_has_PrimaryKeyType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType101(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataStructure_has_PrimaryKeyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataStructure_has_PrimaryKeyType.subclass:
            return DataStructure_has_PrimaryKeyType.subclass(*args_, **kwargs_)
        else:
            return DataStructure_has_PrimaryKeyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType101(self, value):
        result = True
        # Validate type validTypeType101, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PrimaryKey']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType101' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(DataStructure_has_PrimaryKeyType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataStructure_has_PrimaryKeyType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataStructure_has_PrimaryKeyType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType101
            self.validate_validTypeType101(self.validType)
# end class DataStructure_has_PrimaryKeyType


class DataStructureComponent_isDefinedBy_RepresentedVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataStructureComponent_isDefinedBy_RepresentedVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataStructureComponent_isDefinedBy_RepresentedVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataStructureComponent_isDefinedBy_RepresentedVariableType.subclass:
            return DataStructureComponent_isDefinedBy_RepresentedVariableType.subclass(*args_, **kwargs_)
        else:
            return DataStructureComponent_isDefinedBy_RepresentedVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType102(self, value):
        result = True
        # Validate type validTypeType102, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DescriptorVariable', 'InstanceVariable', 'ReferenceVariable', 'RepresentedVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType102' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DataStructureComponent_isDefinedBy_RepresentedVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataStructureComponent_isDefinedBy_RepresentedVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DataStructureComponent_isDefinedBy_RepresentedVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType102
            self.validate_validTypeType102(self.validType[-1])
# end class DataStructureComponent_isDefinedBy_RepresentedVariableType


class Datum_uses_NotationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Datum_uses_NotationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Datum_uses_NotationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Datum_uses_NotationType.subclass:
            return Datum_uses_NotationType.subclass(*args_, **kwargs_)
        else:
            return Datum_uses_NotationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType103(self, value):
        result = True
        # Validate type validTypeType103, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Notation']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType103' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Datum_uses_NotationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Datum_uses_NotationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Datum_uses_NotationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType103
            self.validate_validTypeType103(self.validType[-1])
# end class Datum_uses_NotationType


class Datum_denotes_ConceptualValueType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Datum_denotes_ConceptualValueType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Datum_denotes_ConceptualValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Datum_denotes_ConceptualValueType.subclass:
            return Datum_denotes_ConceptualValueType.subclass(*args_, **kwargs_)
        else:
            return Datum_denotes_ConceptualValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType104(self, value):
        result = True
        # Validate type validTypeType104, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ConceptualValue', 'DimensionalKeyDefinitionMember', 'KeyDefinitionMember']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType104' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Datum_denotes_ConceptualValueType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Datum_denotes_ConceptualValueType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Datum_denotes_ConceptualValueType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType104
            self.validate_validTypeType104(self.validType[-1])
# end class Datum_denotes_ConceptualValueType


class Datum_uses_InstanceValueType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Datum_uses_InstanceValueType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Datum_uses_InstanceValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Datum_uses_InstanceValueType.subclass:
            return Datum_uses_InstanceValueType.subclass(*args_, **kwargs_)
        else:
            return Datum_uses_InstanceValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType105(self, value):
        result = True
        # Validate type validTypeType105, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Descriptor', 'DimensionalKeyMember', 'InstanceValue', 'KeyMember', 'LongMainKeyMember', 'MainKeyMember', 'ReferenceValue', 'WideKeyMember']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType105' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Datum_uses_InstanceValueType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Datum_uses_InstanceValueType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Datum_uses_InstanceValueType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType105
            self.validate_validTypeType105(self.validType[-1])
# end class Datum_uses_InstanceValueType


class Datum_isBoundedBy_InstanceVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Datum_isBoundedBy_InstanceVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Datum_isBoundedBy_InstanceVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Datum_isBoundedBy_InstanceVariableType.subclass:
            return Datum_isBoundedBy_InstanceVariableType.subclass(*args_, **kwargs_)
        else:
            return Datum_isBoundedBy_InstanceVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType106(self, value):
        result = True
        # Validate type validTypeType106, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['InstanceVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType106' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Datum_isBoundedBy_InstanceVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Datum_isBoundedBy_InstanceVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Datum_isBoundedBy_InstanceVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType106
            self.validate_validTypeType106(self.validType[-1])
# end class Datum_isBoundedBy_InstanceVariableType


class Descriptor_refersTo_ReferenceValueType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Descriptor_refersTo_ReferenceValueType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType107(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Descriptor_refersTo_ReferenceValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Descriptor_refersTo_ReferenceValueType.subclass:
            return Descriptor_refersTo_ReferenceValueType.subclass(*args_, **kwargs_)
        else:
            return Descriptor_refersTo_ReferenceValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType107(self, value):
        result = True
        # Validate type validTypeType107, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ReferenceValue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType107' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(Descriptor_refersTo_ReferenceValueType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Descriptor_refersTo_ReferenceValueType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Descriptor_refersTo_ReferenceValueType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType107
            self.validate_validTypeType107(self.validType)
# end class Descriptor_refersTo_ReferenceValueType


class Descriptor_identifies_ReferenceVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Descriptor_identifies_ReferenceVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Descriptor_identifies_ReferenceVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Descriptor_identifies_ReferenceVariableType.subclass:
            return Descriptor_identifies_ReferenceVariableType.subclass(*args_, **kwargs_)
        else:
            return Descriptor_identifies_ReferenceVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType108(self, value):
        result = True
        # Validate type validTypeType108, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ReferenceVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType108' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Descriptor_identifies_ReferenceVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Descriptor_identifies_ReferenceVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Descriptor_identifies_ReferenceVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType108
            self.validate_validTypeType108(self.validType[-1])
# end class Descriptor_identifies_ReferenceVariableType


class Descriptor_hasValueFrom_DescriptorValueDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Descriptor_hasValueFrom_DescriptorValueDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Descriptor_hasValueFrom_DescriptorValueDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Descriptor_hasValueFrom_DescriptorValueDomainType.subclass:
            return Descriptor_hasValueFrom_DescriptorValueDomainType.subclass(*args_, **kwargs_)
        else:
            return Descriptor_hasValueFrom_DescriptorValueDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType109(self, value):
        result = True
        # Validate type validTypeType109, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DescriptorValueDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType109' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Descriptor_hasValueFrom_DescriptorValueDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Descriptor_hasValueFrom_DescriptorValueDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Descriptor_hasValueFrom_DescriptorValueDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType109
            self.validate_validTypeType109(self.validType[-1])
# end class Descriptor_hasValueFrom_DescriptorValueDomainType


class DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomainType.subclass:
            return DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomainType.subclass(*args_, **kwargs_)
        else:
            return DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType110(self, value):
        result = True
        # Validate type validTypeType110, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DescriptorValueDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType110' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType110
            self.validate_validTypeType110(self.validType[-1])
# end class DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomainType


class DimensionComponent_isStructuredBy_ValueDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DimensionComponent_isStructuredBy_ValueDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionComponent_isStructuredBy_ValueDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionComponent_isStructuredBy_ValueDomainType.subclass:
            return DimensionComponent_isStructuredBy_ValueDomainType.subclass(*args_, **kwargs_)
        else:
            return DimensionComponent_isStructuredBy_ValueDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType111(self, value):
        result = True
        # Validate type validTypeType111, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DescriptorValueDomain', 'ReferenceValueDomain', 'SentinelValueDomain', 'SubstantiveValueDomain', 'ValueDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType111' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DimensionComponent_isStructuredBy_ValueDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionComponent_isStructuredBy_ValueDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DimensionComponent_isStructuredBy_ValueDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType111
            self.validate_validTypeType111(self.validType[-1])
# end class DimensionComponent_isStructuredBy_ValueDomainType


class DimensionGroup_has_DimensionComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DimensionGroup_has_DimensionComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionGroup_has_DimensionComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionGroup_has_DimensionComponentType.subclass:
            return DimensionGroup_has_DimensionComponentType.subclass(*args_, **kwargs_)
        else:
            return DimensionGroup_has_DimensionComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType112(self, value):
        result = True
        # Validate type validTypeType112, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DimensionComponent']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType112' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DimensionGroup_has_DimensionComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionGroup_has_DimensionComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DimensionGroup_has_DimensionComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType112
            self.validate_validTypeType112(self.validType[-1])
# end class DimensionGroup_has_DimensionComponentType


class DimensionalDataSet_represents_ScopedMeasureType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DimensionalDataSet_represents_ScopedMeasureType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionalDataSet_represents_ScopedMeasureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionalDataSet_represents_ScopedMeasureType.subclass:
            return DimensionalDataSet_represents_ScopedMeasureType.subclass(*args_, **kwargs_)
        else:
            return DimensionalDataSet_represents_ScopedMeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType113(self, value):
        result = True
        # Validate type validTypeType113, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ScopedMeasure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType113' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DimensionalDataSet_represents_ScopedMeasureType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionalDataSet_represents_ScopedMeasureType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DimensionalDataSet_represents_ScopedMeasureType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType113
            self.validate_validTypeType113(self.validType[-1])
# end class DimensionalDataSet_represents_ScopedMeasureType


class DimensionalDataStructure_uses_DimensionGroupType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DimensionalDataStructure_uses_DimensionGroupType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionalDataStructure_uses_DimensionGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionalDataStructure_uses_DimensionGroupType.subclass:
            return DimensionalDataStructure_uses_DimensionGroupType.subclass(*args_, **kwargs_)
        else:
            return DimensionalDataStructure_uses_DimensionGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType114(self, value):
        result = True
        # Validate type validTypeType114, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DimensionGroup']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType114' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DimensionalDataStructure_uses_DimensionGroupType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionalDataStructure_uses_DimensionGroupType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DimensionalDataStructure_uses_DimensionGroupType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType114
            self.validate_validTypeType114(self.validType[-1])
# end class DimensionalDataStructure_uses_DimensionGroupType


class DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMemberType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMemberType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType115(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMemberType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMemberType.subclass:
            return DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMemberType.subclass(*args_, **kwargs_)
        else:
            return DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType115(self, value):
        result = True
        # Validate type validTypeType115, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DimensionalKeyMember']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType115' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMemberType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMemberType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMemberType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType115
            self.validate_validTypeType115(self.validType)
# end class DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMemberType


class DimensionalKeyMember_hasValueFrom_CodeListType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DimensionalKeyMember_hasValueFrom_CodeListType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionalKeyMember_hasValueFrom_CodeListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionalKeyMember_hasValueFrom_CodeListType.subclass:
            return DimensionalKeyMember_hasValueFrom_CodeListType.subclass(*args_, **kwargs_)
        else:
            return DimensionalKeyMember_hasValueFrom_CodeListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType116(self, value):
        result = True
        # Validate type validTypeType116, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CodeList']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType116' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(DimensionalKeyMember_hasValueFrom_CodeListType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionalKeyMember_hasValueFrom_CodeListType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DimensionalKeyMember_hasValueFrom_CodeListType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType116
            self.validate_validTypeType116(self.validType[-1])
# end class DimensionalKeyMember_hasValueFrom_CodeListType


class EnumerationDomain_uses_LevelStructureType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EnumerationDomain_uses_LevelStructureType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnumerationDomain_uses_LevelStructureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnumerationDomain_uses_LevelStructureType.subclass:
            return EnumerationDomain_uses_LevelStructureType.subclass(*args_, **kwargs_)
        else:
            return EnumerationDomain_uses_LevelStructureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType117(self, value):
        result = True
        # Validate type validTypeType117, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LevelStructure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType117' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(EnumerationDomain_uses_LevelStructureType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='EnumerationDomain_uses_LevelStructureType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EnumerationDomain_uses_LevelStructureType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType117
            self.validate_validTypeType117(self.validType[-1])
# end class EnumerationDomain_uses_LevelStructureType


class EnumerationDomain_references_CategorySetType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EnumerationDomain_references_CategorySetType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnumerationDomain_references_CategorySetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnumerationDomain_references_CategorySetType.subclass:
            return EnumerationDomain_references_CategorySetType.subclass(*args_, **kwargs_)
        else:
            return EnumerationDomain_references_CategorySetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType118(self, value):
        result = True
        # Validate type validTypeType118, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CategorySet']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType118' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(EnumerationDomain_references_CategorySetType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='EnumerationDomain_references_CategorySetType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EnumerationDomain_references_CategorySetType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType118
            self.validate_validTypeType118(self.validType[-1])
# end class EnumerationDomain_references_CategorySetType


class EnumerationDomain_isDefinedBy_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EnumerationDomain_isDefinedBy_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnumerationDomain_isDefinedBy_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnumerationDomain_isDefinedBy_ConceptType.subclass:
            return EnumerationDomain_isDefinedBy_ConceptType.subclass(*args_, **kwargs_)
        else:
            return EnumerationDomain_isDefinedBy_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType119(self, value):
        result = True
        # Validate type validTypeType119, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType119' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(EnumerationDomain_isDefinedBy_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='EnumerationDomain_isDefinedBy_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EnumerationDomain_isDefinedBy_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType119
            self.validate_validTypeType119(self.validType[-1])
# end class EnumerationDomain_isDefinedBy_ConceptType


class ForeignKey_isComposedOf_ForeignKeyComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ForeignKey_isComposedOf_ForeignKeyComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType120(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForeignKey_isComposedOf_ForeignKeyComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForeignKey_isComposedOf_ForeignKeyComponentType.subclass:
            return ForeignKey_isComposedOf_ForeignKeyComponentType.subclass(*args_, **kwargs_)
        else:
            return ForeignKey_isComposedOf_ForeignKeyComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType120(self, value):
        result = True
        # Validate type validTypeType120, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ForeignKeyComponent']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType120' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ForeignKey_isComposedOf_ForeignKeyComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ForeignKey_isComposedOf_ForeignKeyComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ForeignKey_isComposedOf_ForeignKeyComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType120
            self.validate_validTypeType120(self.validType)
# end class ForeignKey_isComposedOf_ForeignKeyComponentType


class ForeignKeyComponent_references_PrimaryKeyComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ForeignKeyComponent_references_PrimaryKeyComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType121(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForeignKeyComponent_references_PrimaryKeyComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForeignKeyComponent_references_PrimaryKeyComponentType.subclass:
            return ForeignKeyComponent_references_PrimaryKeyComponentType.subclass(*args_, **kwargs_)
        else:
            return ForeignKeyComponent_references_PrimaryKeyComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType121(self, value):
        result = True
        # Validate type validTypeType121, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PrimaryKeyComponent']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType121' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ForeignKeyComponent_references_PrimaryKeyComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ForeignKeyComponent_references_PrimaryKeyComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ForeignKeyComponent_references_PrimaryKeyComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType121
            self.validate_validTypeType121(self.validType)
# end class ForeignKeyComponent_references_PrimaryKeyComponentType


class ForeignKeyComponent_correspondsTo_DataStructureComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ForeignKeyComponent_correspondsTo_DataStructureComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType122(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForeignKeyComponent_correspondsTo_DataStructureComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForeignKeyComponent_correspondsTo_DataStructureComponentType.subclass:
            return ForeignKeyComponent_correspondsTo_DataStructureComponentType.subclass(*args_, **kwargs_)
        else:
            return ForeignKeyComponent_correspondsTo_DataStructureComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType122(self, value):
        result = True
        # Validate type validTypeType122, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AttributeComponent', 'ContextualComponent', 'DataStructure', 'DataStructureComponent', 'DimensionComponent', 'DimensionalDataStructure', 'IdentifierComponent', 'KeyValueStructure', 'LongDataStructure', 'MeasureComponent', 'QualifiedMeasure', 'SyntheticIdComponent', 'VariableDescriptorComponent', 'VariableValueComponent', 'WideDataStructure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType122' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ForeignKeyComponent_correspondsTo_DataStructureComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ForeignKeyComponent_correspondsTo_DataStructureComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ForeignKeyComponent_correspondsTo_DataStructureComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType122
            self.validate_validTypeType122(self.validType)
# end class ForeignKeyComponent_correspondsTo_DataStructureComponentType


class InformationFlowDefinition_from_ParameterType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("InformationFlowDefinition_from_ParameterType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformationFlowDefinition_from_ParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformationFlowDefinition_from_ParameterType.subclass:
            return InformationFlowDefinition_from_ParameterType.subclass(*args_, **kwargs_)
        else:
            return InformationFlowDefinition_from_ParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType123(self, value):
        result = True
        # Validate type validTypeType123, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Parameter']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType123' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(InformationFlowDefinition_from_ParameterType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InformationFlowDefinition_from_ParameterType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InformationFlowDefinition_from_ParameterType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType123
            self.validate_validTypeType123(self.validType[-1])
# end class InformationFlowDefinition_from_ParameterType


class InformationFlowDefinition_to_ParameterType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("InformationFlowDefinition_to_ParameterType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformationFlowDefinition_to_ParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformationFlowDefinition_to_ParameterType.subclass:
            return InformationFlowDefinition_to_ParameterType.subclass(*args_, **kwargs_)
        else:
            return InformationFlowDefinition_to_ParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType124(self, value):
        result = True
        # Validate type validTypeType124, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Parameter']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType124' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(InformationFlowDefinition_to_ParameterType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InformationFlowDefinition_to_ParameterType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InformationFlowDefinition_to_ParameterType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType124
            self.validate_validTypeType124(self.validType[-1])
# end class InformationFlowDefinition_to_ParameterType


class InstanceKey_has_InstanceValueType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("InstanceKey_has_InstanceValueType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceKey_has_InstanceValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceKey_has_InstanceValueType.subclass:
            return InstanceKey_has_InstanceValueType.subclass(*args_, **kwargs_)
        else:
            return InstanceKey_has_InstanceValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType125(self, value):
        result = True
        # Validate type validTypeType125, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Descriptor', 'DimensionalKeyMember', 'InstanceValue', 'KeyMember', 'LongMainKeyMember', 'MainKeyMember', 'ReferenceValue', 'WideKeyMember']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType125' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(InstanceKey_has_InstanceValueType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InstanceKey_has_InstanceValueType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InstanceKey_has_InstanceValueType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType125
            self.validate_validTypeType125(self.validType[-1])
# end class InstanceKey_has_InstanceValueType


class InstanceKey_refersTo_ReferenceValueType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("InstanceKey_refersTo_ReferenceValueType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceKey_refersTo_ReferenceValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceKey_refersTo_ReferenceValueType.subclass:
            return InstanceKey_refersTo_ReferenceValueType.subclass(*args_, **kwargs_)
        else:
            return InstanceKey_refersTo_ReferenceValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType126(self, value):
        result = True
        # Validate type validTypeType126, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ReferenceValue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType126' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(InstanceKey_refersTo_ReferenceValueType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InstanceKey_refersTo_ReferenceValueType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InstanceKey_refersTo_ReferenceValueType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType126
            self.validate_validTypeType126(self.validType[-1])
# end class InstanceKey_refersTo_ReferenceValueType


class InstanceValue_hasValueFrom_ValueDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("InstanceValue_hasValueFrom_ValueDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceValue_hasValueFrom_ValueDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceValue_hasValueFrom_ValueDomainType.subclass:
            return InstanceValue_hasValueFrom_ValueDomainType.subclass(*args_, **kwargs_)
        else:
            return InstanceValue_hasValueFrom_ValueDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType127(self, value):
        result = True
        # Validate type validTypeType127, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DescriptorValueDomain', 'ReferenceValueDomain', 'SentinelValueDomain', 'SubstantiveValueDomain', 'ValueDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType127' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(InstanceValue_hasValueFrom_ValueDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InstanceValue_hasValueFrom_ValueDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InstanceValue_hasValueFrom_ValueDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType127
            self.validate_validTypeType127(self.validType[-1])
# end class InstanceValue_hasValueFrom_ValueDomainType


class InstanceValue_isStoredIn_DataPointType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("InstanceValue_isStoredIn_DataPointType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType128(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceValue_isStoredIn_DataPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceValue_isStoredIn_DataPointType.subclass:
            return InstanceValue_isStoredIn_DataPointType.subclass(*args_, **kwargs_)
        else:
            return InstanceValue_isStoredIn_DataPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType128(self, value):
        result = True
        # Validate type validTypeType128, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataPoint']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType128' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(InstanceValue_isStoredIn_DataPointType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InstanceValue_isStoredIn_DataPointType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InstanceValue_isStoredIn_DataPointType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType128
            self.validate_validTypeType128(self.validType)
# end class InstanceValue_isStoredIn_DataPointType


class InstanceValue_represents_ConceptualValueType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("InstanceValue_represents_ConceptualValueType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceValue_represents_ConceptualValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceValue_represents_ConceptualValueType.subclass:
            return InstanceValue_represents_ConceptualValueType.subclass(*args_, **kwargs_)
        else:
            return InstanceValue_represents_ConceptualValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType129(self, value):
        result = True
        # Validate type validTypeType129, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ConceptualValue', 'DimensionalKeyDefinitionMember', 'KeyDefinitionMember']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType129' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(InstanceValue_represents_ConceptualValueType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InstanceValue_represents_ConceptualValueType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InstanceValue_represents_ConceptualValueType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType129
            self.validate_validTypeType129(self.validType[-1])
# end class InstanceValue_represents_ConceptualValueType


class InstanceVariableMap_hasTarget_InstanceVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("InstanceVariableMap_hasTarget_InstanceVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceVariableMap_hasTarget_InstanceVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceVariableMap_hasTarget_InstanceVariableType.subclass:
            return InstanceVariableMap_hasTarget_InstanceVariableType.subclass(*args_, **kwargs_)
        else:
            return InstanceVariableMap_hasTarget_InstanceVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType130(self, value):
        result = True
        # Validate type validTypeType130, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['InstanceVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType130' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(InstanceVariableMap_hasTarget_InstanceVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InstanceVariableMap_hasTarget_InstanceVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InstanceVariableMap_hasTarget_InstanceVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType130
            self.validate_validTypeType130(self.validType[-1])
# end class InstanceVariableMap_hasTarget_InstanceVariableType


class InstanceVariableMap_hasSource_InstanceVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("InstanceVariableMap_hasSource_InstanceVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceVariableMap_hasSource_InstanceVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceVariableMap_hasSource_InstanceVariableType.subclass:
            return InstanceVariableMap_hasSource_InstanceVariableType.subclass(*args_, **kwargs_)
        else:
            return InstanceVariableMap_hasSource_InstanceVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType131(self, value):
        result = True
        # Validate type validTypeType131, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['InstanceVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType131' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(InstanceVariableMap_hasSource_InstanceVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InstanceVariableMap_hasSource_InstanceVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InstanceVariableMap_hasSource_InstanceVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType131
            self.validate_validTypeType131(self.validType[-1])
# end class InstanceVariableMap_hasSource_InstanceVariableType


class Key_correspondsTo_UnitType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Key_correspondsTo_UnitType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Key_correspondsTo_UnitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Key_correspondsTo_UnitType.subclass:
            return Key_correspondsTo_UnitType.subclass(*args_, **kwargs_)
        else:
            return Key_correspondsTo_UnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType132(self, value):
        result = True
        # Validate type validTypeType132, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Unit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType132' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Key_correspondsTo_UnitType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Key_correspondsTo_UnitType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Key_correspondsTo_UnitType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType132
            self.validate_validTypeType132(self.validType[-1])
# end class Key_correspondsTo_UnitType


class Key_represents_KeyDefinitionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Key_represents_KeyDefinitionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Key_represents_KeyDefinitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Key_represents_KeyDefinitionType.subclass:
            return Key_represents_KeyDefinitionType.subclass(*args_, **kwargs_)
        else:
            return Key_represents_KeyDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType133(self, value):
        result = True
        # Validate type validTypeType133, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DimensionalKeyDefinition', 'KeyDefinition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType133' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Key_represents_KeyDefinitionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Key_represents_KeyDefinitionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Key_represents_KeyDefinitionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType133
            self.validate_validTypeType133(self.validType[-1])
# end class Key_represents_KeyDefinitionType


class Key_identifies_DataPointType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Key_identifies_DataPointType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType134(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Key_identifies_DataPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Key_identifies_DataPointType.subclass:
            return Key_identifies_DataPointType.subclass(*args_, **kwargs_)
        else:
            return Key_identifies_DataPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType134(self, value):
        result = True
        # Validate type validTypeType134, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataPoint']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType134' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(Key_identifies_DataPointType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Key_identifies_DataPointType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Key_identifies_DataPointType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType134
            self.validate_validTypeType134(self.validType)
# end class Key_identifies_DataPointType


class Key_correspondsTo_UniverseType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Key_correspondsTo_UniverseType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Key_correspondsTo_UniverseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Key_correspondsTo_UniverseType.subclass:
            return Key_correspondsTo_UniverseType.subclass(*args_, **kwargs_)
        else:
            return Key_correspondsTo_UniverseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType135(self, value):
        result = True
        # Validate type validTypeType135, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Population', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType135' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Key_correspondsTo_UniverseType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Key_correspondsTo_UniverseType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Key_correspondsTo_UniverseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType135
            self.validate_validTypeType135(self.validType[-1])
# end class Key_correspondsTo_UniverseType


class Key_has_KeyMemberType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Key_has_KeyMemberType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType136(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Key_has_KeyMemberType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Key_has_KeyMemberType.subclass:
            return Key_has_KeyMemberType.subclass(*args_, **kwargs_)
        else:
            return Key_has_KeyMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType136(self, value):
        result = True
        # Validate type validTypeType136, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Descriptor', 'DimensionalKeyMember', 'KeyMember', 'LongMainKeyMember', 'MainKeyMember', 'WideKeyMember']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType136' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(Key_has_KeyMemberType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Key_has_KeyMemberType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Key_has_KeyMemberType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType136
            self.validate_validTypeType136(self.validType)
# end class Key_has_KeyMemberType


class KeyDefinition_correspondsTo_UniverseType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("KeyDefinition_correspondsTo_UniverseType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyDefinition_correspondsTo_UniverseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyDefinition_correspondsTo_UniverseType.subclass:
            return KeyDefinition_correspondsTo_UniverseType.subclass(*args_, **kwargs_)
        else:
            return KeyDefinition_correspondsTo_UniverseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType137(self, value):
        result = True
        # Validate type validTypeType137, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Population', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType137' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(KeyDefinition_correspondsTo_UniverseType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='KeyDefinition_correspondsTo_UniverseType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(KeyDefinition_correspondsTo_UniverseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType137
            self.validate_validTypeType137(self.validType[-1])
# end class KeyDefinition_correspondsTo_UniverseType


class KeyDefinition_correspondsTo_UnitType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("KeyDefinition_correspondsTo_UnitType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyDefinition_correspondsTo_UnitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyDefinition_correspondsTo_UnitType.subclass:
            return KeyDefinition_correspondsTo_UnitType.subclass(*args_, **kwargs_)
        else:
            return KeyDefinition_correspondsTo_UnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType138(self, value):
        result = True
        # Validate type validTypeType138, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Unit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType138' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(KeyDefinition_correspondsTo_UnitType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='KeyDefinition_correspondsTo_UnitType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(KeyDefinition_correspondsTo_UnitType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType138
            self.validate_validTypeType138(self.validType[-1])
# end class KeyDefinition_correspondsTo_UnitType


class KeyDefinition_has_KeyDefinitionMemberType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("KeyDefinition_has_KeyDefinitionMemberType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType139(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyDefinition_has_KeyDefinitionMemberType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyDefinition_has_KeyDefinitionMemberType.subclass:
            return KeyDefinition_has_KeyDefinitionMemberType.subclass(*args_, **kwargs_)
        else:
            return KeyDefinition_has_KeyDefinitionMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType139(self, value):
        result = True
        # Validate type validTypeType139, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['KeyDefinitionMember']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType139' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(KeyDefinition_has_KeyDefinitionMemberType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='KeyDefinition_has_KeyDefinitionMemberType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(KeyDefinition_has_KeyDefinitionMemberType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType139
            self.validate_validTypeType139(self.validType)
# end class KeyDefinition_has_KeyDefinitionMemberType


class KeyMember_isBasedOn_DataStructureComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("KeyMember_isBasedOn_DataStructureComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyMember_isBasedOn_DataStructureComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyMember_isBasedOn_DataStructureComponentType.subclass:
            return KeyMember_isBasedOn_DataStructureComponentType.subclass(*args_, **kwargs_)
        else:
            return KeyMember_isBasedOn_DataStructureComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType140(self, value):
        result = True
        # Validate type validTypeType140, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AttributeComponent', 'ContextualComponent', 'DataStructure', 'DataStructureComponent', 'DimensionComponent', 'DimensionalDataStructure', 'IdentifierComponent', 'KeyValueStructure', 'LongDataStructure', 'MeasureComponent', 'QualifiedMeasure', 'SyntheticIdComponent', 'VariableDescriptorComponent', 'VariableValueComponent', 'WideDataStructure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType140' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(KeyMember_isBasedOn_DataStructureComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='KeyMember_isBasedOn_DataStructureComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(KeyMember_isBasedOn_DataStructureComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType140
            self.validate_validTypeType140(self.validType[-1])
# end class KeyMember_isBasedOn_DataStructureComponentType


class Level_isDefinedBy_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Level_isDefinedBy_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Level_isDefinedBy_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Level_isDefinedBy_ConceptType.subclass:
            return Level_isDefinedBy_ConceptType.subclass(*args_, **kwargs_)
        else:
            return Level_isDefinedBy_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType141(self, value):
        result = True
        # Validate type validTypeType141, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType141' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Level_isDefinedBy_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Level_isDefinedBy_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Level_isDefinedBy_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType141
            self.validate_validTypeType141(self.validType[-1])
# end class Level_isDefinedBy_ConceptType


class Level_groups_ClassificationItemType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Level_groups_ClassificationItemType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Level_groups_ClassificationItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Level_groups_ClassificationItemType.subclass:
            return Level_groups_ClassificationItemType.subclass(*args_, **kwargs_)
        else:
            return Level_groups_ClassificationItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType142(self, value):
        result = True
        # Validate type validTypeType142, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationItem']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType142' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Level_groups_ClassificationItemType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Level_groups_ClassificationItemType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Level_groups_ClassificationItemType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType142
            self.validate_validTypeType142(self.validType[-1])
# end class Level_groups_ClassificationItemType


class LevelStructure_has_LevelType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LevelStructure_has_LevelType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LevelStructure_has_LevelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LevelStructure_has_LevelType.subclass:
            return LevelStructure_has_LevelType.subclass(*args_, **kwargs_)
        else:
            return LevelStructure_has_LevelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType143(self, value):
        result = True
        # Validate type validTypeType143, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Level']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType143' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(LevelStructure_has_LevelType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LevelStructure_has_LevelType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LevelStructure_has_LevelType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType143
            self.validate_validTypeType143(self.validType[-1])
# end class LevelStructure_has_LevelType


class LogicalRecord_organizes_DataSetType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LogicalRecord_organizes_DataSetType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalRecord_organizes_DataSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalRecord_organizes_DataSetType.subclass:
            return LogicalRecord_organizes_DataSetType.subclass(*args_, **kwargs_)
        else:
            return LogicalRecord_organizes_DataSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType144(self, value):
        result = True
        # Validate type validTypeType144, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataSet', 'DimensionalDataSet', 'KeyValueDataStore', 'LongDataSet', 'WideDataSet']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType144' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(LogicalRecord_organizes_DataSetType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LogicalRecord_organizes_DataSetType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LogicalRecord_organizes_DataSetType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType144
            self.validate_validTypeType144(self.validType[-1])
# end class LogicalRecord_organizes_DataSetType


class LogicalRecord_isDefinedBy_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LogicalRecord_isDefinedBy_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalRecord_isDefinedBy_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalRecord_isDefinedBy_ConceptType.subclass:
            return LogicalRecord_isDefinedBy_ConceptType.subclass(*args_, **kwargs_)
        else:
            return LogicalRecord_isDefinedBy_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType145(self, value):
        result = True
        # Validate type validTypeType145, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType145' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(LogicalRecord_isDefinedBy_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LogicalRecord_isDefinedBy_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LogicalRecord_isDefinedBy_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType145
            self.validate_validTypeType145(self.validType[-1])
# end class LogicalRecord_isDefinedBy_ConceptType


class LogicalRecord_has_InstanceVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LogicalRecord_has_InstanceVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalRecord_has_InstanceVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalRecord_has_InstanceVariableType.subclass:
            return LogicalRecord_has_InstanceVariableType.subclass(*args_, **kwargs_)
        else:
            return LogicalRecord_has_InstanceVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType146(self, value):
        result = True
        # Validate type validTypeType146, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['InstanceVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType146' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(LogicalRecord_has_InstanceVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LogicalRecord_has_InstanceVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LogicalRecord_has_InstanceVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType146
            self.validate_validTypeType146(self.validType[-1])
# end class LogicalRecord_has_InstanceVariableType


class LogicalRecordPosition_indexes_LogicalRecordType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LogicalRecordPosition_indexes_LogicalRecordType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalRecordPosition_indexes_LogicalRecordType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalRecordPosition_indexes_LogicalRecordType.subclass:
            return LogicalRecordPosition_indexes_LogicalRecordType.subclass(*args_, **kwargs_)
        else:
            return LogicalRecordPosition_indexes_LogicalRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType147(self, value):
        result = True
        # Validate type validTypeType147, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LogicalRecord']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType147' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(LogicalRecordPosition_indexes_LogicalRecordType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LogicalRecordPosition_indexes_LogicalRecordType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LogicalRecordPosition_indexes_LogicalRecordType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType147
            self.validate_validTypeType147(self.validType[-1])
# end class LogicalRecordPosition_indexes_LogicalRecordType


class LogicalRecordRelationStructure_structures_DataStoreType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LogicalRecordRelationStructure_structures_DataStoreType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalRecordRelationStructure_structures_DataStoreType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalRecordRelationStructure_structures_DataStoreType.subclass:
            return LogicalRecordRelationStructure_structures_DataStoreType.subclass(*args_, **kwargs_)
        else:
            return LogicalRecordRelationStructure_structures_DataStoreType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType148(self, value):
        result = True
        # Validate type validTypeType148, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataStore']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType148' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(LogicalRecordRelationStructure_structures_DataStoreType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LogicalRecordRelationStructure_structures_DataStoreType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LogicalRecordRelationStructure_structures_DataStoreType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType148
            self.validate_validTypeType148(self.validType[-1])
# end class LogicalRecordRelationStructure_structures_DataStoreType


class LogicalRecordRelationStructure_has_LogicalRecordRelationshipType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LogicalRecordRelationStructure_has_LogicalRecordRelationshipType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType149(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalRecordRelationStructure_has_LogicalRecordRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalRecordRelationStructure_has_LogicalRecordRelationshipType.subclass:
            return LogicalRecordRelationStructure_has_LogicalRecordRelationshipType.subclass(*args_, **kwargs_)
        else:
            return LogicalRecordRelationStructure_has_LogicalRecordRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType149(self, value):
        result = True
        # Validate type validTypeType149, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LogicalRecordRelationship']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType149' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(LogicalRecordRelationStructure_has_LogicalRecordRelationshipType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LogicalRecordRelationStructure_has_LogicalRecordRelationshipType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LogicalRecordRelationStructure_has_LogicalRecordRelationshipType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType149
            self.validate_validTypeType149(self.validType)
# end class LogicalRecordRelationStructure_has_LogicalRecordRelationshipType


class LogicalRecordRelationship_hasTarget_LogicalRecordType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LogicalRecordRelationship_hasTarget_LogicalRecordType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalRecordRelationship_hasTarget_LogicalRecordType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalRecordRelationship_hasTarget_LogicalRecordType.subclass:
            return LogicalRecordRelationship_hasTarget_LogicalRecordType.subclass(*args_, **kwargs_)
        else:
            return LogicalRecordRelationship_hasTarget_LogicalRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType150(self, value):
        result = True
        # Validate type validTypeType150, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LogicalRecord']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType150' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(LogicalRecordRelationship_hasTarget_LogicalRecordType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LogicalRecordRelationship_hasTarget_LogicalRecordType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LogicalRecordRelationship_hasTarget_LogicalRecordType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType150
            self.validate_validTypeType150(self.validType[-1])
# end class LogicalRecordRelationship_hasTarget_LogicalRecordType


class LogicalRecordRelationship_hasSource_LogicalRecordType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LogicalRecordRelationship_hasSource_LogicalRecordType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalRecordRelationship_hasSource_LogicalRecordType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalRecordRelationship_hasSource_LogicalRecordType.subclass:
            return LogicalRecordRelationship_hasSource_LogicalRecordType.subclass(*args_, **kwargs_)
        else:
            return LogicalRecordRelationship_hasSource_LogicalRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType151(self, value):
        result = True
        # Validate type validTypeType151, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LogicalRecord']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType151' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(LogicalRecordRelationship_hasSource_LogicalRecordType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LogicalRecordRelationship_hasSource_LogicalRecordType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LogicalRecordRelationship_hasSource_LogicalRecordType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType151
            self.validate_validTypeType151(self.validType[-1])
# end class LogicalRecordRelationship_hasSource_LogicalRecordType


class MainKeyMember_hasValueFrom_SubstantiveValueDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MainKeyMember_hasValueFrom_SubstantiveValueDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MainKeyMember_hasValueFrom_SubstantiveValueDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MainKeyMember_hasValueFrom_SubstantiveValueDomainType.subclass:
            return MainKeyMember_hasValueFrom_SubstantiveValueDomainType.subclass(*args_, **kwargs_)
        else:
            return MainKeyMember_hasValueFrom_SubstantiveValueDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType152(self, value):
        result = True
        # Validate type validTypeType152, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DescriptorValueDomain', 'SubstantiveValueDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType152' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(MainKeyMember_hasValueFrom_SubstantiveValueDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='MainKeyMember_hasValueFrom_SubstantiveValueDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MainKeyMember_hasValueFrom_SubstantiveValueDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType152
            self.validate_validTypeType152(self.validType[-1])
# end class MainKeyMember_hasValueFrom_SubstantiveValueDomainType


class Notation_represents_CategoryType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Notation_represents_CategoryType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Notation_represents_CategoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Notation_represents_CategoryType.subclass:
            return Notation_represents_CategoryType.subclass(*args_, **kwargs_)
        else:
            return Notation_represents_CategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType153(self, value):
        result = True
        # Validate type validTypeType153, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType153' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Notation_represents_CategoryType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Notation_represents_CategoryType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Notation_represents_CategoryType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType153
            self.validate_validTypeType153(self.validType[-1])
# end class Notation_represents_CategoryType


class PhysicalDataSet_isDefinedBy_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalDataSet_isDefinedBy_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalDataSet_isDefinedBy_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalDataSet_isDefinedBy_ConceptType.subclass:
            return PhysicalDataSet_isDefinedBy_ConceptType.subclass(*args_, **kwargs_)
        else:
            return PhysicalDataSet_isDefinedBy_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType154(self, value):
        result = True
        # Validate type validTypeType154, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType154' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalDataSet_isDefinedBy_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalDataSet_isDefinedBy_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalDataSet_isDefinedBy_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType154
            self.validate_validTypeType154(self.validType[-1])
# end class PhysicalDataSet_isDefinedBy_ConceptType


class PhysicalDataSet_formats_DataStoreType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalDataSet_formats_DataStoreType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalDataSet_formats_DataStoreType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalDataSet_formats_DataStoreType.subclass:
            return PhysicalDataSet_formats_DataStoreType.subclass(*args_, **kwargs_)
        else:
            return PhysicalDataSet_formats_DataStoreType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType155(self, value):
        result = True
        # Validate type validTypeType155, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataStore']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType155' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalDataSet_formats_DataStoreType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalDataSet_formats_DataStoreType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalDataSet_formats_DataStoreType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType155
            self.validate_validTypeType155(self.validType[-1])
# end class PhysicalDataSet_formats_DataStoreType


class PhysicalDataSet_has_InstanceVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalDataSet_has_InstanceVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalDataSet_has_InstanceVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalDataSet_has_InstanceVariableType.subclass:
            return PhysicalDataSet_has_InstanceVariableType.subclass(*args_, **kwargs_)
        else:
            return PhysicalDataSet_has_InstanceVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType156(self, value):
        result = True
        # Validate type validTypeType156, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['InstanceVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType156' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalDataSet_has_InstanceVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalDataSet_has_InstanceVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalDataSet_has_InstanceVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType156
            self.validate_validTypeType156(self.validType[-1])
# end class PhysicalDataSet_has_InstanceVariableType


class PhysicalDataSet_has_PhysicalRecordSegmentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalDataSet_has_PhysicalRecordSegmentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalDataSet_has_PhysicalRecordSegmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalDataSet_has_PhysicalRecordSegmentType.subclass:
            return PhysicalDataSet_has_PhysicalRecordSegmentType.subclass(*args_, **kwargs_)
        else:
            return PhysicalDataSet_has_PhysicalRecordSegmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType157(self, value):
        result = True
        # Validate type validTypeType157, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PhysicalRecordSegment']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType157' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalDataSet_has_PhysicalRecordSegmentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalDataSet_has_PhysicalRecordSegmentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalDataSet_has_PhysicalRecordSegmentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType157
            self.validate_validTypeType157(self.validType[-1])
# end class PhysicalDataSet_has_PhysicalRecordSegmentType


class PhysicalDataSet_has_PhysicalRecordSegmentPositionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalDataSet_has_PhysicalRecordSegmentPositionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType158(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalDataSet_has_PhysicalRecordSegmentPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalDataSet_has_PhysicalRecordSegmentPositionType.subclass:
            return PhysicalDataSet_has_PhysicalRecordSegmentPositionType.subclass(*args_, **kwargs_)
        else:
            return PhysicalDataSet_has_PhysicalRecordSegmentPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType158(self, value):
        result = True
        # Validate type validTypeType158, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PhysicalRecordSegmentPosition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType158' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(PhysicalDataSet_has_PhysicalRecordSegmentPositionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalDataSet_has_PhysicalRecordSegmentPositionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalDataSet_has_PhysicalRecordSegmentPositionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType158
            self.validate_validTypeType158(self.validType)
# end class PhysicalDataSet_has_PhysicalRecordSegmentPositionType


class PhysicalDataSetStructure_structures_PhysicalDataSetType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalDataSetStructure_structures_PhysicalDataSetType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalDataSetStructure_structures_PhysicalDataSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalDataSetStructure_structures_PhysicalDataSetType.subclass:
            return PhysicalDataSetStructure_structures_PhysicalDataSetType.subclass(*args_, **kwargs_)
        else:
            return PhysicalDataSetStructure_structures_PhysicalDataSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType159(self, value):
        result = True
        # Validate type validTypeType159, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PhysicalDataSet']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType159' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalDataSetStructure_structures_PhysicalDataSetType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalDataSetStructure_structures_PhysicalDataSetType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalDataSetStructure_structures_PhysicalDataSetType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType159
            self.validate_validTypeType159(self.validType[-1])
# end class PhysicalDataSetStructure_structures_PhysicalDataSetType


class PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationshipType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationshipType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType160(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationshipType.subclass:
            return PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationshipType.subclass(*args_, **kwargs_)
        else:
            return PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType160(self, value):
        result = True
        # Validate type validTypeType160, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PhysicalRecordSegmentRelationship']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType160' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationshipType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationshipType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationshipType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType160
            self.validate_validTypeType160(self.validType)
# end class PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationshipType


class PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayoutType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayoutType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayoutType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayoutType.subclass:
            return PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayoutType.subclass(*args_, **kwargs_)
        else:
            return PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayoutType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType161(self, value):
        result = True
        # Validate type validTypeType161, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PhysicalSegmentLayout', 'UnitSegmentLayout']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType161' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayoutType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayoutType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayoutType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType161
            self.validate_validTypeType161(self.validType[-1])
# end class PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayoutType


class PhysicalLayoutRelationStructure_has_ValueMappingRelationshipType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalLayoutRelationStructure_has_ValueMappingRelationshipType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType162(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalLayoutRelationStructure_has_ValueMappingRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalLayoutRelationStructure_has_ValueMappingRelationshipType.subclass:
            return PhysicalLayoutRelationStructure_has_ValueMappingRelationshipType.subclass(*args_, **kwargs_)
        else:
            return PhysicalLayoutRelationStructure_has_ValueMappingRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType162(self, value):
        result = True
        # Validate type validTypeType162, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ValueMappingRelationship']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType162' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(PhysicalLayoutRelationStructure_has_ValueMappingRelationshipType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalLayoutRelationStructure_has_ValueMappingRelationshipType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalLayoutRelationStructure_has_ValueMappingRelationshipType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType162
            self.validate_validTypeType162(self.validType)
# end class PhysicalLayoutRelationStructure_has_ValueMappingRelationshipType


class PhysicalRecordSegment_represents_PopulationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalRecordSegment_represents_PopulationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegment_represents_PopulationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegment_represents_PopulationType.subclass:
            return PhysicalRecordSegment_represents_PopulationType.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegment_represents_PopulationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType163(self, value):
        result = True
        # Validate type validTypeType163, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Population']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType163' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalRecordSegment_represents_PopulationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegment_represents_PopulationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalRecordSegment_represents_PopulationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType163
            self.validate_validTypeType163(self.validType[-1])
# end class PhysicalRecordSegment_represents_PopulationType


class PhysicalRecordSegment_isDefinedBy_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalRecordSegment_isDefinedBy_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegment_isDefinedBy_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegment_isDefinedBy_ConceptType.subclass:
            return PhysicalRecordSegment_isDefinedBy_ConceptType.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegment_isDefinedBy_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType164(self, value):
        result = True
        # Validate type validTypeType164, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType164' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalRecordSegment_isDefinedBy_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegment_isDefinedBy_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalRecordSegment_isDefinedBy_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType164
            self.validate_validTypeType164(self.validType[-1])
# end class PhysicalRecordSegment_isDefinedBy_ConceptType


class PhysicalRecordSegment_has_PhysicalSegmentLayoutType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalRecordSegment_has_PhysicalSegmentLayoutType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegment_has_PhysicalSegmentLayoutType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegment_has_PhysicalSegmentLayoutType.subclass:
            return PhysicalRecordSegment_has_PhysicalSegmentLayoutType.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegment_has_PhysicalSegmentLayoutType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType165(self, value):
        result = True
        # Validate type validTypeType165, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PhysicalSegmentLayout', 'UnitSegmentLayout']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType165' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalRecordSegment_has_PhysicalSegmentLayoutType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegment_has_PhysicalSegmentLayoutType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalRecordSegment_has_PhysicalSegmentLayoutType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType165
            self.validate_validTypeType165(self.validType[-1])
# end class PhysicalRecordSegment_has_PhysicalSegmentLayoutType


class PhysicalRecordSegment_mapsTo_LogicalRecordType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalRecordSegment_mapsTo_LogicalRecordType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegment_mapsTo_LogicalRecordType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegment_mapsTo_LogicalRecordType.subclass:
            return PhysicalRecordSegment_mapsTo_LogicalRecordType.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegment_mapsTo_LogicalRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType166(self, value):
        result = True
        # Validate type validTypeType166, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LogicalRecord']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType166' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalRecordSegment_mapsTo_LogicalRecordType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegment_mapsTo_LogicalRecordType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalRecordSegment_mapsTo_LogicalRecordType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType166
            self.validate_validTypeType166(self.validType[-1])
# end class PhysicalRecordSegment_mapsTo_LogicalRecordType


class PhysicalRecordSegment_has_DataPointPositionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalRecordSegment_has_DataPointPositionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType167(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegment_has_DataPointPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegment_has_DataPointPositionType.subclass:
            return PhysicalRecordSegment_has_DataPointPositionType.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegment_has_DataPointPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType167(self, value):
        result = True
        # Validate type validTypeType167, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataPointPosition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType167' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(PhysicalRecordSegment_has_DataPointPositionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegment_has_DataPointPositionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalRecordSegment_has_DataPointPositionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType167
            self.validate_validTypeType167(self.validType)
# end class PhysicalRecordSegment_has_DataPointPositionType


class PhysicalRecordSegment_has_DataPointType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalRecordSegment_has_DataPointType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegment_has_DataPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegment_has_DataPointType.subclass:
            return PhysicalRecordSegment_has_DataPointType.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegment_has_DataPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType168(self, value):
        result = True
        # Validate type validTypeType168, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataPoint']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType168' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalRecordSegment_has_DataPointType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegment_has_DataPointType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalRecordSegment_has_DataPointType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType168
            self.validate_validTypeType168(self.validType[-1])
# end class PhysicalRecordSegment_has_DataPointType


class PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegmentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegmentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegmentType.subclass:
            return PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegmentType.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType169(self, value):
        result = True
        # Validate type validTypeType169, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PhysicalRecordSegment']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType169' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegmentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegmentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegmentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType169
            self.validate_validTypeType169(self.validType[-1])
# end class PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegmentType


class PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegmentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegmentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegmentType.subclass:
            return PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegmentType.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType170(self, value):
        result = True
        # Validate type validTypeType170, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PhysicalRecordSegment']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType170' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegmentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegmentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegmentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType170
            self.validate_validTypeType170(self.validType[-1])
# end class PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegmentType


class PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegmentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegmentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegmentType.subclass:
            return PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegmentType.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType171(self, value):
        result = True
        # Validate type validTypeType171, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PhysicalRecordSegment']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType171' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegmentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegmentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegmentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType171
            self.validate_validTypeType171(self.validType[-1])
# end class PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegmentType


class PhysicalRecordSegmentStructure_structures_PhysicalRecordSegmentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalRecordSegmentStructure_structures_PhysicalRecordSegmentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegmentStructure_structures_PhysicalRecordSegmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegmentStructure_structures_PhysicalRecordSegmentType.subclass:
            return PhysicalRecordSegmentStructure_structures_PhysicalRecordSegmentType.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegmentStructure_structures_PhysicalRecordSegmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType172(self, value):
        result = True
        # Validate type validTypeType172, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PhysicalRecordSegment']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType172' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalRecordSegmentStructure_structures_PhysicalRecordSegmentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegmentStructure_structures_PhysicalRecordSegmentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalRecordSegmentStructure_structures_PhysicalRecordSegmentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType172
            self.validate_validTypeType172(self.validType[-1])
# end class PhysicalRecordSegmentStructure_structures_PhysicalRecordSegmentType


class PhysicalRecordSegmentStructure_has_DataPointRelationshipType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalRecordSegmentStructure_has_DataPointRelationshipType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType173(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalRecordSegmentStructure_has_DataPointRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalRecordSegmentStructure_has_DataPointRelationshipType.subclass:
            return PhysicalRecordSegmentStructure_has_DataPointRelationshipType.subclass(*args_, **kwargs_)
        else:
            return PhysicalRecordSegmentStructure_has_DataPointRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType173(self, value):
        result = True
        # Validate type validTypeType173, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataPointRelationship']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType173' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(PhysicalRecordSegmentStructure_has_DataPointRelationshipType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalRecordSegmentStructure_has_DataPointRelationshipType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalRecordSegmentStructure_has_DataPointRelationshipType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType173
            self.validate_validTypeType173(self.validType)
# end class PhysicalRecordSegmentStructure_has_DataPointRelationshipType


class PhysicalSegmentLayout_isDefinedBy_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalSegmentLayout_isDefinedBy_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalSegmentLayout_isDefinedBy_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalSegmentLayout_isDefinedBy_ConceptType.subclass:
            return PhysicalSegmentLayout_isDefinedBy_ConceptType.subclass(*args_, **kwargs_)
        else:
            return PhysicalSegmentLayout_isDefinedBy_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType174(self, value):
        result = True
        # Validate type validTypeType174, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType174' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalSegmentLayout_isDefinedBy_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalSegmentLayout_isDefinedBy_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalSegmentLayout_isDefinedBy_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType174
            self.validate_validTypeType174(self.validType[-1])
# end class PhysicalSegmentLayout_isDefinedBy_ConceptType


class PhysicalSegmentLayout_formats_LogicalRecordType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalSegmentLayout_formats_LogicalRecordType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalSegmentLayout_formats_LogicalRecordType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalSegmentLayout_formats_LogicalRecordType.subclass:
            return PhysicalSegmentLayout_formats_LogicalRecordType.subclass(*args_, **kwargs_)
        else:
            return PhysicalSegmentLayout_formats_LogicalRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType175(self, value):
        result = True
        # Validate type validTypeType175, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LogicalRecord']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType175' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalSegmentLayout_formats_LogicalRecordType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalSegmentLayout_formats_LogicalRecordType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalSegmentLayout_formats_LogicalRecordType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType175
            self.validate_validTypeType175(self.validType[-1])
# end class PhysicalSegmentLayout_formats_LogicalRecordType


class PhysicalSegmentLayout_has_ValueMappingType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalSegmentLayout_has_ValueMappingType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalSegmentLayout_has_ValueMappingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalSegmentLayout_has_ValueMappingType.subclass:
            return PhysicalSegmentLayout_has_ValueMappingType.subclass(*args_, **kwargs_)
        else:
            return PhysicalSegmentLayout_has_ValueMappingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType176(self, value):
        result = True
        # Validate type validTypeType176, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ValueMapping']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType176' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(PhysicalSegmentLayout_has_ValueMappingType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalSegmentLayout_has_ValueMappingType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalSegmentLayout_has_ValueMappingType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType176
            self.validate_validTypeType176(self.validType[-1])
# end class PhysicalSegmentLayout_has_ValueMappingType


class PhysicalSegmentLayout_has_ValueMappingPositionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PhysicalSegmentLayout_has_ValueMappingPositionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType177(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalSegmentLayout_has_ValueMappingPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalSegmentLayout_has_ValueMappingPositionType.subclass:
            return PhysicalSegmentLayout_has_ValueMappingPositionType.subclass(*args_, **kwargs_)
        else:
            return PhysicalSegmentLayout_has_ValueMappingPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType177(self, value):
        result = True
        # Validate type validTypeType177, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ValueMappingPosition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType177' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(PhysicalSegmentLayout_has_ValueMappingPositionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PhysicalSegmentLayout_has_ValueMappingPositionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PhysicalSegmentLayout_has_ValueMappingPositionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType177
            self.validate_validTypeType177(self.validType)
# end class PhysicalSegmentLayout_has_ValueMappingPositionType


class Population_isComposedOf_UnitType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Population_isComposedOf_UnitType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Population_isComposedOf_UnitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Population_isComposedOf_UnitType.subclass:
            return Population_isComposedOf_UnitType.subclass(*args_, **kwargs_)
        else:
            return Population_isComposedOf_UnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType178(self, value):
        result = True
        # Validate type validTypeType178, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Unit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType178' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Population_isComposedOf_UnitType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Population_isComposedOf_UnitType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Population_isComposedOf_UnitType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType178
            self.validate_validTypeType178(self.validType[-1])
# end class Population_isComposedOf_UnitType


class PrimaryKey_isComposedOf_PrimaryKeyComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PrimaryKey_isComposedOf_PrimaryKeyComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType179(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrimaryKey_isComposedOf_PrimaryKeyComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrimaryKey_isComposedOf_PrimaryKeyComponentType.subclass:
            return PrimaryKey_isComposedOf_PrimaryKeyComponentType.subclass(*args_, **kwargs_)
        else:
            return PrimaryKey_isComposedOf_PrimaryKeyComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType179(self, value):
        result = True
        # Validate type validTypeType179, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PrimaryKeyComponent']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType179' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(PrimaryKey_isComposedOf_PrimaryKeyComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PrimaryKey_isComposedOf_PrimaryKeyComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PrimaryKey_isComposedOf_PrimaryKeyComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType179
            self.validate_validTypeType179(self.validType)
# end class PrimaryKey_isComposedOf_PrimaryKeyComponentType


class PrimaryKeyComponent_correspondsTo_DataStructureComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PrimaryKeyComponent_correspondsTo_DataStructureComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType180(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrimaryKeyComponent_correspondsTo_DataStructureComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrimaryKeyComponent_correspondsTo_DataStructureComponentType.subclass:
            return PrimaryKeyComponent_correspondsTo_DataStructureComponentType.subclass(*args_, **kwargs_)
        else:
            return PrimaryKeyComponent_correspondsTo_DataStructureComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType180(self, value):
        result = True
        # Validate type validTypeType180, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AttributeComponent', 'ContextualComponent', 'DataStructure', 'DataStructureComponent', 'DimensionComponent', 'DimensionalDataStructure', 'IdentifierComponent', 'KeyValueStructure', 'LongDataStructure', 'MeasureComponent', 'QualifiedMeasure', 'SyntheticIdComponent', 'VariableDescriptorComponent', 'VariableValueComponent', 'WideDataStructure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType180' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(PrimaryKeyComponent_correspondsTo_DataStructureComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PrimaryKeyComponent_correspondsTo_DataStructureComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PrimaryKeyComponent_correspondsTo_DataStructureComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType180
            self.validate_validTypeType180(self.validType)
# end class PrimaryKeyComponent_correspondsTo_DataStructureComponentType


class ProcessingAgent_performs_ActivityType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ProcessingAgent_performs_ActivityType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessingAgent_performs_ActivityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessingAgent_performs_ActivityType.subclass:
            return ProcessingAgent_performs_ActivityType.subclass(*args_, **kwargs_)
        else:
            return ProcessingAgent_performs_ActivityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType181(self, value):
        result = True
        # Validate type validTypeType181, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Activity', 'Step']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType181' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ProcessingAgent_performs_ActivityType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ProcessingAgent_performs_ActivityType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ProcessingAgent_performs_ActivityType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType181
            self.validate_validTypeType181(self.validType[-1])
# end class ProcessingAgent_performs_ActivityType


class ProcessingAgent_operatesOn_ProductionEnvironmentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ProcessingAgent_operatesOn_ProductionEnvironmentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessingAgent_operatesOn_ProductionEnvironmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessingAgent_operatesOn_ProductionEnvironmentType.subclass:
            return ProcessingAgent_operatesOn_ProductionEnvironmentType.subclass(*args_, **kwargs_)
        else:
            return ProcessingAgent_operatesOn_ProductionEnvironmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType182(self, value):
        result = True
        # Validate type validTypeType182, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ProductionEnvironment']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType182' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ProcessingAgent_operatesOn_ProductionEnvironmentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ProcessingAgent_operatesOn_ProductionEnvironmentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ProcessingAgent_operatesOn_ProductionEnvironmentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType182
            self.validate_validTypeType182(self.validType[-1])
# end class ProcessingAgent_operatesOn_ProductionEnvironmentType


class QualifiedMeasure_refines_MeasureComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QualifiedMeasure_refines_MeasureComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QualifiedMeasure_refines_MeasureComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QualifiedMeasure_refines_MeasureComponentType.subclass:
            return QualifiedMeasure_refines_MeasureComponentType.subclass(*args_, **kwargs_)
        else:
            return QualifiedMeasure_refines_MeasureComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType183(self, value):
        result = True
        # Validate type validTypeType183, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MeasureComponent', 'QualifiedMeasure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType183' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(QualifiedMeasure_refines_MeasureComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='QualifiedMeasure_refines_MeasureComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QualifiedMeasure_refines_MeasureComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType183
            self.validate_validTypeType183(self.validType[-1])
# end class QualifiedMeasure_refines_MeasureComponentType


class RecordRelation_maps_LogicalRecordType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RecordRelation_maps_LogicalRecordType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RecordRelation_maps_LogicalRecordType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RecordRelation_maps_LogicalRecordType.subclass:
            return RecordRelation_maps_LogicalRecordType.subclass(*args_, **kwargs_)
        else:
            return RecordRelation_maps_LogicalRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType184(self, value):
        result = True
        # Validate type validTypeType184, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LogicalRecord']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType184' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(RecordRelation_maps_LogicalRecordType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RecordRelation_maps_LogicalRecordType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RecordRelation_maps_LogicalRecordType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType184
            self.validate_validTypeType184(self.validType[-1])
# end class RecordRelation_maps_LogicalRecordType


class RecordRelation_has_InstanceVariableMapType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RecordRelation_has_InstanceVariableMapType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType185(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RecordRelation_has_InstanceVariableMapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RecordRelation_has_InstanceVariableMapType.subclass:
            return RecordRelation_has_InstanceVariableMapType.subclass(*args_, **kwargs_)
        else:
            return RecordRelation_has_InstanceVariableMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType185(self, value):
        result = True
        # Validate type validTypeType185, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['InstanceVariableMap']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType185' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(RecordRelation_has_InstanceVariableMapType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RecordRelation_has_InstanceVariableMapType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RecordRelation_has_InstanceVariableMapType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType185
            self.validate_validTypeType185(self.validType)
# end class RecordRelation_has_InstanceVariableMapType


class ReferenceValue_correspondsTo_VariableValueComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReferenceValue_correspondsTo_VariableValueComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceValue_correspondsTo_VariableValueComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceValue_correspondsTo_VariableValueComponentType.subclass:
            return ReferenceValue_correspondsTo_VariableValueComponentType.subclass(*args_, **kwargs_)
        else:
            return ReferenceValue_correspondsTo_VariableValueComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType186(self, value):
        result = True
        # Validate type validTypeType186, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['VariableValueComponent']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType186' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ReferenceValue_correspondsTo_VariableValueComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ReferenceValue_correspondsTo_VariableValueComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReferenceValue_correspondsTo_VariableValueComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType186
            self.validate_validTypeType186(self.validType[-1])
# end class ReferenceValue_correspondsTo_VariableValueComponentType


class ReferenceValue_hasValueFrom_ReferenceValueDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReferenceValue_hasValueFrom_ReferenceValueDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceValue_hasValueFrom_ReferenceValueDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceValue_hasValueFrom_ReferenceValueDomainType.subclass:
            return ReferenceValue_hasValueFrom_ReferenceValueDomainType.subclass(*args_, **kwargs_)
        else:
            return ReferenceValue_hasValueFrom_ReferenceValueDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType187(self, value):
        result = True
        # Validate type validTypeType187, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ReferenceValueDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType187' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ReferenceValue_hasValueFrom_ReferenceValueDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ReferenceValue_hasValueFrom_ReferenceValueDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReferenceValue_hasValueFrom_ReferenceValueDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType187
            self.validate_validTypeType187(self.validType[-1])
# end class ReferenceValue_hasValueFrom_ReferenceValueDomainType


class ReferenceVariable_takesValuesFrom_ReferenceValueDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReferenceVariable_takesValuesFrom_ReferenceValueDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceVariable_takesValuesFrom_ReferenceValueDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceVariable_takesValuesFrom_ReferenceValueDomainType.subclass:
            return ReferenceVariable_takesValuesFrom_ReferenceValueDomainType.subclass(*args_, **kwargs_)
        else:
            return ReferenceVariable_takesValuesFrom_ReferenceValueDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType188(self, value):
        result = True
        # Validate type validTypeType188, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ReferenceValueDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType188' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ReferenceVariable_takesValuesFrom_ReferenceValueDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ReferenceVariable_takesValuesFrom_ReferenceValueDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReferenceVariable_takesValuesFrom_ReferenceValueDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType188
            self.validate_validTypeType188(self.validType[-1])
# end class ReferenceVariable_takesValuesFrom_ReferenceValueDomainType


class RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomainType.subclass:
            return RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomainType.subclass(*args_, **kwargs_)
        else:
            return RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType189(self, value):
        result = True
        # Validate type validTypeType189, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SentinelValueDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType189' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType189
            self.validate_validTypeType189(self.validType[-1])
# end class RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomainType


class RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomainType.subclass:
            return RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomainType.subclass(*args_, **kwargs_)
        else:
            return RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType190(self, value):
        result = True
        # Validate type validTypeType190, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DescriptorValueDomain', 'SubstantiveValueDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType190' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType190
            self.validate_validTypeType190(self.validType[-1])
# end class RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomainType


class RevisableDatum_correspondsTo_RevisionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RevisableDatum_correspondsTo_RevisionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RevisableDatum_correspondsTo_RevisionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RevisableDatum_correspondsTo_RevisionType.subclass:
            return RevisableDatum_correspondsTo_RevisionType.subclass(*args_, **kwargs_)
        else:
            return RevisableDatum_correspondsTo_RevisionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType191(self, value):
        result = True
        # Validate type validTypeType191, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Revision']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType191' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(RevisableDatum_correspondsTo_RevisionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RevisableDatum_correspondsTo_RevisionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RevisableDatum_correspondsTo_RevisionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType191
            self.validate_validTypeType191(self.validType[-1])
# end class RevisableDatum_correspondsTo_RevisionType


class Rule_hasPrecondition_ConditionalControlLogicType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Rule_hasPrecondition_ConditionalControlLogicType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Rule_hasPrecondition_ConditionalControlLogicType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Rule_hasPrecondition_ConditionalControlLogicType.subclass:
            return Rule_hasPrecondition_ConditionalControlLogicType.subclass(*args_, **kwargs_)
        else:
            return Rule_hasPrecondition_ConditionalControlLogicType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType192(self, value):
        result = True
        # Validate type validTypeType192, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ConditionalControlLogic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType192' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Rule_hasPrecondition_ConditionalControlLogicType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Rule_hasPrecondition_ConditionalControlLogicType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Rule_hasPrecondition_ConditionalControlLogicType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType192
            self.validate_validTypeType192(self.validType[-1])
# end class Rule_hasPrecondition_ConditionalControlLogicType


class RuleBasedScheduling_has_RuleSetType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RuleBasedScheduling_has_RuleSetType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType193(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RuleBasedScheduling_has_RuleSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RuleBasedScheduling_has_RuleSetType.subclass:
            return RuleBasedScheduling_has_RuleSetType.subclass(*args_, **kwargs_)
        else:
            return RuleBasedScheduling_has_RuleSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType193(self, value):
        result = True
        # Validate type validTypeType193, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RuleSet']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType193' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(RuleBasedScheduling_has_RuleSetType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RuleBasedScheduling_has_RuleSetType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RuleBasedScheduling_has_RuleSetType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType193
            self.validate_validTypeType193(self.validType)
# end class RuleBasedScheduling_has_RuleSetType


class RuleBasedScheduling_has_CuratorType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RuleBasedScheduling_has_CuratorType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType194(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RuleBasedScheduling_has_CuratorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RuleBasedScheduling_has_CuratorType.subclass:
            return RuleBasedScheduling_has_CuratorType.subclass(*args_, **kwargs_)
        else:
            return RuleBasedScheduling_has_CuratorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType194(self, value):
        result = True
        # Validate type validTypeType194, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Curator']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType194' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(RuleBasedScheduling_has_CuratorType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RuleBasedScheduling_has_CuratorType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RuleBasedScheduling_has_CuratorType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType194
            self.validate_validTypeType194(self.validType)
# end class RuleBasedScheduling_has_CuratorType


class RuleSet_has_RuleType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RuleSet_has_RuleType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType195(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RuleSet_has_RuleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RuleSet_has_RuleType.subclass:
            return RuleSet_has_RuleType.subclass(*args_, **kwargs_)
        else:
            return RuleSet_has_RuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType195(self, value):
        result = True
        # Validate type validTypeType195, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Rule']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType195' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(RuleSet_has_RuleType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='RuleSet_has_RuleType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RuleSet_has_RuleType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType195
            self.validate_validTypeType195(self.validType)
# end class RuleSet_has_RuleType


class ScopedMeasure_circumscribes_DimensionalKeyDefinitionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ScopedMeasure_circumscribes_DimensionalKeyDefinitionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScopedMeasure_circumscribes_DimensionalKeyDefinitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScopedMeasure_circumscribes_DimensionalKeyDefinitionType.subclass:
            return ScopedMeasure_circumscribes_DimensionalKeyDefinitionType.subclass(*args_, **kwargs_)
        else:
            return ScopedMeasure_circumscribes_DimensionalKeyDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType196(self, value):
        result = True
        # Validate type validTypeType196, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DimensionalKeyDefinition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType196' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ScopedMeasure_circumscribes_DimensionalKeyDefinitionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ScopedMeasure_circumscribes_DimensionalKeyDefinitionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ScopedMeasure_circumscribes_DimensionalKeyDefinitionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType196
            self.validate_validTypeType196(self.validType[-1])
# end class ScopedMeasure_circumscribes_DimensionalKeyDefinitionType


class ScopedMeasure_restricts_QualifiedMeasureType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ScopedMeasure_restricts_QualifiedMeasureType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScopedMeasure_restricts_QualifiedMeasureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScopedMeasure_restricts_QualifiedMeasureType.subclass:
            return ScopedMeasure_restricts_QualifiedMeasureType.subclass(*args_, **kwargs_)
        else:
            return ScopedMeasure_restricts_QualifiedMeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType197(self, value):
        result = True
        # Validate type validTypeType197, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['QualifiedMeasure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType197' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ScopedMeasure_restricts_QualifiedMeasureType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ScopedMeasure_restricts_QualifiedMeasureType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ScopedMeasure_restricts_QualifiedMeasureType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType197
            self.validate_validTypeType197(self.validType[-1])
# end class ScopedMeasure_restricts_QualifiedMeasureType


class ScopedMeasure_generates_RevisableDatumType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ScopedMeasure_generates_RevisableDatumType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType198(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScopedMeasure_generates_RevisableDatumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScopedMeasure_generates_RevisableDatumType.subclass:
            return ScopedMeasure_generates_RevisableDatumType.subclass(*args_, **kwargs_)
        else:
            return ScopedMeasure_generates_RevisableDatumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType198(self, value):
        result = True
        # Validate type validTypeType198, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RevisableDatum']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType198' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ScopedMeasure_generates_RevisableDatumType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ScopedMeasure_generates_RevisableDatumType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ScopedMeasure_generates_RevisableDatumType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType198
            self.validate_validTypeType198(self.validType)
# end class ScopedMeasure_generates_RevisableDatumType


class SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomainType.subclass:
            return SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomainType.subclass(*args_, **kwargs_)
        else:
            return SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType199(self, value):
        result = True
        # Validate type validTypeType199, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SentinelConceptualDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType199' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType199
            self.validate_validTypeType199(self.validType[-1])
# end class SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomainType


class SentinelValueDomain_takesValuesFrom_EnumerationDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SentinelValueDomain_takesValuesFrom_EnumerationDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SentinelValueDomain_takesValuesFrom_EnumerationDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SentinelValueDomain_takesValuesFrom_EnumerationDomainType.subclass:
            return SentinelValueDomain_takesValuesFrom_EnumerationDomainType.subclass(*args_, **kwargs_)
        else:
            return SentinelValueDomain_takesValuesFrom_EnumerationDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType200(self, value):
        result = True
        # Validate type validTypeType200, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CodeList', 'EnumerationDomain', 'StatisticalClassification']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType200' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(SentinelValueDomain_takesValuesFrom_EnumerationDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SentinelValueDomain_takesValuesFrom_EnumerationDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SentinelValueDomain_takesValuesFrom_EnumerationDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType200
            self.validate_validTypeType200(self.validType[-1])
# end class SentinelValueDomain_takesValuesFrom_EnumerationDomainType


class SentinelValueDomain_isDescribedBy_ValueAndConceptDescriptionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SentinelValueDomain_isDescribedBy_ValueAndConceptDescriptionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SentinelValueDomain_isDescribedBy_ValueAndConceptDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SentinelValueDomain_isDescribedBy_ValueAndConceptDescriptionType.subclass:
            return SentinelValueDomain_isDescribedBy_ValueAndConceptDescriptionType.subclass(*args_, **kwargs_)
        else:
            return SentinelValueDomain_isDescribedBy_ValueAndConceptDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType201(self, value):
        result = True
        # Validate type validTypeType201, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ValueAndConceptDescription']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType201' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(SentinelValueDomain_isDescribedBy_ValueAndConceptDescriptionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SentinelValueDomain_isDescribedBy_ValueAndConceptDescriptionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SentinelValueDomain_isDescribedBy_ValueAndConceptDescriptionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType201
            self.validate_validTypeType201(self.validType[-1])
# end class SentinelValueDomain_isDescribedBy_ValueAndConceptDescriptionType


class Sequence_has_SequencePositionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Sequence_has_SequencePositionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType202(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Sequence_has_SequencePositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Sequence_has_SequencePositionType.subclass:
            return Sequence_has_SequencePositionType.subclass(*args_, **kwargs_)
        else:
            return Sequence_has_SequencePositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType202(self, value):
        result = True
        # Validate type validTypeType202, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SequencePosition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType202' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(Sequence_has_SequencePositionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Sequence_has_SequencePositionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Sequence_has_SequencePositionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType202
            self.validate_validTypeType202(self.validType)
# end class Sequence_has_SequencePositionType


class StatisticalClassification_isMaintainedBy_OrganizationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("StatisticalClassification_isMaintainedBy_OrganizationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatisticalClassification_isMaintainedBy_OrganizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatisticalClassification_isMaintainedBy_OrganizationType.subclass:
            return StatisticalClassification_isMaintainedBy_OrganizationType.subclass(*args_, **kwargs_)
        else:
            return StatisticalClassification_isMaintainedBy_OrganizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType203(self, value):
        result = True
        # Validate type validTypeType203, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Organization']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType203' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(StatisticalClassification_isMaintainedBy_OrganizationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StatisticalClassification_isMaintainedBy_OrganizationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StatisticalClassification_isMaintainedBy_OrganizationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType203
            self.validate_validTypeType203(self.validType[-1])
# end class StatisticalClassification_isMaintainedBy_OrganizationType


class StatisticalClassification_isIndexedBy_ClassificationIndexType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("StatisticalClassification_isIndexedBy_ClassificationIndexType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatisticalClassification_isIndexedBy_ClassificationIndexType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatisticalClassification_isIndexedBy_ClassificationIndexType.subclass:
            return StatisticalClassification_isIndexedBy_ClassificationIndexType.subclass(*args_, **kwargs_)
        else:
            return StatisticalClassification_isIndexedBy_ClassificationIndexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType204(self, value):
        result = True
        # Validate type validTypeType204, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationIndex']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType204' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(StatisticalClassification_isIndexedBy_ClassificationIndexType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StatisticalClassification_isIndexedBy_ClassificationIndexType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StatisticalClassification_isIndexedBy_ClassificationIndexType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType204
            self.validate_validTypeType204(self.validType[-1])
# end class StatisticalClassification_isIndexedBy_ClassificationIndexType


class StatisticalClassification_isVariantOf_StatisticalClassificationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("StatisticalClassification_isVariantOf_StatisticalClassificationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatisticalClassification_isVariantOf_StatisticalClassificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatisticalClassification_isVariantOf_StatisticalClassificationType.subclass:
            return StatisticalClassification_isVariantOf_StatisticalClassificationType.subclass(*args_, **kwargs_)
        else:
            return StatisticalClassification_isVariantOf_StatisticalClassificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType205(self, value):
        result = True
        # Validate type validTypeType205, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['StatisticalClassification']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType205' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(StatisticalClassification_isVariantOf_StatisticalClassificationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StatisticalClassification_isVariantOf_StatisticalClassificationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StatisticalClassification_isVariantOf_StatisticalClassificationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType205
            self.validate_validTypeType205(self.validType[-1])
# end class StatisticalClassification_isVariantOf_StatisticalClassificationType


class StatisticalClassification_isSuccessorOf_StatisticalClassificationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("StatisticalClassification_isSuccessorOf_StatisticalClassificationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatisticalClassification_isSuccessorOf_StatisticalClassificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatisticalClassification_isSuccessorOf_StatisticalClassificationType.subclass:
            return StatisticalClassification_isSuccessorOf_StatisticalClassificationType.subclass(*args_, **kwargs_)
        else:
            return StatisticalClassification_isSuccessorOf_StatisticalClassificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType206(self, value):
        result = True
        # Validate type validTypeType206, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['StatisticalClassification']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType206' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(StatisticalClassification_isSuccessorOf_StatisticalClassificationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StatisticalClassification_isSuccessorOf_StatisticalClassificationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StatisticalClassification_isSuccessorOf_StatisticalClassificationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType206
            self.validate_validTypeType206(self.validType[-1])
# end class StatisticalClassification_isSuccessorOf_StatisticalClassificationType


class StatisticalClassification_isPredecessorOf_StatisticalClassificationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("StatisticalClassification_isPredecessorOf_StatisticalClassificationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatisticalClassification_isPredecessorOf_StatisticalClassificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatisticalClassification_isPredecessorOf_StatisticalClassificationType.subclass:
            return StatisticalClassification_isPredecessorOf_StatisticalClassificationType.subclass(*args_, **kwargs_)
        else:
            return StatisticalClassification_isPredecessorOf_StatisticalClassificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType207(self, value):
        result = True
        # Validate type validTypeType207, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['StatisticalClassification']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType207' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(StatisticalClassification_isPredecessorOf_StatisticalClassificationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StatisticalClassification_isPredecessorOf_StatisticalClassificationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StatisticalClassification_isPredecessorOf_StatisticalClassificationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType207
            self.validate_validTypeType207(self.validType[-1])
# end class StatisticalClassification_isPredecessorOf_StatisticalClassificationType


class StatisticalClassification_has_ClassificationItemPositionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("StatisticalClassification_has_ClassificationItemPositionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType208(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatisticalClassification_has_ClassificationItemPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatisticalClassification_has_ClassificationItemPositionType.subclass:
            return StatisticalClassification_has_ClassificationItemPositionType.subclass(*args_, **kwargs_)
        else:
            return StatisticalClassification_has_ClassificationItemPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType208(self, value):
        result = True
        # Validate type validTypeType208, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationItemPosition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType208' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(StatisticalClassification_has_ClassificationItemPositionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StatisticalClassification_has_ClassificationItemPositionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StatisticalClassification_has_ClassificationItemPositionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType208
            self.validate_validTypeType208(self.validType)
# end class StatisticalClassification_has_ClassificationItemPositionType


class StatisticalClassification_has_ClassificationItemType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("StatisticalClassification_has_ClassificationItemType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatisticalClassification_has_ClassificationItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatisticalClassification_has_ClassificationItemType.subclass:
            return StatisticalClassification_has_ClassificationItemType.subclass(*args_, **kwargs_)
        else:
            return StatisticalClassification_has_ClassificationItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType209(self, value):
        result = True
        # Validate type validTypeType209, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ClassificationItem']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType209' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(StatisticalClassification_has_ClassificationItemType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StatisticalClassification_has_ClassificationItemType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StatisticalClassification_has_ClassificationItemType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType209
            self.validate_validTypeType209(self.validType[-1])
# end class StatisticalClassification_has_ClassificationItemType


class StatisticalClassification_has_LevelStructureType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("StatisticalClassification_has_LevelStructureType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatisticalClassification_has_LevelStructureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatisticalClassification_has_LevelStructureType.subclass:
            return StatisticalClassification_has_LevelStructureType.subclass(*args_, **kwargs_)
        else:
            return StatisticalClassification_has_LevelStructureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType210(self, value):
        result = True
        # Validate type validTypeType210, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LevelStructure']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType210' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(StatisticalClassification_has_LevelStructureType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StatisticalClassification_has_LevelStructureType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StatisticalClassification_has_LevelStructureType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType210
            self.validate_validTypeType210(self.validType[-1])
# end class StatisticalClassification_has_LevelStructureType


class StatisticalClassificationRelationship_hasTarget_StatisticalClassificationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("StatisticalClassificationRelationship_hasTarget_StatisticalClassificationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatisticalClassificationRelationship_hasTarget_StatisticalClassificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatisticalClassificationRelationship_hasTarget_StatisticalClassificationType.subclass:
            return StatisticalClassificationRelationship_hasTarget_StatisticalClassificationType.subclass(*args_, **kwargs_)
        else:
            return StatisticalClassificationRelationship_hasTarget_StatisticalClassificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType211(self, value):
        result = True
        # Validate type validTypeType211, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['StatisticalClassification']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType211' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(StatisticalClassificationRelationship_hasTarget_StatisticalClassificationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StatisticalClassificationRelationship_hasTarget_StatisticalClassificationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StatisticalClassificationRelationship_hasTarget_StatisticalClassificationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType211
            self.validate_validTypeType211(self.validType[-1])
# end class StatisticalClassificationRelationship_hasTarget_StatisticalClassificationType


class StatisticalClassificationRelationship_hasSource_StatisticalClassificationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("StatisticalClassificationRelationship_hasSource_StatisticalClassificationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatisticalClassificationRelationship_hasSource_StatisticalClassificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatisticalClassificationRelationship_hasSource_StatisticalClassificationType.subclass:
            return StatisticalClassificationRelationship_hasSource_StatisticalClassificationType.subclass(*args_, **kwargs_)
        else:
            return StatisticalClassificationRelationship_hasSource_StatisticalClassificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType212(self, value):
        result = True
        # Validate type validTypeType212, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['StatisticalClassification']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType212' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(StatisticalClassificationRelationship_hasSource_StatisticalClassificationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StatisticalClassificationRelationship_hasSource_StatisticalClassificationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StatisticalClassificationRelationship_hasSource_StatisticalClassificationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType212
            self.validate_validTypeType212(self.validType[-1])
# end class StatisticalClassificationRelationship_hasSource_StatisticalClassificationType


class Step_produces_ParameterType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Step_produces_ParameterType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Step_produces_ParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Step_produces_ParameterType.subclass:
            return Step_produces_ParameterType.subclass(*args_, **kwargs_)
        else:
            return Step_produces_ParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType213(self, value):
        result = True
        # Validate type validTypeType213, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Parameter']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType213' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Step_produces_ParameterType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Step_produces_ParameterType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Step_produces_ParameterType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType213
            self.validate_validTypeType213(self.validType[-1])
# end class Step_produces_ParameterType


class Step_receives_ParameterType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Step_receives_ParameterType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Step_receives_ParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Step_receives_ParameterType.subclass:
            return Step_receives_ParameterType.subclass(*args_, **kwargs_)
        else:
            return Step_receives_ParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType214(self, value):
        result = True
        # Validate type validTypeType214, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Parameter']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType214' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Step_receives_ParameterType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Step_receives_ParameterType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Step_receives_ParameterType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType214
            self.validate_validTypeType214(self.validType[-1])
# end class Step_receives_ParameterType


class Step_hasSubStep_StepType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Step_hasSubStep_StepType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Step_hasSubStep_StepType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Step_hasSubStep_StepType.subclass:
            return Step_hasSubStep_StepType.subclass(*args_, **kwargs_)
        else:
            return Step_hasSubStep_StepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType215(self, value):
        result = True
        # Validate type validTypeType215, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Step']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType215' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Step_hasSubStep_StepType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Step_hasSubStep_StepType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Step_hasSubStep_StepType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType215
            self.validate_validTypeType215(self.validType[-1])
# end class Step_hasSubStep_StepType


class SubstantiveValueDomain_takesValuesFrom_EnumerationDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SubstantiveValueDomain_takesValuesFrom_EnumerationDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubstantiveValueDomain_takesValuesFrom_EnumerationDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubstantiveValueDomain_takesValuesFrom_EnumerationDomainType.subclass:
            return SubstantiveValueDomain_takesValuesFrom_EnumerationDomainType.subclass(*args_, **kwargs_)
        else:
            return SubstantiveValueDomain_takesValuesFrom_EnumerationDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType216(self, value):
        result = True
        # Validate type validTypeType216, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CodeList', 'EnumerationDomain', 'StatisticalClassification']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType216' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(SubstantiveValueDomain_takesValuesFrom_EnumerationDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SubstantiveValueDomain_takesValuesFrom_EnumerationDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SubstantiveValueDomain_takesValuesFrom_EnumerationDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType216
            self.validate_validTypeType216(self.validType[-1])
# end class SubstantiveValueDomain_takesValuesFrom_EnumerationDomainType


class SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescriptionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescriptionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescriptionType.subclass:
            return SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescriptionType.subclass(*args_, **kwargs_)
        else:
            return SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType217(self, value):
        result = True
        # Validate type validTypeType217, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ValueAndConceptDescription']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType217' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescriptionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescriptionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescriptionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType217
            self.validate_validTypeType217(self.validType[-1])
# end class SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescriptionType


class SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomainType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomainType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomainType.subclass:
            return SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomainType.subclass(*args_, **kwargs_)
        else:
            return SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType218(self, value):
        result = True
        # Validate type validTypeType218, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SubstantiveConceptualDomain']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType218' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomainType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomainType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomainType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType218
            self.validate_validTypeType218(self.validType[-1])
# end class SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomainType


class Unit_has_UnitTypeType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Unit_has_UnitTypeType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Unit_has_UnitTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Unit_has_UnitTypeType.subclass:
            return Unit_has_UnitTypeType.subclass(*args_, **kwargs_)
        else:
            return Unit_has_UnitTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType219(self, value):
        result = True
        # Validate type validTypeType219, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Population', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType219' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(Unit_has_UnitTypeType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Unit_has_UnitTypeType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Unit_has_UnitTypeType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType219
            self.validate_validTypeType219(self.validType[-1])
# end class Unit_has_UnitTypeType


class ValueMapping_formats_DataPointType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ValueMapping_formats_DataPointType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType220(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueMapping_formats_DataPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueMapping_formats_DataPointType.subclass:
            return ValueMapping_formats_DataPointType.subclass(*args_, **kwargs_)
        else:
            return ValueMapping_formats_DataPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType220(self, value):
        result = True
        # Validate type validTypeType220, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DataPoint']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType220' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(ValueMapping_formats_DataPointType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ValueMapping_formats_DataPointType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ValueMapping_formats_DataPointType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType220
            self.validate_validTypeType220(self.validType)
# end class ValueMapping_formats_DataPointType


class ValueMapping_uses_PhysicalSegmentLocationType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ValueMapping_uses_PhysicalSegmentLocationType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueMapping_uses_PhysicalSegmentLocationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueMapping_uses_PhysicalSegmentLocationType.subclass:
            return ValueMapping_uses_PhysicalSegmentLocationType.subclass(*args_, **kwargs_)
        else:
            return ValueMapping_uses_PhysicalSegmentLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType221(self, value):
        result = True
        # Validate type validTypeType221, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PhysicalSegmentLocation', 'SegmentByText']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType221' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ValueMapping_uses_PhysicalSegmentLocationType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ValueMapping_uses_PhysicalSegmentLocationType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ValueMapping_uses_PhysicalSegmentLocationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType221
            self.validate_validTypeType221(self.validType[-1])
# end class ValueMapping_uses_PhysicalSegmentLocationType


class ValueMappingPosition_indexes_ValueMappingType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ValueMappingPosition_indexes_ValueMappingType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueMappingPosition_indexes_ValueMappingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueMappingPosition_indexes_ValueMappingType.subclass:
            return ValueMappingPosition_indexes_ValueMappingType.subclass(*args_, **kwargs_)
        else:
            return ValueMappingPosition_indexes_ValueMappingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType222(self, value):
        result = True
        # Validate type validTypeType222, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ValueMapping']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType222' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ValueMappingPosition_indexes_ValueMappingType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ValueMappingPosition_indexes_ValueMappingType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ValueMappingPosition_indexes_ValueMappingType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType222
            self.validate_validTypeType222(self.validType[-1])
# end class ValueMappingPosition_indexes_ValueMappingType


class ValueMappingRelationship_hasTarget_ValueMappingType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ValueMappingRelationship_hasTarget_ValueMappingType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueMappingRelationship_hasTarget_ValueMappingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueMappingRelationship_hasTarget_ValueMappingType.subclass:
            return ValueMappingRelationship_hasTarget_ValueMappingType.subclass(*args_, **kwargs_)
        else:
            return ValueMappingRelationship_hasTarget_ValueMappingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType223(self, value):
        result = True
        # Validate type validTypeType223, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ValueMapping']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType223' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ValueMappingRelationship_hasTarget_ValueMappingType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ValueMappingRelationship_hasTarget_ValueMappingType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ValueMappingRelationship_hasTarget_ValueMappingType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType223
            self.validate_validTypeType223(self.validType[-1])
# end class ValueMappingRelationship_hasTarget_ValueMappingType


class ValueMappingRelationship_hasSource_ValueMappingType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ValueMappingRelationship_hasSource_ValueMappingType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueMappingRelationship_hasSource_ValueMappingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueMappingRelationship_hasSource_ValueMappingType.subclass:
            return ValueMappingRelationship_hasSource_ValueMappingType.subclass(*args_, **kwargs_)
        else:
            return ValueMappingRelationship_hasSource_ValueMappingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType224(self, value):
        result = True
        # Validate type validTypeType224, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ValueMapping']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType224' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(ValueMappingRelationship_hasSource_ValueMappingType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ValueMappingRelationship_hasSource_ValueMappingType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ValueMappingRelationship_hasSource_ValueMappingType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType224
            self.validate_validTypeType224(self.validType[-1])
# end class ValueMappingRelationship_hasSource_ValueMappingType


class VariableCollection_isDefinedBy_ConceptType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("VariableCollection_isDefinedBy_ConceptType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableCollection_isDefinedBy_ConceptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableCollection_isDefinedBy_ConceptType.subclass:
            return VariableCollection_isDefinedBy_ConceptType.subclass(*args_, **kwargs_)
        else:
            return VariableCollection_isDefinedBy_ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType225(self, value):
        result = True
        # Validate type validTypeType225, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Category', 'Concept', 'ConceptualValue', 'ConceptualVariable', 'DescriptorVariable', 'DimensionalKeyDefinitionMember', 'InstanceVariable', 'KeyDefinitionMember', 'Population', 'ReferenceVariable', 'RepresentedVariable', 'UnitType', 'Universe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType225' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(VariableCollection_isDefinedBy_ConceptType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableCollection_isDefinedBy_ConceptType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(VariableCollection_isDefinedBy_ConceptType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType225
            self.validate_validTypeType225(self.validType[-1])
# end class VariableCollection_isDefinedBy_ConceptType


class VariableCollection_has_ConceptualVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("VariableCollection_has_ConceptualVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableCollection_has_ConceptualVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableCollection_has_ConceptualVariableType.subclass:
            return VariableCollection_has_ConceptualVariableType.subclass(*args_, **kwargs_)
        else:
            return VariableCollection_has_ConceptualVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType226(self, value):
        result = True
        # Validate type validTypeType226, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ConceptualVariable', 'DescriptorVariable', 'InstanceVariable', 'ReferenceVariable', 'RepresentedVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType226' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(VariableCollection_has_ConceptualVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableCollection_has_ConceptualVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(VariableCollection_has_ConceptualVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType226
            self.validate_validTypeType226(self.validType[-1])
# end class VariableCollection_has_ConceptualVariableType


class VariableCollection_has_VariablePositionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("VariableCollection_has_VariablePositionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType227(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableCollection_has_VariablePositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableCollection_has_VariablePositionType.subclass:
            return VariableCollection_has_VariablePositionType.subclass(*args_, **kwargs_)
        else:
            return VariableCollection_has_VariablePositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType227(self, value):
        result = True
        # Validate type validTypeType227, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['VariablePosition']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType227' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(VariableCollection_has_VariablePositionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableCollection_has_VariablePositionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(VariableCollection_has_VariablePositionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType227
            self.validate_validTypeType227(self.validType)
# end class VariableCollection_has_VariablePositionType


class VariableDescriptorComponent_isDefinedBy_DescriptorVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("VariableDescriptorComponent_isDefinedBy_DescriptorVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableDescriptorComponent_isDefinedBy_DescriptorVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableDescriptorComponent_isDefinedBy_DescriptorVariableType.subclass:
            return VariableDescriptorComponent_isDefinedBy_DescriptorVariableType.subclass(*args_, **kwargs_)
        else:
            return VariableDescriptorComponent_isDefinedBy_DescriptorVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType228(self, value):
        result = True
        # Validate type validTypeType228, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DescriptorVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType228' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(VariableDescriptorComponent_isDefinedBy_DescriptorVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableDescriptorComponent_isDefinedBy_DescriptorVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(VariableDescriptorComponent_isDefinedBy_DescriptorVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType228
            self.validate_validTypeType228(self.validType[-1])
# end class VariableDescriptorComponent_isDefinedBy_DescriptorVariableType


class VariableDescriptorComponent_refersTo_VariableValueComponentType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("VariableDescriptorComponent_refersTo_VariableValueComponentType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType229(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableDescriptorComponent_refersTo_VariableValueComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableDescriptorComponent_refersTo_VariableValueComponentType.subclass:
            return VariableDescriptorComponent_refersTo_VariableValueComponentType.subclass(*args_, **kwargs_)
        else:
            return VariableDescriptorComponent_refersTo_VariableValueComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType229(self, value):
        result = True
        # Validate type validTypeType229, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['VariableValueComponent']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType229' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(VariableDescriptorComponent_refersTo_VariableValueComponentType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableDescriptorComponent_refersTo_VariableValueComponentType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(VariableDescriptorComponent_refersTo_VariableValueComponentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType229
            self.validate_validTypeType229(self.validType)
# end class VariableDescriptorComponent_refersTo_VariableValueComponentType


class VariablePosition_indexes_ConceptualVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("VariablePosition_indexes_ConceptualVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariablePosition_indexes_ConceptualVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariablePosition_indexes_ConceptualVariableType.subclass:
            return VariablePosition_indexes_ConceptualVariableType.subclass(*args_, **kwargs_)
        else:
            return VariablePosition_indexes_ConceptualVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType230(self, value):
        result = True
        # Validate type validTypeType230, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ConceptualVariable', 'DescriptorVariable', 'InstanceVariable', 'ReferenceVariable', 'RepresentedVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType230' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(VariablePosition_indexes_ConceptualVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariablePosition_indexes_ConceptualVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(VariablePosition_indexes_ConceptualVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType230
            self.validate_validTypeType230(self.validType[-1])
# end class VariablePosition_indexes_ConceptualVariableType


class VariableRelationship_hasTarget_ConceptualVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("VariableRelationship_hasTarget_ConceptualVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableRelationship_hasTarget_ConceptualVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableRelationship_hasTarget_ConceptualVariableType.subclass:
            return VariableRelationship_hasTarget_ConceptualVariableType.subclass(*args_, **kwargs_)
        else:
            return VariableRelationship_hasTarget_ConceptualVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType231(self, value):
        result = True
        # Validate type validTypeType231, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ConceptualVariable', 'DescriptorVariable', 'InstanceVariable', 'ReferenceVariable', 'RepresentedVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType231' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(VariableRelationship_hasTarget_ConceptualVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableRelationship_hasTarget_ConceptualVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(VariableRelationship_hasTarget_ConceptualVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType231
            self.validate_validTypeType231(self.validType[-1])
# end class VariableRelationship_hasTarget_ConceptualVariableType


class VariableRelationship_hasSource_ConceptualVariableType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("VariableRelationship_hasSource_ConceptualVariableType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableRelationship_hasSource_ConceptualVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableRelationship_hasSource_ConceptualVariableType.subclass:
            return VariableRelationship_hasSource_ConceptualVariableType.subclass(*args_, **kwargs_)
        else:
            return VariableRelationship_hasSource_ConceptualVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType232(self, value):
        result = True
        # Validate type validTypeType232, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ConceptualVariable', 'DescriptorVariable', 'InstanceVariable', 'ReferenceVariable', 'RepresentedVariable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType232' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(VariableRelationship_hasSource_ConceptualVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableRelationship_hasSource_ConceptualVariableType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(VariableRelationship_hasSource_ConceptualVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType232
            self.validate_validTypeType232(self.validType[-1])
# end class VariableRelationship_hasSource_ConceptualVariableType


class VariableStructure_structures_VariableCollectionType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("VariableStructure_structures_VariableCollectionType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        if validType is None:
            self.validType = []
        else:
            self.validType = validType
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableStructure_structures_VariableCollectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableStructure_structures_VariableCollectionType.subclass:
            return VariableStructure_structures_VariableCollectionType.subclass(*args_, **kwargs_)
        else:
            return VariableStructure_structures_VariableCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def add_validType(self, value):
        self.validType.append(value)
    def insert_validType_at(self, index, value):
        self.validType.insert(index, value)
    def replace_validType_at(self, index, value):
        self.validType[index] = value
    def validate_validTypeType233(self, value):
        result = True
        # Validate type validTypeType233, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['VariableCollection']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType233' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType or
            super(VariableStructure_structures_VariableCollectionType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableStructure_structures_VariableCollectionType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for validType_ in self.validType:
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(VariableStructure_structures_VariableCollectionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType.append(value_)
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType233
            self.validate_validTypeType233(self.validType[-1])
# end class VariableStructure_structures_VariableCollectionType


class VariableStructure_has_VariableRelationshipType(AssociationReference):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AssociationReference
    def __init__(self, ddiReference=None, deepLink=None, description=None, location=None, nonDdiReference=None, semantic=None, uri=None, validType=None, isAssociationReference=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("VariableStructure_has_VariableRelationshipType"), self).__init__(ddiReference, deepLink, description, location, nonDdiReference, semantic, uri, validType, isAssociationReference,  **kwargs_)
        self.ddiReference = ddiReference
        self.ddiReference_nsprefix_ = None
        self.validType = validType
        self.validate_validTypeType234(self.validType)
        self.validType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableStructure_has_VariableRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableStructure_has_VariableRelationshipType.subclass:
            return VariableStructure_has_VariableRelationshipType.subclass(*args_, **kwargs_)
        else:
            return VariableStructure_has_VariableRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ddiReference(self):
        return self.ddiReference
    def set_ddiReference(self, ddiReference):
        self.ddiReference = ddiReference
    def get_validType(self):
        return self.validType
    def set_validType(self, validType):
        self.validType = validType
    def validate_validTypeType234(self, value):
        result = True
        # Validate type validTypeType234, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['VariableRelationship']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on validTypeType234' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ddiReference is not None or
            self.validType is not None or
            super(VariableStructure_has_VariableRelationshipType, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='VariableStructure_has_VariableRelationshipType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}' + name_, nsmap=nsmap_)
        if self.ddiReference is not None:
            ddiReference_ = self.ddiReference
            ddiReference_.to_etree(element, name_='ddiReference', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.validType is not None:
            validType_ = self.validType
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}validType').text = self.gds_format_string(validType_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(VariableStructure_has_VariableRelationshipType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ddiReference':
            obj_ = InternationalRegistrationDataIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ddiReference = obj_
            obj_.original_tagname_ = 'ddiReference'
        elif nodeName_ == 'validType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validType')
            value_ = self.gds_validate_string(value_, node, 'validType')
            self.validType = value_
            self.validType_nsprefix_ = child_.prefix
            # validate type validTypeType234
            self.validate_validTypeType234(self.validType)
# end class VariableStructure_has_VariableRelationshipType


class ObjectAttributeSelector(Selector):
    """refinedBy -- Nested object attribute selector.
    refinedByOrderNumber -- Order number of the specific attribute.
    value -- Name of the attribute.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Selector
    def __init__(self, refinedBy=None, refinedByOrderNumber=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ObjectAttributeSelector"), self).__init__( **kwargs_)
        self.refinedBy = refinedBy
        self.refinedBy_nsprefix_ = None
        self.refinedByOrderNumber = refinedByOrderNumber
        self.refinedByOrderNumber_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectAttributeSelector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectAttributeSelector.subclass:
            return ObjectAttributeSelector.subclass(*args_, **kwargs_)
        else:
            return ObjectAttributeSelector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refinedBy(self):
        return self.refinedBy
    def set_refinedBy(self, refinedBy):
        self.refinedBy = refinedBy
    def get_refinedByOrderNumber(self):
        return self.refinedByOrderNumber
    def set_refinedByOrderNumber(self, refinedByOrderNumber):
        self.refinedByOrderNumber = refinedByOrderNumber
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def has__content(self):
        if (
            self.refinedBy is not None or
            self.refinedByOrderNumber is not None or
            self.value is not None or
            super(ObjectAttributeSelector, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ObjectAttributeSelector', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(ObjectAttributeSelector, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.refinedBy is not None:
            refinedBy_ = self.refinedBy
            refinedBy_.to_etree(element, name_='refinedBy', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.refinedByOrderNumber is not None:
            refinedByOrderNumber_ = self.refinedByOrderNumber
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}refinedByOrderNumber').text = self.gds_format_integer(refinedByOrderNumber_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}value').text = self.gds_format_string(value_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ObjectAttributeSelector, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'refinedBy':
            obj_ = ObjectAttributeSelector.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.refinedBy = obj_
            obj_.original_tagname_ = 'refinedBy'
        elif nodeName_ == 'refinedByOrderNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'refinedByOrderNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'refinedByOrderNumber')
            self.refinedByOrderNumber = ival_
            self.refinedByOrderNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'value')
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
            self.value_nsprefix_ = child_.prefix
        super(ObjectAttributeSelector, self)._buildChildren(child_, node, nodeName_, True)
# end class ObjectAttributeSelector


class GeoRole(SpecializationRole):
    """geography -- Function in relation to the specification of a place or physical area or feature, ideally drawn from a controlled vocabulary.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SpecializationRole
    def __init__(self, geography=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("GeoRole"), self).__init__( **kwargs_)
        self.geography = geography
        self.geography_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeoRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeoRole.subclass:
            return GeoRole.subclass(*args_, **kwargs_)
        else:
            return GeoRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_geography(self):
        return self.geography
    def set_geography(self, geography):
        self.geography = geography
    def has__content(self):
        if (
            self.geography is not None or
            super(GeoRole, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='GeoRole', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(GeoRole, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.geography is not None:
            geography_ = self.geography
            geography_.to_etree(element, name_='geography', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(GeoRole, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'geography':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geography = obj_
            obj_.original_tagname_ = 'geography'
        super(GeoRole, self)._buildChildren(child_, node, nodeName_, True)
# end class GeoRole


class BibliographicName(InternationalString):
    """affiliation -- The affiliation of this person to an organization. This is generally an organization or sub-organization name and should be related to the specific role within which the individual is being listed.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = InternationalString
    def __init__(self, languageSpecificString=None, affiliation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BibliographicName"), self).__init__(languageSpecificString,  **kwargs_)
        self.affiliation = affiliation
        self.affiliation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BibliographicName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BibliographicName.subclass:
            return BibliographicName.subclass(*args_, **kwargs_)
        else:
            return BibliographicName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_affiliation(self):
        return self.affiliation
    def set_affiliation(self, affiliation):
        self.affiliation = affiliation
    def has__content(self):
        if (
            self.affiliation is not None or
            super(BibliographicName, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='BibliographicName', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(BibliographicName, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.affiliation is not None:
            affiliation_ = self.affiliation
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}affiliation').text = self.gds_format_string(affiliation_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BibliographicName, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'affiliation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'affiliation')
            value_ = self.gds_validate_string(value_, node, 'affiliation')
            self.affiliation = value_
            self.affiliation_nsprefix_ = child_.prefix
        super(BibliographicName, self)._buildChildren(child_, node, nodeName_, True)
# end class BibliographicName


class SubstantiveValueDomain(ValueDomain):
    """SubstantiveValueDomain_takesValuesFrom_EnumerationDomain -- Any subtype of an enumeration domain enumerating the set of valid values.
    SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription -- A formal description of the set of valid values - for described value domains.
    SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain -- Corresponding conceptual definition given by an substantive conceptual domain.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ValueDomain
    def __init__(self, catalogDetails=None, displayLabel=None, identifier=None, recommendedDataType=None, SubstantiveValueDomain_takesValuesFrom_EnumerationDomain=None, SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription=None, SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SubstantiveValueDomain"), self).__init__(catalogDetails, displayLabel, identifier, recommendedDataType, extensiontype_,  **kwargs_)
        self.SubstantiveValueDomain_takesValuesFrom_EnumerationDomain = SubstantiveValueDomain_takesValuesFrom_EnumerationDomain
        self.SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_nsprefix_ = None
        self.SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription = SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription
        self.SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_nsprefix_ = None
        self.SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain = SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain
        self.SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubstantiveValueDomain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubstantiveValueDomain.subclass:
            return SubstantiveValueDomain.subclass(*args_, **kwargs_)
        else:
            return SubstantiveValueDomain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SubstantiveValueDomain_takesValuesFrom_EnumerationDomain(self):
        return self.SubstantiveValueDomain_takesValuesFrom_EnumerationDomain
    def set_SubstantiveValueDomain_takesValuesFrom_EnumerationDomain(self, SubstantiveValueDomain_takesValuesFrom_EnumerationDomain):
        self.SubstantiveValueDomain_takesValuesFrom_EnumerationDomain = SubstantiveValueDomain_takesValuesFrom_EnumerationDomain
    def get_SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription(self):
        return self.SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription
    def set_SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription(self, SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription):
        self.SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription = SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription
    def get_SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain(self):
        return self.SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain
    def set_SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain(self, SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain):
        self.SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain = SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.SubstantiveValueDomain_takesValuesFrom_EnumerationDomain is not None or
            self.SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription is not None or
            self.SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain is not None or
            super(SubstantiveValueDomain, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SubstantiveValueDomain', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(SubstantiveValueDomain, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.SubstantiveValueDomain_takesValuesFrom_EnumerationDomain is not None:
            SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_ = self.SubstantiveValueDomain_takesValuesFrom_EnumerationDomain
            SubstantiveValueDomain_takesValuesFrom_EnumerationDomain_.to_etree(element, name_='SubstantiveValueDomain_takesValuesFrom_EnumerationDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription is not None:
            SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_ = self.SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription
            SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription_.to_etree(element, name_='SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain is not None:
            SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_ = self.SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain
            SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain_.to_etree(element, name_='SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SubstantiveValueDomain, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SubstantiveValueDomain_takesValuesFrom_EnumerationDomain':
            obj_ = SubstantiveValueDomain_takesValuesFrom_EnumerationDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SubstantiveValueDomain_takesValuesFrom_EnumerationDomain = obj_
            obj_.original_tagname_ = 'SubstantiveValueDomain_takesValuesFrom_EnumerationDomain'
        elif nodeName_ == 'SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription':
            obj_ = SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription = obj_
            obj_.original_tagname_ = 'SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription'
        elif nodeName_ == 'SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain':
            obj_ = SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain = obj_
            obj_.original_tagname_ = 'SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain'
        super(SubstantiveValueDomain, self)._buildChildren(child_, node, nodeName_, True)
# end class SubstantiveValueDomain


class SentinelValueDomain(ValueDomain):
    """platformType -- The type of platform under which sentinel codes will be used. Statistical software platforms use different sets of codes to indicate missing values. The external controlled vocabulary should list platform types and a description of the allowed missing value types. A sample list would be:
    - BlankString - A Blank string indicates missing. Comparison is based on lexical order.
    - EmptyString - An empty string indicates missing. Use in comparisons returns missing.
    - Rstyle - Codes drawn from  NA and the IEEE 754 values of NaN  -Inf   +Inf.   Comparisons return NA.
    - SASNumeric - codes drawn from . ._ .A .B .C .D .E .F .G .H .I .J .K .L .M .N .O .P .Q .R .S .T .U .V .W .X .Y .Z    Sentinel code treated as less than any substantive value
    - SPSSstyle - System missing (a dot) a set of individual values drawn from the same datatype as the SubstantiveValueDomain, and a range of values  drawn from the same datatype as the SubstantiveValueDomain. Comparisons return system missing. Some functions substitute with valid values (e.g. SUM replaces missing values with 0).
    - StataNumeric - codes drawn from . ._ .A .B .C .D .E .F .G .H .I .J .K .L .M .N .O .P .Q .R .S .T .U .V .W .X .Y .Z  Sentinel code treated as greater than any substantive value  - Unrestricted - No restrictions on codes for sentinel values. Use in comparisons is indeterminate.
    SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain -- Corresponding conceptual definition given by a sentinel conceptual domain.
    SentinelValueDomain_takesValuesFrom_EnumerationDomain -- Any subtype of an enumeration domain enumerating the set of valid values.
    SentinelValueDomain_isDescribedBy_ValueAndConceptDescription -- A formal description of the set of valid values - for described value domains.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ValueDomain
    def __init__(self, catalogDetails=None, displayLabel=None, identifier=None, recommendedDataType=None, platformType=None, SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain=None, SentinelValueDomain_takesValuesFrom_EnumerationDomain=None, SentinelValueDomain_isDescribedBy_ValueAndConceptDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SentinelValueDomain"), self).__init__(catalogDetails, displayLabel, identifier, recommendedDataType,  **kwargs_)
        self.platformType = platformType
        self.platformType_nsprefix_ = None
        self.SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain = SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain
        self.SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_nsprefix_ = None
        self.SentinelValueDomain_takesValuesFrom_EnumerationDomain = SentinelValueDomain_takesValuesFrom_EnumerationDomain
        self.SentinelValueDomain_takesValuesFrom_EnumerationDomain_nsprefix_ = None
        self.SentinelValueDomain_isDescribedBy_ValueAndConceptDescription = SentinelValueDomain_isDescribedBy_ValueAndConceptDescription
        self.SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SentinelValueDomain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SentinelValueDomain.subclass:
            return SentinelValueDomain.subclass(*args_, **kwargs_)
        else:
            return SentinelValueDomain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_platformType(self):
        return self.platformType
    def set_platformType(self, platformType):
        self.platformType = platformType
    def get_SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain(self):
        return self.SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain
    def set_SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain(self, SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain):
        self.SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain = SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain
    def get_SentinelValueDomain_takesValuesFrom_EnumerationDomain(self):
        return self.SentinelValueDomain_takesValuesFrom_EnumerationDomain
    def set_SentinelValueDomain_takesValuesFrom_EnumerationDomain(self, SentinelValueDomain_takesValuesFrom_EnumerationDomain):
        self.SentinelValueDomain_takesValuesFrom_EnumerationDomain = SentinelValueDomain_takesValuesFrom_EnumerationDomain
    def get_SentinelValueDomain_isDescribedBy_ValueAndConceptDescription(self):
        return self.SentinelValueDomain_isDescribedBy_ValueAndConceptDescription
    def set_SentinelValueDomain_isDescribedBy_ValueAndConceptDescription(self, SentinelValueDomain_isDescribedBy_ValueAndConceptDescription):
        self.SentinelValueDomain_isDescribedBy_ValueAndConceptDescription = SentinelValueDomain_isDescribedBy_ValueAndConceptDescription
    def has__content(self):
        if (
            self.platformType is not None or
            self.SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain is not None or
            self.SentinelValueDomain_takesValuesFrom_EnumerationDomain is not None or
            self.SentinelValueDomain_isDescribedBy_ValueAndConceptDescription is not None or
            super(SentinelValueDomain, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='SentinelValueDomain', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(SentinelValueDomain, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.platformType is not None:
            platformType_ = self.platformType
            platformType_.to_etree(element, name_='platformType', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain is not None:
            SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_ = self.SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain
            SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain_.to_etree(element, name_='SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.SentinelValueDomain_takesValuesFrom_EnumerationDomain is not None:
            SentinelValueDomain_takesValuesFrom_EnumerationDomain_ = self.SentinelValueDomain_takesValuesFrom_EnumerationDomain
            SentinelValueDomain_takesValuesFrom_EnumerationDomain_.to_etree(element, name_='SentinelValueDomain_takesValuesFrom_EnumerationDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.SentinelValueDomain_isDescribedBy_ValueAndConceptDescription is not None:
            SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_ = self.SentinelValueDomain_isDescribedBy_ValueAndConceptDescription
            SentinelValueDomain_isDescribedBy_ValueAndConceptDescription_.to_etree(element, name_='SentinelValueDomain_isDescribedBy_ValueAndConceptDescription', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SentinelValueDomain, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'platformType':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.platformType = obj_
            obj_.original_tagname_ = 'platformType'
        elif nodeName_ == 'SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain':
            obj_ = SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain = obj_
            obj_.original_tagname_ = 'SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomain'
        elif nodeName_ == 'SentinelValueDomain_takesValuesFrom_EnumerationDomain':
            obj_ = SentinelValueDomain_takesValuesFrom_EnumerationDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SentinelValueDomain_takesValuesFrom_EnumerationDomain = obj_
            obj_.original_tagname_ = 'SentinelValueDomain_takesValuesFrom_EnumerationDomain'
        elif nodeName_ == 'SentinelValueDomain_isDescribedBy_ValueAndConceptDescription':
            obj_ = SentinelValueDomain_isDescribedBy_ValueAndConceptDescriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SentinelValueDomain_isDescribedBy_ValueAndConceptDescription = obj_
            obj_.original_tagname_ = 'SentinelValueDomain_isDescribedBy_ValueAndConceptDescription'
        super(SentinelValueDomain, self)._buildChildren(child_, node, nodeName_, True)
# end class SentinelValueDomain


class ReferenceVariable(RepresentedVariable):
    """ReferenceVariable_takesValuesFrom_ReferenceValueDomain -- Points to a value domain that contains values that may be drawn from the domains of multiple simple variables.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RepresentedVariable
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, externalDefinition=None, identifier=None, name=None, Concept_uses_Concept=None, descriptiveText=None, unitOfMeasureKind=None, ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain=None, ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain=None, ConceptualVariable_measures_UnitType=None, describedUnitOfMeasure=None, hasIntendedDataType=None, simpleUnitOfMeasure=None, RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain=None, RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain=None, ReferenceVariable_takesValuesFrom_ReferenceValueDomain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReferenceVariable"), self).__init__(catalogDetails, definition, displayLabel, externalDefinition, identifier, name, Concept_uses_Concept, descriptiveText, unitOfMeasureKind, ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain, ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain, ConceptualVariable_measures_UnitType, describedUnitOfMeasure, hasIntendedDataType, simpleUnitOfMeasure, RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain, RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain,  **kwargs_)
        self.ReferenceVariable_takesValuesFrom_ReferenceValueDomain = ReferenceVariable_takesValuesFrom_ReferenceValueDomain
        self.ReferenceVariable_takesValuesFrom_ReferenceValueDomain_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceVariable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceVariable.subclass:
            return ReferenceVariable.subclass(*args_, **kwargs_)
        else:
            return ReferenceVariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ReferenceVariable_takesValuesFrom_ReferenceValueDomain(self):
        return self.ReferenceVariable_takesValuesFrom_ReferenceValueDomain
    def set_ReferenceVariable_takesValuesFrom_ReferenceValueDomain(self, ReferenceVariable_takesValuesFrom_ReferenceValueDomain):
        self.ReferenceVariable_takesValuesFrom_ReferenceValueDomain = ReferenceVariable_takesValuesFrom_ReferenceValueDomain
    def has__content(self):
        if (
            self.ReferenceVariable_takesValuesFrom_ReferenceValueDomain is not None or
            super(ReferenceVariable, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ReferenceVariable', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(ReferenceVariable, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.ReferenceVariable_takesValuesFrom_ReferenceValueDomain is not None:
            ReferenceVariable_takesValuesFrom_ReferenceValueDomain_ = self.ReferenceVariable_takesValuesFrom_ReferenceValueDomain
            ReferenceVariable_takesValuesFrom_ReferenceValueDomain_.to_etree(element, name_='ReferenceVariable_takesValuesFrom_ReferenceValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReferenceVariable, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ReferenceVariable_takesValuesFrom_ReferenceValueDomain':
            obj_ = ReferenceVariable_takesValuesFrom_ReferenceValueDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReferenceVariable_takesValuesFrom_ReferenceValueDomain = obj_
            obj_.original_tagname_ = 'ReferenceVariable_takesValuesFrom_ReferenceValueDomain'
        super(ReferenceVariable, self)._buildChildren(child_, node, nodeName_, True)
# end class ReferenceVariable


class ReferenceValueDomain(ValueDomain):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ValueDomain
    def __init__(self, catalogDetails=None, displayLabel=None, identifier=None, recommendedDataType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReferenceValueDomain"), self).__init__(catalogDetails, displayLabel, identifier, recommendedDataType,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceValueDomain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceValueDomain.subclass:
            return ReferenceValueDomain.subclass(*args_, **kwargs_)
        else:
            return ReferenceValueDomain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(ReferenceValueDomain, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ReferenceValueDomain', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(ReferenceValueDomain, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReferenceValueDomain, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ReferenceValueDomain, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ReferenceValueDomain


class Population(Universe):
    """timePeriodOfPopulation -- The time period associated with the population.
    Population_isComposedOf_Unit -- A unit in the population.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Universe
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, externalDefinition=None, identifier=None, name=None, Concept_uses_Concept=None, descriptiveText=None, isInclusive=None, timePeriodOfPopulation=None, Population_isComposedOf_Unit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Population"), self).__init__(catalogDetails, definition, displayLabel, externalDefinition, identifier, name, Concept_uses_Concept, descriptiveText, isInclusive,  **kwargs_)
        if timePeriodOfPopulation is None:
            self.timePeriodOfPopulation = []
        else:
            self.timePeriodOfPopulation = timePeriodOfPopulation
        self.timePeriodOfPopulation_nsprefix_ = None
        if Population_isComposedOf_Unit is None:
            self.Population_isComposedOf_Unit = []
        else:
            self.Population_isComposedOf_Unit = Population_isComposedOf_Unit
        self.Population_isComposedOf_Unit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Population)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Population.subclass:
            return Population.subclass(*args_, **kwargs_)
        else:
            return Population(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_timePeriodOfPopulation(self):
        return self.timePeriodOfPopulation
    def set_timePeriodOfPopulation(self, timePeriodOfPopulation):
        self.timePeriodOfPopulation = timePeriodOfPopulation
    def add_timePeriodOfPopulation(self, value):
        self.timePeriodOfPopulation.append(value)
    def insert_timePeriodOfPopulation_at(self, index, value):
        self.timePeriodOfPopulation.insert(index, value)
    def replace_timePeriodOfPopulation_at(self, index, value):
        self.timePeriodOfPopulation[index] = value
    def get_Population_isComposedOf_Unit(self):
        return self.Population_isComposedOf_Unit
    def set_Population_isComposedOf_Unit(self, Population_isComposedOf_Unit):
        self.Population_isComposedOf_Unit = Population_isComposedOf_Unit
    def add_Population_isComposedOf_Unit(self, value):
        self.Population_isComposedOf_Unit.append(value)
    def insert_Population_isComposedOf_Unit_at(self, index, value):
        self.Population_isComposedOf_Unit.insert(index, value)
    def replace_Population_isComposedOf_Unit_at(self, index, value):
        self.Population_isComposedOf_Unit[index] = value
    def has__content(self):
        if (
            self.timePeriodOfPopulation or
            self.Population_isComposedOf_Unit or
            super(Population, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Population', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(Population, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        for timePeriodOfPopulation_ in self.timePeriodOfPopulation:
            timePeriodOfPopulation_.to_etree(element, name_='timePeriodOfPopulation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for Population_isComposedOf_Unit_ in self.Population_isComposedOf_Unit:
            Population_isComposedOf_Unit_.to_etree(element, name_='Population_isComposedOf_Unit', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Population, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'timePeriodOfPopulation':
            obj_ = DateRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timePeriodOfPopulation.append(obj_)
            obj_.original_tagname_ = 'timePeriodOfPopulation'
        elif nodeName_ == 'Population_isComposedOf_Unit':
            obj_ = Population_isComposedOf_UnitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Population_isComposedOf_Unit.append(obj_)
            obj_.original_tagname_ = 'Population_isComposedOf_Unit'
        super(Population, self)._buildChildren(child_, node, nodeName_, True)
# end class Population


class InstanceVariable(RepresentedVariable):
    """physicalDataType -- The data type of this variable. Supports the optional use of an external controlled vocabulary.
    platformType -- Describes the application or technical system context in which the variable has been realized. Typically a statistical processing package or other processing environment.
    source -- Reference capturing provenance information.
    variableFunction -- Immutable characteristic of the variable such as geographic designator, weight, temporal designation, etc.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RepresentedVariable
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, externalDefinition=None, identifier=None, name=None, Concept_uses_Concept=None, descriptiveText=None, unitOfMeasureKind=None, ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain=None, ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain=None, ConceptualVariable_measures_UnitType=None, describedUnitOfMeasure=None, hasIntendedDataType=None, simpleUnitOfMeasure=None, RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain=None, RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain=None, physicalDataType=None, platformType=None, source=None, variableFunction=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("InstanceVariable"), self).__init__(catalogDetails, definition, displayLabel, externalDefinition, identifier, name, Concept_uses_Concept, descriptiveText, unitOfMeasureKind, ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain, ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain, ConceptualVariable_measures_UnitType, describedUnitOfMeasure, hasIntendedDataType, simpleUnitOfMeasure, RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain, RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain,  **kwargs_)
        self.physicalDataType = physicalDataType
        self.physicalDataType_nsprefix_ = None
        self.platformType = platformType
        self.platformType_nsprefix_ = None
        self.source = source
        self.source_nsprefix_ = None
        if variableFunction is None:
            self.variableFunction = []
        else:
            self.variableFunction = variableFunction
        self.variableFunction_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceVariable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceVariable.subclass:
            return InstanceVariable.subclass(*args_, **kwargs_)
        else:
            return InstanceVariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_physicalDataType(self):
        return self.physicalDataType
    def set_physicalDataType(self, physicalDataType):
        self.physicalDataType = physicalDataType
    def get_platformType(self):
        return self.platformType
    def set_platformType(self, platformType):
        self.platformType = platformType
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_variableFunction(self):
        return self.variableFunction
    def set_variableFunction(self, variableFunction):
        self.variableFunction = variableFunction
    def add_variableFunction(self, value):
        self.variableFunction.append(value)
    def insert_variableFunction_at(self, index, value):
        self.variableFunction.insert(index, value)
    def replace_variableFunction_at(self, index, value):
        self.variableFunction[index] = value
    def has__content(self):
        if (
            self.physicalDataType is not None or
            self.platformType is not None or
            self.source is not None or
            self.variableFunction or
            super(InstanceVariable, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InstanceVariable', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(InstanceVariable, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.physicalDataType is not None:
            physicalDataType_ = self.physicalDataType
            physicalDataType_.to_etree(element, name_='physicalDataType', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.platformType is not None:
            platformType_ = self.platformType
            platformType_.to_etree(element, name_='platformType', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.source is not None:
            source_ = self.source
            source_.to_etree(element, name_='source', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for variableFunction_ in self.variableFunction:
            variableFunction_.to_etree(element, name_='variableFunction', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InstanceVariable, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'physicalDataType':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physicalDataType = obj_
            obj_.original_tagname_ = 'physicalDataType'
        elif nodeName_ == 'platformType':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.platformType = obj_
            obj_.original_tagname_ = 'platformType'
        elif nodeName_ == 'source':
            class_obj_ = self.get_class_obj_(child_, Reference)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.source = obj_
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'variableFunction':
            obj_ = ControlledVocabularyEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variableFunction.append(obj_)
            obj_.original_tagname_ = 'variableFunction'
        super(InstanceVariable, self)._buildChildren(child_, node, nodeName_, True)
# end class InstanceVariable


class InstanceKey(Key):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Key
    def __init__(self, identifier=None, Key_correspondsTo_Unit=None, Key_represents_KeyDefinition=None, Key_identifies_DataPoint=None, Key_correspondsTo_Universe=None, Key_has_KeyMember=None, InstanceKey_has_InstanceValue=None, InstanceKey_refersTo_ReferenceValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("InstanceKey"), self).__init__(identifier, Key_correspondsTo_Unit, Key_represents_KeyDefinition, Key_identifies_DataPoint, Key_correspondsTo_Universe, Key_has_KeyMember,  **kwargs_)
        self.InstanceKey_has_InstanceValue = InstanceKey_has_InstanceValue
        self.InstanceKey_has_InstanceValue_nsprefix_ = None
        self.InstanceKey_refersTo_ReferenceValue = InstanceKey_refersTo_ReferenceValue
        self.InstanceKey_refersTo_ReferenceValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceKey.subclass:
            return InstanceKey.subclass(*args_, **kwargs_)
        else:
            return InstanceKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_InstanceKey_has_InstanceValue(self):
        return self.InstanceKey_has_InstanceValue
    def set_InstanceKey_has_InstanceValue(self, InstanceKey_has_InstanceValue):
        self.InstanceKey_has_InstanceValue = InstanceKey_has_InstanceValue
    def get_InstanceKey_refersTo_ReferenceValue(self):
        return self.InstanceKey_refersTo_ReferenceValue
    def set_InstanceKey_refersTo_ReferenceValue(self, InstanceKey_refersTo_ReferenceValue):
        self.InstanceKey_refersTo_ReferenceValue = InstanceKey_refersTo_ReferenceValue
    def has__content(self):
        if (
            self.InstanceKey_has_InstanceValue is not None or
            self.InstanceKey_refersTo_ReferenceValue is not None or
            super(InstanceKey, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InstanceKey', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(InstanceKey, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.InstanceKey_has_InstanceValue is not None:
            InstanceKey_has_InstanceValue_ = self.InstanceKey_has_InstanceValue
            InstanceKey_has_InstanceValue_.to_etree(element, name_='InstanceKey_has_InstanceValue', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.InstanceKey_refersTo_ReferenceValue is not None:
            InstanceKey_refersTo_ReferenceValue_ = self.InstanceKey_refersTo_ReferenceValue
            InstanceKey_refersTo_ReferenceValue_.to_etree(element, name_='InstanceKey_refersTo_ReferenceValue', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InstanceKey, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'InstanceKey_has_InstanceValue':
            obj_ = InstanceKey_has_InstanceValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceKey_has_InstanceValue = obj_
            obj_.original_tagname_ = 'InstanceKey_has_InstanceValue'
        elif nodeName_ == 'InstanceKey_refersTo_ReferenceValue':
            obj_ = InstanceKey_refersTo_ReferenceValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceKey_refersTo_ReferenceValue = obj_
            obj_.original_tagname_ = 'InstanceKey_refersTo_ReferenceValue'
        super(InstanceKey, self)._buildChildren(child_, node, nodeName_, True)
# end class InstanceKey


class DimensionalKeyMember(KeyMember):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = KeyMember
    def __init__(self, content=None, identifier=None, whiteSpace=None, InstanceValue_hasValueFrom_ValueDomain=None, InstanceValue_isStoredIn_DataPoint=None, InstanceValue_represents_ConceptualValue=None, KeyMember_isBasedOn_DataStructureComponent=None, DimensionalKeyMember_hasValueFrom_CodeList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DimensionalKeyMember"), self).__init__(content, identifier, whiteSpace, InstanceValue_hasValueFrom_ValueDomain, InstanceValue_isStoredIn_DataPoint, InstanceValue_represents_ConceptualValue, KeyMember_isBasedOn_DataStructureComponent,  **kwargs_)
        self.DimensionalKeyMember_hasValueFrom_CodeList = DimensionalKeyMember_hasValueFrom_CodeList
        self.DimensionalKeyMember_hasValueFrom_CodeList_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionalKeyMember)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionalKeyMember.subclass:
            return DimensionalKeyMember.subclass(*args_, **kwargs_)
        else:
            return DimensionalKeyMember(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DimensionalKeyMember_hasValueFrom_CodeList(self):
        return self.DimensionalKeyMember_hasValueFrom_CodeList
    def set_DimensionalKeyMember_hasValueFrom_CodeList(self, DimensionalKeyMember_hasValueFrom_CodeList):
        self.DimensionalKeyMember_hasValueFrom_CodeList = DimensionalKeyMember_hasValueFrom_CodeList
    def has__content(self):
        if (
            self.DimensionalKeyMember_hasValueFrom_CodeList is not None or
            super(DimensionalKeyMember, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionalKeyMember', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(DimensionalKeyMember, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.DimensionalKeyMember_hasValueFrom_CodeList is not None:
            DimensionalKeyMember_hasValueFrom_CodeList_ = self.DimensionalKeyMember_hasValueFrom_CodeList
            DimensionalKeyMember_hasValueFrom_CodeList_.to_etree(element, name_='DimensionalKeyMember_hasValueFrom_CodeList', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DimensionalKeyMember, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DimensionalKeyMember_hasValueFrom_CodeList':
            obj_ = DimensionalKeyMember_hasValueFrom_CodeListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalKeyMember_hasValueFrom_CodeList = obj_
            obj_.original_tagname_ = 'DimensionalKeyMember_hasValueFrom_CodeList'
        super(DimensionalKeyMember, self)._buildChildren(child_, node, nodeName_, True)
# end class DimensionalKeyMember


class DimensionalKeyDefinition(KeyDefinition):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = KeyDefinition
    def __init__(self, identifier=None, KeyDefinition_correspondsTo_Universe=None, KeyDefinition_correspondsTo_Unit=None, KeyDefinition_has_KeyDefinitionMember=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DimensionalKeyDefinition"), self).__init__(identifier, KeyDefinition_correspondsTo_Universe, KeyDefinition_correspondsTo_Unit, KeyDefinition_has_KeyDefinitionMember,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionalKeyDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionalKeyDefinition.subclass:
            return DimensionalKeyDefinition.subclass(*args_, **kwargs_)
        else:
            return DimensionalKeyDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(DimensionalKeyDefinition, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionalKeyDefinition', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(DimensionalKeyDefinition, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DimensionalKeyDefinition, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DimensionalKeyDefinition, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DimensionalKeyDefinition


class DimensionalKey(Key):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Key
    def __init__(self, identifier=None, Key_correspondsTo_Unit=None, Key_represents_KeyDefinition=None, Key_identifies_DataPoint=None, Key_correspondsTo_Universe=None, Key_has_KeyMember=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DimensionalKey"), self).__init__(identifier, Key_correspondsTo_Unit, Key_represents_KeyDefinition, Key_identifies_DataPoint, Key_correspondsTo_Universe, Key_has_KeyMember,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionalKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionalKey.subclass:
            return DimensionalKey.subclass(*args_, **kwargs_)
        else:
            return DimensionalKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(DimensionalKey, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionalKey', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(DimensionalKey, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DimensionalKey, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DimensionalKey, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DimensionalKey


class DescriptorVariable(RepresentedVariable):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RepresentedVariable
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, externalDefinition=None, identifier=None, name=None, Concept_uses_Concept=None, descriptiveText=None, unitOfMeasureKind=None, ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain=None, ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain=None, ConceptualVariable_measures_UnitType=None, describedUnitOfMeasure=None, hasIntendedDataType=None, simpleUnitOfMeasure=None, RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain=None, RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain=None, DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DescriptorVariable"), self).__init__(catalogDetails, definition, displayLabel, externalDefinition, identifier, name, Concept_uses_Concept, descriptiveText, unitOfMeasureKind, ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomain, ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomain, ConceptualVariable_measures_UnitType, describedUnitOfMeasure, hasIntendedDataType, simpleUnitOfMeasure, RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomain, RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomain,  **kwargs_)
        self.DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain = DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain
        self.DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DescriptorVariable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DescriptorVariable.subclass:
            return DescriptorVariable.subclass(*args_, **kwargs_)
        else:
            return DescriptorVariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain(self):
        return self.DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain
    def set_DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain(self, DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain):
        self.DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain = DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain
    def has__content(self):
        if (
            self.DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain is not None or
            super(DescriptorVariable, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DescriptorVariable', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(DescriptorVariable, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain is not None:
            DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_ = self.DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain
            DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain_.to_etree(element, name_='DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DescriptorVariable, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain':
            obj_ = DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain = obj_
            obj_.original_tagname_ = 'DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomain'
        super(DescriptorVariable, self)._buildChildren(child_, node, nodeName_, True)
# end class DescriptorVariable


class DescriptorValueDomain(SubstantiveValueDomain):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubstantiveValueDomain
    def __init__(self, catalogDetails=None, displayLabel=None, identifier=None, recommendedDataType=None, SubstantiveValueDomain_takesValuesFrom_EnumerationDomain=None, SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription=None, SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DescriptorValueDomain"), self).__init__(catalogDetails, displayLabel, identifier, recommendedDataType, SubstantiveValueDomain_takesValuesFrom_EnumerationDomain, SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescription, SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomain,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DescriptorValueDomain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DescriptorValueDomain.subclass:
            return DescriptorValueDomain.subclass(*args_, **kwargs_)
        else:
            return DescriptorValueDomain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(DescriptorValueDomain, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DescriptorValueDomain', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(DescriptorValueDomain, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DescriptorValueDomain, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DescriptorValueDomain, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DescriptorValueDomain


class Descriptor(KeyMember):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = KeyMember
    def __init__(self, content=None, identifier=None, whiteSpace=None, InstanceValue_hasValueFrom_ValueDomain=None, InstanceValue_isStoredIn_DataPoint=None, InstanceValue_represents_ConceptualValue=None, KeyMember_isBasedOn_DataStructureComponent=None, Descriptor_refersTo_ReferenceValue=None, Descriptor_identifies_ReferenceVariable=None, Descriptor_hasValueFrom_DescriptorValueDomain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Descriptor"), self).__init__(content, identifier, whiteSpace, InstanceValue_hasValueFrom_ValueDomain, InstanceValue_isStoredIn_DataPoint, InstanceValue_represents_ConceptualValue, KeyMember_isBasedOn_DataStructureComponent,  **kwargs_)
        if Descriptor_refersTo_ReferenceValue is None:
            self.Descriptor_refersTo_ReferenceValue = []
        else:
            self.Descriptor_refersTo_ReferenceValue = Descriptor_refersTo_ReferenceValue
        self.Descriptor_refersTo_ReferenceValue_nsprefix_ = None
        self.Descriptor_identifies_ReferenceVariable = Descriptor_identifies_ReferenceVariable
        self.Descriptor_identifies_ReferenceVariable_nsprefix_ = None
        self.Descriptor_hasValueFrom_DescriptorValueDomain = Descriptor_hasValueFrom_DescriptorValueDomain
        self.Descriptor_hasValueFrom_DescriptorValueDomain_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Descriptor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Descriptor.subclass:
            return Descriptor.subclass(*args_, **kwargs_)
        else:
            return Descriptor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Descriptor_refersTo_ReferenceValue(self):
        return self.Descriptor_refersTo_ReferenceValue
    def set_Descriptor_refersTo_ReferenceValue(self, Descriptor_refersTo_ReferenceValue):
        self.Descriptor_refersTo_ReferenceValue = Descriptor_refersTo_ReferenceValue
    def add_Descriptor_refersTo_ReferenceValue(self, value):
        self.Descriptor_refersTo_ReferenceValue.append(value)
    def insert_Descriptor_refersTo_ReferenceValue_at(self, index, value):
        self.Descriptor_refersTo_ReferenceValue.insert(index, value)
    def replace_Descriptor_refersTo_ReferenceValue_at(self, index, value):
        self.Descriptor_refersTo_ReferenceValue[index] = value
    def get_Descriptor_identifies_ReferenceVariable(self):
        return self.Descriptor_identifies_ReferenceVariable
    def set_Descriptor_identifies_ReferenceVariable(self, Descriptor_identifies_ReferenceVariable):
        self.Descriptor_identifies_ReferenceVariable = Descriptor_identifies_ReferenceVariable
    def get_Descriptor_hasValueFrom_DescriptorValueDomain(self):
        return self.Descriptor_hasValueFrom_DescriptorValueDomain
    def set_Descriptor_hasValueFrom_DescriptorValueDomain(self, Descriptor_hasValueFrom_DescriptorValueDomain):
        self.Descriptor_hasValueFrom_DescriptorValueDomain = Descriptor_hasValueFrom_DescriptorValueDomain
    def has__content(self):
        if (
            self.Descriptor_refersTo_ReferenceValue or
            self.Descriptor_identifies_ReferenceVariable is not None or
            self.Descriptor_hasValueFrom_DescriptorValueDomain is not None or
            super(Descriptor, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Descriptor', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(Descriptor, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        for Descriptor_refersTo_ReferenceValue_ in self.Descriptor_refersTo_ReferenceValue:
            Descriptor_refersTo_ReferenceValue_.to_etree(element, name_='Descriptor_refersTo_ReferenceValue', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.Descriptor_identifies_ReferenceVariable is not None:
            Descriptor_identifies_ReferenceVariable_ = self.Descriptor_identifies_ReferenceVariable
            Descriptor_identifies_ReferenceVariable_.to_etree(element, name_='Descriptor_identifies_ReferenceVariable', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.Descriptor_hasValueFrom_DescriptorValueDomain is not None:
            Descriptor_hasValueFrom_DescriptorValueDomain_ = self.Descriptor_hasValueFrom_DescriptorValueDomain
            Descriptor_hasValueFrom_DescriptorValueDomain_.to_etree(element, name_='Descriptor_hasValueFrom_DescriptorValueDomain', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Descriptor, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Descriptor_refersTo_ReferenceValue':
            obj_ = Descriptor_refersTo_ReferenceValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Descriptor_refersTo_ReferenceValue.append(obj_)
            obj_.original_tagname_ = 'Descriptor_refersTo_ReferenceValue'
        elif nodeName_ == 'Descriptor_identifies_ReferenceVariable':
            obj_ = Descriptor_identifies_ReferenceVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Descriptor_identifies_ReferenceVariable = obj_
            obj_.original_tagname_ = 'Descriptor_identifies_ReferenceVariable'
        elif nodeName_ == 'Descriptor_hasValueFrom_DescriptorValueDomain':
            obj_ = Descriptor_hasValueFrom_DescriptorValueDomainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Descriptor_hasValueFrom_DescriptorValueDomain = obj_
            obj_.original_tagname_ = 'Descriptor_hasValueFrom_DescriptorValueDomain'
        super(Descriptor, self)._buildChildren(child_, node, nodeName_, True)
# end class Descriptor


class DataStructure(DataStructureComponent):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataStructureComponent
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, DataStructure_has_ForeignKey=None, DataStructure_has_DataStructureComponent=None, DataStructure_has_ComponentPosition=None, DataStructure_has_PrimaryKey=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DataStructure"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable, extensiontype_,  **kwargs_)
        if DataStructure_has_ForeignKey is None:
            self.DataStructure_has_ForeignKey = []
        else:
            self.DataStructure_has_ForeignKey = DataStructure_has_ForeignKey
        self.DataStructure_has_ForeignKey_nsprefix_ = None
        if DataStructure_has_DataStructureComponent is None:
            self.DataStructure_has_DataStructureComponent = []
        else:
            self.DataStructure_has_DataStructureComponent = DataStructure_has_DataStructureComponent
        self.DataStructure_has_DataStructureComponent_nsprefix_ = None
        if DataStructure_has_ComponentPosition is None:
            self.DataStructure_has_ComponentPosition = []
        else:
            self.DataStructure_has_ComponentPosition = DataStructure_has_ComponentPosition
        self.DataStructure_has_ComponentPosition_nsprefix_ = None
        self.DataStructure_has_PrimaryKey = DataStructure_has_PrimaryKey
        self.DataStructure_has_PrimaryKey_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataStructure.subclass:
            return DataStructure.subclass(*args_, **kwargs_)
        else:
            return DataStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DataStructure_has_ForeignKey(self):
        return self.DataStructure_has_ForeignKey
    def set_DataStructure_has_ForeignKey(self, DataStructure_has_ForeignKey):
        self.DataStructure_has_ForeignKey = DataStructure_has_ForeignKey
    def add_DataStructure_has_ForeignKey(self, value):
        self.DataStructure_has_ForeignKey.append(value)
    def insert_DataStructure_has_ForeignKey_at(self, index, value):
        self.DataStructure_has_ForeignKey.insert(index, value)
    def replace_DataStructure_has_ForeignKey_at(self, index, value):
        self.DataStructure_has_ForeignKey[index] = value
    def get_DataStructure_has_DataStructureComponent(self):
        return self.DataStructure_has_DataStructureComponent
    def set_DataStructure_has_DataStructureComponent(self, DataStructure_has_DataStructureComponent):
        self.DataStructure_has_DataStructureComponent = DataStructure_has_DataStructureComponent
    def add_DataStructure_has_DataStructureComponent(self, value):
        self.DataStructure_has_DataStructureComponent.append(value)
    def insert_DataStructure_has_DataStructureComponent_at(self, index, value):
        self.DataStructure_has_DataStructureComponent.insert(index, value)
    def replace_DataStructure_has_DataStructureComponent_at(self, index, value):
        self.DataStructure_has_DataStructureComponent[index] = value
    def get_DataStructure_has_ComponentPosition(self):
        return self.DataStructure_has_ComponentPosition
    def set_DataStructure_has_ComponentPosition(self, DataStructure_has_ComponentPosition):
        self.DataStructure_has_ComponentPosition = DataStructure_has_ComponentPosition
    def add_DataStructure_has_ComponentPosition(self, value):
        self.DataStructure_has_ComponentPosition.append(value)
    def insert_DataStructure_has_ComponentPosition_at(self, index, value):
        self.DataStructure_has_ComponentPosition.insert(index, value)
    def replace_DataStructure_has_ComponentPosition_at(self, index, value):
        self.DataStructure_has_ComponentPosition[index] = value
    def get_DataStructure_has_PrimaryKey(self):
        return self.DataStructure_has_PrimaryKey
    def set_DataStructure_has_PrimaryKey(self, DataStructure_has_PrimaryKey):
        self.DataStructure_has_PrimaryKey = DataStructure_has_PrimaryKey
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.DataStructure_has_ForeignKey or
            self.DataStructure_has_DataStructureComponent or
            self.DataStructure_has_ComponentPosition or
            self.DataStructure_has_PrimaryKey is not None or
            super(DataStructure, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DataStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(DataStructure, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        for DataStructure_has_ForeignKey_ in self.DataStructure_has_ForeignKey:
            DataStructure_has_ForeignKey_.to_etree(element, name_='DataStructure_has_ForeignKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataStructure_has_DataStructureComponent_ in self.DataStructure_has_DataStructureComponent:
            DataStructure_has_DataStructureComponent_.to_etree(element, name_='DataStructure_has_DataStructureComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for DataStructure_has_ComponentPosition_ in self.DataStructure_has_ComponentPosition:
            DataStructure_has_ComponentPosition_.to_etree(element, name_='DataStructure_has_ComponentPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.DataStructure_has_PrimaryKey is not None:
            DataStructure_has_PrimaryKey_ = self.DataStructure_has_PrimaryKey
            DataStructure_has_PrimaryKey_.to_etree(element, name_='DataStructure_has_PrimaryKey', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(DataStructure, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DataStructure_has_ForeignKey':
            obj_ = DataStructure_has_ForeignKeyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStructure_has_ForeignKey.append(obj_)
            obj_.original_tagname_ = 'DataStructure_has_ForeignKey'
        elif nodeName_ == 'DataStructure_has_DataStructureComponent':
            obj_ = DataStructure_has_DataStructureComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStructure_has_DataStructureComponent.append(obj_)
            obj_.original_tagname_ = 'DataStructure_has_DataStructureComponent'
        elif nodeName_ == 'DataStructure_has_ComponentPosition':
            obj_ = DataStructure_has_ComponentPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStructure_has_ComponentPosition.append(obj_)
            obj_.original_tagname_ = 'DataStructure_has_ComponentPosition'
        elif nodeName_ == 'DataStructure_has_PrimaryKey':
            obj_ = DataStructure_has_PrimaryKeyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataStructure_has_PrimaryKey = obj_
            obj_.original_tagname_ = 'DataStructure_has_PrimaryKey'
        super(DataStructure, self)._buildChildren(child_, node, nodeName_, True)
# end class DataStructure


class Curator(ProcessingAgent):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ProcessingAgent
    def __init__(self, catalogDetails=None, identifier=None, image=None, purpose=None, ProcessingAgent_performs_Activity=None, ProcessingAgent_operatesOn_ProductionEnvironment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Curator"), self).__init__(catalogDetails, identifier, image, purpose, ProcessingAgent_performs_Activity, ProcessingAgent_operatesOn_ProductionEnvironment,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Curator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Curator.subclass:
            return Curator.subclass(*args_, **kwargs_)
        else:
            return Curator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(Curator, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Curator', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(Curator, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Curator, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(Curator, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class Curator


class ContextualComponent(DataStructureComponent):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataStructureComponent
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ContextualComponent"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContextualComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContextualComponent.subclass:
            return ContextualComponent.subclass(*args_, **kwargs_)
        else:
            return ContextualComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(ContextualComponent, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ContextualComponent', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(ContextualComponent, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ContextualComponent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ContextualComponent, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ContextualComponent


class ConditionalControlLogic(DeterministicImperative):
    """condition -- A condition associated with the construct property of the ConditionalControlLogic. It is a logical expression which can be evaluated as either true or false to determine the specific execution of the associated  construct.
    construct -- controlConstruct is an enumeration of type ControlConstructType. The enumeration consists of IfThen, Else, Loop, RepeatUntil and RepeatWhile.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DeterministicImperative
    def __init__(self, description=None, identifier=None, workflow=None, ControlLogic_informs_ProcessingAgent=None, ControlLogic_invokes_Activity=None, ControlLogic_hasSubControlLogic_ControlLogic=None, ControlLogic_has_InformationFlowDefinition=None, condition=None, construct=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConditionalControlLogic"), self).__init__(description, identifier, workflow, ControlLogic_informs_ProcessingAgent, ControlLogic_invokes_Activity, ControlLogic_hasSubControlLogic_ControlLogic, ControlLogic_has_InformationFlowDefinition,  **kwargs_)
        self.condition = condition
        self.condition_nsprefix_ = None
        self.construct = construct
        self.validate_ControlConstruct(self.construct)
        self.construct_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConditionalControlLogic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConditionalControlLogic.subclass:
            return ConditionalControlLogic.subclass(*args_, **kwargs_)
        else:
            return ConditionalControlLogic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_condition(self):
        return self.condition
    def set_condition(self, condition):
        self.condition = condition
    def get_construct(self):
        return self.construct
    def set_construct(self, construct):
        self.construct = construct
    def validate_ControlConstruct(self, value):
        result = True
        # Validate type ControlConstruct, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Else', 'IfThen', 'Loop', 'RepeatUntil', 'RepeatWhile']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ControlConstruct' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.condition is not None or
            self.construct is not None or
            super(ConditionalControlLogic, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ConditionalControlLogic', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(ConditionalControlLogic, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.condition is not None:
            condition_ = self.condition
            condition_.to_etree(element, name_='condition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.construct is not None:
            construct_ = self.construct
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}construct').text = self.gds_format_string(construct_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConditionalControlLogic, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'condition':
            obj_ = CommandCode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.condition = obj_
            obj_.original_tagname_ = 'condition'
        elif nodeName_ == 'construct':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'construct')
            value_ = self.gds_validate_string(value_, node, 'construct')
            self.construct = value_
            self.construct_nsprefix_ = child_.prefix
            # validate type ControlConstruct
            self.validate_ControlConstruct(self.construct)
        super(ConditionalControlLogic, self)._buildChildren(child_, node, nodeName_, True)
# end class ConditionalControlLogic


class CodeList(EnumerationDomain):
    """allowsDuplicates -- If value is False, the members are unique within the collection - if True, there may be duplicates. (Note that a mathematical
    “
    bag
    ”
    permits duplicates and is unordered - a
    “
    set
    ”
    does not have duplicates and may be ordered.)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EnumerationDomain
    def __init__(self, identifier=None, name=None, purpose=None, EnumerationDomain_uses_LevelStructure=None, EnumerationDomain_references_CategorySet=None, EnumerationDomain_isDefinedBy_Concept=None, allowsDuplicates=None, CodeList_has_CodePosition=None, CodeList_has_Code=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CodeList"), self).__init__(identifier, name, purpose, EnumerationDomain_uses_LevelStructure, EnumerationDomain_references_CategorySet, EnumerationDomain_isDefinedBy_Concept,  **kwargs_)
        self.allowsDuplicates = allowsDuplicates
        self.allowsDuplicates_nsprefix_ = None
        if CodeList_has_CodePosition is None:
            self.CodeList_has_CodePosition = []
        else:
            self.CodeList_has_CodePosition = CodeList_has_CodePosition
        self.CodeList_has_CodePosition_nsprefix_ = None
        if CodeList_has_Code is None:
            self.CodeList_has_Code = []
        else:
            self.CodeList_has_Code = CodeList_has_Code
        self.CodeList_has_Code_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeList.subclass:
            return CodeList.subclass(*args_, **kwargs_)
        else:
            return CodeList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_allowsDuplicates(self):
        return self.allowsDuplicates
    def set_allowsDuplicates(self, allowsDuplicates):
        self.allowsDuplicates = allowsDuplicates
    def get_CodeList_has_CodePosition(self):
        return self.CodeList_has_CodePosition
    def set_CodeList_has_CodePosition(self, CodeList_has_CodePosition):
        self.CodeList_has_CodePosition = CodeList_has_CodePosition
    def add_CodeList_has_CodePosition(self, value):
        self.CodeList_has_CodePosition.append(value)
    def insert_CodeList_has_CodePosition_at(self, index, value):
        self.CodeList_has_CodePosition.insert(index, value)
    def replace_CodeList_has_CodePosition_at(self, index, value):
        self.CodeList_has_CodePosition[index] = value
    def get_CodeList_has_Code(self):
        return self.CodeList_has_Code
    def set_CodeList_has_Code(self, CodeList_has_Code):
        self.CodeList_has_Code = CodeList_has_Code
    def add_CodeList_has_Code(self, value):
        self.CodeList_has_Code.append(value)
    def insert_CodeList_has_Code_at(self, index, value):
        self.CodeList_has_Code.insert(index, value)
    def replace_CodeList_has_Code_at(self, index, value):
        self.CodeList_has_Code[index] = value
    def has__content(self):
        if (
            self.allowsDuplicates is not None or
            self.CodeList_has_CodePosition or
            self.CodeList_has_Code or
            super(CodeList, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CodeList', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(CodeList, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.allowsDuplicates is not None:
            allowsDuplicates_ = self.allowsDuplicates
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}allowsDuplicates').text = self.gds_format_boolean(allowsDuplicates_)
        for CodeList_has_CodePosition_ in self.CodeList_has_CodePosition:
            CodeList_has_CodePosition_.to_etree(element, name_='CodeList_has_CodePosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CodeList_has_Code_ in self.CodeList_has_Code:
            CodeList_has_Code_.to_etree(element, name_='CodeList_has_Code', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CodeList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allowsDuplicates':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'allowsDuplicates')
            ival_ = self.gds_validate_boolean(ival_, node, 'allowsDuplicates')
            self.allowsDuplicates = ival_
            self.allowsDuplicates_nsprefix_ = child_.prefix
        elif nodeName_ == 'CodeList_has_CodePosition':
            obj_ = CodeList_has_CodePositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodeList_has_CodePosition.append(obj_)
            obj_.original_tagname_ = 'CodeList_has_CodePosition'
        elif nodeName_ == 'CodeList_has_Code':
            obj_ = CodeList_has_CodeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CodeList_has_Code.append(obj_)
            obj_.original_tagname_ = 'CodeList_has_Code'
        super(CodeList, self)._buildChildren(child_, node, nodeName_, True)
# end class CodeList


class CategorySet(ConceptSystem):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ConceptSystem
    def __init__(self, allowsDuplicates=None, catalogDetails=None, externalDefinition=None, identifier=None, name=None, purpose=None, ConceptSystem_isDefinedBy_Concept=None, ConceptSystem_has_Concept=None, CategorySet_has_Category=None, CategorySet_has_CategoryPosition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CategorySet"), self).__init__(allowsDuplicates, catalogDetails, externalDefinition, identifier, name, purpose, ConceptSystem_isDefinedBy_Concept, ConceptSystem_has_Concept,  **kwargs_)
        if CategorySet_has_Category is None:
            self.CategorySet_has_Category = []
        else:
            self.CategorySet_has_Category = CategorySet_has_Category
        self.CategorySet_has_Category_nsprefix_ = None
        if CategorySet_has_CategoryPosition is None:
            self.CategorySet_has_CategoryPosition = []
        else:
            self.CategorySet_has_CategoryPosition = CategorySet_has_CategoryPosition
        self.CategorySet_has_CategoryPosition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategorySet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategorySet.subclass:
            return CategorySet.subclass(*args_, **kwargs_)
        else:
            return CategorySet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CategorySet_has_Category(self):
        return self.CategorySet_has_Category
    def set_CategorySet_has_Category(self, CategorySet_has_Category):
        self.CategorySet_has_Category = CategorySet_has_Category
    def add_CategorySet_has_Category(self, value):
        self.CategorySet_has_Category.append(value)
    def insert_CategorySet_has_Category_at(self, index, value):
        self.CategorySet_has_Category.insert(index, value)
    def replace_CategorySet_has_Category_at(self, index, value):
        self.CategorySet_has_Category[index] = value
    def get_CategorySet_has_CategoryPosition(self):
        return self.CategorySet_has_CategoryPosition
    def set_CategorySet_has_CategoryPosition(self, CategorySet_has_CategoryPosition):
        self.CategorySet_has_CategoryPosition = CategorySet_has_CategoryPosition
    def add_CategorySet_has_CategoryPosition(self, value):
        self.CategorySet_has_CategoryPosition.append(value)
    def insert_CategorySet_has_CategoryPosition_at(self, index, value):
        self.CategorySet_has_CategoryPosition.insert(index, value)
    def replace_CategorySet_has_CategoryPosition_at(self, index, value):
        self.CategorySet_has_CategoryPosition[index] = value
    def has__content(self):
        if (
            self.CategorySet_has_Category or
            self.CategorySet_has_CategoryPosition or
            super(CategorySet, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CategorySet', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(CategorySet, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        for CategorySet_has_Category_ in self.CategorySet_has_Category:
            CategorySet_has_Category_.to_etree(element, name_='CategorySet_has_Category', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for CategorySet_has_CategoryPosition_ in self.CategorySet_has_CategoryPosition:
            CategorySet_has_CategoryPosition_.to_etree(element, name_='CategorySet_has_CategoryPosition', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CategorySet, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CategorySet_has_Category':
            obj_ = CategorySet_has_CategoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategorySet_has_Category.append(obj_)
            obj_.original_tagname_ = 'CategorySet_has_Category'
        elif nodeName_ == 'CategorySet_has_CategoryPosition':
            obj_ = CategorySet_has_CategoryPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategorySet_has_CategoryPosition.append(obj_)
            obj_.original_tagname_ = 'CategorySet_has_CategoryPosition'
        super(CategorySet, self)._buildChildren(child_, node, nodeName_, True)
# end class CategorySet


class Category(Concept):
    """descriptiveText -- A short natural language account of the characteristics of the object.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Concept
    def __init__(self, catalogDetails=None, definition=None, displayLabel=None, externalDefinition=None, identifier=None, name=None, Concept_uses_Concept=None, descriptiveText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Category"), self).__init__(catalogDetails, definition, displayLabel, externalDefinition, identifier, name, Concept_uses_Concept,  **kwargs_)
        self.descriptiveText = descriptiveText
        self.descriptiveText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Category)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Category.subclass:
            return Category.subclass(*args_, **kwargs_)
        else:
            return Category(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_descriptiveText(self):
        return self.descriptiveText
    def set_descriptiveText(self, descriptiveText):
        self.descriptiveText = descriptiveText
    def has__content(self):
        if (
            self.descriptiveText is not None or
            super(Category, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Category', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(Category, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.descriptiveText is not None:
            descriptiveText_ = self.descriptiveText
            descriptiveText_.to_etree(element, name_='descriptiveText', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Category, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'descriptiveText':
            class_obj_ = self.get_class_obj_(child_, InternationalString)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.descriptiveText = obj_
            obj_.original_tagname_ = 'descriptiveText'
        super(Category, self)._buildChildren(child_, node, nodeName_, True)
# end class Category


class AttributeComponent(DataStructureComponent):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataStructureComponent
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, AttributeComponent_qualifies_DataStructureComponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AttributeComponent"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable,  **kwargs_)
        if AttributeComponent_qualifies_DataStructureComponent is None:
            self.AttributeComponent_qualifies_DataStructureComponent = []
        else:
            self.AttributeComponent_qualifies_DataStructureComponent = AttributeComponent_qualifies_DataStructureComponent
        self.AttributeComponent_qualifies_DataStructureComponent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeComponent.subclass:
            return AttributeComponent.subclass(*args_, **kwargs_)
        else:
            return AttributeComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AttributeComponent_qualifies_DataStructureComponent(self):
        return self.AttributeComponent_qualifies_DataStructureComponent
    def set_AttributeComponent_qualifies_DataStructureComponent(self, AttributeComponent_qualifies_DataStructureComponent):
        self.AttributeComponent_qualifies_DataStructureComponent = AttributeComponent_qualifies_DataStructureComponent
    def add_AttributeComponent_qualifies_DataStructureComponent(self, value):
        self.AttributeComponent_qualifies_DataStructureComponent.append(value)
    def insert_AttributeComponent_qualifies_DataStructureComponent_at(self, index, value):
        self.AttributeComponent_qualifies_DataStructureComponent.insert(index, value)
    def replace_AttributeComponent_qualifies_DataStructureComponent_at(self, index, value):
        self.AttributeComponent_qualifies_DataStructureComponent[index] = value
    def has__content(self):
        if (
            self.AttributeComponent_qualifies_DataStructureComponent or
            super(AttributeComponent, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AttributeComponent', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(AttributeComponent, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        for AttributeComponent_qualifies_DataStructureComponent_ in self.AttributeComponent_qualifies_DataStructureComponent:
            AttributeComponent_qualifies_DataStructureComponent_.to_etree(element, name_='AttributeComponent_qualifies_DataStructureComponent', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AttributeComponent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AttributeComponent_qualifies_DataStructureComponent':
            obj_ = AttributeComponent_qualifies_DataStructureComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeComponent_qualifies_DataStructureComponent.append(obj_)
            obj_.original_tagname_ = 'AttributeComponent_qualifies_DataStructureComponent'
        super(AttributeComponent, self)._buildChildren(child_, node, nodeName_, True)
# end class AttributeComponent


class AllenIntervalAlgebra(TemporalConstraints):
    """temporalIntervalRelation -- Temporal constraint specified as an Allen's interval relation.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TemporalConstraints
    def __init__(self, description=None, identifier=None, workflow=None, ControlLogic_informs_ProcessingAgent=None, ControlLogic_invokes_Activity=None, ControlLogic_hasSubControlLogic_ControlLogic=None, ControlLogic_has_InformationFlowDefinition=None, temporalIntervalRelation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AllenIntervalAlgebra"), self).__init__(description, identifier, workflow, ControlLogic_informs_ProcessingAgent, ControlLogic_invokes_Activity, ControlLogic_hasSubControlLogic_ControlLogic, ControlLogic_has_InformationFlowDefinition,  **kwargs_)
        self.temporalIntervalRelation = temporalIntervalRelation
        self.validate_TemporalRelation(self.temporalIntervalRelation)
        self.temporalIntervalRelation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AllenIntervalAlgebra)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AllenIntervalAlgebra.subclass:
            return AllenIntervalAlgebra.subclass(*args_, **kwargs_)
        else:
            return AllenIntervalAlgebra(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_temporalIntervalRelation(self):
        return self.temporalIntervalRelation
    def set_temporalIntervalRelation(self, temporalIntervalRelation):
        self.temporalIntervalRelation = temporalIntervalRelation
    def validate_TemporalRelation(self, value):
        result = True
        # Validate type TemporalRelation, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Contains', 'Equals', 'Finishes', 'Meets', 'Overlaps', 'Precedes', 'Starts']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TemporalRelation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.temporalIntervalRelation is not None or
            super(AllenIntervalAlgebra, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AllenIntervalAlgebra', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(AllenIntervalAlgebra, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if self.temporalIntervalRelation is not None:
            temporalIntervalRelation_ = self.temporalIntervalRelation
            etree_.SubElement(element, '{http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/}temporalIntervalRelation').text = self.gds_format_string(temporalIntervalRelation_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AllenIntervalAlgebra, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'temporalIntervalRelation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'temporalIntervalRelation')
            value_ = self.gds_validate_string(value_, node, 'temporalIntervalRelation')
            self.temporalIntervalRelation = value_
            self.temporalIntervalRelation_nsprefix_ = child_.prefix
            # validate type TemporalRelation
            self.validate_TemporalRelation(self.temporalIntervalRelation)
        super(AllenIntervalAlgebra, self)._buildChildren(child_, node, nodeName_, True)
# end class AllenIntervalAlgebra


class WideDataStructure(DataStructure):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataStructure
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, DataStructure_has_ForeignKey=None, DataStructure_has_DataStructureComponent=None, DataStructure_has_ComponentPosition=None, DataStructure_has_PrimaryKey=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("WideDataStructure"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable, DataStructure_has_ForeignKey, DataStructure_has_DataStructureComponent, DataStructure_has_ComponentPosition, DataStructure_has_PrimaryKey,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WideDataStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WideDataStructure.subclass:
            return WideDataStructure.subclass(*args_, **kwargs_)
        else:
            return WideDataStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(WideDataStructure, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='WideDataStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(WideDataStructure, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(WideDataStructure, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(WideDataStructure, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class WideDataStructure


class LongDataStructure(DataStructure):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataStructure
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, DataStructure_has_ForeignKey=None, DataStructure_has_DataStructureComponent=None, DataStructure_has_ComponentPosition=None, DataStructure_has_PrimaryKey=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LongDataStructure"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable, DataStructure_has_ForeignKey, DataStructure_has_DataStructureComponent, DataStructure_has_ComponentPosition, DataStructure_has_PrimaryKey,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LongDataStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LongDataStructure.subclass:
            return LongDataStructure.subclass(*args_, **kwargs_)
        else:
            return LongDataStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(LongDataStructure, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LongDataStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(LongDataStructure, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LongDataStructure, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(LongDataStructure, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class LongDataStructure


class KeyValueStructure(DataStructure):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataStructure
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, DataStructure_has_ForeignKey=None, DataStructure_has_DataStructureComponent=None, DataStructure_has_ComponentPosition=None, DataStructure_has_PrimaryKey=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("KeyValueStructure"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable, DataStructure_has_ForeignKey, DataStructure_has_DataStructureComponent, DataStructure_has_ComponentPosition, DataStructure_has_PrimaryKey,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyValueStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyValueStructure.subclass:
            return KeyValueStructure.subclass(*args_, **kwargs_)
        else:
            return KeyValueStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(KeyValueStructure, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='KeyValueStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(KeyValueStructure, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(KeyValueStructure, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(KeyValueStructure, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class KeyValueStructure


class DimensionalDataStructure(DataStructure):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataStructure
    def __init__(self, identifier=None, semantic=None, specialization=None, DataStructureComponent_isDefinedBy_RepresentedVariable=None, DataStructure_has_ForeignKey=None, DataStructure_has_DataStructureComponent=None, DataStructure_has_ComponentPosition=None, DataStructure_has_PrimaryKey=None, DimensionalDataStructure_uses_DimensionGroup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DimensionalDataStructure"), self).__init__(identifier, semantic, specialization, DataStructureComponent_isDefinedBy_RepresentedVariable, DataStructure_has_ForeignKey, DataStructure_has_DataStructureComponent, DataStructure_has_ComponentPosition, DataStructure_has_PrimaryKey,  **kwargs_)
        if DimensionalDataStructure_uses_DimensionGroup is None:
            self.DimensionalDataStructure_uses_DimensionGroup = []
        else:
            self.DimensionalDataStructure_uses_DimensionGroup = DimensionalDataStructure_uses_DimensionGroup
        self.DimensionalDataStructure_uses_DimensionGroup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionalDataStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionalDataStructure.subclass:
            return DimensionalDataStructure.subclass(*args_, **kwargs_)
        else:
            return DimensionalDataStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DimensionalDataStructure_uses_DimensionGroup(self):
        return self.DimensionalDataStructure_uses_DimensionGroup
    def set_DimensionalDataStructure_uses_DimensionGroup(self, DimensionalDataStructure_uses_DimensionGroup):
        self.DimensionalDataStructure_uses_DimensionGroup = DimensionalDataStructure_uses_DimensionGroup
    def add_DimensionalDataStructure_uses_DimensionGroup(self, value):
        self.DimensionalDataStructure_uses_DimensionGroup.append(value)
    def insert_DimensionalDataStructure_uses_DimensionGroup_at(self, index, value):
        self.DimensionalDataStructure_uses_DimensionGroup.insert(index, value)
    def replace_DimensionalDataStructure_uses_DimensionGroup_at(self, index, value):
        self.DimensionalDataStructure_uses_DimensionGroup[index] = value
    def has__content(self):
        if (
            self.DimensionalDataStructure_uses_DimensionGroup or
            super(DimensionalDataStructure, self).has__content()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DimensionalDataStructure', mapping_=None, reverse_mapping_=None, nsmap_=None):
        element = super(DimensionalDataStructure, self).to_etree(parent_element, name_, mapping_, reverse_mapping_, nsmap_)
        for DimensionalDataStructure_uses_DimensionGroup_ in self.DimensionalDataStructure_uses_DimensionGroup:
            DimensionalDataStructure_uses_DimensionGroup_.to_etree(element, name_='DimensionalDataStructure_uses_DimensionGroup', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DimensionalDataStructure, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DimensionalDataStructure_uses_DimensionGroup':
            obj_ = DimensionalDataStructure_uses_DimensionGroupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionalDataStructure_uses_DimensionGroup.append(obj_)
            obj_.original_tagname_ = 'DimensionalDataStructure_uses_DimensionGroup'
        super(DimensionalDataStructure, self)._buildChildren(child_, node, nodeName_, True)
# end class DimensionalDataStructure


#
# End data representation classes.
#


GDSClassesMapping = {
    'AccessInformation': AccessInformation,
    'AccessLocation': AccessLocation,
    'Activity': Activity,
    'Address': Address,
    'Agent': Agent,
    'AgentInRole': AgentInRole,
    'AgentListing': AgentListing,
    'AgentPosition': AgentPosition,
    'AgentRelationship': AgentRelationship,
    'AgentStructure': AgentStructure,
    'AllenIntervalAlgebra': AllenIntervalAlgebra,
    'AssociationReference': AssociationReference,
    'AttributeComponent': AttributeComponent,
    'AuthorizationSource': AuthorizationSource,
    'BibliographicName': BibliographicName,
    'CatalogDetails': CatalogDetails,
    'Category': Category,
    'CategoryPosition': CategoryPosition,
    'CategoryRelationStructure': CategoryRelationStructure,
    'CategoryRelationship': CategoryRelationship,
    'CategorySet': CategorySet,
    'CategoryStatistic': CategoryStatistic,
    'ClassificationFamily': ClassificationFamily,
    'ClassificationIndex': ClassificationIndex,
    'ClassificationIndexEntry': ClassificationIndexEntry,
    'ClassificationIndexEntryPosition': ClassificationIndexEntryPosition,
    'ClassificationItem': ClassificationItem,
    'ClassificationItemPosition': ClassificationItemPosition,
    'ClassificationItemRelationship': ClassificationItemRelationship,
    'ClassificationItemStructure': ClassificationItemStructure,
    'ClassificationPosition': ClassificationPosition,
    'ClassificationSeries': ClassificationSeries,
    'ClassificationSeriesStructure': ClassificationSeriesStructure,
    'Code': Code,
    'CodeList': CodeList,
    'CodeListStructure': CodeListStructure,
    'CodePosition': CodePosition,
    'CodeRelationship': CodeRelationship,
    'CombinedDate': CombinedDate,
    'Command': Command,
    'CommandCode': CommandCode,
    'CommandFile': CommandFile,
    'ComponentPosition': ComponentPosition,
    'Concept': Concept,
    'ConceptMap': ConceptMap,
    'ConceptRelationship': ConceptRelationship,
    'ConceptStructure': ConceptStructure,
    'ConceptSystem': ConceptSystem,
    'ConceptSystemCorrespondence': ConceptSystemCorrespondence,
    'ConceptualDomain': ConceptualDomain,
    'ConceptualValue': ConceptualValue,
    'ConceptualVariable': ConceptualVariable,
    'ConditionalControlLogic': ConditionalControlLogic,
    'ContactInformation': ContactInformation,
    'ContextualComponent': ContextualComponent,
    'ControlLogic': ControlLogic,
    'ControlledVocabularyEntry': ControlledVocabularyEntry,
    'CorrespondenceDefinition': CorrespondenceDefinition,
    'CorrespondenceTable': CorrespondenceTable,
    'Curator': Curator,
    'DDICDIModels': DDICDIModels,
    'DataPoint': DataPoint,
    'DataPointPosition': DataPointPosition,
    'DataPointRelationship': DataPointRelationship,
    'DataSet': DataSet,
    'DataStore': DataStore,
    'DataStructure': DataStructure,
    'DataStructureComponent': DataStructureComponent,
    'DateRange': DateRange,
    'Datum': Datum,
    'Descriptor': Descriptor,
    'DescriptorValueDomain': DescriptorValueDomain,
    'DescriptorVariable': DescriptorVariable,
    'DeterministicImperative': DeterministicImperative,
    'DimensionComponent': DimensionComponent,
    'DimensionGroup': DimensionGroup,
    'DimensionalDataSet': DimensionalDataSet,
    'DimensionalDataStructure': DimensionalDataStructure,
    'DimensionalKey': DimensionalKey,
    'DimensionalKeyDefinition': DimensionalKeyDefinition,
    'DimensionalKeyDefinitionMember': DimensionalKeyDefinitionMember,
    'DimensionalKeyMember': DimensionalKeyMember,
    'ElectronicMessageSystem': ElectronicMessageSystem,
    'Email': Email,
    'EmbargoInformation': EmbargoInformation,
    'EnumerationDomain': EnumerationDomain,
    'ForeignKey': ForeignKey,
    'ForeignKeyComponent': ForeignKeyComponent,
    'FundingInformation': FundingInformation,
    'GeoRole': GeoRole,
    'Identifier': Identifier,
    'IdentifierComponent': IdentifierComponent,
    'Individual': Individual,
    'IndividualName': IndividualName,
    'InformationFlowDefinition': InformationFlowDefinition,
    'InstanceKey': InstanceKey,
    'InstanceValue': InstanceValue,
    'InstanceVariable': InstanceVariable,
    'InstanceVariableMap': InstanceVariableMap,
    'InternationalIdentifier': InternationalIdentifier,
    'InternationalRegistrationDataIdentifier': InternationalRegistrationDataIdentifier,
    'InternationalString': InternationalString,
    'Key': Key,
    'KeyDefinition': KeyDefinition,
    'KeyDefinitionMember': KeyDefinitionMember,
    'KeyMember': KeyMember,
    'KeyValueDataStore': KeyValueDataStore,
    'KeyValueStructure': KeyValueStructure,
    'LabelForDisplay': LabelForDisplay,
    'LanguageString': LanguageString,
    'Level': Level,
    'LevelStructure': LevelStructure,
    'LicenseInformation': LicenseInformation,
    'LogicalRecord': LogicalRecord,
    'LogicalRecordPosition': LogicalRecordPosition,
    'LogicalRecordRelationStructure': LogicalRecordRelationStructure,
    'LogicalRecordRelationship': LogicalRecordRelationship,
    'LongDataSet': LongDataSet,
    'LongDataStructure': LongDataStructure,
    'LongKey': LongKey,
    'LongMainKeyMember': LongMainKeyMember,
    'Machine': Machine,
    'MainKeyMember': MainKeyMember,
    'MeasureComponent': MeasureComponent,
    'ModelIdentification': ModelIdentification,
    'NonDdiIdentifier': NonDdiIdentifier,
    'NonDeterministicDeclarative': NonDeterministicDeclarative,
    'NonIsoDate': NonIsoDate,
    'Notation': Notation,
    'ObjectAttributeSelector': ObjectAttributeSelector,
    'ObjectName': ObjectName,
    'Organization': Organization,
    'OrganizationName': OrganizationName,
    'PairedControlledVocabularyEntry': PairedControlledVocabularyEntry,
    'Parameter': Parameter,
    'PhysicalDataSet': PhysicalDataSet,
    'PhysicalDataSetStructure': PhysicalDataSetStructure,
    'PhysicalLayoutRelationStructure': PhysicalLayoutRelationStructure,
    'PhysicalRecordSegment': PhysicalRecordSegment,
    'PhysicalRecordSegmentPosition': PhysicalRecordSegmentPosition,
    'PhysicalRecordSegmentRelationship': PhysicalRecordSegmentRelationship,
    'PhysicalRecordSegmentStructure': PhysicalRecordSegmentStructure,
    'PhysicalSegmentLayout': PhysicalSegmentLayout,
    'PhysicalSegmentLocation': PhysicalSegmentLocation,
    'Population': Population,
    'PrimaryKey': PrimaryKey,
    'PrimaryKeyComponent': PrimaryKeyComponent,
    'PrivateImage': PrivateImage,
    'ProcessingAgent': ProcessingAgent,
    'ProductionEnvironment': ProductionEnvironment,
    'ProvenanceInformation': ProvenanceInformation,
    'QualifiedMeasure': QualifiedMeasure,
    'RationaleDefinition': RationaleDefinition,
    'RecordRelation': RecordRelation,
    'Reference': Reference,
    'ReferenceValue': ReferenceValue,
    'ReferenceValueDomain': ReferenceValueDomain,
    'ReferenceVariable': ReferenceVariable,
    'RepresentedVariable': RepresentedVariable,
    'RevisableDatum': RevisableDatum,
    'Revision': Revision,
    'Rule': Rule,
    'RuleBasedScheduling': RuleBasedScheduling,
    'RuleSet': RuleSet,
    'ScopedMeasure': ScopedMeasure,
    'SegmentByText': SegmentByText,
    'Selector': Selector,
    'SentinelConceptualDomain': SentinelConceptualDomain,
    'SentinelValueDomain': SentinelValueDomain,
    'Sequence': Sequence,
    'SequencePosition': SequencePosition,
    'Service': Service,
    'SpatialCoordinate': SpatialCoordinate,
    'SpatialPoint': SpatialPoint,
    'SpecializationRole': SpecializationRole,
    'Statistic': Statistic,
    'StatisticalClassification': StatisticalClassification,
    'StatisticalClassificationRelationship': StatisticalClassificationRelationship,
    'Step': Step,
    'StructureSpecification': StructureSpecification,
    'SubstantiveConceptualDomain': SubstantiveConceptualDomain,
    'SubstantiveValueDomain': SubstantiveValueDomain,
    'SyntheticIdComponent': SyntheticIdComponent,
    'Telephone': Telephone,
    'TemporalConstraints': TemporalConstraints,
    'TemporalControlConstruct': TemporalControlConstruct,
    'TextPositionSelector': TextPositionSelector,
    'TimeRole': TimeRole,
    'TypedString': TypedString,
    'Unit': Unit,
    'UnitSegmentLayout': UnitSegmentLayout,
    'UnitType': UnitType,
    'Universe': Universe,
    'ValueAndConceptDescription': ValueAndConceptDescription,
    'ValueDomain': ValueDomain,
    'ValueMapping': ValueMapping,
    'ValueMappingPosition': ValueMappingPosition,
    'ValueMappingRelationship': ValueMappingRelationship,
    'VariableCollection': VariableCollection,
    'VariableDescriptorComponent': VariableDescriptorComponent,
    'VariablePosition': VariablePosition,
    'VariableRelationship': VariableRelationship,
    'VariableStructure': VariableStructure,
    'VariableValueComponent': VariableValueComponent,
    'WebLink': WebLink,
    'WideDataSet': WideDataSet,
    'WideDataStructure': WideDataStructure,
    'WideKey': WideKey,
    'WideKeyMember': WideKeyMember,
    'Wrapper': Wrapper,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DDICDIModels'
        rootClass = DDICDIModels
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DDICDIModels'
        rootClass = DDICDIModels
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DDICDIModels'
        rootClass = DDICDIModels
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DDICDIModels'
        rootClass = DDICDIModels
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from ddi-cdi_43 import *\n\n')
        sys.stdout.write('import ddi-cdi_43 as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://ddialliance.org/Specification/DDI-CDI/1.0/XMLSchema/': [('CategoryRelationCode',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('ComparisonOperator',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('ComputationBaseList',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('ControlConstruct',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('MatchingCriterion',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('MemberRelationshipScope',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('PointFormat',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('SchedulingStrategy',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('SexSpecification',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('StructureExtent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('TableDirectionValues',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('TemporalOperator',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('TemporalRelation',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('TextDirectionValues',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('TrimValues',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('WhiteSpaceRule',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType1',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType2',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType3',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType4',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType5',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType6',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType7',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType8',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType9',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType10',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType11',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType12',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType13',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType14',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType15',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType16',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType17',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType18',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType19',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType20',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType21',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType22',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType23',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType24',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType25',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType26',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType27',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType28',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType29',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType30',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType31',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType32',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType33',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType34',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType35',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType36',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType37',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType38',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType39',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType40',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType41',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType42',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType43',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType44',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType45',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType46',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType47',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType48',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType49',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType50',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType51',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType52',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType53',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType54',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType55',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType56',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType57',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType58',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType59',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType60',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType61',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType62',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType63',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType64',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType65',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType66',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType67',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType68',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType69',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType70',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType71',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType72',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType73',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType74',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType75',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType76',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType77',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType78',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType79',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType80',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType81',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType82',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType83',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType84',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType85',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType86',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType87',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType88',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType89',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType90',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType91',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType92',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType93',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType94',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType95',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType96',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType97',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType98',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType99',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType100',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType101',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType102',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType103',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType104',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType105',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType106',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType107',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType108',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType109',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType110',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType111',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType112',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType113',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType114',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType115',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType116',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType117',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType118',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType119',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType120',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType121',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType122',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType123',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType124',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType125',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType126',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType127',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType128',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType129',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType130',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType131',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType132',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType133',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType134',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType135',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType136',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType137',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType138',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType139',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType140',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType141',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType142',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType143',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType144',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType145',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType146',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType147',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType148',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType149',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType150',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType151',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType152',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType153',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType154',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType155',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType156',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType157',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType158',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType159',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType160',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType161',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType162',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType163',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType164',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType165',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType166',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType167',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType168',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType169',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType170',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType171',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType172',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType173',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType174',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType175',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType176',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType177',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType178',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType179',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType180',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType181',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType182',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType183',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType184',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType185',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType186',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType187',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType188',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType189',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType190',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType191',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType192',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType193',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType194',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType195',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType196',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType197',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType198',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType199',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType200',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType201',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType202',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType203',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType204',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType205',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType206',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType207',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType208',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType209',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType210',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType211',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType212',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType213',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType214',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType215',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType216',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType217',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType218',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType219',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType220',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType221',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType222',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType223',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType224',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType225',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType226',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType227',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType228',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType229',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType230',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType231',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType232',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType233',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('validTypeType234',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'ST'),
                                                                 ('DDICDIModels',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Wrapper',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Activity',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Agent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentListing',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentPosition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentRelationship',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AllenIntervalAlgebra',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AttributeComponent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AuthorizationSource',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Category',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategoryPosition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategoryRelationStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategoryRelationship',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategorySet',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategoryStatistic',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationFamily',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationIndex',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationIndexEntry',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationIndexEntryPosition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationItem',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationItemPosition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationItemRelationship',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationItemStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationPosition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationSeries',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationSeriesStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Code',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CodeList',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CodeListStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CodePosition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CodeRelationship',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ComponentPosition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Concept',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptMap',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptRelationship',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptSystem',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptSystemCorrespondence',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptualDomain',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptualValue',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptualVariable',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConditionalControlLogic',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ContextualComponent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ControlLogic',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CorrespondenceTable',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Curator',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataPoint',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataPointPosition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataPointRelationship',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataSet',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataStore',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataStructureComponent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Datum',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Descriptor',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DescriptorValueDomain',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DescriptorVariable',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DeterministicImperative',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionComponent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionGroup',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionalDataSet',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionalDataStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionalKey',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionalKeyDefinition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionalKeyDefinitionMember',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionalKeyMember',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('EnumerationDomain',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ForeignKey',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ForeignKeyComponent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('IdentifierComponent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Individual',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InformationFlowDefinition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InstanceKey',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InstanceValue',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InstanceVariable',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InstanceVariableMap',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Key',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('KeyDefinition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('KeyDefinitionMember',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('KeyMember',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('KeyValueDataStore',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('KeyValueStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Level',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LevelStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LogicalRecord',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LogicalRecordPosition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LogicalRecordRelationStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LogicalRecordRelationship',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LongDataSet',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LongDataStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LongKey',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LongMainKeyMember',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Machine',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('MainKeyMember',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('MeasureComponent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('NonDeterministicDeclarative',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Notation',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Organization',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Parameter',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalDataSet',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalDataSetStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalLayoutRelationStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegment',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegmentPosition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegmentRelationship',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegmentStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalSegmentLayout',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalSegmentLocation',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Population',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PrimaryKey',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PrimaryKeyComponent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ProcessingAgent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ProductionEnvironment',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('QualifiedMeasure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RecordRelation',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ReferenceValue',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ReferenceValueDomain',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ReferenceVariable',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RepresentedVariable',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RevisableDatum',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Revision',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Rule',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RuleBasedScheduling',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RuleSet',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ScopedMeasure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SegmentByText',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SentinelConceptualDomain',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SentinelValueDomain',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Sequence',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SequencePosition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Service',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('StatisticalClassification',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('StatisticalClassificationRelationship',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Step',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SubstantiveConceptualDomain',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SubstantiveValueDomain',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SyntheticIdComponent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('TemporalConstraints',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('TemporalControlConstruct',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Unit',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('UnitSegmentLayout',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('UnitType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Universe',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ValueAndConceptDescription',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ValueDomain',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ValueMapping',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ValueMappingPosition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ValueMappingRelationship',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableCollection',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableDescriptorComponent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariablePosition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableRelationship',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableValueComponent',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('WideDataSet',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('WideDataStructure',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('WideKey',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('WideKeyMember',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AccessInformation',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AccessLocation',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Address',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentInRole',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('BibliographicName',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CatalogDetails',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CombinedDate',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Command',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CommandCode',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CommandFile',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ContactInformation',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ControlledVocabularyEntry',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CorrespondenceDefinition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DateRange',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ElectronicMessageSystem',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Email',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('EmbargoInformation',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('FundingInformation',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('GeoRole',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Identifier',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('IndividualName',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InternationalIdentifier',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InternationalRegistrationDataIdentifier',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InternationalString',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LabelForDisplay',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LanguageString',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LicenseInformation',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ModelIdentification',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('NonDdiIdentifier',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('NonIsoDate',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ObjectAttributeSelector',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ObjectName',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('OrganizationName',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PairedControlledVocabularyEntry',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PrivateImage',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ProvenanceInformation',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RationaleDefinition',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Reference',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AssociationReference',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Selector',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SpatialCoordinate',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SpatialPoint',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SpecializationRole',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Statistic',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('StructureSpecification',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Telephone',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('TextPositionSelector',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('TimeRole',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('TypedString',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('WebLink',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Activity_hasInternal_ControlLogicType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Activity_hasSubActivity_ActivityType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Activity_has_StepType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentListing_isDefinedBy_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentListing_isMaintainedBy_AgentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentListing_has_AgentPositionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentListing_has_AgentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentPosition_indexes_AgentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentRelationship_hasSource_AgentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentRelationship_hasTarget_AgentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentStructure_structures_AgentListingType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AgentStructure_has_AgentRelationshipType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AttributeComponent_qualifies_DataStructureComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('AuthorizationSource_has_AgentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategoryPosition_indexes_CategoryType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategoryRelationStructure_structures_CategorySetType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategoryRelationStructure_has_CategoryRelationshipType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategoryRelationship_hasSource_CategoryType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategoryRelationship_hasTarget_CategoryType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategorySet_has_CategoryType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategorySet_has_CategoryPositionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategoryStatistic_appliesTo_InstanceVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CategoryStatistic_for_CategoryType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationFamily_uses_ClassificationIndexType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationFamily_isDefinedBy_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationFamily_groups_ClassificationSeriesType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationIndex_isMaintainedBy_AgentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationIndex_hasContact_AgentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationIndex_isDefinedBy_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationIndex_has_ClassificationIndexEntryPositionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationIndex_has_ClassificationIndexEntryType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationIndexEntryPosition_indexes_ClassificationIndexEntryType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationItem_excludes_ClassificationItemType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationItem_denotes_CategoryType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationItem_uses_NotationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationItem_hasRulingBy_AuthorizationSourceType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationItemPosition_indexes_ClassificationItemType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationItemRelationship_hasSource_ClassificationItemType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationItemRelationship_hasTarget_ClassificationItemType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationItemStructure_structures_StatisticalClassificationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationItemStructure_has_ClassificationItemRelationshipType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationPosition_indexes_StatisticalClassificationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationSeries_isOwnedBy_AgentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationSeries_isDefinedBy_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationSeries_has_StatisticalClassificationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationSeries_has_ClassificationPositionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationSeriesStructure_structures_ClassificationSeriesType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ClassificationSeriesStructure_has_StatisticalClassificationRelationshipType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Code_denotes_CategoryType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Code_uses_NotationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CodeList_has_CodePositionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CodeList_has_CodeType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CodeListStructure_structures_CodeListType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CodeListStructure_has_CodeRelationshipType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CodePosition_indexes_CodeType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CodeRelationship_hasTarget_CodeType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CodeRelationship_hasSource_CodeType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ComponentPosition_indexes_DataStructureComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Concept_uses_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptMap_hasSource_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptMap_hasTarget_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptRelationship_hasSource_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptRelationship_hasTarget_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptStructure_structures_ConceptSystemType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptStructure_has_ConceptRelationshipType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptSystem_isDefinedBy_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptSystem_has_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptSystemCorrespondence_maps_ConceptSystemType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptSystemCorrespondence_has_ConceptMapType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptualDomain_isDescribedBy_ValueAndConceptDescriptionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptualDomain_takesConceptsFrom_ConceptSystemType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptualValue_hasConceptFrom_ConceptualDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ConceptualVariable_measures_UnitTypeType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ControlLogic_informs_ProcessingAgentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ControlLogic_invokes_ActivityType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ControlLogic_hasSubControlLogic_ControlLogicType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ControlLogic_has_InformationFlowDefinitionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CorrespondenceTable_hasSource_LevelType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CorrespondenceTable_hasTarget_LevelType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CorrespondenceTable_isOwnedBy_AgentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CorrespondenceTable_mapsTo_StatisticalClassificationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CorrespondenceTable_hasContact_AgentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CorrespondenceTable_isMaintainedBy_AgentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('CorrespondenceTable_has_ConceptMapType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataPoint_correspondsTo_DataStructureComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataPoint_isDescribedBy_InstanceVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataPointPosition_indexes_DataPointType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataPointRelationship_hasTarget_DataPointType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataPointRelationship_hasSource_DataPointType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataSet_isStructuredBy_DataStructureType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataSet_has_DataPointType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataSet_has_KeyType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataStore_isDefinedBy_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataStore_has_LogicalRecordPositionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataStore_has_LogicalRecordType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataStore_has_RecordRelationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataStructure_has_ForeignKeyType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataStructure_has_DataStructureComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataStructure_has_ComponentPositionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataStructure_has_PrimaryKeyType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DataStructureComponent_isDefinedBy_RepresentedVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Datum_uses_NotationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Datum_denotes_ConceptualValueType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Datum_uses_InstanceValueType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Datum_isBoundedBy_InstanceVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Descriptor_refersTo_ReferenceValueType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Descriptor_identifies_ReferenceVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Descriptor_hasValueFrom_DescriptorValueDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionComponent_isStructuredBy_ValueDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionGroup_has_DimensionComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionalDataSet_represents_ScopedMeasureType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionalDataStructure_uses_DimensionGroupType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMemberType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('DimensionalKeyMember_hasValueFrom_CodeListType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('EnumerationDomain_uses_LevelStructureType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('EnumerationDomain_references_CategorySetType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('EnumerationDomain_isDefinedBy_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ForeignKey_isComposedOf_ForeignKeyComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ForeignKeyComponent_references_PrimaryKeyComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ForeignKeyComponent_correspondsTo_DataStructureComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InformationFlowDefinition_from_ParameterType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InformationFlowDefinition_to_ParameterType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InstanceKey_has_InstanceValueType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InstanceKey_refersTo_ReferenceValueType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InstanceValue_hasValueFrom_ValueDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InstanceValue_isStoredIn_DataPointType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InstanceValue_represents_ConceptualValueType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InstanceVariableMap_hasTarget_InstanceVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('InstanceVariableMap_hasSource_InstanceVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Key_correspondsTo_UnitType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Key_represents_KeyDefinitionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Key_identifies_DataPointType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Key_correspondsTo_UniverseType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Key_has_KeyMemberType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('KeyDefinition_correspondsTo_UniverseType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('KeyDefinition_correspondsTo_UnitType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('KeyDefinition_has_KeyDefinitionMemberType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('KeyMember_isBasedOn_DataStructureComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Level_isDefinedBy_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Level_groups_ClassificationItemType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LevelStructure_has_LevelType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LogicalRecord_organizes_DataSetType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LogicalRecord_isDefinedBy_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LogicalRecord_has_InstanceVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LogicalRecordPosition_indexes_LogicalRecordType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LogicalRecordRelationStructure_structures_DataStoreType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LogicalRecordRelationStructure_has_LogicalRecordRelationshipType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LogicalRecordRelationship_hasTarget_LogicalRecordType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('LogicalRecordRelationship_hasSource_LogicalRecordType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('MainKeyMember_hasValueFrom_SubstantiveValueDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Notation_represents_CategoryType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalDataSet_isDefinedBy_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalDataSet_formats_DataStoreType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalDataSet_has_InstanceVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalDataSet_has_PhysicalRecordSegmentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalDataSet_has_PhysicalRecordSegmentPositionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalDataSetStructure_structures_PhysicalDataSetType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationshipType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayoutType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalLayoutRelationStructure_has_ValueMappingRelationshipType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegment_represents_PopulationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegment_isDefinedBy_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegment_has_PhysicalSegmentLayoutType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegment_mapsTo_LogicalRecordType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegment_has_DataPointPositionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegment_has_DataPointType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegmentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegmentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegmentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegmentStructure_structures_PhysicalRecordSegmentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalRecordSegmentStructure_has_DataPointRelationshipType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalSegmentLayout_isDefinedBy_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalSegmentLayout_formats_LogicalRecordType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalSegmentLayout_has_ValueMappingType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PhysicalSegmentLayout_has_ValueMappingPositionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Population_isComposedOf_UnitType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PrimaryKey_isComposedOf_PrimaryKeyComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('PrimaryKeyComponent_correspondsTo_DataStructureComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ProcessingAgent_performs_ActivityType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ProcessingAgent_operatesOn_ProductionEnvironmentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('QualifiedMeasure_refines_MeasureComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RecordRelation_maps_LogicalRecordType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RecordRelation_has_InstanceVariableMapType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ReferenceValue_correspondsTo_VariableValueComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ReferenceValue_hasValueFrom_ReferenceValueDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ReferenceVariable_takesValuesFrom_ReferenceValueDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RevisableDatum_correspondsTo_RevisionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Rule_hasPrecondition_ConditionalControlLogicType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RuleBasedScheduling_has_RuleSetType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RuleBasedScheduling_has_CuratorType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('RuleSet_has_RuleType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ScopedMeasure_circumscribes_DimensionalKeyDefinitionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ScopedMeasure_restricts_QualifiedMeasureType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ScopedMeasure_generates_RevisableDatumType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SentinelValueDomain_takesValuesFrom_EnumerationDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SentinelValueDomain_isDescribedBy_ValueAndConceptDescriptionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Sequence_has_SequencePositionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('StatisticalClassification_isMaintainedBy_OrganizationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('StatisticalClassification_isIndexedBy_ClassificationIndexType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('StatisticalClassification_isVariantOf_StatisticalClassificationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('StatisticalClassification_isSuccessorOf_StatisticalClassificationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('StatisticalClassification_isPredecessorOf_StatisticalClassificationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('StatisticalClassification_has_ClassificationItemPositionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('StatisticalClassification_has_ClassificationItemType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('StatisticalClassification_has_LevelStructureType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('StatisticalClassificationRelationship_hasTarget_StatisticalClassificationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('StatisticalClassificationRelationship_hasSource_StatisticalClassificationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Step_produces_ParameterType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Step_receives_ParameterType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Step_hasSubStep_StepType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SubstantiveValueDomain_takesValuesFrom_EnumerationDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescriptionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomainType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('Unit_has_UnitTypeType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ValueMapping_formats_DataPointType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ValueMapping_uses_PhysicalSegmentLocationType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ValueMappingPosition_indexes_ValueMappingType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ValueMappingRelationship_hasTarget_ValueMappingType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('ValueMappingRelationship_hasSource_ValueMappingType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableCollection_isDefinedBy_ConceptType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableCollection_has_ConceptualVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableCollection_has_VariablePositionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableDescriptorComponent_isDefinedBy_DescriptorVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableDescriptorComponent_refersTo_VariableValueComponentType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariablePosition_indexes_ConceptualVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableRelationship_hasTarget_ConceptualVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableRelationship_hasSource_ConceptualVariableType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableStructure_structures_VariableCollectionType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT'),
                                                                 ('VariableStructure_has_VariableRelationshipType',
                                                                  'ddi-cdi_43_noXsdTypeInName_complete.xsd',
                                                                  'CT')]}

__all__ = [
    "AccessInformation",
    "AccessLocation",
    "Activity",
    "Activity_hasInternal_ControlLogicType",
    "Activity_hasSubActivity_ActivityType",
    "Activity_has_StepType",
    "Address",
    "Agent",
    "AgentInRole",
    "AgentListing",
    "AgentListing_has_AgentPositionType",
    "AgentListing_has_AgentType",
    "AgentListing_isDefinedBy_ConceptType",
    "AgentListing_isMaintainedBy_AgentType",
    "AgentPosition",
    "AgentPosition_indexes_AgentType",
    "AgentRelationship",
    "AgentRelationship_hasSource_AgentType",
    "AgentRelationship_hasTarget_AgentType",
    "AgentStructure",
    "AgentStructure_has_AgentRelationshipType",
    "AgentStructure_structures_AgentListingType",
    "AllenIntervalAlgebra",
    "AssociationReference",
    "AttributeComponent",
    "AttributeComponent_qualifies_DataStructureComponentType",
    "AuthorizationSource",
    "AuthorizationSource_has_AgentType",
    "BibliographicName",
    "CatalogDetails",
    "Category",
    "CategoryPosition",
    "CategoryPosition_indexes_CategoryType",
    "CategoryRelationStructure",
    "CategoryRelationStructure_has_CategoryRelationshipType",
    "CategoryRelationStructure_structures_CategorySetType",
    "CategoryRelationship",
    "CategoryRelationship_hasSource_CategoryType",
    "CategoryRelationship_hasTarget_CategoryType",
    "CategorySet",
    "CategorySet_has_CategoryPositionType",
    "CategorySet_has_CategoryType",
    "CategoryStatistic",
    "CategoryStatistic_appliesTo_InstanceVariableType",
    "CategoryStatistic_for_CategoryType",
    "ClassificationFamily",
    "ClassificationFamily_groups_ClassificationSeriesType",
    "ClassificationFamily_isDefinedBy_ConceptType",
    "ClassificationFamily_uses_ClassificationIndexType",
    "ClassificationIndex",
    "ClassificationIndexEntry",
    "ClassificationIndexEntryPosition",
    "ClassificationIndexEntryPosition_indexes_ClassificationIndexEntryType",
    "ClassificationIndex_hasContact_AgentType",
    "ClassificationIndex_has_ClassificationIndexEntryPositionType",
    "ClassificationIndex_has_ClassificationIndexEntryType",
    "ClassificationIndex_isDefinedBy_ConceptType",
    "ClassificationIndex_isMaintainedBy_AgentType",
    "ClassificationItem",
    "ClassificationItemPosition",
    "ClassificationItemPosition_indexes_ClassificationItemType",
    "ClassificationItemRelationship",
    "ClassificationItemRelationship_hasSource_ClassificationItemType",
    "ClassificationItemRelationship_hasTarget_ClassificationItemType",
    "ClassificationItemStructure",
    "ClassificationItemStructure_has_ClassificationItemRelationshipType",
    "ClassificationItemStructure_structures_StatisticalClassificationType",
    "ClassificationItem_denotes_CategoryType",
    "ClassificationItem_excludes_ClassificationItemType",
    "ClassificationItem_hasRulingBy_AuthorizationSourceType",
    "ClassificationItem_uses_NotationType",
    "ClassificationPosition",
    "ClassificationPosition_indexes_StatisticalClassificationType",
    "ClassificationSeries",
    "ClassificationSeriesStructure",
    "ClassificationSeriesStructure_has_StatisticalClassificationRelationshipType",
    "ClassificationSeriesStructure_structures_ClassificationSeriesType",
    "ClassificationSeries_has_ClassificationPositionType",
    "ClassificationSeries_has_StatisticalClassificationType",
    "ClassificationSeries_isDefinedBy_ConceptType",
    "ClassificationSeries_isOwnedBy_AgentType",
    "Code",
    "CodeList",
    "CodeListStructure",
    "CodeListStructure_has_CodeRelationshipType",
    "CodeListStructure_structures_CodeListType",
    "CodeList_has_CodePositionType",
    "CodeList_has_CodeType",
    "CodePosition",
    "CodePosition_indexes_CodeType",
    "CodeRelationship",
    "CodeRelationship_hasSource_CodeType",
    "CodeRelationship_hasTarget_CodeType",
    "Code_denotes_CategoryType",
    "Code_uses_NotationType",
    "CombinedDate",
    "Command",
    "CommandCode",
    "CommandFile",
    "ComponentPosition",
    "ComponentPosition_indexes_DataStructureComponentType",
    "Concept",
    "ConceptMap",
    "ConceptMap_hasSource_ConceptType",
    "ConceptMap_hasTarget_ConceptType",
    "ConceptRelationship",
    "ConceptRelationship_hasSource_ConceptType",
    "ConceptRelationship_hasTarget_ConceptType",
    "ConceptStructure",
    "ConceptStructure_has_ConceptRelationshipType",
    "ConceptStructure_structures_ConceptSystemType",
    "ConceptSystem",
    "ConceptSystemCorrespondence",
    "ConceptSystemCorrespondence_has_ConceptMapType",
    "ConceptSystemCorrespondence_maps_ConceptSystemType",
    "ConceptSystem_has_ConceptType",
    "ConceptSystem_isDefinedBy_ConceptType",
    "Concept_uses_ConceptType",
    "ConceptualDomain",
    "ConceptualDomain_isDescribedBy_ValueAndConceptDescriptionType",
    "ConceptualDomain_takesConceptsFrom_ConceptSystemType",
    "ConceptualValue",
    "ConceptualValue_hasConceptFrom_ConceptualDomainType",
    "ConceptualVariable",
    "ConceptualVariable_measures_UnitTypeType",
    "ConceptualVariable_takesSentinelConceptsFrom_SentinelConceptualDomainType",
    "ConceptualVariable_takesSubstantiveConceptsFrom_SubstantiveConceptualDomainType",
    "ConditionalControlLogic",
    "ContactInformation",
    "ContextualComponent",
    "ControlLogic",
    "ControlLogic_hasSubControlLogic_ControlLogicType",
    "ControlLogic_has_InformationFlowDefinitionType",
    "ControlLogic_informs_ProcessingAgentType",
    "ControlLogic_invokes_ActivityType",
    "ControlledVocabularyEntry",
    "CorrespondenceDefinition",
    "CorrespondenceTable",
    "CorrespondenceTable_hasContact_AgentType",
    "CorrespondenceTable_hasSource_LevelType",
    "CorrespondenceTable_hasTarget_LevelType",
    "CorrespondenceTable_has_ConceptMapType",
    "CorrespondenceTable_isMaintainedBy_AgentType",
    "CorrespondenceTable_isOwnedBy_AgentType",
    "CorrespondenceTable_mapsTo_StatisticalClassificationType",
    "Curator",
    "DDICDIModels",
    "DataPoint",
    "DataPointPosition",
    "DataPointPosition_indexes_DataPointType",
    "DataPointRelationship",
    "DataPointRelationship_hasSource_DataPointType",
    "DataPointRelationship_hasTarget_DataPointType",
    "DataPoint_correspondsTo_DataStructureComponentType",
    "DataPoint_isDescribedBy_InstanceVariableType",
    "DataSet",
    "DataSet_has_DataPointType",
    "DataSet_has_KeyType",
    "DataSet_isStructuredBy_DataStructureType",
    "DataStore",
    "DataStore_has_LogicalRecordPositionType",
    "DataStore_has_LogicalRecordType",
    "DataStore_has_RecordRelationType",
    "DataStore_isDefinedBy_ConceptType",
    "DataStructure",
    "DataStructureComponent",
    "DataStructureComponent_isDefinedBy_RepresentedVariableType",
    "DataStructure_has_ComponentPositionType",
    "DataStructure_has_DataStructureComponentType",
    "DataStructure_has_ForeignKeyType",
    "DataStructure_has_PrimaryKeyType",
    "DateRange",
    "Datum",
    "Datum_denotes_ConceptualValueType",
    "Datum_isBoundedBy_InstanceVariableType",
    "Datum_uses_InstanceValueType",
    "Datum_uses_NotationType",
    "Descriptor",
    "DescriptorValueDomain",
    "DescriptorVariable",
    "DescriptorVariable_takesSubstantiveValuesFrom_DescriptorValueDomainType",
    "Descriptor_hasValueFrom_DescriptorValueDomainType",
    "Descriptor_identifies_ReferenceVariableType",
    "Descriptor_refersTo_ReferenceValueType",
    "DeterministicImperative",
    "DimensionComponent",
    "DimensionComponent_isStructuredBy_ValueDomainType",
    "DimensionGroup",
    "DimensionGroup_has_DimensionComponentType",
    "DimensionalDataSet",
    "DimensionalDataSet_represents_ScopedMeasureType",
    "DimensionalDataStructure",
    "DimensionalDataStructure_uses_DimensionGroupType",
    "DimensionalKey",
    "DimensionalKeyDefinition",
    "DimensionalKeyDefinitionMember",
    "DimensionalKeyDefinitionMember_isRepresentedBy_DimensionalKeyMemberType",
    "DimensionalKeyMember",
    "DimensionalKeyMember_hasValueFrom_CodeListType",
    "ElectronicMessageSystem",
    "Email",
    "EmbargoInformation",
    "EnumerationDomain",
    "EnumerationDomain_isDefinedBy_ConceptType",
    "EnumerationDomain_references_CategorySetType",
    "EnumerationDomain_uses_LevelStructureType",
    "ForeignKey",
    "ForeignKeyComponent",
    "ForeignKeyComponent_correspondsTo_DataStructureComponentType",
    "ForeignKeyComponent_references_PrimaryKeyComponentType",
    "ForeignKey_isComposedOf_ForeignKeyComponentType",
    "FundingInformation",
    "GeoRole",
    "Identifier",
    "IdentifierComponent",
    "Individual",
    "IndividualName",
    "InformationFlowDefinition",
    "InformationFlowDefinition_from_ParameterType",
    "InformationFlowDefinition_to_ParameterType",
    "InstanceKey",
    "InstanceKey_has_InstanceValueType",
    "InstanceKey_refersTo_ReferenceValueType",
    "InstanceValue",
    "InstanceValue_hasValueFrom_ValueDomainType",
    "InstanceValue_isStoredIn_DataPointType",
    "InstanceValue_represents_ConceptualValueType",
    "InstanceVariable",
    "InstanceVariableMap",
    "InstanceVariableMap_hasSource_InstanceVariableType",
    "InstanceVariableMap_hasTarget_InstanceVariableType",
    "InternationalIdentifier",
    "InternationalRegistrationDataIdentifier",
    "InternationalString",
    "Key",
    "KeyDefinition",
    "KeyDefinitionMember",
    "KeyDefinition_correspondsTo_UnitType",
    "KeyDefinition_correspondsTo_UniverseType",
    "KeyDefinition_has_KeyDefinitionMemberType",
    "KeyMember",
    "KeyMember_isBasedOn_DataStructureComponentType",
    "KeyValueDataStore",
    "KeyValueStructure",
    "Key_correspondsTo_UnitType",
    "Key_correspondsTo_UniverseType",
    "Key_has_KeyMemberType",
    "Key_identifies_DataPointType",
    "Key_represents_KeyDefinitionType",
    "LabelForDisplay",
    "LanguageString",
    "Level",
    "LevelStructure",
    "LevelStructure_has_LevelType",
    "Level_groups_ClassificationItemType",
    "Level_isDefinedBy_ConceptType",
    "LicenseInformation",
    "LogicalRecord",
    "LogicalRecordPosition",
    "LogicalRecordPosition_indexes_LogicalRecordType",
    "LogicalRecordRelationStructure",
    "LogicalRecordRelationStructure_has_LogicalRecordRelationshipType",
    "LogicalRecordRelationStructure_structures_DataStoreType",
    "LogicalRecordRelationship",
    "LogicalRecordRelationship_hasSource_LogicalRecordType",
    "LogicalRecordRelationship_hasTarget_LogicalRecordType",
    "LogicalRecord_has_InstanceVariableType",
    "LogicalRecord_isDefinedBy_ConceptType",
    "LogicalRecord_organizes_DataSetType",
    "LongDataSet",
    "LongDataStructure",
    "LongKey",
    "LongMainKeyMember",
    "Machine",
    "MainKeyMember",
    "MainKeyMember_hasValueFrom_SubstantiveValueDomainType",
    "MeasureComponent",
    "ModelIdentification",
    "NonDdiIdentifier",
    "NonDeterministicDeclarative",
    "NonIsoDate",
    "Notation",
    "Notation_represents_CategoryType",
    "ObjectAttributeSelector",
    "ObjectName",
    "Organization",
    "OrganizationName",
    "PairedControlledVocabularyEntry",
    "Parameter",
    "PhysicalDataSet",
    "PhysicalDataSetStructure",
    "PhysicalDataSetStructure_has_PhysicalRecordSegmentRelationshipType",
    "PhysicalDataSetStructure_structures_PhysicalDataSetType",
    "PhysicalDataSet_formats_DataStoreType",
    "PhysicalDataSet_has_InstanceVariableType",
    "PhysicalDataSet_has_PhysicalRecordSegmentPositionType",
    "PhysicalDataSet_has_PhysicalRecordSegmentType",
    "PhysicalDataSet_isDefinedBy_ConceptType",
    "PhysicalLayoutRelationStructure",
    "PhysicalLayoutRelationStructure_has_ValueMappingRelationshipType",
    "PhysicalLayoutRelationStructure_structures_PhysicalSegmentLayoutType",
    "PhysicalRecordSegment",
    "PhysicalRecordSegmentPosition",
    "PhysicalRecordSegmentPosition_indexes_PhysicalRecordSegmentType",
    "PhysicalRecordSegmentRelationship",
    "PhysicalRecordSegmentRelationship_hasSource_PhysicalRecordSegmentType",
    "PhysicalRecordSegmentRelationship_hasTarget_PhysicalRecordSegmentType",
    "PhysicalRecordSegmentStructure",
    "PhysicalRecordSegmentStructure_has_DataPointRelationshipType",
    "PhysicalRecordSegmentStructure_structures_PhysicalRecordSegmentType",
    "PhysicalRecordSegment_has_DataPointPositionType",
    "PhysicalRecordSegment_has_DataPointType",
    "PhysicalRecordSegment_has_PhysicalSegmentLayoutType",
    "PhysicalRecordSegment_isDefinedBy_ConceptType",
    "PhysicalRecordSegment_mapsTo_LogicalRecordType",
    "PhysicalRecordSegment_represents_PopulationType",
    "PhysicalSegmentLayout",
    "PhysicalSegmentLayout_formats_LogicalRecordType",
    "PhysicalSegmentLayout_has_ValueMappingPositionType",
    "PhysicalSegmentLayout_has_ValueMappingType",
    "PhysicalSegmentLayout_isDefinedBy_ConceptType",
    "PhysicalSegmentLocation",
    "Population",
    "Population_isComposedOf_UnitType",
    "PrimaryKey",
    "PrimaryKeyComponent",
    "PrimaryKeyComponent_correspondsTo_DataStructureComponentType",
    "PrimaryKey_isComposedOf_PrimaryKeyComponentType",
    "PrivateImage",
    "ProcessingAgent",
    "ProcessingAgent_operatesOn_ProductionEnvironmentType",
    "ProcessingAgent_performs_ActivityType",
    "ProductionEnvironment",
    "ProvenanceInformation",
    "QualifiedMeasure",
    "QualifiedMeasure_refines_MeasureComponentType",
    "RationaleDefinition",
    "RecordRelation",
    "RecordRelation_has_InstanceVariableMapType",
    "RecordRelation_maps_LogicalRecordType",
    "Reference",
    "ReferenceValue",
    "ReferenceValueDomain",
    "ReferenceValue_correspondsTo_VariableValueComponentType",
    "ReferenceValue_hasValueFrom_ReferenceValueDomainType",
    "ReferenceVariable",
    "ReferenceVariable_takesValuesFrom_ReferenceValueDomainType",
    "RepresentedVariable",
    "RepresentedVariable_takesSentinelValuesFrom_SentinelValueDomainType",
    "RepresentedVariable_takesSubstantiveValuesFrom_SubstantiveValueDomainType",
    "RevisableDatum",
    "RevisableDatum_correspondsTo_RevisionType",
    "Revision",
    "Rule",
    "RuleBasedScheduling",
    "RuleBasedScheduling_has_CuratorType",
    "RuleBasedScheduling_has_RuleSetType",
    "RuleSet",
    "RuleSet_has_RuleType",
    "Rule_hasPrecondition_ConditionalControlLogicType",
    "ScopedMeasure",
    "ScopedMeasure_circumscribes_DimensionalKeyDefinitionType",
    "ScopedMeasure_generates_RevisableDatumType",
    "ScopedMeasure_restricts_QualifiedMeasureType",
    "SegmentByText",
    "Selector",
    "SentinelConceptualDomain",
    "SentinelValueDomain",
    "SentinelValueDomain_isDescribedBy_ValueAndConceptDescriptionType",
    "SentinelValueDomain_takesConceptsFrom_SentinelConceptualDomainType",
    "SentinelValueDomain_takesValuesFrom_EnumerationDomainType",
    "Sequence",
    "SequencePosition",
    "Sequence_has_SequencePositionType",
    "Service",
    "SpatialCoordinate",
    "SpatialPoint",
    "SpecializationRole",
    "Statistic",
    "StatisticalClassification",
    "StatisticalClassificationRelationship",
    "StatisticalClassificationRelationship_hasSource_StatisticalClassificationType",
    "StatisticalClassificationRelationship_hasTarget_StatisticalClassificationType",
    "StatisticalClassification_has_ClassificationItemPositionType",
    "StatisticalClassification_has_ClassificationItemType",
    "StatisticalClassification_has_LevelStructureType",
    "StatisticalClassification_isIndexedBy_ClassificationIndexType",
    "StatisticalClassification_isMaintainedBy_OrganizationType",
    "StatisticalClassification_isPredecessorOf_StatisticalClassificationType",
    "StatisticalClassification_isSuccessorOf_StatisticalClassificationType",
    "StatisticalClassification_isVariantOf_StatisticalClassificationType",
    "Step",
    "Step_hasSubStep_StepType",
    "Step_produces_ParameterType",
    "Step_receives_ParameterType",
    "StructureSpecification",
    "SubstantiveConceptualDomain",
    "SubstantiveValueDomain",
    "SubstantiveValueDomain_isDescribedBy_ValueAndConceptDescriptionType",
    "SubstantiveValueDomain_takesConceptsFrom_SubstantiveConceptualDomainType",
    "SubstantiveValueDomain_takesValuesFrom_EnumerationDomainType",
    "SyntheticIdComponent",
    "Telephone",
    "TemporalConstraints",
    "TemporalControlConstruct",
    "TextPositionSelector",
    "TimeRole",
    "TypedString",
    "Unit",
    "UnitSegmentLayout",
    "UnitType",
    "Unit_has_UnitTypeType",
    "Universe",
    "ValueAndConceptDescription",
    "ValueDomain",
    "ValueMapping",
    "ValueMappingPosition",
    "ValueMappingPosition_indexes_ValueMappingType",
    "ValueMappingRelationship",
    "ValueMappingRelationship_hasSource_ValueMappingType",
    "ValueMappingRelationship_hasTarget_ValueMappingType",
    "ValueMapping_formats_DataPointType",
    "ValueMapping_uses_PhysicalSegmentLocationType",
    "VariableCollection",
    "VariableCollection_has_ConceptualVariableType",
    "VariableCollection_has_VariablePositionType",
    "VariableCollection_isDefinedBy_ConceptType",
    "VariableDescriptorComponent",
    "VariableDescriptorComponent_isDefinedBy_DescriptorVariableType",
    "VariableDescriptorComponent_refersTo_VariableValueComponentType",
    "VariablePosition",
    "VariablePosition_indexes_ConceptualVariableType",
    "VariableRelationship",
    "VariableRelationship_hasSource_ConceptualVariableType",
    "VariableRelationship_hasTarget_ConceptualVariableType",
    "VariableStructure",
    "VariableStructure_has_VariableRelationshipType",
    "VariableStructure_structures_VariableCollectionType",
    "VariableValueComponent",
    "WebLink",
    "WideDataSet",
    "WideDataStructure",
    "WideKey",
    "WideKeyMember",
    "Wrapper"
]
